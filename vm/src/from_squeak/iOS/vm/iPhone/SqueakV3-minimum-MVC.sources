'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 8 October 2008 at 1:15:45 pm'!Object subclass: #AbstractEvent	instanceVariableNames: 'item itemKind environment'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:10'!changeKind	^self class changeKind! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:43'!environmentAt: anItemKind	(self itemKind = anItemKind) ifTrue: [^self item].	^environment at: anItemKind ifAbsent: [nil]! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:20'!eventSelector	^self class eventSelectorBlock value: itemKind value: self changeKind! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:36'!item: anItem kind: anItemKind	item := anItem.	itemKind := anItemKind.	environment := Dictionary new! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:37'!itemCategory: aCategory	environment at: self class categoryKind put: aCategory! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:36'!itemClass: aClass	environment at: self class classKind put: aClass! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:38'!itemProtocol: aProtocol	environment at: self class protocolKind put: aProtocol! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'NS 1/27/2004 10:38'!itemRequestor: requestor	environment at: #requestor put: requestor! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'NS 1/27/2004 10:39'!itemSelector: aSymbol	environment at: #selector put: aSymbol! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 6/30/2003 08:22'!item	"Return the item that triggered the event (typically the name of a class, a category, a protocol, a method)."	^item! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:43'!itemClass	^self environmentAt: self class classKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 6/30/2003 08:22'!itemKind	"Return the kind of the item of the event (#category, #class, #protocol, #method, ...)"	^itemKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:44'!itemProtocol	^self environmentAt: self class protocolKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 10:38'!itemRequestor	^self environmentAt: #requestor! !!AbstractEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 10:38'!itemSelector	^self environmentAt: #selector! !!AbstractEvent methodsFor: 'printing' stamp: 'NS 1/19/2004 17:52'!printOn: aStream	self printEventKindOn: aStream.	aStream		nextPutAll: ' Event for item: ';		print: self item;		nextPutAll: ' of kind: ';		print: self itemKind! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:34'!isAdded	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/10/2003 15:01'!isCommented	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/14/2003 10:15'!isDoIt	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'NS 1/19/2004 15:09'!isModified	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 19:53'!isRecategorized	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:34'!isRemoved	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 11:35'!isRenamed	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'NS 1/27/2004 12:44'!isReorganized	^ false! !!AbstractEvent methodsFor: 'triggering' stamp: 'rw 7/14/2003 17:06'!trigger: anEventManager 	"Trigger the event manager."	anEventManager triggerEvent: self eventSelector with: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AbstractEvent class	instanceVariableNames: ''!!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/19/2004 18:42'!class: aClass	^ self item: aClass kind: AbstractEvent classKind.! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/19/2004 18:42'!class: aClass category: cat 	| instance |	instance := self class: aClass.	instance itemCategory: cat.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'rw 7/9/2003 11:19'!item: anItem kind: anItemKind	^self basicNew item: anItem kind: anItemKind! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/16/2004 14:19'!method: aMethod class: aClass	| instance |	instance := self item: aMethod kind: self methodKind.	instance itemClass: aClass.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/16/2004 14:20'!method: aMethod protocol: prot class: aClass	| instance |	instance := self method: aMethod class: aClass.	instance itemProtocol: prot.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:48'!method: aMethod selector: aSymbol class: aClass	| instance |	instance := self item: aMethod kind: self methodKind.	instance itemSelector: aSymbol.	instance itemClass: aClass.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:49'!method: aMethod selector: aSymbol class: aClass requestor: requestor	| instance |	instance := self method: aMethod selector: aSymbol class: aClass.	instance itemRequestor: requestor.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:49'!method: aMethod selector: aSymbol protocol: prot class: aClass	| instance |	instance := self method: aMethod selector: aSymbol class: aClass.	instance itemProtocol: prot.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:50'!method: aMethod selector: aSymbol protocol: prot class: aClass requestor: requestor	| instance |	instance := self method: aMethod selector: aSymbol protocol: prot class: aClass.	instance itemRequestor: requestor.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'rw 6/30/2003 09:20'!new	"Override new to trigger an error, since we want to use specialized methods to create basic and higher-level events."	^self error: 'Instances can only be created using specialized instance creation methods.'! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/29/2003 15:14'!allItemKinds	"SystemEvent allItemKinds"	^(AbstractEvent class organization listAtCategoryNamed: #'item kinds') 		collect: [:sel | self perform: sel]! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:08'!changeKind	"Return a symbol, with a : as last character, identifying the change kind."	self subclassResponsibility! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:18'!eventSelectorBlock	^[:itemKind :changeKind | itemKind, changeKind, 'Event:']! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:19'!itemChangeCombinations	^self supportedKinds collect: [:itemKind | self eventSelectorBlock value: itemKind value: self changeKind]! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:04'!supportedKinds	"All the kinds of items that this event can take. By default this is all the kinds in the system. But subclasses can override this to limit the choices. For example, the SuperChangedEvent only works with classes, and not with methods, instance variables, ..."	^self allItemKinds! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 11:39'!systemEvents	"Return all the possible events in the system. Make a cross product of 	the items and the change types."	"self systemEvents"	^self allSubclasses		inject: OrderedCollection new		into: [:allEvents :eventClass | allEvents addAll: eventClass itemChangeCombinations; yourself]! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/9/2003 11:12'!categoryKind	^#category! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/9/2003 11:12'!classKind	^#class! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/14/2003 11:41'!expressionKind	^#expression! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/9/2003 11:12'!methodKind	^#method! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/10/2003 12:36'!protocolKind	^#protocol! !Object subclass: #AbstractFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!AbstractFont commentStamp: '<historical>' prior: 0!AbstractFont defines the generic interface that all fonts need to implement.!!AbstractFont methodsFor: 'accessing' stamp: 'nk 4/2/2004 11:06'!baseKern	^0! !!AbstractFont methodsFor: 'accessing' stamp: 'ar 5/19/2000 14:56'!characterToGlyphMap	"Return the character to glyph mapping table. If the table is not provided the character scanner will query the font directly for the width of each individual character."	^nil! !!AbstractFont methodsFor: 'accessing' stamp: 'nk 4/1/2004 10:51'!height	"Answer the height of the receiver, total of maximum extents of 	characters above and below the baseline."	^self ascent + self descent! !!AbstractFont methodsFor: 'accessing' stamp: 'nk 4/2/2004 11:07'!lineGrid	"Answer the relative space between lines"	^ self ascent + self descent! !!AbstractFont methodsFor: 'accessing' stamp: 'nk 4/2/2004 11:33'!pixelSize	"Make sure that we don't return a Fraction"	^ TextStyle pointsToPixels: self pointSize! !!AbstractFont methodsFor: 'accessing' stamp: 'nk 4/1/2004 10:48'!pointSize	self subclassResponsibility.! !!AbstractFont methodsFor: 'accessing' stamp: 'nk 7/11/2004 21:15'!textStyle	^ TextStyle actualTextStyles detect:		[:aStyle | aStyle fontArray includes: self] ifNone: [ TextStyle fontArray: { self } ]! !!AbstractFont methodsFor: 'accessing' stamp: 'ar 5/19/2000 14:57'!xTable	"Return the xTable for the font. The xTable defines the left x-value for each individual glyph in the receiver. If such a table is not provided, the character scanner will ask the font directly for the appropriate width of each individual character."	^nil! !!AbstractFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 14:59'!displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) display context."	^self subclassResponsibility! !!AbstractFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 14:59'!installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColor	"Install the receiver on the given DisplayContext (either BitBlt or Canvas) for further drawing operations."	^self subclassResponsibility! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 5/19/2000 14:58'!widthOf: aCharacter	"Return the width of the given character"	^self subclassResponsibility! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 12/31/2001 14:25'!widthOfString: aString	aString ifNil:[^0].	^self widthOfString: aString from: 1 to: aString size."	TextStyle default defaultFont widthOfString: 'zort' 21"! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 12/31/2001 00:54'!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| character resultX |	resultX _ 0.	startIndex to: stopIndex do:[:i | 		character _ aString at: i.		resultX _ resultX + (self widthOf: character)].	^resultX! !!AbstractFont methodsFor: 'testing' stamp: 'nk 6/25/2003 12:54'!isTTCFont	^false! !!AbstractFont methodsFor: 'caching' stamp: 'nk 3/15/2004 18:47'!releaseCachedState	! !Array variableSubclass: #ActionSequence	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Events'!!ActionSequence methodsFor: 'converting' stamp: 'reThink 2/18/2001 15:12'!asActionSequence	^self! !!ActionSequence methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors withAll: self! !!ActionSequence methodsFor: 'converting' stamp: 'reThink 2/18/2001 15:28'!asMinimalRepresentation	self size = 0		ifTrue: [^nil].	self size = 1		ifTrue: [^self first].	^self! !!ActionSequence methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 17:51'!value    "Answer the result of evaluating the elements of the receiver."    | answer |    self do:        [:each |        answer := each value].    ^answer! !!ActionSequence methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 17:52'!valueWithArguments: anArray    | answer |    self do:        [:each |        answer := each valueWithArguments: anArray].    ^answer! !!ActionSequence methodsFor: 'printing' stamp: 'SqR 07/28/2001 18:25'!printOn: aStream	self size < 2 ifTrue: [^super printOn: aStream].	aStream nextPutAll: '#('.	self		do: [:each | each printOn: aStream]		separatedBy: [aStream cr].	aStream nextPut: $)! !AbstractEvent subclass: #AddedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AddedEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:35'!isAdded	^true! !!AddedEvent methodsFor: 'printing' stamp: 'rw 6/30/2003 09:31'!printEventKindOn: aStream	aStream nextPutAll: 'Added'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddedEvent class	instanceVariableNames: ''!!AddedEvent class methodsFor: 'accessing' stamp: 'rw 7/19/2003 09:52'!changeKind	^#Added! !!AddedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:22'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self methodKind with: self categoryKind with: self protocolKind! !Object subclass: #AppRegistry	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Applications'!!AppRegistry commentStamp: 'ads 4/2/2003 15:30' prior: 0!AppRegistry is a simple little class, not much more than a wrapper around a collection. It's intended to help break dependencies between packages. For example, if you'd like to be able to send e-mail, you could use the bare-bones MailComposition class, or you could use the full-blown Celeste e-mail client. Instead of choosing one or the other, you can call "MailSender default" (where MailSender is a subclass of AppRegistry), and thus avoid creating a hard-coded dependency on either of the two mail senders.This will only really be useful, of course, for applications that have a very simple, general, well-defined interface. Most of the time, you're probably better off just marking your package as being dependent on a specific other package, and avoiding the hassle of this whole AppRegistry thing. But for simple things like e-mail senders or web browsers, it might be useful.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AppRegistry class	instanceVariableNames: 'registeredClasses default'!!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 3/29/2003 13:36'!appName	"Defaults to the class name, which is probably good enough, but you could override this in subclasses if you want to."	^ self name! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 4/2/2003 15:31'!askForDefault	| menu |	self registeredClasses isEmpty ifTrue:		[self inform: 'There are no ', self appName, ' applications registered.'.		^ default _ nil].	self registeredClasses size = 1 ifTrue:		[^ default _ self registeredClasses anyOne].		menu _ CustomMenu new.	self registeredClasses do: [:c | menu add: c name printString action: c].	^ default _ menu startUpWithCaption: 'Which ', self appName, ' would you prefer?'! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 3/29/2003 13:11'!default	^ default ifNil: [self askForDefault]! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'nk 3/9/2004 12:33'!default: aClassOrNil	"Sets my default to aClassOrNil. 	Answers the old default."	| oldDefault |	oldDefault := default.	aClassOrNil ifNotNil: [ self register: aClassOrNil ].	default := aClassOrNil.	^ oldDefault! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 4/2/2003 15:25'!register: aProviderClass	(self registeredClasses includes: aProviderClass) ifFalse:		[default _ nil.  "so it'll ask for a new default, since if you're registering a new app you probably want to use it"		self registeredClasses add: aProviderClass].! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 3/29/2003 13:01'!registeredClasses	^ registeredClasses ifNil: [registeredClasses _ OrderedCollection new]! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 3/29/2003 13:03'!unregister: aProviderClass	(default = aProviderClass) ifTrue: [default _ nil].	self registeredClasses remove: aProviderClass ifAbsent: [].! !Path subclass: #Arc	instanceVariableNames: 'quadrant radius center'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!Arc commentStamp: '<historical>' prior: 0!Arcs are an unusual implementation of splines due to Ted Kaehler.  Imagine two lines that meet at a corner. Now imagine two moving points; one moves from the corner to the end on one line, the other moves from the end of the other line in to the corner.  Now imagine a series of lines drawn between those moving points at each step along the way (they form a sort of spider web pattern).  By connecting segments of the intersecting lines, a smooth curve is achieved that is tangent to both of the original lines.  Voila.!!Arc methodsFor: 'accessing'!center	"Answer the point at the center of the receiver."	^center! !!Arc methodsFor: 'accessing'!center: aPoint 	"Set aPoint to be the receiver's center."	center _ aPoint! !!Arc methodsFor: 'accessing'!quadrant	"Answer the part of the circle represented by the receiver."	^quadrant! !!Arc methodsFor: 'accessing'!quadrant: section 	"Set the part of the circle represented by the receiver to be the argument, 	section."	quadrant _ section! !!Arc methodsFor: 'accessing'!radius	"Answer the receiver's radius."	^radius! !!Arc methodsFor: 'accessing'!radius: anInteger 	"Set the receiver's radius to be the argument, anInteger."	radius _ anInteger! !!Arc methodsFor: 'display box access'!computeBoundingBox	| aRectangle aPoint |	aRectangle _ center - radius + form offset extent: form extent + (radius * 2) asPoint.	aPoint _ center + form extent.	quadrant = 1 ifTrue: [^ aRectangle encompass: center x @ aPoint y].	quadrant = 2 ifTrue: [^ aRectangle encompass: aPoint x @ aPoint y].	quadrant = 3 ifTrue: [^ aRectangle encompass: aPoint x @ center y].	quadrant = 4 ifTrue: [^ aRectangle encompass: center x @ center y]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| nSegments line angle sin cos xn yn xn1 yn1 |	nSegments _ 12.0.	line _ Line new.	line form: self form.	angle _ 90.0 / nSegments.	sin _ (angle * (2 * Float pi / 360.0)) sin.	cos _ (angle * (2 * Float pi / 360.0)) cos.	quadrant = 1		ifTrue: 			[xn _ radius asFloat.			yn _ 0.0].	quadrant = 2		ifTrue: 			[xn _ 0.0.			yn _ 0.0 - radius asFloat].	quadrant = 3		ifTrue: 			[xn _ 0.0 - radius asFloat.			yn _ 0.0].	quadrant = 4		ifTrue: 			[xn _ 0.0.			yn _ radius asFloat].	nSegments asInteger		timesRepeat: 			[xn1 _ xn * cos + (yn * sin).			yn1 _ yn * cos - (xn * sin).			line beginPoint: center + (xn asInteger @ yn asInteger).			line endPoint: center + (xn1 asInteger @ yn1 asInteger).			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			xn _ xn1.			yn _ yn1]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newArc tempCenter |	newArc _ Arc new.	tempCenter _ aTransformation applyTo: self center.	newArc center: tempCenter x asInteger @ tempCenter y asInteger.	newArc quadrant: self quadrant.	newArc radius: (self radius * aTransformation scale x) asInteger.	newArc form: self form.	newArc		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Arc class	instanceVariableNames: ''!!Arc class methodsFor: 'examples'!example	"Click the button somewhere on the screen. The designated point will	be the center of an Arc with radius 50 in the 4th quadrant."	| anArc aForm |	aForm _ Form extent: 1 @ 30.	"make a long thin Form for display"	aForm fillBlack.						"turn it black"	anArc _ Arc new.	anArc form: aForm.					"set the form for display"	anArc radius: 50.0.	anArc center: Sensor waitButton.	anArc quadrant: 4.	anArc displayOn: Display.	Sensor waitButton	"Arc example"! !Error subclass: #ArithmeticError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!ArrayedCollection variableSubclass: #Array	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!Array commentStamp: '<historical>' prior: 0!I present an ArrayedCollection whose elements are objects.!!Array methodsFor: 'comparing'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	self size = 0 ifTrue: [^self hash].	^(self first hashMappedBy: map) + (self last hashMappedBy: map)! !!Array methodsFor: 'comparing' stamp: 'ajh 2/2/2002 15:03'!literalEqual: other	self class == other class ifFalse: [^ false].	self size = other size ifFalse: [^ false].	self with: other do: [:e1 :e2 |		(e1 literalEqual: e2) ifFalse: [^ false]].	^ true! !!Array methodsFor: 'converting' stamp: 'sma 5/12/2000 17:32'!asArray	"Answer with the receiver itself."	^ self! !!Array methodsFor: 'converting' stamp: 'ajh 9/8/2002 17:45'!elementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'converting' stamp: 'di 3/28/1999 10:23'!elementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'converting' stamp: 'brp 9/26/2003 08:09'!elementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!Array methodsFor: 'converting'!evalStrings	   "Allows you to construct literal arrays.    #(true false nil '5@6' 'Set new' '''text string''') evalStrings    gives an array with true, false, nil, a Point, a Set, and a String    instead of just a bunch of Symbols"    | it |    ^ self collect: [:each |        it _ each.        each == #true ifTrue: [it _ true].		      each == #false ifTrue: [it _ false].        each == #nil ifTrue: [it _ nil].        each class == String ifTrue: [			it _ Compiler evaluate: each].        each class == Array ifTrue: [it _ it evalStrings].        it]! !!Array methodsFor: 'printing' stamp: 'sma 5/12/2000 14:11'!isLiteral	^ self allSatisfy: [:each | each isLiteral]! !!Array methodsFor: 'printing' stamp: 'sma 6/1/2000 09:39'!printOn: aStream	aStream nextPut: $#.	self printElementsOn: aStream! !!Array methodsFor: 'printing'!storeOn: aStream 	"Use the literal form if possible."	self isLiteral		ifTrue: 			[aStream nextPut: $#; nextPut: $(.			self do: 				[:element | 				element printOn: aStream.				aStream space].			aStream nextPut: $)]		ifFalse: [super storeOn: aStream]! !!Array methodsFor: 'private' stamp: 'sma 6/3/2000 21:39'!hasLiteral: literal	"Answer true if literal is identical to any literal in this array, even 	if imbedded in further array structure. This method is only intended 	for private use by CompiledMethod hasLiteralSymbol:"	| lit |	1 to: self size do: 		[:index | 		(lit _ self at: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false! !!Array methodsFor: 'private' stamp: 'di 8/15/97 09:55'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in this array, even if imbedded in further array structure.  This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	| lit |	1 to: self size do:		[:index | lit _ self at: index.		(litBlock value: lit) ifTrue: [^ true].		(lit class == Array and: [lit hasLiteralSuchThat: litBlock]) ifTrue: [^ true]].	^false! !!Array methodsFor: 'private'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!Array methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:42'!byteEncode:aStream	aStream writeArray:self.! !!Array methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:55'!storeOnStream:aStream	self isLiteral ifTrue: [super storeOnStream:aStream] ifFalse:[aStream writeCollection:self].! !!Array methodsFor: 'copying' stamp: 'ar 2/11/2001 01:55'!copyWithDependent: newElement	self size = 0 ifTrue:[^DependentsArray with: newElement].	^self copyWith: newElement! !!Array methodsFor: 'accessing' stamp: 'ar 8/26/2001 22:02'!atWrap: index 	"Optimized to go through the primitive if possible"	<primitive: 60>	^ self at: index - 1 \\ self size + 1! !!Array methodsFor: 'accessing' stamp: 'ar 8/26/2001 22:03'!atWrap: index put: anObject	"Optimized to go through the primitive if possible"	<primitive: 61>	^ self at: index - 1 \\ self size + 1 put: anObject! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:09'!+* aCollection	"Premultiply aCollection by self.  aCollection should be an Array or Matrix.	 The name of this method is APL's +.x squished into Smalltalk syntax."	^aCollection preMultiplyByArray: self! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:10'!preMultiplyByArray: a	"Answer a+*self where a is an Array.  Arrays are always understood as column vectors,	 so an n element Array is an n*1 Array.  This multiplication is legal iff self size = 1."	self size = 1 ifFalse: [self error: 'dimensions do not conform'].	^a * self first! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:08'!preMultiplyByMatrix: m	"Answer m+*self where m is a Matrix."	|s|	m columnCount = self size ifFalse: [self error: 'dimensions do not conform'].	^(1 to: m rowCount) collect: [:row |		s _ 0.		1 to: self size do: [:k | s _ (m at: row at: k) * (self at: k) + s].		s]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Array class	instanceVariableNames: ''!!Array class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:12'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asIntPtrFrom: anInteger on: aStream! !!Array class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 13:10'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isIndexable')! !!Array class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:12'!ccgDeclareCForVar: aSymbolOrString	^'int *', aSymbolOrString! !!Array class methodsFor: 'brace support' stamp: 'di 11/18/1999 22:53'!braceStream: nElements	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ WriteStream basicNew braceArray: (self new: nElements)! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:16'!braceWith: a	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 1.	array at: 1 put: a.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:15'!braceWith: a with: b 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 2.	array at: 1 put: a.	array at: 2 put: b.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 3.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c with: d	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 4.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	array at: 4 put: d.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:16'!braceWithNone	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ self new: 0! !SequenceableCollection subclass: #ArrayedCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Abstract'!!ArrayedCollection commentStamp: '<historical>' prior: 0!I am an abstract collection of elements with a fixed range of integers (from 1 to n>=0) as external keys.!!ArrayedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:36'!size	"Answer how many elements the receiver contains."	<primitive: 62>	^ self basicSize! !!ArrayedCollection methodsFor: 'adding' stamp: 'sma 5/12/2000 14:09'!add: newObject	self shouldNotImplement! !!ArrayedCollection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 14:20'!flattenOnStream: aStream 	aStream writeArrayedCollection: self! !!ArrayedCollection methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new: '.	aStream store: self size.	aStream nextPut: $).	(self storeElementsFrom: 1 to: self size on: aStream)		ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!ArrayedCollection methodsFor: 'private'!defaultElement	^nil! !!ArrayedCollection methodsFor: 'private'!storeElementsFrom: firstIndex to: lastIndex on: aStream	| noneYet defaultElement arrayElement |	noneYet _ true.	defaultElement _ self defaultElement.	firstIndex to: lastIndex do: 		[:index | 		arrayElement _ self at: index.		arrayElement = defaultElement			ifFalse: 				[noneYet					ifTrue: [noneYet _ false]					ifFalse: [aStream nextPut: $;].				aStream nextPutAll: ' at: '.				aStream store: index.				aStream nextPutAll: ' put: '.				aStream store: arrayElement]].	^noneYet! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 18:18'!asSortedArray	self isSorted ifTrue: [^ self asArray].	^ super asSortedArray! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:57'!isSorted	"Return true if the receiver is sorted by the given criterion.	Optimization for isSortedBy: [:a :b | a <= b]."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm _ self first.	2 to: self size do: 		[:index | 		elm _ self at: index.		lastElm <= elm ifFalse: [^ false].		lastElm _ elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:58'!isSortedBy: aBlock	"Return true if the receiver is sorted by the given criterion."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm _ self first.	2 to: self size do: 		[:index | 		elm _ self at: index.		(aBlock value: lastElm value: elm) ifFalse: [^ false].		lastElm _ elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:28'!mergeFirst: first middle: middle last: last into: dst by: aBlock	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 	of the receiver into the range [first..last] of dst."	| i1 i2 val1 val2 out |	i1 _ first.	i2 _ middle + 1.	val1 _ self at: i1.	val2 _ self at: i2.	out _ first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue:		[(aBlock value: val1 value: val2)			ifTrue: [dst at: (out _ out + 1) put: val1.					val1 _ self at: (i1 _ i1 + 1)]			ifFalse: [dst at: (out _ out + 1) put: val2.					i2 _ i2 + 1.					i2 <= last ifTrue: [val2 _ self at: i2]]].	"copy the remaining elements"	i1 <= middle		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:25'!mergeSortFrom: startIndex to: stopIndex by: aBlock	"Sort the given range of indices using the mergesort algorithm.	Mergesort is a worst-case O(N log N) sorting algorithm that usually	does only half as many comparisons as heapsort or quicksort."	"Details: recursively split the range to be sorted into two halves,	mergesort each half, then merge the two halves together. An extra 	copy of the data is used as temporary storage and successive merge 	phases copy data back and forth between the receiver and this copy.	The recursion is set up so that the final merge is performed into the	receiver, resulting in the receiver being completely sorted."	self size <= 1 ifTrue: [^ self].  "nothing to do"	startIndex = stopIndex ifTrue: [^ self].	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. "bad start index"	self assert: [stopIndex <= self size]. "bad stop index"	self		mergeSortFrom: startIndex		to: stopIndex 		src: self clone 		dst: self 		by: aBlock! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:26'!mergeSortFrom: first to: last src: src dst: dst by: aBlock	"Private. Split the range to be sorted in half, sort each half, and 	merge the two half-ranges into dst."	| middle |	first = last ifTrue: [^ self].	middle _ (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:22'!sort	"Sort this array into ascending order using the '<=' operator."	self sort: [:a :b | a <= b]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:21'!sort: aSortBlock 	"Sort this array using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one."	self		mergeSortFrom: 1		to: self size		by: aSortBlock! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 15:22'!byteSize	^self basicSize * self bytesPerBasicElement! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 16:28'!bytesPerBasicElement	"Answer the number of bytes that each of my basic elements requires.	In other words:		self basicSize * self bytesPerBasicElement	should equal the space required on disk by my variable sized representation."	^self class isBytes ifTrue: [ 1 ] ifFalse: [ 4 ]! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 18:51'!bytesPerElement	^self class isBytes ifTrue: [ 1 ] ifFalse: [ 4 ].! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'sd 6/28/2003 09:49'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Reverse the byte order if the current machine is Little Endian.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	self class isPointers | self class isWords not ifTrue: [^ self].	Smalltalk isLittleEndian 		ifTrue: [Bitmap swapBytesIn: self from: 1 to: self basicSize]! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'md 12/12/2003 17:01'!swapBytesFrom: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	| hack blt |	self deprecated: 'Use BitMap class>>swapBytesIn:from:to:'.	self class isPointers | self class isWords not ifTrue: [^ self].	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:36'!swapHalves		"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word.	This method is only used for 16-bit quanities in SoundBuffer, ShortIntegerArray, etc."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 2.	blt sourceX: 0; destX: 2; copyBits.  "Exchange bytes 0&1 with 2&3"	blt sourceX: 2; destX: 0; copyBits.	blt sourceX: 0; destX: 2; copyBits.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'ar 5/17/2001 19:50'!writeOn: aStream 	"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds. We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	self class isPointers | self class isWords not ifTrue: [^ super writeOn: aStream].				"super may cause an error, but will not be called."	aStream nextInt32Put: self basicSize.	aStream nextWordsPutAll: self.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 18:07'!writeOnGZIPByteStream: aStream 	"We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	self class isPointers | self class isWords not ifTrue: [^ super writeOnGZIPByteStream: aStream].		"super may cause an error, but will not be called."		aStream nextPutAllWordArray: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ArrayedCollection class	instanceVariableNames: ''!!ArrayedCollection class methodsFor: 'instance creation'!new	"Answer a new instance of me, with size = 0."	^self new: 0! !!ArrayedCollection class methodsFor: 'instance creation'!new: size withAll: value 	"Answer an instance of me, with number of elements equal to size, each 	of which refers to the argument, value."	^(self new: size) atAllPut: value! !!ArrayedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newArray |	newArray _ self new: aCollection size.	1 to: aCollection size do: [:i | newArray at: i put: (aCollection at: i)].	^ newArray"	Array newFrom: {1. 2. 3}	{1. 2. 3} as: Array	{1. 2. 3} as: ByteArray	{$c. $h. $r} as: String	{$c. $h. $r} as: Text"! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'ar 5/17/2001 19:50'!newFromStream: s	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."	| len |	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].		"super may cause an error, but will not be called."	s next = 16r80 ifTrue:		["A compressed format.  Could copy what BitMap does, or use a 		special sound compression format.  Callers normally compress their own way."		^ self error: 'not implemented'].	s skip: -1.	len _ s nextInt32.	^ s nextWordsInto: (self basicNew: len)! !!ArrayedCollection class methodsFor: 'instance creation'!with: anObject 	"Answer a new instance of me, containing only anObject."	| newCollection |	newCollection _ self new: 1.	newCollection at: 1 put: anObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject 	"Answer a new instance of me, containing firstObject and secondObject."	| newCollection |	newCollection _ self new: 2.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject 	"Answer a new instance of me, containing only the three arguments as	elements."	| newCollection |	newCollection _ self new: 3.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	"Answer a new instance of me, containing only the three arguments as	elements."	| newCollection |	newCollection _ self new: 4.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of me, containing only the five arguments as	elements."	| newCollection |	newCollection _ self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection _ self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:37'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size) replaceFrom: 1 to: aCollection size with: aCollection! !!ArrayedCollection class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 10:03'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	self instSize > 0 ifTrue: 		[self error: 'cannot auto-coerce arrays with named instance variables'].	cg generateCoerceToObjectFromPtr: aNode on: aStream! !!ArrayedCollection class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:18'!ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg 		generateCoerceToPtr: (self ccgDeclareCForVar: '')		fromObject: aNode on: aStream! !Halt subclass: #AssertionFailure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Extensions'!!AssertionFailure commentStamp: 'gh 5/2/2002 20:29' prior: 0!AsssertionFailure is the exception signaled from Object>>assert: when the assertion block evaluates to false.!ParseNode subclass: #AssignmentNode	instanceVariableNames: 'variable value'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!AssignmentNode commentStamp: '<historical>' prior: 0!AssignmentNode comment: 'I represent a (var_expr) construct.'!!AssignmentNode methodsFor: 'initialize-release'!toDoIncrement: var	var = variable ifFalse: [^ nil].	(value isMemberOf: MessageNode) 		ifTrue: [^ value toDoIncrement: var]		ifFalse: [^ nil]! !!AssignmentNode methodsFor: 'initialize-release'!value	^ value! !!AssignmentNode methodsFor: 'initialize-release'!variable: aVariable value: expression	variable _ aVariable.	value _ expression! !!AssignmentNode methodsFor: 'initialize-release' stamp: 'di 3/22/1999 12:00'!variable: aVariable value: expression from: encoder	(aVariable isMemberOf: MessageAsTempNode)		ifTrue: ["Case of remote temp vars"				^ aVariable store: expression from: encoder].	variable _ aVariable.	value _ expression! !!AssignmentNode methodsFor: 'initialize-release' stamp: 'hmm 7/15/2001 21:17'!variable: aVariable value: expression from: encoder sourceRange: range	encoder noteSourceRange: range forNode: self.	^self		variable: aVariable		value: expression		from: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'di 9/5/2001 18:46'!emitForEffect: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	variable emitStorePop: stack on: aStream.	pc _ aStream position! !!AssignmentNode methodsFor: 'code generation' stamp: 'di 9/5/2001 21:26'!emitForValue: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	variable emitStore: stack on: aStream.	pc _ aStream position! !!AssignmentNode methodsFor: 'code generation'!sizeForEffect: encoder	^(value sizeForValue: encoder)		+ (variable sizeForStorePop: encoder)! !!AssignmentNode methodsFor: 'code generation'!sizeForValue: encoder	^(value sizeForValue: encoder)		+ (variable sizeForStore: encoder)! !!AssignmentNode methodsFor: 'printing' stamp: 'brp 10/8/2003 14:55'!printOn: aStream indent: level 	aStream dialect = #SQ00		ifTrue: [aStream				withStyleFor: #setOrReturn				do: [aStream nextPutAll: 'Set '].			variable printOn: aStream indent: level.			aStream				withStyleFor: #setOrReturn				do: [aStream nextPutAll: ' to '].			value printOn: aStream indent: level + 2]		ifFalse: [variable printOn: aStream indent: level.			aStream				nextPutAll: (Preferences ansiAssignmentOperatorWhenPrettyPrinting						ifTrue: [' := ']						ifFalse: [' _ ']).			value printOn: aStream indent: level + 2]! !!AssignmentNode methodsFor: 'printing' stamp: 'di 4/25/2000 13:52'!printOn: aStream indent: level precedence: p	(aStream dialect = #SQ00			ifTrue: [p < 3]			ifFalse: [p < 4])		ifTrue: [aStream nextPutAll: '('.				self printOn: aStream indent: level.				aStream nextPutAll: ')']		ifFalse: [self printOn: aStream indent: level]! !!AssignmentNode methodsFor: 'equation translation'!variable	^variable! !LookupKey subclass: #Association	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!Association commentStamp: '<historical>' prior: 0!I represent a pair of associated objects--a key and a value. My instances can serve as entries in a dictionary.!!Association methodsFor: 'accessing'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key _ aKey.	value _ anObject! !!Association methodsFor: 'accessing'!value	"Answer the value of the receiver."	^value! !!Association methodsFor: 'accessing'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value _ anObject! !!Association methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '->'.	value printOn: aStream! !!Association methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:31'!propertyListOn: aStream	aStream write:key; print:'='; write:value.! !!Association methodsFor: 'printing'!storeOn: aStream	"Store in the format (key->value)"	aStream nextPut: $(.	key storeOn: aStream.	aStream nextPutAll: '->'.	value storeOn: aStream.	aStream nextPut: $)! !!Association methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 20:53'!byteEncode: aStream	aStream writeAssocation:self.! !!Association methodsFor: 'testing' stamp: 'ar 8/14/2001 23:06'!isSpecialWriteBinding	"Return true if this variable binding is write protected, e.g., should not be accessed primitively but rather by sending #value: messages"	^false! !!Association methodsFor: 'testing' stamp: 'ar 8/14/2001 22:39'!isVariableBinding	"Return true if I represent a literal variable binding"	^true! !!Association methodsFor: 'comparing' stamp: 'md 1/27/2004 17:27'!= anAssociation	^ super = anAssociation and: [value = anAssociation value]! !!Association methodsFor: 'comparing' stamp: 'md 1/27/2004 17:28'!hash	"Hash is reimplemented because = is implemented."		^key hash bitXor: value hash.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Association class	instanceVariableNames: ''!!Association class methodsFor: 'instance creation'!key: newKey value: newValue	"Answer an instance of me with the arguments as the key and value of 	the association."	^(super key: newKey) value: newValue! !Error subclass: #AttemptToWriteReadOnlyGlobal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!AttemptToWriteReadOnlyGlobal commentStamp: 'gh 5/2/2002 20:26' prior: 0!This is a resumable error you get if you try to assign a readonly variable a value.Name definitions in the module system can be read only and are then created using instances of ReadOnlyVariableBinding instead of Association.See also LookupKey>>beReadWriteBinding and LookupKey>>beReadOnlyBinding.!!AttemptToWriteReadOnlyGlobal methodsFor: 'as yet unclassified' stamp: 'ar 8/17/2001 18:02'!description	"Return a textual description of the exception."	| desc mt |	desc := 'Error'.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !!AttemptToWriteReadOnlyGlobal methodsFor: 'as yet unclassified' stamp: 'ar 8/17/2001 18:02'!isResumable	^true! !Collection subclass: #Bag	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!Bag commentStamp: '<historical>' prior: 0!I represent an unordered collection of possibly duplicate elements.	I store these elements in a dictionary, tallying up occurrences of equal objects. Because I store an occurrence only once, my clients should beware that objects they store will not necessarily be retrieved such that == is true. If the client cares, a subclass of me should be created.!!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 17:23'!at: index 	self errorNotKeyed! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 17:23'!at: index put: anObject 	self errorNotKeyed! !!Bag methodsFor: 'accessing' stamp: 'tao 1/5/2000 18:25'!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s _ self size / 100.0. n _ 0.	^ self sortedCounts asArray collect:		[:a | n _ n + a key. (n / s roundTo: 0.1) -> a value]! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:35'!size	"Answer how many elements the receiver contains."	| tally |	tally _ 0.	contents do: [:each | tally _ tally + each].	^ tally! !!Bag methodsFor: 'accessing' stamp: 'sma 6/15/2000 17:00'!sortedCounts	"Answer with a collection of counts with elements, sorted by decreasing	count."	| counts |	counts _ SortedCollection sortBlock: [:x :y | x >= y].	contents associationsDo:		[:assn |		counts add: (Association key: assn value value: assn key)].	^ counts! !!Bag methodsFor: 'accessing'!sortedElements	"Answer with a collection of elements with counts, sorted by element."	| elements |	elements _ SortedCollection new.	contents associationsDo: [:assn | elements add: assn].	^elements! !!Bag methodsFor: 'adding' stamp: 'sma 5/12/2000 17:18'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject."	^ self add: newObject withOccurrences: 1! !!Bag methodsFor: 'adding' stamp: 'sma 5/12/2000 17:20'!add: newObject withOccurrences: anInteger 	"Add newObject anInteger times to the receiver. Answer newObject."	contents at: newObject put: (contents at: newObject ifAbsent: [0]) + anInteger.	^ newObject! !!Bag methodsFor: 'converting' stamp: 'sma 5/12/2000 14:34'!asBag	^ self! !!Bag methodsFor: 'converting' stamp: 'sma 5/12/2000 14:30'!asSet	"Answer a set with the elements of the receiver."	^ contents keys! !!Bag methodsFor: 'copying' stamp: 'sma 5/12/2000 14:53'!copy	^ self shallowCopy setContents: contents copy! !!Bag methodsFor: 'enumerating'!do: aBlock 	"Refer to the comment in Collection|do:."	contents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]! !!Bag methodsFor: 'private' stamp: 'sma 5/12/2000 14:49'!setContents: aDictionary	contents _ aDictionary! !!Bag methodsFor: 'removing' stamp: 'sma 5/12/2000 14:32'!remove: oldObject ifAbsent: exceptionBlock 	"Refer to the comment in Collection|remove:ifAbsent:."	| count |	count _ contents at: oldObject ifAbsent: [^ exceptionBlock value].	count = 1		ifTrue: [contents removeKey: oldObject]		ifFalse: [contents at: oldObject put: count - 1].	^ oldObject! !!Bag methodsFor: 'testing'!includes: anObject 	"Refer to the comment in Collection|includes:."	^contents includesKey: anObject! !!Bag methodsFor: 'testing'!occurrencesOf: anObject 	"Refer to the comment in Collection|occurrencesOf:."	(self includes: anObject)		ifTrue: [^contents at: anObject]		ifFalse: [^0]! !!Bag methodsFor: 'comparing' stamp: 'raok 6/10/2002 15:28'!= aBag	"Two bags are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same size.	 (c) each element occurs the same number of times in both of them".	(aBag isKindOf: Bag) ifFalse: [^false].	self size = aBag size ifFalse: [^false].	contents associationsDo: [:assoc|		(aBag occurrencesOf: assoc key) = assoc value			ifFalse: [^false]].	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Bag class	instanceVariableNames: ''!!Bag class methodsFor: 'instance creation' stamp: 'nk 3/17/2001 09:52'!contentsClass	^Dictionary! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 13:31'!new	^ self new: 4! !!Bag class methodsFor: 'instance creation' stamp: 'nk 3/17/2001 09:52'!new: nElements	^ super new setContents: (self contentsClass new: nElements)! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:17'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ self withAll: aCollection"Examples:	Bag newFrom: {1. 2. 3. 3}	{1. 2. 3. 3} as: Bag"! !Categorizer subclass: #BasicClassOrganizer	instanceVariableNames: 'subject classComment commentStamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:02'!classComment	classComment		ifNil: [^ ''].	^ classComment text ifNil: ['']! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!classComment: aString 	"Store the comment, aString, associated with the object that refers to the 	receiver."	(aString isKindOf: RemoteString) 		ifTrue: [classComment _ aString]		ifFalse: [(aString == nil or: [aString size = 0])			ifTrue: [classComment _ nil]			ifFalse: [				self error: 'use aClass classComment:'.				classComment _ RemoteString newString: aString onFileNumber: 2]]				"Later add priorSource and date and initials?"! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!classComment: aString  stamp: aStamp	"Store the comment, aString, associated with the object that refers to the receiver."	self commentStamp: aStamp.	(aString isKindOf: RemoteString) 		ifTrue: [classComment _ aString]		ifFalse: [(aString == nil or: [aString size = 0])			ifTrue: [classComment _ nil]			ifFalse:				[self error: 'use aClass classComment:'.				classComment _ RemoteString newString: aString onFileNumber: 2]]				"Later add priorSource and date and initials?"! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!commentRemoteStr	^ classComment! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!commentStamp	"Answer the comment stamp for the class"	^ commentStamp! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!commentStamp: aStamp	commentStamp _ aStamp! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!dateCommentLastSubmitted	"Answer a Date object indicating when my class comment was last submitted.  If there is no date stamp, or one of the old-time <historical>  guys, return nil"	"RecentMessageSet organization dateCommentLastSubmitted"	| aStamp tokens |	(aStamp _ self commentStamp) isEmptyOrNil ifTrue: [^ nil].	tokens _ aStamp findBetweenSubStrs: ' '.  "space is expected delimiter, but cr is sometimes seen, though of mysterious provenance"	^ tokens size > 1		ifTrue:			[[tokens second asDate] ifError: [nil]]		ifFalse:			[nil]! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!hasNoComment	"Answer whether the class classified by the receiver has a comment."	^classComment == nil! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:04'!hasSubject	^ self subject notNil! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:04'!subject	^ subject.! !!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'NS 4/7/2004 16:03'!fileOutCommentOn: aFileStream moveSource: moveSource toFile: fileIndex	"Copy the class comment to aFileStream.  If moveSource is true (as in compressChanges or compressSources, then update classComment to point to the new file."	| fileComment |	classComment ifNotNil: 			[aFileStream cr.			fileComment _ RemoteString newString: classComment text							onFileNumber: fileIndex toFile: aFileStream.			moveSource ifTrue: [classComment _ fileComment]]! !!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'NS 4/7/2004 16:04'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| header |	classComment ifNotNil:		[aFileStream cr; nextPut: $!!.		header _ String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				commentStamp ifNil: [commentStamp _ '<historical>'].				commentStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header.		aClass organization fileOutCommentOn: aFileStream				moveSource: moveSource toFile: sourceIndex.		aFileStream cr]! !!BasicClassOrganizer methodsFor: 'private' stamp: 'NS 4/7/2004 16:04'!setSubject: aClassDescription	subject _ aClassDescription! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BasicClassOrganizer class	instanceVariableNames: ''!!BasicClassOrganizer class methodsFor: 'instance creation' stamp: 'NS 4/7/2004 16:04'!class: aClassDescription	^ self new setSubject: aClassDescription! !Inspector subclass: #BasicInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!BasicInspector methodsFor: 'as yet unclassified' stamp: 'ajh 1/31/2003 15:49'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection."	self initialize.	object _ anObject.	selectionIndex _ 0.	contents _ ''! !Object subclass: #Beeper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!Beeper commentStamp: 'gk 2/26/2004 22:44' prior: 0!Beeper provides simple audio (or in some other way) feedback to the user.The recommended use is "Beeper beep" to give the user the equivalence of a beep. If you want to force the beep to use the primitive in the VM for beeping, then use "Beeper beepPrimitive". In either case, if sounds are disabled there will be no beep.The actual beeping, when you use "Beeper beep", is done by sending a #play message to a registered playable object. You can register your own playable object by invoking the class side method #setDefault: passing in an object that responds to the #play message.The default playable object is an instance of Beeper itself which implements #play on the instance side. That implementation delegates the playing of the beep to the default SoundService.Note that #play is introduced as a common interface between AbstractSound and Beeper.This way we can register instances of AbstractSound as playable entities, for example:	Beeper setDefault: (SampledSound new						setSamples: self coffeeCupClink						samplingRate: 12000).Then "Beeper beep" will play the coffeeCup sound.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Beeper class	instanceVariableNames: 'default'!!Beeper class methodsFor: 'customize' stamp: 'gk 2/22/2004 17:55'!default	"When the default is not defined it is	initialized using #newDefault."	default isNil 		ifTrue: [default := self newDefault ].	^ default! !!Beeper class methodsFor: 'customize' stamp: 'gk 2/24/2004 22:12'!newDefault	"Subclasses may override me to provide a default beep.	This base implementation returns an instance of Beeper	which uses the pluggable sound service."	^ self new! !!Beeper class methodsFor: 'beeping' stamp: 'BG 11/26/2003 22:58'!beep	"The preferred way of producing an audible feedback"	self beepPrimitive! !!Beeper class methodsFor: 'beeping' stamp: 'gk 2/24/2004 08:38'!beepPrimitive	"Make a primitive beep. Only use this if	you want to force this to be a primitive beep.	Otherwise use Beeper class>>beep	since this method bypasses the current	registered playable entity."	Preferences soundsEnabled ifTrue: [		self primitiveBeep]! !!Beeper class methodsFor: 'private' stamp: 'gk 2/24/2004 23:51'!primitiveBeep	"Make a primitive beep. Not to be called directly.	It is much better to use Beeper class>>beep	or Beeper class>>beepPrimitive	since this method bypasses the current	registered playable entity and does not	check Preferences class>>soundsEnabled."	<primitive: 140>	self primitiveFailed! !Object subclass: #Behavior	instanceVariableNames: 'superclass methodDict format'	classVariableNames: 'ObsoleteSubclasses'	poolDictionaries: ''	category: 'Kernel-Classes'!!Behavior commentStamp: '<historical>' prior: 0!My instances describe the behavior of other objects. I provide the minimum state necessary for compiling methods, and creating and running instances. Most objects are created as instances of the more fully supported subclass, Class, but I am a good starting point for providing instance-specific behavior (as in Metaclass).!!Behavior methodsFor: 'initialize-release' stamp: 'NS 1/28/2004 11:17'!forgetDoIts	"get rid of old DoIt methods"	self 		basicRemoveSelector: #DoIt;		basicRemoveSelector: #DoItIn:! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 9/10/1999 17:33'!obsolete	"Invalidate and recycle local messages,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue:[ methodDict _ MethodDictionary new ].! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 16:39'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ aClass.	format _ fmt.	methodDict _ mDict.! !!Behavior methodsFor: 'accessing'!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^Compiler! !!Behavior methodsFor: 'accessing'!decompilerClass	"Answer a decompiler class appropriate for compiled methods of this class."	^Decompiler! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/11/1999 05:17'!environment	"Return the environment in which the receiver is visible"	^Smalltalk! !!Behavior methodsFor: 'accessing'!evaluatorClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."	^Compiler! !!Behavior methodsFor: 'accessing'!format	"Answer an Integer that encodes the kinds and numbers of variables of 	instances of the receiver."	^format! !!Behavior methodsFor: 'accessing' stamp: 'di 3/7/2001 17:05'!methodDict	methodDict == nil ifTrue: [self recoverFromMDFaultWithTrace].	^ methodDict! !!Behavior methodsFor: 'accessing' stamp: 'rca 7/26/2000 16:53'!name	"Answer a String that is the name of the receiver."	^'a subclass of ', superclass name! !!Behavior methodsFor: 'accessing'!parserClass	"Answer a parser class to use for parsing method headers."	^self compilerClass parserClass! !!Behavior methodsFor: 'accessing'!sourceCodeTemplate	"Answer an expression to be edited and evaluated in order to define 	methods in this class."	^'message selector and argument names	"comment stating purpose of message"	| temporary variable names |	statements'! !!Behavior methodsFor: 'accessing'!subclassDefinerClass	"Answer an evaluator class appropriate for evaluating definitions of new 	subclasses of this class."	^Compiler! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/13/1999 22:00'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self instSpec = CompiledMethod instSpec ifTrue:[^#compiledMethod]. "Very special!!"	self isBytes ifTrue:[^#bytes].	(self isWords and:[self isPointers not]) ifTrue:[^#words].	self isWeak ifTrue:[^#weak].	self isVariable ifTrue:[^#variable].	^#normal.! !!Behavior methodsFor: 'testing' stamp: 'ar 9/10/1999 17:29'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'testing'!instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1! !!Behavior methodsFor: 'testing'!instSpec	^ (format bitShift: -7) bitAnd: 16rF! !!Behavior methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior"	^true! !!Behavior methodsFor: 'testing'!isBits	"Answer whether the receiver contains just bits (not pointers)."	^ self instSpec >= 6! !!Behavior methodsFor: 'testing'!isBytes	"Answer whether the receiver has 8-bit instance variables."	^ self instSpec >= 8! !!Behavior methodsFor: 'testing'!isFixed	"Answer whether the receiver does not have a variable (indexable) part."	^self isVariable not! !!Behavior methodsFor: 'testing' stamp: 'ab 3/12/2003 17:44'!isMeta	^ false! !!Behavior methodsFor: 'testing' stamp: 'ar 7/14/1999 02:38'!isObsolete	"Return true if the receiver is obsolete."	^self instanceCount = 0! !!Behavior methodsFor: 'testing'!isPointers	"Answer whether the receiver contains just pointers (not bits)."	^self isBits not! !!Behavior methodsFor: 'testing'!isVariable	"Answer whether the receiver has indexable variables."	^ self instSpec >= 2! !!Behavior methodsFor: 'testing' stamp: 'ar 3/21/98 02:36'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'testing'!isWords	"Answer whether the receiver has 16-bit instance variables."	^self isBytes not! !!Behavior methodsFor: 'testing' stamp: 'sd 3/28/2003 15:07'!shouldNotBeRedefined	"Return true if the receiver should not be redefined.	The assumption is that compact classes,	classes in Smalltalk specialObjects and 	Behaviors should not be redefined"	^(self environment compactClassesArray includes: self)		or:[(self environment specialObjectsArray includes: self)			or:[self isKindOf: self]]! !!Behavior methodsFor: 'copying' stamp: 'di 2/17/2000 22:37'!copy	"Answer a copy of the receiver without a list of subclasses."	| myCopy |	myCopy _ self shallowCopy.	^myCopy methodDictionary: self methodDict copy! !!Behavior methodsFor: 'copying' stamp: 'tk 4/16/1999 17:30'!deepCopy	"Classes should only be shallowCopied or made anew."^ self shallowCopy! !!Behavior methodsFor: 'printing' stamp: 'sw 10/13/2000 12:59'!defaultNameStemForInstances	"Answer a basis for external names for default instances of the receiver.  For classees, the class-name itself is a good one."	^ self name! !!Behavior methodsFor: 'printing' stamp: 'ar 5/17/2003 14:11'!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key _ scannedLiteral key.	value _ scannedLiteral value.	key isNil 		ifTrue: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNilDo:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isMemberOf: Symbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNilDo:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!Behavior methodsFor: 'printing' stamp: 'tk 10/16/2001 19:35'!longPrintOn: aStream	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  But, not useful for a class with a method dictionary."	aStream nextPutAll: '<<too complex to show>>'; cr.! !!Behavior methodsFor: 'printing'!printHierarchy	"Answer a description containing the names and instance variable names 	of all of the subclasses and superclasses of the receiver."	| aStream index |	index _ 0.	aStream _ WriteStream on: (String new: 16).	self allSuperclasses reverseDo: 		[:aClass | 		aStream crtab: index.		index _ index + 1.		aStream nextPutAll: aClass name.		aStream space.		aStream print: aClass instVarNames].	aStream cr.	self printSubclassesOn: aStream level: index.	^aStream contents! !!Behavior methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'a descendent of '.	superclass printOn: aStream! !!Behavior methodsFor: 'printing' stamp: 'MPW 1/1/1901 21:56'!printOnStream: aStream 	"Refer to the comment in Object|printOn:." 	aStream print: 'a descendent of '; write:superclass.! !!Behavior methodsFor: 'compiling'!compile: code 	"Compile the argument, code, as source code in the context of the 	receiver. Create an error notification if the code can not be compiled. 	The argument is either a string or an object that converts to a string or a 	PositionableStream on an object that converts to a string."	^self compile: code notifying: nil! !!Behavior methodsFor: 'compiling' stamp: 'NS 1/28/2004 13:59'!compile: code notifying: requestor 	"Compile the argument, code, as source code in the context of the 	receiver and insEtall the result in the receiver's method dictionary. The 	second argument, requestor, is to be notified if an error occurs. The 	argument code is either a string or an object that converts to a string or 	a PositionableStream. This method also saves the source code."		| methodAndNode |	methodAndNode _ self		basicCompile: code "a Text"		notifying: requestor		trailer: self defaultMethodTrailer		ifFail: [^nil].	methodAndNode method putSource: code fromParseNode: methodAndNode node inFile: 2			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].	self addSelector: methodAndNode selector withMethod: methodAndNode method notifying: requestor.	^ methodAndNode selector! !!Behavior methodsFor: 'compiling'!compileAll	^ self compileAllFrom: self! !!Behavior methodsFor: 'compiling' stamp: 'sd 3/28/2003 15:07'!compileAllFrom: oldClass	"Compile all the methods in the receiver's method dictionary.	This validates sourceCode and variable references and forces	all methods to use the current bytecode set"	"ar 7/10/1999: Use oldClass selectors not self selectors"	oldClass selectorsDo: [:sel | self recompile: sel from: oldClass].	self environment currentProjectDo: [:proj | proj compileAllIsolated: self from: oldClass].! !!Behavior methodsFor: 'compiling' stamp: 'NS 1/28/2004 11:32'!defaultMethodTrailer	^ #(0 0 0 0)! !!Behavior methodsFor: 'compiling' stamp: 'NS 1/28/2004 09:22'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method _ oldClass compiledMethodAt: selector.	trailer _ method trailer.	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelectorSilently: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'compiling' stamp: 'ajh 6/11/2001 17:05'!recompileNonResidentMethod: method atSelector: selector from: oldClass	"Recompile the method supplied in the context of this class."	| trailer methodNode |	trailer _ method trailer.	methodNode _ self compilerClass new			compile: (method getSourceFor: selector in: oldClass)			in: self			notifying: nil			ifFail: ["We're in deep doo-doo if this fails (syntax error).				Presumably the user will correct something and proceed,				thus installing the result in this methodDict.  We must				retrieve that new method, and restore the original (or remove)				and then return the method we retrieved."				^ self error: 'see comment'].	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ methodNode generate: trailer! !!Behavior methodsFor: 'instance creation' stamp: 'sd 3/28/2003 15:06'!basicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self basicNew: 0 ].	"space must be low"	self environment signalLowSpace.	^ self basicNew  "retry if user proceeds"! !!Behavior methodsFor: 'instance creation' stamp: 'sd 3/28/2003 15:06'!basicNew: sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		self environment signalLowSpace.		^ self basicNew: sizeRequested  "retry if user proceeds"].	self primitiveFailed! !!Behavior methodsFor: 'instance creation' stamp: 'sw 5/4/2000 20:47'!initializedInstance	"Answer an instance of the receiver which in some sense is initialized.  In the case of Morphs, this will yield an instance that can be attached to the Hand after having received the same kind of basic initialization that would be obtained from an instance chosen from the 'new morph' menu.   Return nil if the receiver is reluctant for some reason to return such a thing"	^ self new! !!Behavior methodsFor: 'instance creation'!new	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."	^ self basicNew initialize! !!Behavior methodsFor: 'instance creation' stamp: 'sd 5/20/2004 11:20'!new: sizeRequested 	"Answer an initialized instance of this class with the number of indexable	variables specified by the argument, sizeRequested."	^ (self basicNew: sizeRequested) initialize  ! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'nb 5/6/2003 17:11'!allSubclasses	"Answer a Set of the receiver's and the receiver's descendent's subclasses. "	| scan scanTop |	scan _ OrderedCollection withAll: self subclasses.	scanTop _ 1.	[scanTop > scan size]		whileFalse: [scan addAll: (scan at: scanTop) subclasses.			scanTop _ scanTop + 1].	^ scan asSet! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'sd 3/28/2003 15:06'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subclassNames |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames _ SortedCollection new.	self subclassesDo: [:subC | subclassNames add: subC name].	subclassNames do:		[:name | (self environment at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Behavior methodsFor: 'accessing class hierarchy'!allSuperclasses	"Answer an OrderedCollection of the receiver's and the receiver's  	ancestor's superclasses. The first element is the receiver's immediate  	superclass, followed by its superclass; the last element is Object."	| temp |	^ superclass == nil		ifTrue: [ OrderedCollection new]		ifFalse: [temp _ superclass allSuperclasses.			temp addFirst: superclass.			temp]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'sd 3/14/2004 18:09'!subclasses	"slow implementation since Behavior does not keep trace of subclasses"		^ self class allInstances  select: [:each | each superclass = self ]! !!Behavior methodsFor: 'accessing class hierarchy'!superclass	"Answer the receiver's superclass, a Class."	^superclass! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'ar 7/10/1999 12:10'!superclass: aClass 	"Change the receiver's superclass to be aClass."	"Note: Do not use 'aClass isKindOf: Behavior' here		in case we recompile from Behavior itself."	(aClass == nil or: [aClass isBehavior])		ifTrue: [superclass _ aClass.				Object flushCache]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'accessing class hierarchy'!withAllSubclasses	"Answer a Set of the receiver, the receiver's descendent's, and the  	receiver's descendent's subclasses."	^ self allSubclasses add: self;		 yourself! !!Behavior methodsFor: 'accessing class hierarchy'!withAllSuperclasses	"Answer an OrderedCollection of the receiver and the receiver's 	superclasses. The first element is the receiver, 	followed by its superclass; the last element is Object."	| temp |	temp _ self allSuperclasses.	temp addFirst: self.	^ temp! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'bf 9/27/1999 17:23'!>> selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^self compiledMethodAt: selector ! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'NS 1/28/2004 09:34'!addSelector: selector withMethod: compiledMethod notifying: requestor	^ self addSelectorSilently: selector withMethod: compiledMethod! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'NS 1/28/2004 11:27'!addSelectorSilently: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary.	Do this without sending system change notifications"	| oldMethodOrNil |	oldMethodOrNil _ self lookupSelector: selector.	self methodDict at: selector put: compiledMethod.	"Now flush Squeak's method cache, either by selector or by method"	oldMethodOrNil == nil ifFalse: [oldMethodOrNil flushCache].	selector flushCache.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'NS 12/12/2003 15:57'!allSelectors	"Answer all selectors understood by instances of the receiver"	| coll |	coll _ OrderedCollection new.	self withAllSuperclasses do:		[:aClass | coll addAll: aClass selectors].	^ coll asIdentitySet! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 10/19/1999 15:12'!changeRecordsAt: selector	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"	| aList |	aList _ VersionsBrowser new			scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [^ nil])			class: self meta: self isMeta			category: (self whichCategoryIncludesSelector: selector)			selector: selector.	^ aList ifNotNil: [aList changeList]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:37'!compiledMethodAt: selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^ self methodDict at: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!compiledMethodAt: selector ifAbsent: aBlock	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"	^ self methodDict at: selector ifAbsent: [aBlock value]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 12/1/2000 20:12'!firstCommentAt:  selector	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."	| sourceString commentStart  pos nextQuotePos |	sourceString _ (self sourceCodeAt: selector) asString.	sourceString size == 0 ifTrue: [^ ''].	commentStart _ sourceString findString: '"' startingAt: 1.	commentStart == 0 ifTrue: [^ ''].	pos _ commentStart + 1.	[(nextQuotePos _ sourceString findString: '"' startingAt: pos) == (sourceString findString: '""' startingAt: pos)]		whileTrue:			[pos _ nextQuotePos + 2].		commentStart == nextQuotePos ifTrue: [^ ''].  "Must have been a quote in string literal"	^ (sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"'"Behavior firstCommentAt: #firstCommentAt:"! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 6/20/2001 15:46'!firstPrecodeCommentFor:  selector	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"	| parser source tree |	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"	(MessageSet isPseudoSelector: selector)		ifTrue:			["Not really a selector"			^ nil].	source _ self sourceCodeAt: selector asSymbol ifAbsent: [^ nil].	parser _ self parserClass new.	tree _ 		parser			parse: (ReadStream on: source)			class: self			noPattern: false			context: nil			notifying: nil			ifFail: [^ nil].	^ (tree comment ifNil: [^ nil]) first! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 1/2/1999 15:45'!lookupSelector: selector	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass _ self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass _ lookupClass superclass].	^ nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ar 7/11/1999 05:11'!methodDictionary	"Convenience"	^self methodDict! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ar 7/12/1999 07:45'!methodDictionary: aDictionary 	"Store the argument, aDictionary, as the method dictionary of the 	receiver."	methodDict _ aDictionary.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ar 12/27/2001 22:29'!methodHeaderFor: selector 	"Answer the string corresponding to the method header for the given selector"	| sourceString parser |	sourceString _ self ultimateSourceCodeAt: selector ifAbsent: [self standardMethodHeaderFor: selector].	(parser _ self parserClass new) parseSelector: sourceString.	^ sourceString asString copyFrom: 1 to: (parser endOfLastToken min: sourceString size)"Behavior methodHeaderFor: #methodHeaderFor: "! !!Behavior methodsFor: 'accessing method dictionary'!precodeCommentOrInheritedCommentFor: selector 	"Answer a string representing the first comment in the method associated 	with selector, considering however only comments that occur before the 	beginning of the actual code. If the version recorded in the receiver is 	uncommented, look up the inheritance chain. Return nil if none found."	| aSuper aComment |	^ (aComment _ self firstPrecodeCommentFor: selector) isEmptyOrNil		ifTrue: [(self == Behavior					or: [superclass == nil							or: [(aSuper _ superclass whichClassIncludesSelector: selector) == nil]])				ifFalse: [aSuper precodeCommentOrInheritedCommentFor: selector]			"ActorState precodeCommentOrInheritedCommentFor: #printOn:"]		ifFalse: [aComment]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'NS 1/28/2004 11:17'!removeSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	^ self basicRemoveSelector: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'rw 5/12/2003 11:19'!selectorAtMethod: method setClass: classResultBlock 	"Answer both the message selector associated with the compiled method 	and the class in which that selector is defined."	| sel |	sel _ self methodDict keyAtIdentityValue: method				ifAbsent: 					[superclass == nil						ifTrue: 							[classResultBlock value: self.							^method defaultSelector].					sel _ superclass selectorAtMethod: method setClass: classResultBlock.					"Set class to be self, rather than that returned from 					superclass. "					sel == method defaultSelector ifTrue: [classResultBlock value: self].					^sel].	classResultBlock value: self.	^sel! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:38'!selectors	"Answer a Set of all the message selectors specified in the receiver's 	method dictionary."	^ self methodDict keys  	"Point selectors."! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:38'!selectorsDo: selectorBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysDo: selectorBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'tk 3/24/1999 07:44'!selectorsWithArgs: numberOfArgs	"Return all selectors defined in this class that take this number of arguments.  Could use String.keywords.  Could see how compiler does this."	| list num |	list _ OrderedCollection new.	self selectorsDo: [:aSel | 		num _ aSel count: [:char | char == $:].		num = 0 ifTrue: [aSel last isLetter ifFalse: [num _ 1]].		num = numberOfArgs ifTrue: [list add: aSel]].	^ list! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:40'!sourceCodeAt: selector	^ (self methodDict at: selector) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:40'!sourceCodeAt: selector ifAbsent: aBlock	^ (self methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary'!sourceMethodAt: selector 	"Answer the paragraph corresponding to the source code for the 	argument."	^(self sourceCodeAt: selector) asText makeSelectorBoldIn: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 11/3/97 00:10'!sourceMethodAt: selector ifAbsent: aBlock	"Answer the paragraph corresponding to the source code for the 	argument."	^ (self sourceCodeAt: selector ifAbsent: [^ aBlock value]) asText makeSelectorBoldIn: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ar 12/27/2001 22:29'!standardMethodHeaderFor: aSelector	| args |	args _ (1 to: aSelector numArgs)	collect:[:i| 'arg', i printString].	args size = 0 ifTrue:[^aSelector asString].	args size = 1 ifTrue:[^aSelector,' arg1'].	^String streamContents:[:s|		(aSelector findTokens:':') with: args do:[:tok :arg|			s nextPutAll: tok; nextPutAll:': '; nextPutAll: arg; nextPutAll:' '.		].	].! !!Behavior methodsFor: 'accessing method dictionary'!supermostPrecodeCommentFor: selector 	"Answer a string representing the precode comment in the most distant 	superclass's implementation of the selector. Return nil if none found."	| aSuper superComment |	(self == Behavior			or: [superclass == nil					or: [(aSuper _ superclass whichClassIncludesSelector: selector) == nil]])		ifFalse: ["There is a super implementor"			superComment _ aSuper supermostPrecodeCommentFor: selector].	^ superComment		ifNil: [self firstPrecodeCommentFor: selector			"ActorState supermostPrecodeCommentFor: #printOn:"]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sd 2/1/2004 19:41'!zapAllMethods	"Remove all methods in this class which is assumed to be obsolete"	methodDict _ MethodDictionary new.	self class isMeta ifTrue: [self class zapAllMethods]! !!Behavior methodsFor: 'accessing instances and variables'!allClassVarNames	"Answer a Set of the names of the receiver's and the receiver's ancestor's 	class variables."	^superclass allClassVarNames! !!Behavior methodsFor: 'accessing instances and variables'!allInstVarNames	"Answer an Array of the names of the receiver's instance variables. The 	Array ordering is the order in which the variables are stored and 	accessed by the interpreter."	| vars |	superclass == nil		ifTrue: [vars _ self instVarNames copy]	"Guarantee a copy is answered."		ifFalse: [vars _ superclass allInstVarNames , self instVarNames].	^vars! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'jm 5/20/1998 15:53'!allInstances 	"Answer a collection of all current instances of the receiver."	| all |	all _ OrderedCollection new.	self allInstancesDo: [:x | x == all ifFalse: [all add: x]].	^ all asArray! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'tpr 5/30/2003 13:04'!allSharedPools	"Answer a Set of the names of the pools (Dictionaries or SharedPool subclasses) that the receiver and the receiver's ancestors share."	^superclass allSharedPools! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'di 6/20/97 10:51'!allSubInstances 	"Answer a list of all current instances of the receiver and all of its subclasses."	| aCollection |	aCollection _ OrderedCollection new.	self allSubInstancesDo:		[:x | x == aCollection ifFalse: [aCollection add: x]].	^ aCollection! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ajh 10/17/2002 11:03'!allowsSubInstVars	"Classes that allow instances to change classes among its subclasses will want to override this and return false, so inst vars are not accidentally added to its subclasses."	^ true! !!Behavior methodsFor: 'accessing instances and variables'!classVarNames	"Answer a Set of the receiver's class variable names."	^Set new! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'sw 5/21/2001 22:51'!inspectAllInstances 	"Inpsect all instances of the receiver.  1/26/96 sw"	| all allSize prefix |	all _ self allInstances.	(allSize _ all size) == 0 ifTrue: [^ self inform: 'There are no instances of ', self name].	prefix _ allSize == 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name)! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'sw 5/21/2001 22:51'!inspectSubInstances 	"Inspect all instances of the receiver and all its subclasses.  CAUTION - don't do this for something as generic as Object!!  1/26/96 sw"	| all allSize prefix |	all _ self allSubInstances.	(allSize _ all size) == 0 ifTrue: [^ self inform: 'There are no instances of ', self name, 'or any of its subclasses'].	prefix _ allSize == 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name, ' & its subclasses')! !!Behavior methodsFor: 'accessing instances and variables'!instVarNames	"Answer an Array of the instance variable names. Behaviors must make 	up fake local instance variable names because Behaviors have instance 	variables for the purpose of compiling methods, but these are not named 	instance variables."	| mySize superSize |	mySize _ self instSize.	superSize _ 		superclass == nil			ifTrue: [0]			ifFalse: [superclass instSize].	mySize = superSize ifTrue: [^#()].		^(superSize + 1 to: mySize) collect: [:i | 'inst' , i printString]! !!Behavior methodsFor: 'accessing instances and variables'!instanceCount	"Answer the number of instances of the receiver that are currently in 	use."	| count |	count _ 0.	self allInstancesDo: [:x | count _ count + 1].	^count! !!Behavior methodsFor: 'accessing instances and variables'!sharedPools	"Answer a Set of the names of the pools (Dictionaries) that the receiver 	shares.	9/12/96 tk  sharedPools have an order now"	^ OrderedCollection new! !!Behavior methodsFor: 'accessing instances and variables'!someInstance	"Primitive. Answer the first instance in the enumeration of all instances 	of the receiver. Fails if there are none. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 77>	^nil! !!Behavior methodsFor: 'accessing instances and variables'!subclassInstVarNames	"Answer a Set of the names of the receiver's subclasses' instance 	variables."	| vars |	vars _ Set new.	self allSubclasses do: [:aSubclass | vars addAll: aSubclass instVarNames].	^vars! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/12/98 12:36'!includesBehavior: aClass	^self == aClass or:[self inheritsFrom: aClass]! !!Behavior methodsFor: 'testing class hierarchy'!inheritsFrom: aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| aSuperclass |	aSuperclass _ superclass.	[aSuperclass == nil]		whileFalse: 			[aSuperclass == aClass ifTrue: [^true].			aSuperclass _ aSuperclass superclass].	^false! !!Behavior methodsFor: 'testing class hierarchy'!kindOfSubclass	"Answer a String that is the keyword that describes the receiver's kind 	of subclass, either a regular subclass, a variableSubclass, a  	variableByteSubclass, a variableWordSubclass, or a weakSubclass."	self isWeak		ifTrue: [^ ' weakSubclass: '].	^ self isVariable		ifTrue: [self isBits				ifTrue: [self isBytes						ifTrue: [ ' variableByteSubclass: ']						ifFalse: [ ' variableWordSubclass: ']]				ifFalse: [ ' variableSubclass: ']]		ifFalse: [ ' subclass: ']! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 5/17/2003 14:06'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^superclass bindingOf: varName! !!Behavior methodsFor: 'testing method dictionary'!canUnderstand: selector 	"Answer whether the receiver can respond to the message whose selector 	is the argument. The selector can be in the method dictionary of the 	receiver's class or any of its superclasses."	(self includesSelector: selector) ifTrue: [^true].	superclass == nil ifTrue: [^false].	^superclass canUnderstand: selector! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 5/18/2003 18:13'!classBindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver's class"	^self bindingOf: varName! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:40'!hasMethods	"Answer whether the receiver has any methods in its method dictionary."	^ self methodDict size > 0! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 3/27/1999 23:20'!includesSelector: aSymbol 	"Answer whether the message whose selector is the argument is in the 	method dictionary of the receiver's class."	^ self methodDict includesKey: aSymbol! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 5/17/2003 14:20'!scopeHas: varName ifTrue: aBlock	"Obsolete. Kept around for possible spurios senders which we don't know about"	(self bindingOf: varName) ifNotNilDo:[:binding|		aBlock value: binding.		^true].	^false! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 8/16/2001 13:31'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "	| who |	who _ Set new.	self selectorsAndMethodsDo:		[:sel :method |		((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])						ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'testing method dictionary'!whichClassIncludesSelector: aSymbol 	"Answer the class on the receiver's superclass chain where the 	argument, aSymbol (a message selector), will be found. Answer nil if none found."	"Rectangle whichClassIncludesSelector: #inspect."	(self includesSelector: aSymbol)		ifTrue: [^ self].	superclass == nil		ifTrue: [^ nil].	^ superclass whichClassIncludesSelector: aSymbol! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:40'!whichSelectorsAccess: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].	^ self methodDict keys select: 		[:sel | 		((self methodDict at: sel)			readsField: instVarIndex)			or: [(self methodDict at: sel) writesField: instVarIndex]]	"Point whichSelectorsAccess: 'x'."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'sd 3/28/2003 15:07'!whichSelectorsReferTo: literal 	"Answer a Set of selectors whose methods access the argument as aliteral."	| special byte |	special _ self environment hasSpecialSelector: literal ifTrueSetByte: [:b |byte _ b].	^self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 8/16/2001 13:31'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ Set new.	self selectorsAndMethodsDo: 		[:sel :method |		((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])						ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:39'!whichSelectorsStoreInto: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].	^ self methodDict keys select: 		[:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!Behavior methodsFor: 'enumerating'!allInstancesDo: aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver."	| inst next |	self ==  UndefinedObject ifTrue: [^ aBlock value: nil].	inst _ self someInstance.	[inst == nil]		whileFalse:		[aBlock value: inst.		inst _ inst nextInstance]! !!Behavior methodsFor: 'enumerating' stamp: 'di 6/20/97 10:50'!allSubInstancesDo: aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver and all its subclasses."	self allInstancesDo: aBlock.	self allSubclassesDo: [:sub | sub allInstancesDo: aBlock]! !!Behavior methodsFor: 'enumerating'!allSubclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's subclasses."	self subclassesDo: 		[:cl | 		aBlock value: cl.		cl allSubclassesDo: aBlock]! !!Behavior methodsFor: 'enumerating' stamp: 'tk 8/18/1999 17:38'!allSubclassesDoGently: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's subclasses."	self subclassesDoGently: 		[:cl | 		cl isInMemory ifTrue: [			aBlock value: cl.			cl allSubclassesDoGently: aBlock]]! !!Behavior methodsFor: 'enumerating'!allSuperclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	superclass == nil		ifFalse: [aBlock value: superclass.				superclass allSuperclassesDo: aBlock]! !!Behavior methodsFor: 'enumerating'!withAllSubclassesDo: aBlock 	"Evaluate the argument, aBlock, for the receiver and each of its 	subclasses."	aBlock value: self.	self allSubclassesDo: aBlock! !!Behavior methodsFor: 'enumerating' stamp: 'nk 2/14/2001 12:09'!withAllSuperAndSubclassesDoGently: aBlock	self allSuperclassesDo: aBlock.	aBlock value: self.	self allSubclassesDoGently: aBlock! !!Behavior methodsFor: 'enumerating' stamp: 'ar 7/11/1999 04:21'!withAllSuperclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	aBlock value: self.	superclass == nil		ifFalse: [superclass withAllSuperclassesDo: aBlock]! !!Behavior methodsFor: 'user interface' stamp: 'sd 3/28/2003 15:05'!allLocalCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."	| aSet special byte cls |	aSet _ Set new.	cls _ self theNonMetaClass.	special _ self environment hasSpecialSelector: aSymbol					ifTrueSetByte: [:b | byte _ b ].	cls withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel ~~ #DoIt ifTrue: [aSet add: class name , ' ', sel]]].	cls class withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel ~~ #DoIt ifTrue: [aSet add: class name , ' ', sel]]].	^aSet! !!Behavior methodsFor: 'user interface' stamp: 'sw 4/4/2000 11:22'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	| any definingClass |	^ self allInstVarNames copy reject:		[:ivn | any _ false.		definingClass _ self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses do:			[:class |  any ifFalse:				[(class whichSelectorsAccess: ivn asSymbol) do: 					[:sel | sel ~~ #DoIt ifTrue: [any _ true]]]].			any]! !!Behavior methodsFor: 'user interface' stamp: 'RAA 5/28/2001 12:00'!withAllSubAndSuperclassesDo: aBlock	self withAllSubclassesDo: aBlock.	self allSuperclassesDo: aBlock.! !!Behavior methodsFor: 'private' stamp: 'NS 1/28/2004 13:59'!basicCompile: code notifying: requestor trailer: bytes ifFail: failBlock	"Compile code without logging the source in the changes file"	| methodNode |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	methodNode encoder requestor: requestor.	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes.! !!Behavior methodsFor: 'private' stamp: 'NS 1/28/2004 10:29'!basicRemoveSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !!Behavior methodsFor: 'private' stamp: 'sd 3/28/2003 15:06'!becomeCompact	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct index |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ self environment compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'sd 3/28/2003 15:06'!becomeUncompact	| cct index |	cct _ self environment compactClassesArray.	(index _ self indexIfCompact) = 0		ifTrue: [^ self].	(cct includes: self)		ifFalse: [^ self halt  "inconsistent state"].	"Update instspec so future instances will not be compact"	format _ format - (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Make sure there are no compact ones left around"	Smalltalk garbageCollect.	"Remove this class from the compact class table"	cct at: index put: nil.! !!Behavior methodsFor: 'private'!flushCache	"Tell the interpreter to remove the contents of its method lookup cache, if it has 	one.  Essential.  See Object documentation whatIsAPrimitive."	<primitive: 89>	self primitiveFailed! !!Behavior methodsFor: 'private'!indexIfCompact	"If these 5 bits are non-zero, then instances of this class	will be compact.  It is crucial that there be an entry in	Smalltalk compactClassesArray for any class so optimized.	See the msgs becomeCompact and becomeUncompact."	^ (format bitShift: -11) bitAnd: 16r1F"Smalltalk compactClassesArray doWithIndex: 	[:c :i | c == nil ifFalse:		[c indexIfCompact = i ifFalse: [self halt]]]"! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!shutDown	"This message is sent on system shutdown to registered classes"! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!shutDown: quitting	"This message is sent on system shutdown to registered classes"	^self shutDown.! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!startUp	"This message is sent to registered classes when the system is coming up."! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!startUp: resuming	"This message is sent to registered classes when the system is coming up."	^self startUp! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'ar 3/2/2001 00:58'!addObsoleteSubclass: aClass	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"	| obs |	ObsoleteSubclasses finalizeValues. "clean up if need be"	obs _ ObsoleteSubclasses at: self ifAbsent:[WeakArray new].	(obs includes: aClass) ifTrue:[^self].	obs _ obs copyWithout: nil.	obs _ obs copyWith: aClass.	ObsoleteSubclasses at: self put: obs.! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'ar 3/2/2001 00:58'!obsoleteSubclasses	"Return all the weakly remembered obsolete subclasses of the receiver"	| obs |	ObsoleteSubclasses finalizeValues. "clean up if need be"	obs _ ObsoleteSubclasses at: self ifAbsent:[^#()].	obs _ obs copyWithout: nil.	obs isEmpty		ifTrue:[ObsoleteSubclasses removeKey: self ifAbsent:[]]		ifFalse:[ObsoleteSubclasses at: self put: obs].	^obs! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'NS 2/19/2002 11:16'!removeObsoleteSubclass: aClass	"Remove aClass from the weakly remembered obsolete subclasses"	| obs |	ObsoleteSubclasses finalizeValues. "clean up if need be"	obs _ ObsoleteSubclasses at: self ifAbsent:[^ self].	(obs includes: aClass) ifFalse:[^self].	obs _ obs copyWithout: aClass.	obs _ obs copyWithout: nil.	obs isEmpty		ifTrue: [ObsoleteSubclasses removeKey: self ifAbsent: []]		ifFalse: [ObsoleteSubclasses at: self put: obs].! !!Behavior methodsFor: 'deprecated' stamp: 'NS 1/28/2004 11:29'!removeSelectorSimply: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	self deprecated: 'Use basicRemoveSelector: instead.'.	oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !!Behavior methodsFor: '*system-support' stamp: 'tpr 12/17/2003 16:04'!allCallsOn	"Answer a SortedCollection of all the methods that refer to me by name or as part of an association in a global dict."	^ (self  systemNavigation allCallsOn:  (self environment associationAt: self theNonMetaClass name)), (self  systemNavigation allCallsOn:  self theNonMetaClass name)	! !!Behavior methodsFor: '*system-support' stamp: 'dvf 8/23/2003 12:43'!allCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol."	^ self  systemNavigation allCallsOn: aSymbol from: self .	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Behavior class	instanceVariableNames: ''!!Behavior class methodsFor: 'testing' stamp: 'ar 9/10/1999 17:28'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!Behavior class methodsFor: 'class initialization' stamp: 'ar 3/3/2001 00:30'!flushObsoleteSubclasses	"Behavior flushObsoleteSubclasses"	ObsoleteSubclasses keys "need a copy" 		do:[:obs| obs ifNotNil:[obs obsoleteSubclasses]]. "remove themselves"	ObsoleteSubclasses finalizeValues.! !!Behavior class methodsFor: 'class initialization' stamp: 'ar 3/2/2001 00:47'!initialize	"Behavior initialize"	"Never called for real"	ObsoleteSubclasses ifNil:[self initializeObsoleteSubclasses].! !!Behavior class methodsFor: 'class initialization' stamp: 'ar 3/2/2001 00:48'!initializeObsoleteSubclasses	ObsoleteSubclasses _ WeakIdentityKeyDictionary new.! !Object subclass: #BitBlt	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight colorMap'	classVariableNames: 'CachedFontColorMaps'	poolDictionaries: ''	category: 'Graphics-Primitives'!!BitBlt commentStamp: '<historical>' prior: 0!I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipHeight	^clipHeight! !!BitBlt methodsFor: 'accessing'!clipHeight: anInteger 	"Set the receiver's clipping area height to be the argument, anInteger."	clipHeight _ anInteger! !!BitBlt methodsFor: 'accessing'!clipRect	"Answer the receiver's clipping area rectangle."	^clipX @ clipY extent: clipWidth @ clipHeight! !!BitBlt methodsFor: 'accessing' stamp: 'ar 10/4/2000 16:37'!clipRect: aRectangle 	"Set the receiver's clipping area rectangle to be the argument, aRectangle."	clipX _ aRectangle left truncated.	clipY _ aRectangle top truncated.	clipWidth _ aRectangle right truncated - clipX.	clipHeight _ aRectangle bottom truncated - clipY.! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipWidth	^clipWidth! !!BitBlt methodsFor: 'accessing'!clipWidth: anInteger 	"Set the receiver's clipping area width to be the argument, anInteger."	clipWidth _ anInteger! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipX	^clipX! !!BitBlt methodsFor: 'accessing'!clipX: anInteger 	"Set the receiver's clipping area top left x coordinate to be the argument, 	anInteger."	clipX _ anInteger! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipY	^clipY! !!BitBlt methodsFor: 'accessing'!clipY: anInteger 	"Set the receiver's clipping area top left y coordinate to be the argument, 	anInteger."	clipY _ anInteger! !!BitBlt methodsFor: 'accessing' stamp: 'tk 8/15/2001 10:56'!color	"Return the current fill color as a Color.  	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."	halftoneForm ifNil: [^ Color black].	^ Color colorFromPixelValue: halftoneForm first depth: destForm depth! !!BitBlt methodsFor: 'accessing'!colorMap	^ colorMap! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/4/2001 15:45'!colorMap: map	"See last part of BitBlt comment. 6/18/96 tk"	colorMap _ map.! !!BitBlt methodsFor: 'accessing'!combinationRule: anInteger 	"Set the receiver's combination rule to be the argument, anInteger, a 	number in the range 0-15."	combinationRule _ anInteger! !!BitBlt methodsFor: 'accessing'!destForm	^ destForm! !!BitBlt methodsFor: 'accessing'!destOrigin: aPoint 	"Set the receiver's destination top left coordinates to be those of the 	argument, aPoint."	destX _ aPoint x.	destY _ aPoint y! !!BitBlt methodsFor: 'accessing'!destRect: aRectangle 	"Set the receiver's destination form top left coordinates to be the origin of 	the argument, aRectangle, and set the width and height of the receiver's 	destination form to be the width and height of aRectangle."	destX _ aRectangle left.	destY _ aRectangle top.	width _ aRectangle width.	height _ aRectangle height! !!BitBlt methodsFor: 'accessing'!destX: anInteger 	"Set the top left x coordinate of the receiver's destination form to be the 	argument, anInteger."	destX _ anInteger! !!BitBlt methodsFor: 'accessing'!destX: x destY: y width: w height: h	"Combined init message saves 3 sends from DisplayScanner"	destX _ x.	destY _ y.	width _ w.	height _ h.! !!BitBlt methodsFor: 'accessing'!destY: anInteger 	"Set the top left y coordinate of the receiver's destination form to be the 	argument, anInteger."	destY _ anInteger! !!BitBlt methodsFor: 'accessing'!fillColor	^ halftoneForm! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/14/2001 23:25'!fillColor: aColorOrPattern 	"The destForm will be filled with this color or pattern of colors.  May be an old Color, a new type Color, a Bitmap (see BitBlt comment), a Pattern, or a Form.  6/18/96 tk"	aColorOrPattern == nil ifTrue: [halftoneForm _ nil. ^ self].	destForm == nil ifTrue: [self error: 'Must set destForm first'].	halftoneForm _ destForm bitPatternFor: aColorOrPattern ! !!BitBlt methodsFor: 'accessing'!height: anInteger 	"Set the receiver's destination form height to be the argument, anInteger."	height _ anInteger! !!BitBlt methodsFor: 'accessing'!sourceForm: aForm 	"Set the receiver's source form to be the argument, aForm."	sourceForm _ aForm! !!BitBlt methodsFor: 'accessing'!sourceOrigin: aPoint 	"Set the receiver's source form coordinates to be those of the argument, 	aPoint."	sourceX _ aPoint x.	sourceY _ aPoint y! !!BitBlt methodsFor: 'accessing'!sourceRect: aRectangle 	"Set the receiver's source form top left x and y, width and height to be 	the top left coordinate and extent of the argument, aRectangle."	sourceX _ aRectangle left.	sourceY _ aRectangle top.	width _ aRectangle width.	height _ aRectangle height! !!BitBlt methodsFor: 'accessing'!sourceX: anInteger 	"Set the receiver's source form top left x to be the argument, anInteger."	sourceX _ anInteger! !!BitBlt methodsFor: 'accessing'!sourceY: anInteger 	"Set the receiver's source form top left y to be the argument, anInteger."	sourceY _ anInteger! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap: aBitmap	"Install the map used for tallying pixels"	colorMap _ aBitmap! !!BitBlt methodsFor: 'accessing'!width: anInteger 	"Set the receiver's destination form width to be the argument, anInteger."	width _ anInteger! !!BitBlt methodsFor: 'copying'!copy: destRectangle from: sourcePt in: srcForm	| destOrigin |	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	sourceForm _ srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	srcForm == nil ifFalse:		[colorMap _ srcForm colormapIfNeededFor: destForm].	^ self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'nk 4/17/2004 19:41'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap _ colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'nk 4/17/2004 19:42'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!copyForm: srcForm to: destPt rule: rule	^ self copyForm: srcForm to: destPt rule: rule		colorMap: (srcForm colormapIfNeededFor: destForm)! !!BitBlt methodsFor: 'copying' stamp: 'di 7/17/97 10:04'!copyForm: srcForm to: destPt rule: rule colorMap: map	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	colorMap _ map.	self copyBits! !!BitBlt methodsFor: 'copying'!copyForm: srcForm to: destPt rule: rule fillColor: color	sourceForm _ srcForm.	self fillColor: color.	"sets halftoneForm"	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!copyFrom: sourceRectangle in: srcForm to: destPt	| sourceOrigin |	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destX _ destPt x.	destY _ destPt y.	sourceOrigin _ sourceRectangle origin.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ sourceRectangle width.	height _ sourceRectangle height.	colorMap _ srcForm colormapIfNeededFor: destForm.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'RAA 9/27/2000 16:48'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	destY _ aPoint y.	destX _ aPoint x.	"the following are not really needed, but theBitBlt primitive will fail if not set"	sourceX ifNil: [sourceX _ 100].	width ifNil: [width _ 100].	^self primDisplayString: aString from: startIndex to: stopIndex			map: font characterToGlyphMap xTable: font xTable			kern: kernDelta.! !!BitBlt methodsFor: 'copying'!fill: destRect fillColor: grayForm rule: rule	"Fill with a Color, not a Form. 6/18/96 tk"	sourceForm _ nil.	self fillColor: grayForm.		"sets halftoneForm"	combinationRule _ rule.	destX _ destRect left.	destY _ destRect top.	sourceX _ 0.	sourceY _ 0.	width _ destRect width.	height _ destRect height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 3/1/2004 13:49'!pixelAt: aPoint	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPeekerFromForm:.  Returns the pixel at aPoint."	sourceX _ aPoint x.	sourceY _ aPoint y.	destForm unhibernate. "before poking"	destForm bits at: 1 put: 0.  "Just to be sure"	self copyBits.	^ destForm bits at: 1! !!BitBlt methodsFor: 'copying' stamp: 'ar 3/1/2004 13:49'!pixelAt: aPoint put: pixelValue	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPokerToForm:.  Overwrites the pixel at aPoint."	destX _ aPoint x.	destY _ aPoint y.	sourceForm unhibernate. "before poking"	sourceForm bits at: 1 put: pixelValue.	self copyBits"| bb |bb _ (BitBlt bitPokerToForm: Display).[Sensor anyButtonPressed] whileFalse:	[bb pixelAt: Sensor cursorPoint put: 55]"! !!BitBlt methodsFor: 'line drawing'!drawFrom: startPoint to: stopPoint 		 ^ self drawFrom: startPoint to: stopPoint withFirstPoint: true! !!BitBlt methodsFor: 'line drawing' stamp: '6/8/97 15:41 di'!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards _ (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 _ startPoint. point2 _ stopPoint]		ifFalse: [point1 _ stopPoint. point2 _ startPoint].	sourceForm == nil ifTrue:		[destX _ point1 x.		destY _ point1 y]		ifFalse:		[width _ sourceForm width.		height _ sourceForm height.		offset _ sourceForm offset.		destX _ (point1 x + offset x) rounded.		destY _ (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded.	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].! !!BitBlt methodsFor: 'line drawing' stamp: 'ar 2/2/2001 15:09'!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy.						P _ P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx.						P _ P + px].				i < px ifTrue: [self copyBits]]]! !!BitBlt methodsFor: 'private' stamp: 'hg 6/27/2000 12:27'!cachedFontColormapFrom: sourceDepth to: destDepth	| srcIndex map |	CachedFontColorMaps class == Array 		ifFalse: [CachedFontColorMaps _ (1 to: 9) collect: [:i | Array new: 32]].	srcIndex _ sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex _ 9].	(map _ (CachedFontColorMaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].	map _ (Color cachedColormapFrom: sourceDepth to: destDepth) copy.	(CachedFontColorMaps at: srcIndex) at: destDepth put: map.	^ map! !!BitBlt methodsFor: 'private' stamp: 'ar 3/8/2003 00:34'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	| sx sy dx dy bbW bbH |	"fill in the lazy state if needed"	destX ifNil:[destX := 0].	destY ifNil:[destY := 0].	width ifNil:[width := destForm width].	height ifNil:[height := destForm height].	sourceX ifNil:[sourceX := 0].	sourceY ifNil:[sourceY := 0].	clipX ifNil:[clipX := 0].	clipY ifNil:[clipY := 0].	clipWidth ifNil:[clipWidth := destForm width].	clipHeight ifNil:[clipHeight := destForm height].	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].	sourceForm ifNotNil:[		sx < 0			ifTrue: [dx _ dx - sx.					bbW _ bbW + sx.					sx _ 0].		sx + bbW > sourceForm width			ifTrue: [bbW _ bbW - (sx + bbW - sourceForm width)].		sy < 0			ifTrue: [dy _ dy - sy.					bbH _ bbH + sy.					sy _ 0].		sy + bbH > sourceForm height			ifTrue: [bbH _ bbH - (sy + bbH - sourceForm height)].	].	(bbW <= 0 or:[bbH <= 0]) ifTrue:[		sourceX := sourceY := destX := destY := clipX := clipY := width := height := 0.		^true].	(sx = sourceX 		and:[sy = sourceY 		and:[dx = destX 		and:[dy = destY 		and:[bbW = width 		and:[bbH = height]]]]]) ifTrue:[^false].	sourceX := sx.	sourceY := sy.	destX := dx.	destY := dy.	width := bbW.	height := bbH.	^true! !!BitBlt methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!copyBitsAgain	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object	documentation whatIsAPrimitive."	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	self primitiveFailed! !!BitBlt methodsFor: 'private'!eraseBits	"Perform the erase operation, which puts 0's in the destination	wherever the source (which is assumed to be just 1 bit deep)	has a 1.  This requires the colorMap to be set in order to AND	all 1's into the destFrom pixels regardless of their size."	| oldMask oldMap |	oldMask _ halftoneForm.	halftoneForm _ nil.	oldMap _ colorMap.	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ oldMask.	"already converted to a Bitmap"	colorMap _ oldMap! !!BitBlt methodsFor: 'private' stamp: 'ar 5/14/2001 23:43'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth |	sourceForm ifNotNil:[lastSourceDepth _ sourceForm depth].	sourceForm _ aStrikeFont glyphs.	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:		["Set up color map for a different source depth (color font)"		"Uses caching for reasonable efficiency"		colorMap _ self cachedFontColormapFrom: sourceForm depth to: destForm depth.		colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).		"Ignore any halftone pattern since we use a color map approach here"		halftoneForm _ nil].	sourceY _ 0.	height _ aStrikeFont height.! !!BitBlt methodsFor: 'private'!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule _ combinationRule.	color _ halftoneForm.  halftoneForm _ nil.	oldMap _ colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ color.	combinationRule _ Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap _ oldMap.	combinationRule _ saveRule" | dot |dot _ Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor cursorPoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !!BitBlt methodsFor: 'private' stamp: 'ar 5/18/2000 21:49'!primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta	| ascii glyph |	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>	startIndex to: stopIndex do:[:charIndex|		ascii _ (aString at: charIndex) asciiValue.		glyph _ glyphMap at: ascii + 1.		sourceX _ xTable at: glyph + 1.		width _ (xTable at: glyph + 2) - sourceX.		self copyBits.		destX _ destX + width + kernDelta.	].! !!BitBlt methodsFor: 'private'!setDestForm: df	| bb |	bb _ df boundingBox.	destForm _ df.	clipX _ bb left.	clipY _ bb top.	clipWidth _ bb width.	clipHeight _ bb height! !!BitBlt methodsFor: 'private' stamp: 'ar 5/14/2001 23:32'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededFor: destForm]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BitBlt class	instanceVariableNames: ''!!BitBlt class methodsFor: 'instance creation' stamp: 'di 3/2/98 12:53'!bitPeekerFromForm: sourceForm	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."	| pixPerWord |	pixPerWord _ 32 // sourceForm depth.	sourceForm unhibernate.	^ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)	 	sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: (pixPerWord - 1)@0		sourceOrigin: 0@0		extent: 1@1		clipRect: (0@0 extent: pixPerWord@1)! !!BitBlt class methodsFor: 'instance creation' stamp: 'di 3/2/98 12:53'!bitPokerToForm: destForm	"Answer an instance to be used for valueAt: aPoint put: pixValue.	The source for a 1x1 copyBits will be the low order of (bits at: 1)"	| pixPerWord |	pixPerWord _ 32//destForm depth.	destForm unhibernate.	^ self destForm: destForm	 	sourceForm: (Form extent: pixPerWord@1 depth: destForm depth)		halftoneForm: nil combinationRule: Form over		destOrigin: 0@0 sourceOrigin: (pixPerWord-1)@0		extent: 1@1 clipRect: (0@0 extent: destForm extent)! !!BitBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:00'!current	"Return the class currently to be used for BitBlt"	^Display defaultBitBltClass! !!BitBlt class methodsFor: 'instance creation'!destForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 	"Answer an instance of me with values set according to the arguments."	^ self new		setDestForm: df		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: sourceOrigin		extent: extent		clipRect: clipRect! !!BitBlt class methodsFor: 'instance creation'!destForm: df sourceForm: sf halftoneForm: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 	"Answer an instance of me with values set according to the arguments."	^ self new		setDestForm: df		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: sourceOrigin		extent: extent		clipRect: clipRect! !!BitBlt class methodsFor: 'instance creation'!toForm: aForm	^ self new setDestForm: aForm! !!BitBlt class methodsFor: 'examples' stamp: 'dew 9/18/2001 02:30'!exampleOne	"This tests BitBlt by displaying the result of all sixteen combination rules that BitBlt is capable of using. (Please see the comment in BitBlt for the meaning of the combination rules). This only works at Display depth of 1. (Rule 15 does not work?)"	| path displayDepth |	displayDepth _ Display depth.	Display newDepth: 1.	path _ Path new.	0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 75)]].	Display fillWhite.	path _ path translateBy: 60 @ 40.	1 to: 16 do: [:index | BitBlt			exampleAt: (path at: index)			rule: index - 1			fillColor: nil].	[Sensor anyButtonPressed] whileFalse: [].	Display newDepth: displayDepth.	"BitBlt exampleOne"! !!BitBlt class methodsFor: 'examples' stamp: 'jrm 2/21/2001 23:43'!exampleTwo	"This is to test painting with a gray tone. It also tests that the seaming with gray patterns is correct in the microcode. Lets you paint for a while and then automatically stops. This only works at Depth of 1."	| f aBitBlt displayDepth |	"create a small black Form source as a brush. "	displayDepth _ Display depth.	Display newDepth: 1.	f _ Form extent: 20 @ 20.	f fillBlack.	"create a BitBlt which will OR gray into the display. "	aBitBlt _ BitBlt		destForm: Display		sourceForm: f		fillColor: Color gray		combinationRule: Form over		destOrigin: Sensor cursorPoint		sourceOrigin: 0 @ 0		extent: f extent		clipRect: Display computeBoundingBox.	"paint the gray Form on the screen for a while. "	[Sensor anyButtonPressed] whileFalse: 		[aBitBlt destOrigin: Sensor cursorPoint.		aBitBlt copyBits].	Display newDepth: displayDepth.	"BitBlt exampleTwo"! !!BitBlt class methodsFor: 'private' stamp: 'jrm 2/21/2001 23:45'!exampleAt: originPoint rule: rule fillColor: mask 	"This builds a source and destination form and copies the source to the	destination using the specifed rule and mask. It is called from the method	named exampleOne. Only works with Display depth of 1"	| s d border aBitBlt | 	border_Form extent: 32@32.	border fillBlack.	border fill: (1@1 extent: 30@30) fillColor: Color white.	s _ Form extent: 32@32.	s fillWhite.	s fillBlack: (7@7 corner: 25@25).	d _ Form extent: 32@32.	d fillWhite.	d fillBlack: (0@0 corner: 32@16).	s displayOn: Display at: originPoint.	border displayOn: Display at: originPoint rule: Form under.	d displayOn: Display at: originPoint + (s width @0).	border displayOn: Display at: originPoint + (s width @0) rule: Form under.	d displayOn: Display at: originPoint + (s extent // (2 @ 1)). 	aBitBlt _ BitBlt		destForm: Display		sourceForm: s		fillColor: mask		combinationRule: rule		destOrigin: originPoint + (s extent // (2 @ 1))		sourceOrigin: 0 @ 0		extent: s extent		clipRect: Display computeBoundingBox.	aBitBlt copyBits.	border 		displayOn: Display at: originPoint + (s extent // (2 @ 1))		rule: Form under.	"BitBlt exampleAt: 100@100 rule: 0 fillColor: nil"  ! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/14/2001 23:31'!benchmark		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log _ WriteStream on: String new.	destRect _ 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest _ nil.			dest _ Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source _ nil. bb _ nil.				source _ Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb _ WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t _ Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !ArrayedCollection variableWordSubclass: #Bitmap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Bitmap commentStamp: '<historical>' prior: 0!My instances provide contiguous storage of bits, primarily to hold the graphical data of Forms. Forms and their subclasses provide the additional structural information as to how the bits should be interpreted in two dimensions.!!Bitmap methodsFor: 'filing' stamp: 'ar 2/3/2001 16:11'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	size _ bm size.	i _ self encodeInt: size in: ba at: 1.	k _ 1.	[k <= size] whileTrue:		[word _ bm at: k.		lowByte _ word bitAnd: 16rFF.		eqBytes _ ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j _ k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j _ j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i _ self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i _ i+1]				ifFalse: [i _ self encodeInt: j-k+1*4+2 in: ba at: i.						i _ self encodeBytesOf: word in: ba at: i].			k _ j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i _ self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i _ i+1.				k _ k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j _ j+1].				j = size ifTrue: [j _ j + 1].				"We have one or more unmatching words, ending at j-1"				i _ self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i _ self encodeBytesOf: (bm at: m) in: ba at: i].				k _ j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | f unhibernate.	b _ f bits.	n _ n + 1.	rawBytes _ rawBytes + (b size*4).	myBytes _ myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:31'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 7 + (self size//1984*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!Bitmap methodsFor: 'filing' stamp: 'ar 2/3/2001 16:11'!decompress: bm fromByteArray: ba at: index	"Decompress the body of a byteArray encoded by compressToByteArray (qv)...	The format is simply a sequence of run-coded pairs, {N D}*.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent				(could be used to skip from one raster line to the next)			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows (see decodeIntFrom:)...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"		"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm."	| i code n anInt data end k pastEnd |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	i _ index.  "byteArray read index"	end _ ba size.	k _ 1.  "bitmap write index"	pastEnd _ bm size + 1.	[i <= end] whileTrue:		["Decode next run start N"		anInt _ ba at: i.  i _ i+1.		anInt <= 223 ifFalse:			[anInt <= 254				ifTrue: [anInt _ (anInt-224)*256 + (ba at: i).  i _ i+1]				ifFalse: [anInt _ 0.						1 to: 4 do: [:j | anInt _ (anInt bitShift: 8) + (ba at: i).  i _ i+1]]].		n _ anInt >> 2.		(k + n) > pastEnd ifTrue: [^ self primitiveFail].		code _ anInt bitAnd: 3.		code = 0 ifTrue: ["skip"].		code = 1 ifTrue: ["n consecutive words of 4 bytes = the following byte"						data _ ba at: i.  i _ i+1.						data _ data bitOr: (data bitShift: 8).						data _ data bitOr: (data bitShift: 16).						1 to: n do: [:j | bm at: k put: data.  k _ k+1]].		code = 2 ifTrue: ["n consecutive words = 4 following bytes"						data _ 0.						1 to: 4 do: [:j | data _ (data bitShift: 8) bitOr: (ba at: i).  i _ i+1].						1 to: n do: [:j | bm at: k put: data.  k _ k+1]].		code = 3 ifTrue: ["n consecutive words from the data..."						1 to: n do:							[:m | data _ 0.							1 to: 4 do: [:j | data _ (data bitShift: 8) bitOr: (ba at: i).  i _ i+1].							bm at: k put: data.  k _ k+1]]]! !!Bitmap methodsFor: 'filing' stamp: 'jm 2/15/98 17:27'!encodeBytesOf: anInt in: ba at: i	"Copy the integer anInt into byteArray ba at index i, and return the next index"	self inline: true.	self var: #ba declareC: 'unsigned char *ba'.	0 to: 3 do:		[:j | ba at: i+j put: (anInt >> (3-j*8) bitAnd: 16rFF)].	^ i+4! !!Bitmap methodsFor: 'filing' stamp: 'jm 2/12/98 17:32'!encodeInt: int	"Encode the integer int as per encodeInt:in:at:, and return it as a ByteArray"	| byteArray next |	byteArray _ ByteArray new: 5.	next _ self encodeInt: int in: byteArray at: 1.	^ byteArray copyFrom: 1 to: next - 1! !!Bitmap methodsFor: 'filing' stamp: 'jm 2/15/98 17:26'!encodeInt: anInt in: ba at: i	"Encode the integer anInt in byteArray ba at index i, and return the next index.	The encoding is as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes"			self inline: true.	self var: #ba declareC: 'unsigned char *ba'.	anInt <= 223 ifTrue: [ba at: i put: anInt. ^ i+1].	anInt <= 7935 ifTrue: [ba at: i put: anInt//256+224. ba at: i+1 put: anInt\\256.  ^ i+2].	ba at: i put: 255.	^ self encodeBytesOf: anInt in: ba at: i+1! !!Bitmap methodsFor: 'filing' stamp: 'di 2/11/98 21:34'!readCompressedFrom: strm	"Decompress an old-style run-coded stream into this bitmap:		[0 means end of runs]		[n = 1..127] [(n+3) copies of next byte]		[n = 128..191] [(n-127) next bytes as is]		[n = 192..255] [(n-190) copies of next 4 bytes]"	| n byte out outBuff bytes |	out _ WriteStream on: (outBuff _ ByteArray new: self size*4).	[(n _ strm next) > 0] whileTrue:		[(n between: 1 and: 127) ifTrue:			[byte _ strm next.			1 to: n+3 do: [:i | out nextPut: byte]].		(n between: 128 and: 191) ifTrue:			[1 to: n-127 do: [:i | out nextPut: strm next]].		(n between: 192 and: 255) ifTrue:			[bytes _ (1 to: 4) collect: [:i | strm next].			1 to: n-190 do: [:i | bytes do: [:b | out nextPut: b]]]].	out position = outBuff size ifFalse: [self error: 'Decompression size error'].	"Copy the final byteArray into self"	self copyFromByteArray: outBuff.! !!Bitmap methodsFor: 'filing' stamp: 'tk 1/24/2000 22:37'!restoreEndianness	"This word object was just read in from a stream.  Bitmaps are always compressed and serialized in a machine-independent way.  Do not correct the Endianness."	"^ self"! !!Bitmap methodsFor: 'filing' stamp: 'nk 12/31/2003 16:02'!storeBits: startBit to: stopBit on: aStream 	"Store my bits as a hex string, breaking the lines every 100 bytes or 	so to comply with the maximum line length limits of Postscript (255 	bytes). "	| lineWidth |	lineWidth := 0.	self		do: [:word | 			startBit				to: stopBit				by: -4				do: [:shift | 					aStream nextPut: (word >> shift bitAnd: 15) asHexDigit.					lineWidth := lineWidth + 1].			(lineWidth > 100)				ifTrue: [aStream cr.					lineWidth := 0]].	lineWidth > 0 ifTrue: [ aStream cr ].! !!Bitmap methodsFor: 'filing' stamp: 'jm 2/18/98 14:19'!writeOn: aStream 	"Store the array of bits onto the argument, aStream. A leading byte of 16r80 identifies this as compressed by compressToByteArray (qv)."	| b |	aStream nextPut: 16r80.	b _ self compressToByteArray.	aStream		nextPutAll: (self encodeInt: b size);		nextPutAll: b.! !!Bitmap methodsFor: 'filing' stamp: 'tk 2/19/1999 07:36'!writeUncompressedOn: aStream 	"Store the array of bits onto the argument, aStream.	(leading byte ~= 16r80) identifies this as raw bits (uncompressed)."	aStream nextInt32Put: self size.	aStream nextPutAll: self! !!Bitmap methodsFor: 'printing' stamp: 'sma 6/1/2000 09:42'!printOn: aStream	self printNameOn: aStream.	aStream nextPutAll: ' of length '; print: self size! !!Bitmap methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:00'!printOnStream: aStream	aStream print: 'a Bitmap of length '; write:self size.! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 16:11'!atAllPut: value	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	super atAllPut: value.! !!Bitmap methodsFor: 'accessing'!bitPatternForDepth: depth	"The raw call on BitBlt needs a Bitmap to represent this color.  I already am Bitmap like.  I am already adjusted for a specific depth.  Interpret me as an array of (32/depth) Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary. 6/18/96 tk"	^ self! !!Bitmap methodsFor: 'accessing'!byteAt: byteAddress	"Extract a byte from a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:.  See Form pixelAt:  7/1/96 tk"	| lowBits |	lowBits _ byteAddress - 1 bitAnd: 3.	^((self at: byteAddress - 1 - lowBits // 4 + 1)		bitShift: (lowBits - 3) * 8)		bitAnd: 16rFF! !!Bitmap methodsFor: 'accessing' stamp: 'ar 9/21/2001 23:06'!byteAt: byteAddress put: byte	"Insert a byte into a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:put:.  See Form pixelAt:put:  7/1/96 tk"	| longWord shift lowBits longAddr |	(byte < 0 or:[byte > 255]) ifTrue:[^self errorImproperStore].	lowBits _ byteAddress - 1 bitAnd: 3.	longWord _ self at: (longAddr _ (byteAddress - 1 - lowBits) // 4 + 1).	shift _ (3 - lowBits) * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) 		+ (byte bitShift: shift).	self at: longAddr put: longWord.	^ byte! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 16:18'!byteSize	^self size * 4! !!Bitmap methodsFor: 'accessing' stamp: 'ar 6/16/2002 18:49'!copyFromByteArray: byteArray	"This method should work with either byte orderings"	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk isLittleEndian ifTrue:[byteHack swapEndianness].	byteHack displayOn: myHack.! !!Bitmap methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:41'!integerAt: index	"Return the integer at the given index"	| word |	<primitive: 165>	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:42'!integerAt: index put: anInteger	"Store the integer at the given index"	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!Bitmap methodsFor: 'accessing' stamp: 'tk 3/15/97'!pixelValueForDepth: depth	"Self is being used to represent a single color.  Answer bits that appear in ONE pixel of this color in a Bitmap of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32.  Returns an integer.  First pixel only.  "	^ (self at: 1) bitAnd: (1 bitShift: depth) - 1! !!Bitmap methodsFor: 'accessing'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!Bitmap methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!Bitmap methodsFor: 'testing' stamp: 'ar 5/25/2000 19:42'!isColormap	"Bitmaps were used as color maps for BitBlt.	This method allows to recognize real color maps."	^false! !!Bitmap methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 21:51'!copy	^self clone! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Bitmap class	instanceVariableNames: ''!!Bitmap class methodsFor: 'instance creation' stamp: 'di 2/9/98 16:02'!decodeIntFrom: s	"Decode an integer in stream s as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes	"			| int |	int _ s next.	int <= 223 ifTrue: [^ int].	int <= 254 ifTrue: [^ (int-224)*256 + s next].	int _ s next.	1 to: 3 do: [:j | int _ (int bitShift: 8) + s next].	^ int! !!Bitmap class methodsFor: 'instance creation' stamp: 'di 2/12/98 14:34'!decompressFromByteArray: byteArray	| s bitmap size |	s _ ReadStream on: byteArray.	size _ self decodeIntFrom: s.	bitmap _ self new: size.	bitmap decompress: bitmap fromByteArray: byteArray at: s position+1.	^ bitmap! !!Bitmap class methodsFor: 'instance creation' stamp: 'ar 12/23/1999 14:35'!newFromStream: s	| len |	s next = 16r80 ifTrue:		["New compressed format"		len _ self decodeIntFrom: s.		^ Bitmap decompressFromByteArray: (s nextInto: (ByteArray new: len))].	s skip: -1.	len _ s nextInt32.	len <= 0		ifTrue: ["Old compressed format"				^ (self new: len negated) readCompressedFrom: s]		ifFalse: ["Old raw data format"				^ s nextWordsInto: (self new: len)]! !!Bitmap class methodsFor: 'utilities' stamp: 'sd 6/28/2003 09:33'!swapBytesIn: aNonPointerThing from: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: aNonPointerThing.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !Error subclass: #BlockCannotReturn	instanceVariableNames: 'result deadHome'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!BlockCannotReturn commentStamp: '<historical>' prior: 0!This class is private to the EHS implementation.  Its use allows for ensured execution to survive code such as:[self doThis.^nil]	ensure: [self doThat]Signaling or handling this exception is not recommended.!!BlockCannotReturn methodsFor: 'accessing' stamp: 'ajh 2/6/2002 11:12'!deadHome: context	deadHome _ context! !!BlockCannotReturn methodsFor: 'accessing' stamp: 'tfei 3/30/1999 12:54'!result	^result! !!BlockCannotReturn methodsFor: 'accessing' stamp: 'tfei 3/30/1999 12:54'!result: r	result := r! !!BlockCannotReturn methodsFor: 'exceptionDescription' stamp: 'tfei 3/30/1999 12:55'!defaultAction	self messageText: 'Block cannot return'.	^super defaultAction! !!BlockCannotReturn methodsFor: 'exceptionDescription' stamp: 'tfei 4/2/1999 15:49'!isResumable	^true! !ContextPart variableSubclass: #BlockContext	instanceVariableNames: 'nargs startpc home'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!BlockContext commentStamp: '<historical>' prior: 0!My instances function similarly to instances of MethodContext, but they hold the dynamic state for execution of a block in Smalltalk. They access all temporary variables and the method sender via their home pointer, so that those values are effectively shared. Their indexable part is used to store their independent value stack during execution.	My instance must hold onto its home in order to work. This can cause circularities if the home is also pointing (via a temp, perhaps) to the instance. In the rare event that this happens (as in SortedCollection sortBlock:) the message fixTemps will replace home with a copy of home, thus defeating the sharing of temps but, nonetheless, eliminating the circularity.BlockContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a BlockContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.!!BlockContext methodsFor: 'initialize-release' stamp: 'ls 6/21/2000 17:42'!home: aContextPart startpc: position nargs: anInteger 	"This is the initialization message. The receiver has been initialized with 	the correct size only."	home _ aContextPart.	pc _ startpc _ position.	nargs _ anInteger.	stackp _ 0.! !!BlockContext methodsFor: 'initialize-release' stamp: 'ajh 7/18/2003 21:49'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ startpc.	self stackp: 0.	nargs timesRepeat: [  "skip arg popping"		self nextInstruction selector = #popIntoTemporaryVariable:			ifFalse: [self halt: 'unexpected bytecode instruction']	].! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/24/2003 12:35'!blockHome	^ self home! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 23:29'!finalBlockHome	^ self home! !!BlockContext methodsFor: 'accessing'!fixTemps	"Fix the values of the temporary variables used in the block that are 	ordinarily shared with the method in which the block is defined."	home _ home copy.	home swapSender: nil! !!BlockContext methodsFor: 'accessing'!hasMethodReturn	"Answer whether the receiver has a return ('^') in its code."	| method scanner end |	method _ self method.	"Determine end of block from long jump preceding it"	end _ (method at: startpc-2)\\16-4*256 + (method at: startpc-1) + startpc - 1.	scanner _ InstructionStream new method: method pc: startpc.	scanner scanFor: [:byte | (byte between: 120 and: 124) or: [scanner pc > end]].	^scanner pc <= end! !!BlockContext methodsFor: 'accessing'!home	"Answer the context in which the receiver was defined."	^home! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/21/2003 13:16'!isBlock	^ true! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 12:12'!isExecutingBlock	^ true! !!BlockContext methodsFor: 'accessing'!method	"Answer the compiled method in which the receiver was defined."	^home method! !!BlockContext methodsFor: 'accessing' stamp: 'mdr 4/10/2001 10:34'!numArgs	"Answer the number of arguments that must be used to evaluate this block"	^nargs! !!BlockContext methodsFor: 'accessing'!receiver 	"Refer to the comment in ContextPart|receiver."	^home receiver! !!BlockContext methodsFor: 'accessing'!tempAt: index 	"Refer to the comment in ContextPart|tempAt:."	^home at: index! !!BlockContext methodsFor: 'accessing'!tempAt: index put: value 	"Refer to the comment in ContextPart|tempAt:put:."	^home at: index put: value! !!BlockContext methodsFor: 'evaluating' stamp: 'ajh 1/13/2002 13:36'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'evaluating'!value	"Primitive. Evaluate the block represented by the receiver. Fail if the 	block expects any arguments or if the block is already being executed. 	Optional. No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 81>	^self valueWithArguments: #()! !!BlockContext methodsFor: 'evaluating'!value: arg 	"Primitive. Evaluate the block represented by the receiver. Fail if the 	block expects other than one argument or if the block is already being 	executed. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 81>	^self valueWithArguments: (Array with: arg)! !!BlockContext methodsFor: 'evaluating'!value: arg1 value: arg2 	"Primitive. Evaluate the block represented by the receiver. Fail if the 	block expects other than two arguments or if the block is already being 	executed. Optional. See Object documentation whatIsAPrimitive."	<primitive: 81>	^self valueWithArguments: (Array with: arg1 with: arg2)! !!BlockContext methodsFor: 'evaluating'!value: arg1 value: arg2 value: arg3 	"Primitive. Evaluate the block represented by the receiver. Fail if the 	block expects other than three arguments or if the block is already being 	executed. Optional. See Object documentation whatIsAPrimitive."	<primitive: 81>	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3)! !!BlockContext methodsFor: 'evaluating' stamp: 'di 11/30/97 09:19'!value: arg1 value: arg2 value: arg3 value: arg4 	"Primitive. Evaluate the block represented by the receiver. Fail if the 	block expects other than three arguments or if the block is already being 	executed. Optional. See Object documentation whatIsAPrimitive."	<primitive: 81>	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3			with: arg4)! !!BlockContext methodsFor: 'evaluating' stamp: 'mjr 9/10/2003 22:42'!valueWithArguments: anArray 	"Primitive. Evaluate the block represented by the receiver. The argument 	is an Array whose elements are the arguments for the block. Fail if the 	length of the Array is not the same as the the number of arguments that 	the block was expecting. Fail if the block is already being executed. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 82>	self numArgs = anArray size		ifTrue: [self error: 'Attempt to evaluate a block that is already being evaluated.']		ifFalse: [self error: 			'This block accepts ' ,self numArgs printString, ' argument', (self numArgs = 1 ifTrue:[''] ifFalse:['s']) , 			', but was called with ', anArray size printString, '.']! !!BlockContext methodsFor: 'controlling' stamp: 'sma 5/12/2000 13:22'!repeat	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."	[self value. true] whileTrue! !!BlockContext methodsFor: 'controlling'!whileFalse	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is false." 	^ [self value] whileFalse: []! !!BlockContext methodsFor: 'controlling'!whileFalse: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is false."	^ [self value] whileFalse: [aBlock value]! !!BlockContext methodsFor: 'controlling'!whileTrue	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is true." 	^ [self value] whileTrue: []! !!BlockContext methodsFor: 'controlling'!whileTrue: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is true."	^ [self value] whileTrue: [aBlock value]! !!BlockContext methodsFor: 'scheduling' stamp: 'di 9/12/1998 11:53'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'jm 11/9/1998 10:16'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	| forkedProcess |	forkedProcess _ self newProcess.	forkedProcess priority: priority.	^ forkedProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:35'!blockReturnTop	"Simulate the interpreter's action when a ReturnTopOfStack bytecode is 	encountered in the receiver."	| save dest |	save _ home.	"Needed because return code will nil it"	dest _ self return: self pop from: self.	home _ save.	sender _ nil.	^ dest! !!BlockContext methodsFor: 'printing' stamp: 'LC 1/6/2002 11:59'!decompile	^ Decompiler new decompileBlock: self! !!BlockContext methodsFor: 'printing' stamp: 'dew 11/11/2003 01:15'!printOn: aStream	| blockString truncatedBlockString |	home == nil ifTrue: [^aStream nextPutAll: 'a BlockContext with home=nil'].	aStream nextPutAll: '[] in '.	super printOn: aStream.	aStream nextPutAll: ' '.	blockString _ ((self decompile ifNil: ['--source missing--']) printString						replaceAll: Character cr with: Character space)							replaceAll: Character tab with: Character space.	truncatedBlockString _ blockString truncateWithElipsisTo: 80.	truncatedBlockString size < blockString size ifTrue:		[truncatedBlockString _ truncatedBlockString, ']}'].	aStream nextPutAll: truncatedBlockString.! !!BlockContext methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:01'!printOnStream: aStream	home == nil ifTrue: [^aStream print: 'a BlockContext with home=nil'].	aStream print: '[] in '.	super printOnStream: aStream! !!BlockContext methodsFor: 'private' stamp: 'ajh 1/24/2003 20:36'!aboutToReturn: result through: firstUnwindContext 	"Called from VM when an unwindBlock is found between self and its home.  Return to home's sender, executing unwind blocks on the way."	self home return: result! !!BlockContext methodsFor: 'private' stamp: 'tfei 3/31/1999 17:40'!cannotReturn: result	"The receiver tried to return result to a method context that no longer exists."	| ex newResult |	ex := BlockCannotReturn new.	ex result: result.	newResult := ex signal.	^newResult! !!BlockContext methodsFor: 'private' stamp: 'di 1/14/1999 22:28'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!BlockContext methodsFor: 'private'!startpc	"for use by the System Tracer only"	^startpc! !!BlockContext methodsFor: 'private' stamp: 'ar 3/2/2001 01:16'!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess _ Processor activeProcess.	oldPriority _ activeProcess priority.	activeProcess priority: Processor highestPriority.	result _ self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!BlockContext methodsFor: 'system simulation' stamp: 'di 1/11/1999 10:24'!pushArgs: args from: sendr 	"Simulates action of the value primitive."	args size ~= nargs ifTrue: [^self error: 'incorrect number of args'].	self stackp: 0.	args do: [:arg | self push: arg].	sender _ sendr.	pc _ startpc! !!BlockContext methodsFor: 'system simulation' stamp: 'hmm 7/30/2001 18:03'!stepToSendOrReturn	pc = startpc ifTrue: [		"pop args first"		self numArgs timesRepeat: [self step]].	^super stepToSendOrReturn! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 3/4/2004 22:36'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue b |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b _ aBlock.		thisContext tempAt: 1 put: nil.  "aBlock _ nil"		b value.	].	^ returnValue! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 1/24/2003 21:43'!ifCurtailed: aBlock	"Evaluate the receiver with an abnormal termination action."	<primitive: 198>	^ self value! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 3/6/2001 14:25'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	| handlerActive |	<primitive: 199>	handlerActive _ true.	^self value! !!BlockContext methodsFor: 'private-debugger' stamp: 'tfei 3/20/2000 00:24'!hideFromDebugger	^home ~~ nil and: [home hideFromDebugger]! !!BlockContext methodsFor: 'tiles' stamp: 'RAA 8/16/1999 13:52'!valueWithPossibleArgs: anArray 	self numArgs = 0 ifTrue: [^self value].	self numArgs = anArray size ifTrue: [^self valueWithArguments: anArray].	self numArgs > anArray size ifTrue: [		^self valueWithArguments: anArray,				(Array new: (self numArgs - anArray size))	].	^self valueWithArguments: (anArray copyFrom: 1 to: self numArgs)! !ParseNode subclass: #BlockNode	instanceVariableNames: 'arguments statements returns nArgsNode size remoteCopyNode temporaries'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!BlockNode commentStamp: '<historical>' prior: 0!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!BlockNode methodsFor: 'initialize-release'!arguments: argNodes statements: statementsCollection returns: returnBool from: encoder	"Compile."	arguments _ argNodes.	statements _ statementsCollection size > 0				ifTrue: [statementsCollection]				ifFalse: [argNodes size > 0						ifTrue: [statementsCollection copyWith: arguments last]						ifFalse: [Array with: NodeNil]].	returns _ returnBool! !!BlockNode methodsFor: 'initialize-release' stamp: 'sma 3/3/2000 13:38'!statements: statementsCollection returns: returnBool 	"Decompile."	| returnLast |	returnLast _ returnBool.	returns _ false.	statements _ 		(statementsCollection size > 1 			and: [(statementsCollection at: statementsCollection size - 1) 					isReturningIf])				ifTrue: 					[returnLast _ false.					statementsCollection allButLast]				ifFalse: [statementsCollection size = 0						ifTrue: [Array with: NodeNil]						ifFalse: [statementsCollection]].	arguments _ #().	temporaries _ #().	returnLast ifTrue: [self returnLast]! !!BlockNode methodsFor: 'accessing'!arguments: argNodes 	"Decompile."	arguments _ argNodes! !!BlockNode methodsFor: 'accessing' stamp: 'tk 8/4/1999 22:53'!block	^ self! !!BlockNode methodsFor: 'accessing'!firstArgument	^ arguments first! !!BlockNode methodsFor: 'accessing'!numberOfArguments	^arguments size! !!BlockNode methodsFor: 'accessing'!returnLast	self returns		ifFalse: 			[returns _ true.			statements at: statements size put: statements last asReturnNode]! !!BlockNode methodsFor: 'accessing'!returnSelfIfNoOther	self returns		ifFalse: 			[statements last == NodeSelf ifFalse: [statements add: NodeSelf].			self returnLast]! !!BlockNode methodsFor: 'accessing' stamp: 'sma 2/27/2000 22:37'!temporaries: aCollection	temporaries _ aCollection! !!BlockNode methodsFor: 'testing'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^arguments size = 0! !!BlockNode methodsFor: 'testing'!isComplex	^statements size > 1 or: [statements size = 1 and: [statements first isComplex]]! !!BlockNode methodsFor: 'testing'!isJust: node	returns ifTrue: [^false].	^statements size = 1 and: [statements first == node]! !!BlockNode methodsFor: 'testing'!isJustCaseError	^ statements size = 1 and:		[statements first			isMessage: #caseError			receiver: [:r | r==NodeSelf]			arguments: nil]! !!BlockNode methodsFor: 'testing'!isQuick	^ statements size = 1		and: [statements first isVariableReference				or: [statements first isSpecialConstant]]! !!BlockNode methodsFor: 'testing'!returns	^returns or: [statements last isReturningIf]! !!BlockNode methodsFor: 'code generation'!code	^statements first code! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:32'!emitExceptLast: stack on: aStream	| nextToLast |	nextToLast _ statements size - 1.	nextToLast < 1 ifTrue: [^ self].  "Only one statement"	1 to: nextToLast do:		[:i | (statements at: i) emitForEffect: stack on: aStream].! !!BlockNode methodsFor: 'code generation'!emitForEvaluatedEffect: stack on: aStream	self returns		ifTrue: 			[self emitForEvaluatedValue: stack on: aStream.			stack pop: 1]		ifFalse: 			[self emitExceptLast: stack on: aStream.			statements last emitForEffect: stack on: aStream]! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:44'!emitForEvaluatedValue: stack on: aStream	self emitExceptLast: stack on: aStream.	statements last emitForValue: stack on: aStream.! !!BlockNode methodsFor: 'code generation' stamp: 'hmm 7/17/2001 21:02'!emitForValue: stack on: aStream	aStream nextPut: LdThisContext.	stack push: 1.	nArgsNode emitForValue: stack on: aStream.	remoteCopyNode		emit: stack		args: 1		on: aStream.	"Force a two byte jump."	self emitLong: size code: JmpLong on: aStream.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitStorePop: stack on: aStream].	self emitForEvaluatedValue: stack on: aStream.	self returns ifFalse: [		aStream nextPut: EndRemote.		pc _ aStream position.	].	stack pop: 1! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:33'!sizeExceptLast: encoder	| codeSize nextToLast |	nextToLast _ statements size - 1.	nextToLast < 1 ifTrue: [^ 0]. "Only one statement"	codeSize _ 0.	1 to: nextToLast do: 		[:i | codeSize _ codeSize + ((statements at: i) sizeForEffect: encoder)].	^ codeSize! !!BlockNode methodsFor: 'code generation'!sizeForEvaluatedEffect: encoder	self returns ifTrue: [^self sizeForEvaluatedValue: encoder].	^(self sizeExceptLast: encoder)		+ (statements last sizeForEffect: encoder)! !!BlockNode methodsFor: 'code generation'!sizeForEvaluatedValue: encoder	^(self sizeExceptLast: encoder)		+ (statements last sizeForValue: encoder)! !!BlockNode methodsFor: 'code generation'!sizeForValue: encoder	nArgsNode _ encoder encodeLiteral: arguments size.	remoteCopyNode _ encoder encodeSelector: #blockCopy:.	size _ (self sizeForEvaluatedValue: encoder)				+ (self returns ifTrue: [0] ifFalse: [1]). "endBlock"	arguments _ arguments collect:  "Chance to prepare debugger remote temps"				[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size _ size + (arg sizeForStorePop: encoder)].	^1 + (nArgsNode sizeForValue: encoder) 		+ (remoteCopyNode size: encoder args: 1 super: false) + 2 + size! !!BlockNode methodsFor: 'printing' stamp: 'RAA 7/5/2000 11:43'!printArgumentsOn: aStream indent: level	arguments size = 0		ifTrue: [^ self].	aStream dialect = #SQ00		ifTrue: [aStream				withStyleFor: #setOrReturn				do: [aStream nextPutAll: 'With'].			arguments				do: [:arg | 					aStream space.					aStream						withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key]].			aStream nextPutAll: '. ']		ifFalse: [arguments				do: [:arg | aStream						withStyleFor: #blockArgument						do: [aStream nextPutAll: ':';								 nextPutAll: arg key;								 space]].			aStream nextPutAll: '| '].	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1		ifTrue: [aStream crtab: level]! !!BlockNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:49'!printOn: aStream indent: level	"statements size <= 1 ifFalse: [aStream crtab: level]."	aStream nextPut: $[.	self printArgumentsOn: aStream indent: level.	self printTemporariesOn: aStream indent: level.	self printStatementsOn: aStream indent: level.	aStream nextPut: $]! !!BlockNode methodsFor: 'printing' stamp: 'di 4/3/1999 23:25'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level _ 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len _ shown _ statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown _ 1 max: shown - 1]		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])					ifTrue: [shown _ shown - 1]].	1 to: shown do: 		[:i | 		thisStatement _ statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:09'!printTemporariesOn: aStream indent: level	(temporaries == nil or: [temporaries size = 0])		ifFalse: 			[aStream nextPut: $|.			temporaries do: 				[:arg | 				aStream					space;					withStyleFor: #temporaryVariable						do: [aStream nextPutAll: arg key]].			aStream nextPutAll: ' | '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!BlockNode methodsFor: 'equation translation'!statements	^statements! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BlockNode class	instanceVariableNames: ''!!BlockNode class methodsFor: 'instance creation' stamp: 'sma 3/3/2000 13:34'!statements: statements returns: returns	^ self new statements: statements returns: returns! !!BlockNode class methodsFor: 'instance creation' stamp: 'sma 3/3/2000 13:34'!withJust: aNode	^ self statements: (Array with: aNode) returns: false! !Object subclass: #Boolean	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!Boolean commentStamp: '<historical>' prior: 0!Boolean is an abstract class defining the protocol for logic testing operations and conditional control structures for the logical values represented by the instances of its subclasses True and False.Boolean redefines #new so no instances of Boolean can be created. It also redefines several messages in the 'copying' protocol to ensure that only one instance of each of its subclasses True (the global true, logical assertion) and False (the global false, logical negation) ever exist in the system.!!Boolean methodsFor: 'logical operations'!& aBoolean 	"Evaluating conjunction. Evaluate the argument. Then answer true if 	both the receiver and the argument are true."	self subclassResponsibility! !!Boolean methodsFor: 'logical operations'!eqv: aBoolean 	"Answer true if the receiver is equivalent to aBoolean."	^self == aBoolean! !!Boolean methodsFor: 'logical operations'!not	"Negation. Answer true if the receiver is false, answer false if the 	receiver is true."	self subclassResponsibility! !!Boolean methodsFor: 'logical operations'!xor: aBoolean 	"Exclusive OR. Answer true if the receiver is not equivalent to aBoolean."	^(self == aBoolean) not! !!Boolean methodsFor: 'logical operations'!| aBoolean 	"Evaluating disjunction (OR). Evaluate the argument. Then answer true 	if either the receiver or the argument is true."	self subclassResponsibility! !!Boolean methodsFor: 'controlling'!and: alternativeBlock 	"Nonevaluating conjunction. If the receiver is true, answer the value of 	the argument, alternativeBlock; otherwise answer false without 	evaluating the argument."	self subclassResponsibility! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:44'!and: block1 and: block2	"Nonevaluating conjunction without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as false, then return false immediately,		without evaluating any further blocks.	If all return true, then return true."	self ifFalse: [^ false].	block1 value ifFalse: [^ false].	block2 value ifFalse: [^ false].	^ true! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:44'!and: block1 and: block2 and: block3	"Nonevaluating conjunction without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as false, then return false immediately,		without evaluating any further blocks.	If all return true, then return true."	self ifFalse: [^ false].	block1 value ifFalse: [^ false].	block2 value ifFalse: [^ false].	block3 value ifFalse: [^ false].	^ true! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:44'!and: block1 and: block2 and: block3 and: block4	"Nonevaluating conjunction without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as false, then return false immediately,		without evaluating any further blocks.	If all return true, then return true."	self ifFalse: [^ false].	block1 value ifFalse: [^ false].	block2 value ifFalse: [^ false].	block3 value ifFalse: [^ false].	block4 value ifFalse: [^ false].	^ true! !!Boolean methodsFor: 'controlling'!ifFalse: alternativeBlock 	"If the receiver is true (i.e., the condition is true), then the value is the 	true alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !!Boolean methodsFor: 'controlling'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 	"Same as ifTrue:ifFalse:."	self subclassResponsibility! !!Boolean methodsFor: 'controlling'!ifTrue: alternativeBlock 	"If the receiver is false (i.e., the condition is false), then the value is the 	false alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !!Boolean methodsFor: 'controlling'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock	"If the receiver is true (i.e., the condition is true), then answer the value 	of the argument trueAlternativeBlock. If the receiver is false, answer the 	result of evaluating the argument falseAlternativeBlock. If the receiver 	is a nonBoolean then create an error notification. Execution does not 	actually reach here because the expression is compiled in-line."	self subclassResponsibility! !!Boolean methodsFor: 'controlling'!or: alternativeBlock 	"Nonevaluating disjunction. If the receiver is false, answer the value of 	the argument, alternativeBlock; otherwise answer true without 	evaluating the argument."	self subclassResponsibility! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:45'!or: block1 or: block2	"Nonevaluating alternation without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as true, then return true immediately,		without evaluating any further blocks.	If all return false, then return false."	self ifTrue: [^ true].	block1 value ifTrue: [^ true].	block2 value ifTrue: [^ true].	^ false! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:45'!or: block1 or: block2 or: block3	"Nonevaluating alternation without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as true, then return true immediately,		without evaluating any further blocks.	If all return false, then return false."	self ifTrue: [^ true].	block1 value ifTrue: [^ true].	block2 value ifTrue: [^ true].	block3 value ifTrue: [^ true].	^ false! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:45'!or: block1 or: block2 or: block3 or: block4	"Nonevaluating alternation without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as true, then return true immediately,		without evaluating any further blocks.	If all return false, then return false."	self ifTrue: [^ true].	block1 value ifTrue: [^ true].	block2 value ifTrue: [^ true].	block3 value ifTrue: [^ true].	block4 value ifTrue: [^ true].	^ false! !!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!Boolean methodsFor: 'copying'!deepCopy 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!Boolean methodsFor: 'copying'!shallowCopy 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!Boolean methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!Boolean methodsFor: 'printing' stamp: 'sw 9/27/2001 17:19'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Boolean! !!Boolean methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	self printOn: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Boolean class	instanceVariableNames: ''!!Boolean class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 00:31'!initializedInstance	^ nil! !!Boolean class methodsFor: 'instance creation'!new	self error: 'You may not create any more Booleans - this is two-valued logic'! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:06'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asBooleanValueFrom: anInteger on: aStream ! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:05'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToBooleanObjectFrom: aNode on: aStream! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:10'!ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToBooleanValueFrom: aNode on: aStream! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:08'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asBooleanValueFrom: anInteger! !ParseNode subclass: #BraceNode	instanceVariableNames: 'elements sourceLocations emitNode'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!BraceNode commentStamp: '<historical>' prior: 0!Used for compiling and decompiling brace constructs.These now compile into either a fast short form for 4 elements or less:	Array braceWith: a with: b ... or a long form of indefinfite length:	(Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray.The erstwhile brace assignment form is no longer supported.!!BraceNode methodsFor: 'initialize-release'!elements: collection	"Decompile."	elements _ collection! !!BraceNode methodsFor: 'initialize-release'!elements: collection sourceLocations: locations	"Compile."	elements _ collection.	sourceLocations _ locations! !!BraceNode methodsFor: 'initialize-release' stamp: 'di 11/19/1999 11:06'!matchBraceStreamReceiver: receiver messages: messages	((receiver isMessage: #braceStream: receiver: nil arguments: [:arg | arg isConstantNumber])		and: [messages last isMessage: #braceArray receiver: nil arguments: nil])		ifFalse: [^ nil "no match"].	"Appears to be a long form brace construct"	self elements: (messages allButLast collect:		[:msg | (msg isMessage: #nextPut: receiver: nil arguments: nil)					ifFalse: [^ nil "not a brace element"].		msg arguments first])! !!BraceNode methodsFor: 'initialize-release' stamp: 'di 11/19/1999 11:19'!matchBraceWithReceiver: receiver selector: selector arguments: arguments	selector = (self selectorForShortForm: arguments size)		ifFalse: [^ nil "no match"].	"Appears to be a short form brace construct"	self elements: arguments! !!BraceNode methodsFor: 'testing'!blockAssociationCheck: encoder	"If all elements are MessageNodes of the form [block]->[block], and there is at	 least one element, answer true.	 Otherwise, notify encoder of an error."	elements size = 0		ifTrue: [^encoder notify: 'At least one case required'].	elements with: sourceLocations do:			[:x :loc |			(x 	isMessage: #->				receiver:					[:rcvr |					(rcvr isKindOf: BlockNode) and: [rcvr numberOfArguments = 0]]				arguments:					[:arg |					(arg isKindOf: BlockNode) and: [arg numberOfArguments = 0]])			  ifFalse:				[^encoder notify: 'Association between 0-argument blocks required' at: loc]].	^true! !!BraceNode methodsFor: 'testing'!numElements	^ elements size! !!BraceNode methodsFor: 'code generation' stamp: 'di 11/19/1999 08:58'!emitForValue: stack on: aStream	^ emitNode emitForValue: stack on: aStream! !!BraceNode methodsFor: 'code generation' stamp: 'di 1/4/2000 11:24'!selectorForShortForm: nElements	nElements > 4 ifTrue: [^ nil].	^ #(braceWithNone braceWith: braceWith:with:			braceWith:with:with: braceWith:with:with:with:) at: nElements + 1! !!BraceNode methodsFor: 'code generation' stamp: 'di 11/19/1999 11:13'!sizeForValue: encoder	emitNode _ elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^ emitNode sizeForValue: encoder! !!BraceNode methodsFor: 'enumerating'!casesForwardDo: aBlock	"For each case in forward order, evaluate aBlock with three arguments:	 the key block, the value block, and whether it is the last case."	| numCases case |	1 to: (numCases _ elements size) do:		[:i |		case _ elements at: i.		aBlock value: case receiver value: case arguments first value: i=numCases]! !!BraceNode methodsFor: 'enumerating'!casesReverseDo: aBlock	"For each case in reverse order, evaluate aBlock with three arguments:	 the key block, the value block, and whether it is the last case."	| numCases case |	(numCases _ elements size) to: 1 by: -1 do:		[:i |		case _ elements at: i.		aBlock value: case receiver value: case arguments first value: i=numCases]! !!BraceNode methodsFor: 'printing' stamp: 'di 11/19/1999 09:17'!printOn: aStream indent: level	aStream nextPut: ${.	1 to: elements size do: 		[:i | (elements at: i) printOn: aStream indent: level.		i < elements size ifTrue: [aStream nextPutAll: '. ']].	aStream nextPut: $}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BraceNode class	instanceVariableNames: ''!!BraceNode class methodsFor: 'examples' stamp: 'di 11/19/1999 09:05'!example	"Test the {a. b. c} syntax."	| x |	x _ {1. {2. 3}. 4}.	^ {x first. x second first. x second last. x last. 5} as: Set"BraceNode example Set (0 1 2 3 4 5 )"! !Halt subclass: #BreakPoint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!BreakPoint commentStamp: 'md 11/18/2003 09:32' prior: 0!This exception is raised on executing a breakpoint."BreakPoint signal" is called from "Object>>break".!Object subclass: #BreakpointManager	instanceVariableNames: ''	classVariableNames: 'Installed'	poolDictionaries: ''	category: 'Tools-Debugger'!!BreakpointManager commentStamp: 'emm 5/30/2002 14:20' prior: 0!This class manages methods that include breakpoints.It has several class methods to install and uninstall breakpoints.Evaluating "BreakpointManager clear" will remove all installed breakpoints in the system.Known issues:- currently, only break-on-entry type of breakpoints are supported- emphasis change not implemented for MVC browsers- uninstalling the breakpoint doesn't auto-update other browsers- uninstalling a breakpoint while debugging should restart-simulate the current methodErnest Micklei, 2002Send comments to emicklei@philemonworks.com!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BreakpointManager class	instanceVariableNames: ''!!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'emm 5/30/2002 09:37'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass methodDictionary at: aSymbol put: breakMethod.! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'emm 4/24/2002 23:24'!unInstall: breakMethod 	| who oldMethod |	oldMethod _ self installed at: breakMethod ifAbsent:[^self].	who _ breakMethod who.	(who first methodDictionary at: who last) == breakMethod		ifTrue:[	who first methodDictionary at: who last put: oldMethod].	self installed removeKey: breakMethod! !!BreakpointManager class methodsFor: 'private' stamp: 'emm 5/30/2002 09:36'!breakpointMethodSourceFor: aSymbol in: aClass 	"Compose new source containing a break statement (currently it will be the first,	later we want to insert it in any place)"	| oldSource methodNode breakOnlyMethodNode sendBreakMessageNode |	oldSource := aClass sourceCodeAt: aSymbol.	methodNode := aClass compilerClass new		compile: oldSource		in: aClass 		notifying: nil 		ifFail: [self error: '[breakpoint] unable to install breakpoint'].	breakOnlyMethodNode := aClass compilerClass new		compile: 'temporaryMethodSelectorForBreakpointself break.^self'		in: aClass 		notifying: nil 		ifFail: [self error: '[breakpoint] unable to install breakpoint'].	sendBreakMessageNode := breakOnlyMethodNode block statements first.	methodNode block statements addFirst: sendBreakMessageNode.	^methodNode printString	! !!BreakpointManager class methodsFor: 'private' stamp: 'emm 5/30/2002 09:33'!compilePrototype: aSymbol in: aClass 	"Compile and return a new method containing a break statement"	| source node method |	source := self breakpointMethodSourceFor: aSymbol in: aClass.	node := aClass compilerClass new		compile: source		in: aClass 		notifying: nil 		ifFail: [self error: '[breakpoint] unable to install breakpoint'].	node isNil ifTrue: [^nil].	"dunno what the arguments mean..."	method := node generate: #(0 0 0 0).	^method! !!BreakpointManager class methodsFor: 'private' stamp: 'emm 4/24/2002 23:24'!installed	Installed isNil ifTrue:[Installed := IdentityDictionary new].	^Installed! !!BreakpointManager class methodsFor: 'intialization-release' stamp: 'emm 5/30/2002 09:08'!clear
	"BreakpointManager clear"
	self installed copy keysDo:[ :breakMethod |		self unInstall: breakMethod].				! !!BreakpointManager class methodsFor: 'testing' stamp: 'emm 5/30/2002 09:22'!methodHasBreakpoint: aMethod	^self installed includesKey: aMethod! !CodeHolder subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated'	classVariableNames: 'RecentClasses'	poolDictionaries: ''	category: 'Tools-Browser'!!Browser commentStamp: '<historical>' prior: 0!I represent a query path into the class descriptions, the software of the system.!!Browser methodsFor: 'accessing' stamp: 'ls 10/28/2003 12:28'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue:			[^ self classDefinitionText ].	editSelection == #editComment 		ifTrue:			[(theClass _ self selectedClass) ifNil: [^ ''].			comment _ theClass comment.			currentCompiledMethod _ theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass _ self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'accessing' stamp: 'nk 3/29/2004 10:11'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText theClass |	self changed: #annotation.	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[theClass _ self selectedClass.			theClass				ifNil: 					[self inform: 'You must select a classbefore giving it a comment.'.					^ false].			theClass comment: aText stamp: Utilities changeStamp.			self changed: #classCommentText.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[self inform: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'accessing' stamp: 'drs 1/6/2003 16:11'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	messageCategoryListIndex > 0 & (messageListIndex = 0)		ifTrue: [^ 1 to: 500]	"entire empty method template"		ifFalse: [^ 1 to: 0]  "null selection"! !!Browser methodsFor: 'accessing' stamp: 'BG 10/29/2003 09:01'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView)) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!Browser methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:28'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class 	being browsed. A doIt in the code pane will let the user see the value of 	the class variables."	^ self selectedClass ifNil: [FakeClassPool new]! !!Browser methodsFor: 'accessing'!editSelection	^editSelection! !!Browser methodsFor: 'accessing' stamp: 'nk 2/15/2004 13:27'!editSelection: aSelection	"Set the editSelection as requested."	editSelection _ aSelection.	self changed: #editSelection.! !!Browser methodsFor: 'accessing' stamp: 'sw 10/30/1999 22:59'!noteSelectionIndex: anInteger for: aSymbol	aSymbol == #systemCategoryList		ifTrue:			[systemCategoryListIndex _ anInteger].	aSymbol == #classList		ifTrue:			[classListIndex _ anInteger].	aSymbol == #messageCategoryList		ifTrue:			[messageCategoryListIndex _ anInteger].	aSymbol == #messageList		ifTrue:			[messageListIndex _ anInteger].! !!Browser methodsFor: 'accessing' stamp: 'jm 4/28/1998 05:55'!request: prompt initialAnswer: initialAnswer	^ FillInTheBlank		request: prompt		initialAnswer: initialAnswer! !!Browser methodsFor: 'accessing' stamp: 'sw 1/4/2001 12:24'!spawn: aString 	"Create and schedule a fresh browser and place aString in its code pane.  This method is called when the user issues the #spawn command (cmd-o) in any code pane.  Whatever text was in the original code pane comes in to this method as the aString argument; the changes in the original code pane have already been cancelled by the time this method is called, so aString is the only copy of what the user had in his code pane."	self selectedClassOrMetaClass ifNotNil: [^ super spawn: aString].	systemCategoryListIndex ~= 0		ifTrue:			["This choice is slightly useless but is the historical implementation"			^ self buildSystemCategoryBrowserEditString: aString].			^ super spawn: aString  	"This bail-out at least saves the text being spawned, which would otherwise be lost"! !!Browser methodsFor: 'accessing' stamp: 'sw 9/26/2002 17:56'!suggestCategoryToSpawnedBrowser: aBrowser	"aBrowser is a message-category browser being spawned from the receiver.  Tell it what it needs to know to get its category info properly set up."	(self isMemberOf: Browser) "yecch, but I didn't invent the browser hierarchy"		ifTrue:			[aBrowser messageCategoryListIndex: (self messageCategoryList indexOf: self categoryOfCurrentMethod ifAbsent: [2])]		ifFalse:			[aBrowser setOriginalCategoryIndexForCurrentMethod]! !!Browser methodsFor: 'annotation' stamp: 'sw 8/26/2002 10:00'!annotation	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."	|  aSelector aClass |	(aClass _ self selectedClassOrMetaClass) == nil ifTrue: [^ '------'].	self editSelection == #editComment ifTrue:		[^ self annotationForSelector: #Comment ofClass: aClass].	self editSelection == #editClass ifTrue:		[^ self annotationForSelector: #Definition ofClass: aClass].	(aSelector _ self selectedMessageName) ifNil: [^ '------'].	^ self annotationForSelector: aSelector ofClass: aClass! !!Browser methodsFor: 'breakpoints' stamp: 'emm 5/30/2002 09:23'!toggleBreakOnEntry	"Install or uninstall a halt-on-entry breakpoint"	| selectedMethod |	self selectedClassOrMetaClass isNil ifTrue:[^self].	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.	selectedMethod hasBreakpoint		ifTrue:			[BreakpointManager unInstall: selectedMethod]		ifFalse:			[BreakpointManager 				installInClass: self selectedClassOrMetaClass				selector: self selectedMessageName].	self changed: #messageList		! !!Browser methodsFor: 'class comment pane' stamp: 'nk 2/15/2004 13:19'!classComment: aText notifying: aPluggableTextMorph 	"The user has just entered aText.	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."	| theClass cleanedText redRange |	theClass := self selectedClassOrMetaClass.	theClass		ifNotNil: [cleanedText := aText asText.			redRange := cleanedText rangeOf: TextColor red startingAt: 1.			redRange size = cleanedText size				ifTrue: [cleanedText						removeAttribute: TextColor red						from: 1						to: redRange last ].			theClass classComment: aText].	self changed: #classCommentText.	^ true! !!Browser methodsFor: 'class functions' stamp: 'sd 5/23/2003 14:23'!addAllMethodsToCurrentChangeSet	"Add all the methods in the selected class or metaclass to the current change set.  You ought to know what you're doing before you invoke this!!"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[aClass selectors do:			[:sel |				ChangeSet current adoptSelector: sel forClass: aClass].		self changed: #annotation]! !!Browser methodsFor: 'class functions'!buildClassBrowser	"Create and schedule a new class category browser for the current class 	selection, if one exists."	self buildClassBrowserEditString: nil! !!Browser methodsFor: 'class functions' stamp: 'nk 2/14/2004 14:32'!classCommentText	"return the text to display for the comment of the currently selected class"	| theClass |	theClass _ self selectedClassOrMetaClass.	theClass ifNil: [ ^''].	^ theClass hasComment		ifTrue: [  theClass comment  ]		ifFalse: [ Text string: 'THIS CLASS HAS NO COMMENT!!' translated attribute: TextColor red ]! !!Browser methodsFor: 'class functions' stamp: 'nk 2/14/2004 15:11'!classDefinitionText	"return the text to display for the definition of the currently selected class"	| theClass |	theClass _ self selectedClassOrMetaClass.	theClass ifNil: [ ^''].	^theClass definitionST80: Preferences printAlternateSyntax not! !!Browser methodsFor: 'class functions' stamp: 'sw 12/6/2000 16:32'!classListMenu: aMenu 	"For backward compatibility with old browers stored in image segments"	^ self classListMenu: aMenu shifted: false! !!Browser methodsFor: 'class functions' stamp: 'sw 2/27/2001 12:06'!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	shifted		ifTrue:			[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'class functions' stamp: 'dwh 11/23/1999 00:09'!copyClass	| originalName copysName class oldDefinition newDefinition |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	originalName _ self selectedClass name.	copysName _ self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName _ copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk includesKey: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	oldDefinition _ self selectedClass definition.	newDefinition _ oldDefinition copyReplaceAll: '#' , originalName asString with: '#' , copysName asString.	Cursor wait 		showWhile: [class _ Compiler evaluate: newDefinition logged: true.					class copyAllCategoriesFrom: (Smalltalk at: originalName).					class class copyAllCategoriesFrom: (Smalltalk at: originalName) class].	self classListIndex: 0.	self changed: #classList! !!Browser methodsFor: 'class functions' stamp: 'sw 10/22/2002 16:10'!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"	| aClass newMessage setter |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[aClass instVarNames do: 			[:aName |				(aClass canUnderstand: aName asSymbol)					ifFalse:						[newMessage _ aName, '	"Answer the value of ', aName, '"	^ ', aName.						aClass compile: newMessage classified: 'accessing' notifying: nil].				(aClass canUnderstand: (setter _ aName, ':') asSymbol)					ifFalse:						[newMessage _ setter, ' anObject	"Set the value of ', aName, '"	', aName, ' _ anObject'.						aClass compile: newMessage classified: 'accessing' notifying: nil]]]! !!Browser methodsFor: 'class functions' stamp: 'sw 11/21/2003 21:45'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	keywdIx _ defTokens findFirst: [:x | x beginsWith: 'category'].	envt _ Smalltalk environmentForCategory: ((defTokens at: keywdIx+1) copyWithout: $').	keywdIx _ defTokens findFirst: [:x | '*subclass*' match: x].	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass theNonMetaClass name asString ~= newClassName])		and: [envt includesKeyOrAbove: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: [self changed: #systemCategoryList.				self changed: #classList.				self clearUserEditFlag.				self setClass: class selector: nil.				"self clearUserEditFlag; editClass."				^ true]		ifFalse: [^ false]! !!Browser methodsFor: 'class functions' stamp: 'nk 2/15/2004 13:23'!editClass	"Retrieve the description of the class definition."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #editClass.	self changed: #contents.	self changed: #classCommentText.! !!Browser methodsFor: 'class functions' stamp: 'nk 2/14/2004 15:08'!editComment	"Retrieve the description of the class comment."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	metaClassIndicated _ false.	self editSelection: #editComment.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self decorateButtons.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'nb 5/6/2003 16:49'!explainSpecial: string 	"Answer a string explaining the code pane selection if it is displaying 	one of the special edit functions."	| classes whole lits reply |	(editSelection == #editClass or: [editSelection == #newClass])		ifTrue: 			["Selector parts in class definition"			string last == $: ifFalse: [^nil].			lits _ Array with:				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.			(whole _ lits detect: [:each | (each keywords					detect: [:frag | frag = string] ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifTrue: [reply _ '"' , string , ' is one part of the message selector ' , whole , '.']				ifFalse: [^nil].			classes _ self systemNavigation allClassesImplementing: whole.			classes _ 'these classes ' , classes printString.			^reply , '  It is defined in ' , classes , '."Smalltalk browseAllImplementorsOf: #' , whole].	editSelection == #hierarchy		ifTrue: 			["Instance variables in subclasses"			classes _ self selectedClassOrMetaClass allSubclasses.			classes _ classes detect: [:each | (each instVarNames						detect: [:name | name = string] ifNone: []) ~~ nil]					ifNone: [^nil].			classes _ classes printString.			^'"is an instance variable in class ' , classes , '."' , classes , ' browseAllAccessesTo: ''' , string , '''.'].	editSelection == #editSystemCategories ifTrue: [^nil].	editSelection == #editMessageCategories ifTrue: [^nil].	^nil! !!Browser methodsFor: 'class functions' stamp: 'tk 4/2/98 13:50'!fileOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .st."Cursor write showWhile:		[classListIndex ~= 0 ifTrue: [self selectedClass fileOut]]! !!Browser methodsFor: 'class functions' stamp: 'je 12/4/2002 18:10'!findMethod	"Pop up a list of the current class's methods, and select the one chosen by the user"	| aClass selectors reply cat messageCatIndex messageIndex |	self classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	selectors _ aClass selectors asSortedArray.	selectors isEmpty ifTrue: [self inform: aClass name, ' has no methods.'. ^ self].	reply _ (SelectionMenu labelList: selectors selections: selectors) startUp.	reply == nil ifTrue: [^ self].	cat _ aClass whichCategoryIncludesSelector: reply.	messageCatIndex _ self messageCategoryList indexOf: cat.	self messageCategoryListIndex: messageCatIndex.	messageIndex _ (self messageList indexOf: reply).	self messageListIndex: messageIndex! !!Browser methodsFor: 'class functions' stamp: 'nk 2/14/2004 15:09'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #hierarchy.	self changed: #editComment.	self contentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'nk 2/14/2004 15:07'!makeNewSubclass	self selectedClassOrMetaClass ifNil: [^ self].	self okToChange ifFalse: [^ self].	self editSelection: #newClass.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'nk 2/14/2004 15:09'!plusButtonHit	"Cycle among definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [self hierarchy. ^ self].	editSelection == #hierarchy		ifTrue: [self editSelection: #editClass.			classListIndex = 0 ifTrue: [^ self].			self okToChange ifFalse: [^ self].			self changed: #editComment.			self contentsChanged.			^ self].	self editComment! !!Browser methodsFor: 'class functions' stamp: 'tk 4/2/98 13:50'!printOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .html."Cursor write showWhile:		[classListIndex ~= 0 ifTrue: [self selectedClass fileOutAsHtml: true]]! !!Browser methodsFor: 'class functions' stamp: 'sw 3/5/2001 18:04'!removeClass	"If the user confirms the wish to delete the class, do so"	super removeClass ifTrue:		[self classListIndex: 0]! !!Browser methodsFor: 'class functions' stamp: 'sd 4/29/2003 11:49'!renameClass	| oldName newName obs |	classListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ self request: 'Please type new class name' initialAnswer: oldName.	newName = ''		ifTrue: [^ self].	"Cancel returns ''"	newName _ newName asSymbol.	newName = oldName		ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	self changed: #classList.	self		classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName)				indexOf: newName).	obs _ self systemNavigation				allCallsOn: (Smalltalk associationAt: newName).	obs isEmpty		ifFalse: [self systemNavigation				browseMessageList: obs				name: 'Obsolete References to ' , oldName				autoSelect: oldName]! !!Browser methodsFor: 'class functions' stamp: 'BG 11/1/2003 13:59'!shiftedClassListMenu: aMenu	"Set up the menu to apply to the receiver's class list when the shift key is down"	^ aMenu addList: #(			-			('unsent methods'			browseUnusedMethods	'browse all methods defined by this class that have no senders')			('unreferenced inst vars'	showUnreferencedInstVars	'show a list of all instance variables that are not referenced in methods')			('unreferenced class vars'	showUnreferencedClassVars	'show a list of all class variables that are not referenced in methods')			('subclass template'			makeNewSubclass		'put a template into the code pane for defining of a subclass of this class')			-			('sample instance'			makeSampleInstance		'give me a sample instance of this class, if possible')			('inspect instances'			inspectInstances			'open an inspector on all the extant instances of this class')			('inspect subinstances'		inspectSubInstances		'open an inspector on all the extant instances of this class and of all of its subclasses')			-						('add all meths to current chgs'		addAllMethodsToCurrentChangeSet																'place all the methods defined by this class into the current change set')			('create inst var accessors'	createInstVarAccessors	'compile instance-variable access methods for any instance variables that do not yet have them')			-			('more...'					offerUnshiftedClassListMenu	'return to the standard class-list menu'))! !!Browser methodsFor: 'class list'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	systemCategoryListIndex = 0		ifTrue: [^Array new]		ifFalse: [^systemOrganizer listAtCategoryNumber: systemCategoryListIndex]! !!Browser methodsFor: 'class list'!classListIndex	"Answer the index of the current class selection."	^classListIndex! !!Browser methodsFor: 'class list' stamp: 'nk 2/14/2004 15:07'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])].	contents _ nil.	self selectedClass isNil		ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'class list' stamp: 'tk 4/5/98 12:25'!classListSingleton	| name |	name _ self selectedClassName.	^ name ifNil: [Array new]		ifNotNil: [Array with: name]! !!Browser methodsFor: 'class list' stamp: 'nb 6/17/2003 12:25'!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList _ RecentClasses select: [:n | Smalltalk includesKey: n].	recentList size == 0 ifTrue: [^ Beeper beep].	className := (SelectionMenu selections: recentList) startUp.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self selectCategoryForClass: class.	self classListIndex: (self classList indexOf: class name)! !!Browser methodsFor: 'class list' stamp: 'sr 10/29/1999 20:28'!selectClass: classNotMeta	self classListIndex: (self classList indexOf: classNotMeta name)! !!Browser methodsFor: 'class list' stamp: 'di 12/6/1999 20:41'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	| name envt |	(name _ self selectedClassName) ifNil: [^ nil].	(envt _ self selectedEnvironment) ifNil: [^ nil].	^ envt at: name! !!Browser methodsFor: 'class list' stamp: 'sw 11/24/1999 14:48'!selectedClassName	| aClassList |	"Answer the name of the current class. Answer nil if no selection exists."	(classListIndex = 0 or: [classListIndex > (aClassList _ self classList) size]) ifTrue: [^ nil].	^ aClassList at: classListIndex! !!Browser methodsFor: 'class list'!toggleClassListIndex: anInteger 	"If anInteger is the current class index, deselect it. Else make it the 	current class selection."	self classListIndex: 		(classListIndex = anInteger			ifTrue: [0]			ifFalse: [anInteger])! !!Browser methodsFor: 'code pane' stamp: 'asm 6/25/2003 22:48'!compileMessage: aText notifying: aController	"Compile the code that was accepted by the user, placing the compiled method into an appropriate message category.  Return true if the compilation succeeded, else false."	| fallBackCategoryIndex fallBackMethodIndex originalSelectorName result |	self selectedMessageCategoryName ifNil:			[ self selectOriginalCategoryForCurrentMethod 											ifFalse:["Select the '--all--' category"											self messageCategoryListIndex: 1]]. 	self selectedMessageCategoryName asSymbol = ClassOrganizer allCategory		ifTrue:			[ "User tried to save a method while the ALL category was selected"			fallBackCategoryIndex _ messageCategoryListIndex.			fallBackMethodIndex _ messageListIndex.			editSelection == #newMessage				ifTrue:					[ "Select the 'as yet unclassified' category"					messageCategoryListIndex _ 0.					(result _ self defineMessageFrom: aText notifying: aController)						ifNil:							["Compilation failure:  reselect the original category & method"							messageCategoryListIndex _ fallBackCategoryIndex.							messageListIndex _ fallBackMethodIndex]						ifNotNil:							[self setSelector: result]]				ifFalse:					[originalSelectorName _ self selectedMessageName.					self setOriginalCategoryIndexForCurrentMethod.					messageListIndex _ fallBackMethodIndex _ self messageList indexOf: originalSelectorName.								(result _ self defineMessageFrom: aText notifying: aController)						ifNotNil:							[self setSelector: result]						ifNil:							[ "Compilation failure:  reselect the original category & method"							messageCategoryListIndex _ fallBackCategoryIndex.							messageListIndex _ fallBackMethodIndex.							^ result notNil]].			self changed: #messageCategoryList.			^ result notNil]		ifFalse:			[ "User tried to save a method while the ALL category was NOT selected"			^ (self defineMessageFrom: aText notifying: aController) notNil]! !!Browser methodsFor: 'code pane' stamp: 'sw 5/18/2001 20:55'!showBytecodes	"Show or hide the bytecodes of the selected method -- an older protocol now mostly not relevant."	self toggleShowingByteCodes! !!Browser methodsFor: 'copying' stamp: 'tk 12/5/1999 17:59'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  See DeepCopier class comment."super veryDeepInner: deepCopier."systemOrganizer _ systemOrganizer. 	clone has the old value. we share it""classOrganizer _ classOrganizer		clone has the old value. we share it""metaClassOrganizer 	_ metaClassOrganizer	clone has the old value. we share it"systemCategoryListIndex _ systemCategoryListIndex veryDeepCopyWith: deepCopier.classListIndex _ classListIndex veryDeepCopyWith: deepCopier.messageCategoryListIndex _ messageCategoryListIndex veryDeepCopyWith: deepCopier.messageListIndex _ messageListIndex veryDeepCopyWith: deepCopier.editSelection _ editSelection veryDeepCopyWith: deepCopier.metaClassIndicated _ metaClassIndicated veryDeepCopyWith: deepCopier.! !!Browser methodsFor: 'drag and drop' stamp: 'mir 5/25/2000 13:08'!acceptMethod: methodSel dstMessageCategory: dstMessageCategorySel srcMessageCategory: srcMessageCategorySel dstClass: dstClass dstClassOrMeta: dstClassOrMeta srcClassOrMeta: srcClassOrMeta internal: internal copySemantic: copyFlag 	| success hierarchyChange higher checkForOverwrite |	(success _ dstClassOrMeta ~~ nil) ifFalse: [^false].	checkForOverwrite _ dstClassOrMeta selectors includes: methodSel.	hierarchyChange _ (higher _ srcClassOrMeta inheritsFrom: dstClassOrMeta) | (dstClassOrMeta inheritsFrom: srcClassOrMeta).	success _ (checkForOverwrite not				or: [self						overwriteDialogHierarchyChange: hierarchyChange						higher: higher						sourceClassName: srcClassOrMeta name						destinationClassName: dstClassOrMeta name						methodSelector: methodSel])				and: [self						message: methodSel						compileInClass: dstClassOrMeta						fromClass: srcClassOrMeta						dstMessageCategory: dstMessageCategorySel						srcMessageCategory: srcMessageCategorySel						internal: internal						copySemantic: copyFlag].	^ success! !!Browser methodsFor: 'drag and drop' stamp: 'mir 5/25/2000 13:27'!acceptMethod: methodSel messageCategory: srcMessageCategorySel class: srcClassOrMeta atListMorph: dstListMorph internal: internal copy: copyFlag 	| success dstClassOrMeta dstClass dstMessageCategorySel |	dstClass _ self dstClassDstListMorph: dstListMorph.	dstClassOrMeta _ dstClass				ifNotNil: [self metaClassIndicated						ifTrue: [dstClass class]						ifFalse: [dstClass]].	dstMessageCategorySel _ self dstMessageCategoryDstListMorph: dstListMorph.	success _ (dstClassOrMeta notNil				and: [dstClassOrMeta == srcClassOrMeta])						ifTrue: ["one class"							self								changeMessageCategoryForMethod: methodSel								dstMessageCategory: dstMessageCategorySel								srcMessageCategory: srcMessageCategorySel								insideClassOrMeta: dstClassOrMeta								internal: internal								copySemantic: copyFlag]						ifFalse: ["different classes"							self								acceptMethod: methodSel								dstMessageCategory: dstMessageCategorySel								srcMessageCategory: srcMessageCategorySel								dstClass: dstClass								dstClassOrMeta: dstClassOrMeta								srcClassOrMeta: srcClassOrMeta								internal: internal								copySemantic: copyFlag].	^ success! !!Browser methodsFor: 'drag and drop' stamp: 'mir 5/25/2000 13:27'!changeCategoryForClass: class srcSystemCategory: srcSystemCategorySel atListMorph: dstListMorph internal: internal copy: copyFlag 	"only move semantic"	| newClassCategory success |	self flag: #stringSymbolProblem.	success _ copyFlag not ifFalse: [^ false].	newClassCategory _ self dstCategoryDstListMorph: dstListMorph.	(success _ newClassCategory notNil & (newClassCategory ~= class category))		ifTrue: 			[class category: newClassCategory.			self changed: #classList.			internal ifFalse: [self selectClass: class]].	^ success! !!Browser methodsFor: 'drag and drop' stamp: 'mir 5/23/2000 17:27'!changeMessageCategoryForMethod: methodSel dstMessageCategory: dstMessageCategorySel srcMessageCategory: srcMessageCategorySel insideClassOrMeta: classOrMeta internal: internal copySemantic: copyFlag 	"only move semantic"	| success messageCategorySel |	(success _ copyFlag not) ifFalse: [^ false].	messageCategorySel _ dstMessageCategorySel ifNil: [srcMessageCategorySel].	(success _ messageCategorySel notNil & (messageCategorySel ~= '-- all --' asSymbol)				and: [messageCategorySel ~= srcMessageCategorySel and: [classOrMeta organization categories includes: messageCategorySel]])		ifTrue: 			[classOrMeta organization				classify: methodSel				under: messageCategorySel				suppressIfDefault: false.			self changed: #messageList].	success & internal not ifTrue: [self setSelector: methodSel].	^ success! !!Browser methodsFor: 'drag and drop' stamp: 'ls 6/22/2001 23:21'!dstCategoryDstListMorph: dstListMorph	^(dstListMorph getListSelector == #systemCategoryList)		ifTrue: [dstListMorph potentialDropItem ]		ifFalse: [self selectedSystemCategoryName]! !!Browser methodsFor: 'drag and drop' stamp: 'ls 6/22/2001 23:20'!dstClassDstListMorph: dstListMorph	| dropItem |	^(dstListMorph getListSelector == #classList)		ifTrue: [(dropItem _ dstListMorph potentialDropItem) ifNotNil: [Smalltalk at: dropItem withBlanksCondensed asSymbol]]		ifFalse: [dstListMorph model selectedClass]! !!Browser methodsFor: 'drag and drop' stamp: 'nk 6/13/2004 06:16'!dstMessageCategoryDstListMorph: dstListMorph	| dropItem |	^dstListMorph getListSelector == #messageCategoryList		ifTrue: 			[dropItem _ dstListMorph potentialDropItem.			dropItem ifNotNil: [dropItem asSymbol]]		ifFalse: [self selectedMessageCategoryName ifNil: [ Categorizer default ]]! !!Browser methodsFor: 'drag and drop' stamp: 'mir 5/25/2000 13:47'!message: messageSel compileInClass: dstClassOrMeta fromClass: srcClassOrMeta dstMessageCategory: dstMessageCategorySel srcMessageCategory: srcMessageCategorySel internal: internal copySemantic: copyFlag 	| source messageCategorySel tm success oldOrNoMethod newMethod |	source _ srcClassOrMeta sourceCodeAt: messageSel.	messageCategorySel _ dstMessageCategorySel ifNil: [srcMessageCategorySel].	self selectClass: dstClassOrMeta theNonMetaClass.	(self messageCategoryList includes: messageCategorySel)		ifFalse: ["create message category"			self classOrMetaClassOrganizer addCategory: messageCategorySel].	self selectMessageCategoryNamed: messageCategorySel.	tm _ self codeTextMorph.	tm setText: source.	tm setSelection: (0 to: 0).	tm hasUnacceptedEdits: true.	oldOrNoMethod _ srcClassOrMeta compiledMethodAt: messageSel ifAbsent: [].	tm accept.	"compilation successful?"	newMethod _ dstClassOrMeta compiledMethodAt: messageSel ifAbsent: [].	success _ newMethod ~~ nil & (newMethod ~~ oldOrNoMethod).	"	success ifFalse: [TransferMorph allInstances do: [:e | e delete]].            	 "	success		ifTrue: 			[copyFlag not ifTrue: ["remove old method in move semantic if new exists"		srcClassOrMeta removeSelector: messageSel].internal				ifTrue: [self selectClass: srcClassOrMeta]				ifFalse: [self selectClass: dstClassOrMeta].			self setSelector: messageSel].	^ success! !!Browser methodsFor: 'drag and drop'!overwriteDialogHierarchyChange: hierarchyChange higher: higherFlag sourceClassName: srcClassName destinationClassName: dstClassName methodSelector: methodSelector 	| lf success |	lf _ Character cr asString.	success _ SelectionMenu				confirm: 'There is a conflict.' , ' Overwrite' , (hierarchyChange							ifTrue: [higherFlag									ifTrue: [' superclass']									ifFalse: [' subclass']]							ifFalse: ['']) , ' method' , lf , dstClassName , '>>' , methodSelector , lf , 'by ' , (hierarchyChange							ifTrue: ['moving']							ifFalse: ['copying']) , ' method' , lf , srcClassName name , '>>' , methodSelector , ' ?'				trueChoice: 'Yes, don''t care.'				falseChoice: 'No, I have changed my opinion.'.	^ success! !!Browser methodsFor: 'initialize-release' stamp: 'rww 8/18/2002 09:31'!browseSelectionInPlace	"In place code - incomplete""	self systemCategoryListIndex: 		(self systemCategoryList indexOf: self selectedClass category).	self classListIndex: (self classList indexOf: self selectedClass name)"	self spawnHierarchy.! !!Browser methodsFor: 'initialize-release'!browserWindowActivated	"Called when a window whose model is the receiver is reactivated, giving the receiver an opportunity to take steps if it wishes.  The default is to do nothing.  8/5/96 sw"! !!Browser methodsFor: 'initialize-release' stamp: 'tk 4/8/98 15:22'!buildClassSwitchView	| aSwitchView |	aSwitchView _ PluggableButtonView		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	aSwitchView		label: 'class';		window: (0@0 extent: 15@8);		askBeforeChanging: true.	^ aSwitchView! !!Browser methodsFor: 'initialize-release' stamp: 'di 4/13/1999 13:54'!buildCommentSwitchView	| aSwitchView |	aSwitchView _ PluggableButtonView		on: self		getState: #classCommentIndicated		action: #plusButtonHit.	aSwitchView		label: '?' asText allBold;		borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (0@0 extent: 10@8);		askBeforeChanging: true.	^ aSwitchView! !!Browser methodsFor: 'initialize-release' stamp: 'tk 4/8/98 16:11'!buildInstanceClassSwitchView	| aView aSwitchView instSwitchView comSwitchView |	aView _ View new model: self.	aView window: (0 @ 0 extent: 50 @ 8).	instSwitchView _ self buildInstanceSwitchView.	aView addSubView: instSwitchView.	comSwitchView _ self buildCommentSwitchView.	aView addSubView: comSwitchView toRightOf: instSwitchView.	aSwitchView _ self buildClassSwitchView.	aView addSubView: aSwitchView toRightOf: comSwitchView.	^aView! !!Browser methodsFor: 'initialize-release' stamp: 'tk 4/8/98 16:10'!buildInstanceSwitchView	| aSwitchView |	aSwitchView _ PluggableButtonView		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	aSwitchView		label: 'instance';		borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (0@0 extent: 25@8);		askBeforeChanging: true.	^ aSwitchView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 1/4/2001 15:55'!buildOptionalButtonsView	"Build the view for the optional buttons (mvc)"	| aView buttonView offset bWidth bHeight first previousView |	aView _ View new model: self.	bHeight _ self optionalButtonHeight.	aView window: (0 @ 0 extent: 200 @ bHeight).	offset _ 0.	first _ true.	previousView _ nil.	self optionalButtonPairs do: [:pair |		buttonView _ PluggableButtonView on: self			getState: nil			action: pair second.		buttonView			label: pair first asParagraph.		bWidth _ buttonView label boundingBox width // 2.  "Need something more deterministic."		buttonView window: (offset@0 extent: bWidth@bHeight).		offset _ offset + bWidth + 0.		first			ifTrue:				[aView addSubView: buttonView.				first _ false]			ifFalse:				[buttonView borderWidthLeft: 1 right: 0 top: 0 bottom: 0.				aView addSubView: buttonView toRightOf: previousView]. 		previousView _ buttonView].	^ aView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 1/13/2000 16:45'!defaultBrowserTitle	^ 'System Browser'! !!Browser methodsFor: 'initialize-release' stamp: 'ar 1/31/2001 20:56'!highlightClassList: list with: morphList! !!Browser methodsFor: 'initialize-release' stamp: 'ar 1/31/2001 20:56'!highlightMessageCategoryList: list with: morphList! !!Browser methodsFor: 'initialize-release' stamp: 'ar 1/31/2001 20:56'!highlightSystemCategoryList: list with: morphList! !!Browser methodsFor: 'initialize-release' stamp: 'nk 2/13/2001 13:25'!labelString	^self selectedClass ifNil: [ self defaultBrowserTitle ]		ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].! !!Browser methodsFor: 'initialize-release' stamp: 'sw 9/22/1999 17:13'!methodCategoryChanged	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #annotation.	self messageListIndex: 0! !!Browser methodsFor: 'initialize-release' stamp: 'BG 10/30/2003 21:09'!openEditString: aString        "Create a pluggable version of all the views for a Browser, including views and controllers."        | systemCategoryListView classListView         messageCategoryListView messageListView browserCodeView topView switchView underPane y optionalButtonsView annotationPane |        topView _ StandardSystemView new model: self.        topView borderWidth: 1. "label and minSize taken care of by caller"        systemCategoryListView _ PluggableListView on: self                list: #systemCategoryList                selected: #systemCategoryListIndex                changeSelected: #systemCategoryListIndex:                menu: #systemCategoryMenu:                keystroke: #systemCatListKey:from:.        systemCategoryListView window: (0 @ 0 extent: 50 @ 70).        topView addSubView: systemCategoryListView.        classListView _ PluggableListView on: self                list: #classList                selected: #classListIndex                changeSelected: #classListIndex:                menu: #classListMenu:shifted:                keystroke: #classListKey:from:.        classListView window: (0 @ 0 extent: 50 @ 62).        topView addSubView: classListView toRightOf: systemCategoryListView.        switchView _ self buildInstanceClassSwitchView.        switchView borderWidth: 1.        topView addSubView: switchView below: classListView.        messageCategoryListView _ PluggableListView on: self                list: #messageCategoryList                selected: #messageCategoryListIndex                changeSelected: #messageCategoryListIndex:                menu: #messageCategoryMenu:.         messageCategoryListView controller terminateDuringSelect: true.        messageCategoryListView window: (0 @ 0 extent: 50 @ 70).        topView addSubView: messageCategoryListView toRightOf: classListView.        messageListView _ PluggableListView on: self                list: #messageList                selected: #messageListIndex                changeSelected: #messageListIndex:                menu: #messageListMenu:shifted:                keystroke: #messageListKey:from:.        messageListView window: (0 @ 0 extent: 50 @ 70).        messageListView menuTitleSelector: #messageListSelectorTitle.        topView addSubView: messageListView toRightOf: messageCategoryListView.       self wantsAnnotationPane                ifTrue:                        [annotationPane _ PluggableTextView on: self                                text: #annotation accept: nil                                readSelection: nil menu: nil.                        annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).                        topView addSubView: annotationPane below: systemCategoryListView.                        underPane _ annotationPane.                        y _ 110 - self optionalAnnotationHeight]                ifFalse: [                        underPane _ systemCategoryListView.                        y _ 110].        self wantsOptionalButtons ifTrue:                [optionalButtonsView _ self buildOptionalButtonsView.                optionalButtonsView borderWidth: 1.                topView addSubView: optionalButtonsView below: underPane.                underPane _ optionalButtonsView.                y _ y - self optionalButtonHeight].        browserCodeView _ PluggableTextView on: self                         text: #contents accept: #contents:notifying:                        readSelection: #contentsSelection menu: #codePaneMenu:shifted:.        browserCodeView window: (0@0 extent: 200@y).        topView addSubView: browserCodeView below: underPane.        aString ifNotNil: [browserCodeView editString: aString.                        browserCodeView hasUnacceptedEdits: true].        topView setUpdatablePanesFrom: #(systemCategoryList classList messageCategoryList messageList).        ^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'BG 10/30/2003 21:09'!openMessageCatEditString: aString        "Create a pluggable version of the views for a Browser that just shows one message category."        | messageCategoryListView messageListView browserCodeView topView annotationPane underPane y optionalButtonsView |        topView _ (StandardSystemView new) model: self.        topView borderWidth: 1.                "label and minSize taken care of by caller"        messageCategoryListView _ PluggableListView on: self                list: #messageCatListSingleton                selected: #indexIsOne                 changeSelected: #indexIsOne:                menu: #messageCategoryMenu:.        messageCategoryListView window: (0 @ 0 extent: 200 @ 12).        topView addSubView: messageCategoryListView.        messageListView _ PluggableListView on: self                list: #messageList                selected: #messageListIndex                changeSelected: #messageListIndex:                menu: #messageListMenu:shifted:                keystroke: #messageListKey:from:.        messageListView menuTitleSelector: #messageListSelectorTitle.        messageListView window: (0 @ 0 extent: 200 @ 70).        topView addSubView: messageListView below: messageCategoryListView.        self wantsAnnotationPane                ifTrue:                        [annotationPane _ PluggableTextView on: self                                text: #annotation accept: nil                                readSelection: nil menu: nil.                        annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).                        topView addSubView: annotationPane below: messageListView.                        underPane _ annotationPane.                        y _ (200 - 12 - 70) - self optionalAnnotationHeight]                ifFalse:                        [underPane _ messageListView.                        y _ (200 - 12 - 70)].        self wantsOptionalButtons ifTrue:                [optionalButtonsView _ self buildOptionalButtonsView.                optionalButtonsView borderWidth: 1.                topView addSubView: optionalButtonsView below: underPane.                underPane _ optionalButtonsView.                y _ y - self optionalButtonHeight].        browserCodeView _ PluggableTextView on: self                         text: #contents accept: #contents:notifying:                        readSelection: #contentsSelection menu: #codePaneMenu:shifted:.        browserCodeView window: (0@0 extent: 200@y).        topView addSubView: browserCodeView below: underPane.        aString ifNotNil: [browserCodeView editString: aString.                        browserCodeView hasUnacceptedEdits: true].        topView setUpdatablePanesFrom: #(messageCatListSingleton messageList).        ^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'BG 10/28/2003 20:45'!openMessageEditString: aString	"Create a pluggable version of the views for a Browser that just shows one message."	| messageListView browserCodeView topView annotationPane underPane y |	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	messageListView _ PluggableListView on: self		list: #messageListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #messageListMenu:shifted:.	messageListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: messageListView.	 self wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: messageListView.			underPane _ annotationPane.			y _ (200 - 12) - self optionalAnnotationHeight]		ifFalse:			[underPane _ messageListView.			y _ 200 - 12].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'BG 10/28/2003 20:45'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| classListView messageCategoryListView messageListView browserCodeView topView switchView annotationPane underPane y optionalButtonsView |	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	classListView _ PluggableListView on: self		list: #classListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #classListMenu:shifted:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 100 @ 12).	topView addSubView: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageCategoryListView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	switchView 		window: switchView window 		viewport: (classListView viewport topRight 					corner: messageListView viewport topRight).	topView addSubView: switchView toRightOf: classListView.	 self wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: messageCategoryListView.			underPane _ annotationPane.			y _ (200-12-70) - self optionalAnnotationHeight]		ifFalse:			[underPane _ messageCategoryListView.			y _ (200-12-70)].	self wantsOptionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	topView setUpdatablePanesFrom: #(messageCategoryList messageList).	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'BG 10/28/2003 20:45'!openSystemCatEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	| systemCategoryListView classListView messageCategoryListView messageListView browserCodeView topView switchView y annotationPane underPane optionalButtonsView |	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategorySingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #systemCatSingletonMenu:		keystroke: #systemCatSingletonKey:from:.	systemCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:shifted:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 67 @ 62).	topView addSubView: classListView below: systemCategoryListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView controller terminateDuringSelect: true.	messageCategoryListView window: (0 @ 0 extent: 66 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	switchView _ self buildInstanceClassSwitchView.	switchView 		window: switchView window 		viewport: (classListView viewport bottomLeft 					corner: messageCategoryListView viewport bottomLeft).	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 67 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	 self wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: switchView.			y _ 110 - 12 - self optionalAnnotationHeight.			underPane _ annotationPane]		ifFalse:			[y _ 110 - 12.			underPane _ switchView].	self wantsOptionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	topView setUpdatablePanesFrom: #(classList messageCategoryList messageList).	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sbw 12/8/1999 12:37'!optionalAnnotationHeight	^ 10! !!Browser methodsFor: 'initialize-release' stamp: 'sbw 12/8/1999 12:23'!optionalButtonHeight	^ 10! !!Browser methodsFor: 'initialize-release' stamp: 'rhi 5/12/2004 23:23'!setClass: aBehavior selector: aSymbol	"Set the state of a new, uninitialized Browser."	| isMeta aClass messageCatIndex |	aBehavior ifNil: [^ self].	(aBehavior isKindOf: Metaclass)		ifTrue: [			isMeta _ true.			aClass _ aBehavior soleInstance]		ifFalse: [			isMeta _ false.			aClass _ aBehavior].	self selectCategoryForClass: aClass.	self classListIndex: (		(SystemOrganization listAtCategoryNamed: self selectedSystemCategoryName)			indexOf: aClass name).	self metaClassIndicated: isMeta.	aSymbol ifNil: [^ self].	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: (messageCatIndex > 0		ifTrue: [messageCatIndex + 1]		ifFalse: [0]).	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex: (		(aBehavior organization listAtCategoryNumber: messageCatIndex)			indexOf: aSymbol).! !!Browser methodsFor: 'initialize-release' stamp: 'sw 5/26/1999 23:46'!setSelector: aSymbol	"Make the receiver point at the given selector, in the currently chosen class"	| aClass messageCatIndex |	aSymbol ifNil: [^ self].	(aClass _ self selectedClassOrMetaClass) ifNil: [^ self].	messageCatIndex _ aClass organization numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: messageCatIndex + 1.	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex:			((aClass organization listAtCategoryNumber: messageCatIndex)					indexOf: aSymbol)! !!Browser methodsFor: 'initialize-release' stamp: 'sw 11/8/1999 13:36'!systemCatSingletonKey: aChar from: aView	^ self messageListKey: aChar from: aView! !!Browser methodsFor: 'initialize-release' stamp: 'rhi 5/12/2004 15:00'!systemOrganizer: aSystemOrganizer	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."	contents _ nil.	systemOrganizer _ aSystemOrganizer.	systemCategoryListIndex _ 0.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	metaClassIndicated _ false.	self setClassOrganizer.	self editSelection: #none.! !!Browser methodsFor: 'message category functions' stamp: 'mir 5/5/2000 16:02'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines cats menuIndex oldIndex newName |	self okToChange ifFalse: [^ self].	classListIndex = 0 ifTrue: [^ self].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'NS 4/7/2004 22:47'!alphabetizeMessageCategories	classListIndex = 0 ifTrue: [^ false].	self okToChange ifFalse: [^ false].	self classOrMetaClassOrganizer sortCategories.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions'!buildMessageCategoryBrowser	"Create and schedule a message category browser for the currently 	selected message category."	self buildMessageCategoryBrowserEditString: nil! !!Browser methodsFor: 'message category functions' stamp: 'nk 6/13/2004 07:21'!buildMessageCategoryBrowserEditString: aString 	"Create and schedule a message category browser for the currently 	selected	 message category. The initial text view contains the characters 	in aString."	"wod 6/24/1998: set newBrowser classListIndex so that it works whether the	receiver is a standard or a Hierarchy Browser."	| newBrowser |	messageCategoryListIndex ~= 0		ifTrue: 			[newBrowser _ Browser new.			newBrowser systemCategoryListIndex: systemCategoryListIndex.			newBrowser classListIndex: (newBrowser classList indexOf: self selectedClassName).			newBrowser metaClassIndicated: metaClassIndicated.			newBrowser messageCategoryListIndex: messageCategoryListIndex.			newBrowser messageListIndex: messageListIndex.			self class openBrowserView: (newBrowser openMessageCatEditString: aString)				label: 'Message Category Browser (' , 						newBrowser selectedClassOrMetaClassName , ')']! !!Browser methodsFor: 'message category functions' stamp: 'sw 10/8/2001 14:10'!canShowMultipleMessageCategories	"Answer whether the receiver is capable of showing multiple message categories"	^ true! !!Browser methodsFor: 'message category functions' stamp: 'sw 2/22/2001 06:54'!categoryOfCurrentMethod	"Determine the method category associated with the receiver at the current moment, or nil if none"	| aCategory |	^ super categoryOfCurrentMethod ifNil:		[(aCategory _ self messageCategoryListSelection) == ClassOrganizer allCategory					ifTrue:						[nil]					ifFalse:						[aCategory]]! !!Browser methodsFor: 'message category functions' stamp: 'NS 4/7/2004 22:56'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'nk 2/14/2004 15:06'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	self okToChange ifFalse: [^ self].	classListIndex ~= 0		ifTrue: 			[self messageCategoryListIndex: 0.			self editSelection: #editMessageCategories.			self changed: #editMessageCategories.			self contentsChanged]! !!Browser methodsFor: 'message category functions' stamp: 'tk 4/2/98 13:53'!fileOutMessageCategories	"Print a description of the selected message category of the selected class 	onto an external file."Cursor write showWhile:	[messageCategoryListIndex ~= 0		ifTrue: 			[self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName]]! !!Browser methodsFor: 'message category functions' stamp: 'emm 5/30/2002 09:20'!highlightMessageList: list with: morphList	"Changed by emm to add emphasis in case of breakpoint"	morphList do:[:each | 		| classOrNil methodOrNil |		classOrNil := self selectedClassOrMetaClass.		methodOrNil := classOrNil isNil			ifTrue:[nil]			ifFalse:[classOrNil methodDictionary at: each contents ifAbsent:[]].		(methodOrNil notNil and:[methodOrNil hasBreakpoint])			ifTrue:[each contents: ((each contents ,' [break]') asText allBold)]]! !!Browser methodsFor: 'message category functions' stamp: 'dew 9/20/2001 00:21'!messageCategoryMenu: aMenu^ aMenu labels:'browseprintOutfileOutreorganizealphabetizeremove empty categoriescategorize all uncategorizednew category...rename...remove'	lines: #(3 8)	selections:		#(buildMessageCategoryBrowser printOutMessageCategories fileOutMessageCategories		editMessageCategories alphabetizeMessageCategories removeEmptyCategories		categorizeAllUncategorizedMethods addCategory renameCategory removeMessageCategory)! !!Browser methodsFor: 'message category functions' stamp: 'tk 4/2/98 13:53'!printOutMessageCategories	"Print a description of the selected message category of the selected class 	onto an external file in Html format."Cursor write showWhile:	[messageCategoryListIndex ~= 0		ifTrue: 			[self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName										asHtml: true]]! !!Browser methodsFor: 'message category functions' stamp: 'nk 4/23/2004 09:18'!removeEmptyCategories	self okToChange ifFalse: [^ self].	self selectedClassOrMetaClass organization removeEmptyCategories.	self changed: #messageCategoryList! !!Browser methodsFor: 'message category functions' stamp: 'tk 4/2/98 13:54'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?'])		ifTrue: 			[self selectedClassOrMetaClass removeCategory: messageCategoryName.			self messageCategoryListIndex: 0.			self changed: #classSelectionChanged].	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'NS 4/7/2004 23:01'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(oldIndex _ messageCategoryListIndex) = 0 ifTrue: [^ self].	oldName _ self selectedMessageCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	newName = oldName ifTrue: [^ self].	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self classListIndex: classListIndex.	self messageCategoryListIndex: oldIndex.	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'sw 10/8/2001 15:08'!showHomeCategory	"Show the home category of the selected method.  This is only really useful if one is in a tool that supports the showing of categories.  Thus, it's good in browsers and hierarchy browsers but not in message-list browsers"	| aSelector |	self okToChange ifTrue:		[(aSelector _ self selectedMessageName) ifNotNil:			[self selectOriginalCategoryForCurrentMethod.			self selectedMessageName: aSelector]]! !!Browser methodsFor: 'message category list' stamp: 'nk 11/30/2002 08:20'!categorizeAllUncategorizedMethods	"Categorize methods by looking in parent classes for a method category."	| organizer organizers |	organizer _ self classOrMetaClassOrganizer.	organizers _ self selectedClassOrMetaClass withAllSuperclasses collect: [:ea | ea organization].	(organizer listAtCategoryNamed: ClassOrganizer default) do: [:sel | | found |		found _ (organizers collect: [ :org | org categoryOfElement: sel])			detect: [:ea | ea ~= ClassOrganizer default and: [ ea ~= nil]]			ifNone: [].		found ifNotNil: [organizer classify: sel under: found]].	self changed: #messageCategoryList! !!Browser methodsFor: 'message category list' stamp: 'tk 4/5/98 12:25'!messageCatListSingleton	| name |	name _ self selectedMessageCategoryName.	^ name ifNil: [Array new]		ifNotNil: [Array with: name]! !!Browser methodsFor: 'message category list' stamp: 'ccn 3/22/1999 17:56'!messageCategoryList	"Answer the selected category of messages."	classListIndex = 0		ifTrue: [^ Array new]		ifFalse: [^ (Array with: ClassOrganizer allCategory), self classOrMetaClassOrganizer categories]! !!Browser methodsFor: 'message category list'!messageCategoryListIndex	"Answer the index of the selected message category."	^messageCategoryListIndex! !!Browser methodsFor: 'message category list' stamp: 'rhi 5/12/2004 19:36'!messageCategoryListIndex: anInteger	"Set the selected message category to be the one indexed by anInteger."	messageCategoryListIndex _ anInteger.	messageListIndex _ 0.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex. "update my selection"	self changed: #messageList.	self editSelection: (anInteger > 0		ifTrue: [#newMessage]		ifFalse: [self classListIndex > 0			ifTrue: [#editClass]			ifFalse: [#newClass]]).	contents _ nil.	self contentsChanged.! !!Browser methodsFor: 'message category list' stamp: 'ccn 3/24/1999 11:02'!messageCategoryListSelection	"Return the selected category name or nil."	^ ((self messageCategoryList size = 0 		or: [self messageCategoryListIndex = 0]) 		or: [self messageCategoryList size < self messageCategoryListIndex])			ifTrue: [nil]			ifFalse: [self messageCategoryList at: (self messageCategoryListIndex max: 1)]! !!Browser methodsFor: 'message category list' stamp: 'sw 10/16/1999 22:56'!rawMessageCategoryList	^ classListIndex = 0		ifTrue: [Array new]		ifFalse: [self classOrMetaClassOrganizer categories]! !!Browser methodsFor: 'message category list' stamp: 'nk 6/13/2004 06:20'!selectMessageCategoryNamed: aSymbol 	"Given aSymbol, select the category with that name.  Do nothing if 	aSymbol doesn't exist."	self messageCategoryListIndex: (self messageCategoryList indexOf: aSymbol ifAbsent: [ 1])! !!Browser methodsFor: 'message category list' stamp: 'KLC 2/20/2004 08:08'!selectOriginalCategoryForCurrentMethod	"private - Select the message category for the current method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected. 	 	 Returns: true on success, false on failure."	| aSymbol selectorName |	aSymbol _ self categoryOfCurrentMethod.	selectorName _ self selectedMessageName.	(aSymbol notNil and: [aSymbol ~= ClassOrganizer allCategory])		ifTrue: 			[messageCategoryListIndex _ (self messageCategoryList indexOf: aSymbol).			messageListIndex _ (self messageList indexOf: selectorName).			self changed: #messageCategorySelectionChanged.			self changed: #messageCategoryListIndex.	"update my selection"			self changed: #messageList.			self changed: #messageListIndex.			^ true].	^ false! !!Browser methodsFor: 'message category list'!selectedMessageCategoryName	"Answer the name of the selected message category, if any. Answer nil 	otherwise."	messageCategoryListIndex = 0 ifTrue: [^nil].	^self messageCategoryList at: messageCategoryListIndex! !!Browser methodsFor: 'message category list' stamp: 'ccn+ceg 5/13/1999 19:54'!setOriginalCategoryIndexForCurrentMethod	"private - Set the message category index for the currently selected method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected."	messageCategoryListIndex _ self messageCategoryList indexOf: self categoryOfCurrentMethod	! !!Browser methodsFor: 'message category list'!toggleMessageCategoryListIndex: anInteger 	"If the currently selected message category index is anInteger, deselect 	the category. Otherwise select the category whose index is anInteger."	self messageCategoryListIndex: 		(messageCategoryListIndex = anInteger			ifTrue: [0]			ifFalse: [anInteger])! !!Browser methodsFor: 'message functions' stamp: 'sw 1/11/2001 07:22'!addExtraShiftedItemsTo: aMenu	"The shifted selector-list menu is being built; some menu items are appropriate only for certain kinds of browsers, and this gives a hook for them to be added as approrpiate.  If any is added here, a line should be added first -- browse reimplementors of this message for examples."! !!Browser methodsFor: 'message functions'!buildMessageBrowser	"Create and schedule a message browser on the currently selected 	message. Do nothing if no message is selected. The initial text view 	contains nothing."	self buildMessageBrowserEditString: nil! !!Browser methodsFor: 'message functions' stamp: 'sd 1/5/2002 21:11'!buildMessageBrowserEditString: aString 	"Create and schedule a message browser for the receiver in which the 	argument, aString, contains characters to be edited in the text view."	messageListIndex = 0 ifTrue: [^ self].	^ self class openMessageBrowserForClass: self selectedClassOrMetaClass 		selector: self selectedMessageName editString: aString! !!Browser methodsFor: 'message functions' stamp: 'tk 4/25/1998 00:08'!defineMessage: aString notifying: aController 	"Compile the expressions in aString. Notify aController if a syntax error 	occurs. Install the compiled method in the selected class classified under 	the currently selected message category name. Answer true if 	compilation succeeds, false otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ false].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ true! !!Browser methodsFor: 'message functions' stamp: 'di 11/24/1999 13:40'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ (Parser new parseSelector: aString).	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]].	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ nil].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !!Browser methodsFor: 'message functions' stamp: 'tk 4/2/98 17:02'!inspectInstances	"Inspect all instances of the selected class.  1/26/96 sw"	| myClass |	myClass _ self selectedClassOrMetaClass.	myClass ~~ nil ifTrue:		[myClass theNonMetaClass inspectAllInstances].! !!Browser methodsFor: 'message functions' stamp: 'tk 4/2/98 17:02'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses  1/26/96 sw"	| aClass |	aClass _ self selectedClassOrMetaClass.	aClass ~~ nil ifTrue:		[aClass _ aClass theNonMetaClass.		 aClass inspectSubInstances].! !!Browser methodsFor: 'message functions' stamp: 'BG 11/1/2003 13:27'!messageListMenu: aMenu shifted: shifted	"Answer the message-list menu"	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'message functions' stamp: 'sd 5/11/2003 21:01'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self systemNavigation   confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation == 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation == 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!Browser methodsFor: 'message functions' stamp: 'tk 4/2/98 17:03'!removeMessageFromBrowser	"Our list speaks the truth and can't have arbitrary things removed"	^ self changed: #flash! !!Browser methodsFor: 'message functions' stamp: 'BG 11/1/2003 13:58'!shiftedMessageListMenu: aMenu	"Fill aMenu with the items appropriate when the shift key is held down"	aMenu addList: #(		('toggle diffing (D)'						toggleDiffing)		('implementors of sent messages'			browseAllMessages)		-		('local senders of...'						browseLocalSendersOfMessages)		('local implementors of...'				browseLocalImplementors)		-		('spawn sub-protocol'					spawnProtocol)		('spawn full protocol'					spawnFullProtocol)		-		('sample instance'						makeSampleInstance)		('inspect instances'						inspectInstances)		('inspect subinstances'					inspectSubInstances)).	self addExtraShiftedItemsTo: aMenu.	aMenu addList: #(		-		('change category...'					changeCategory)).	self canShowMultipleMessageCategories ifTrue: [aMenu addList:		 #(('show category (C)'						showHomeCategory))].	aMenu addList: #(		-		('change sets with this method'			findMethodInChangeSets)		('revert to previous version'				revertToPreviousVersion)		('remove from current change set'		removeFromCurrentChanges)		('revert & remove from changes'		revertAndForget)		('add to current change set'				adoptMessageInCurrentChangeset)		('copy up or copy down...'				copyUpOrCopyDown)		-		('more...' 								unshiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'message list' stamp: 'drs 1/1/2003 23:33'!messageList	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."	| sel |	(sel _ self messageCategoryListSelection) ifNil: 		[			^ self classOrMetaClassOrganizer				ifNil:		[Array new]				ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]			"^ Array new"		].	^ sel = ClassOrganizer allCategory		ifTrue: 			[self classOrMetaClassOrganizer				ifNil:		[Array new]				ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]]		ifFalse:			[(self classOrMetaClassOrganizer listAtCategoryNumber: messageCategoryListIndex - 1)				ifNil: [messageCategoryListIndex _ 0.  Array new]]! !!Browser methodsFor: 'message list'!messageListIndex	"Answer the index of the selected message selector into the currently 	selected message category."	^messageListIndex! !!Browser methodsFor: 'message list' stamp: 'rhi 5/12/2004 19:35'!messageListIndex: anInteger	"Set the selected message selector to be the one indexed by anInteger."	messageListIndex _ anInteger.	self editSelection: (anInteger > 0		ifTrue: [#editMessage]		ifFalse: [self messageCategoryListIndex > 0			ifTrue: [#newMessage]			ifFalse: [self classListIndex > 0				ifTrue: [#editClass]				ifFalse: [#newClass]]]).	contents _ nil.	self changed: #messageListIndex. "update my selection"	self contentsChanged.	self decorateButtons.! !!Browser methodsFor: 'message list' stamp: 'tk 4/6/98 10:48'!messageListSingleton	| name |	name _ self selectedMessageName.	^ name ifNil: [Array new]		ifNotNil: [Array with: name]! !!Browser methodsFor: 'message list' stamp: 'sw 12/1/2000 11:17'!reformulateList	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"	super reformulateList.	self messageListIndex: 0! !!Browser methodsFor: 'message list' stamp: 'nk 6/19/2004 16:44'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ contents _ (self showingDocumentation		ifFalse: [ self sourceStringPrettifiedAndDiffed ]		ifTrue: [ self commentContents ])			copy asText makeSelectorBoldIn: class! !!Browser methodsFor: 'message list' stamp: 'sw 8/26/2002 09:55'!selectedMessageName	"Answer the message selector of the currently selected message, if any. 	Answer nil otherwise."	| aList |	editSelection == #editComment ifTrue: [^ #Comment].	editSelection == #editClass ifTrue: [^ #Definition].	messageListIndex = 0 ifTrue: [^ nil].	^ (aList _ self messageList) size >= messageListIndex		ifTrue:			[aList at: messageListIndex]		ifFalse:			[nil]! !!Browser methodsFor: 'message list' stamp: 'sw 10/8/2001 13:37'!selectedMessageName: aSelector	"Make the given selector be the selected message name"	| anIndex |	anIndex _ self messageList indexOf: aSelector.	anIndex > 0 ifTrue:		[self messageListIndex: anIndex]! !!Browser methodsFor: 'message list'!toggleMessageListIndex: anInteger 	"If the currently selected message index is anInteger, deselect the message 	selector. Otherwise select the message selector whose index is anInteger."	self messageListIndex: 		(messageListIndex = anInteger			ifTrue: [0]			ifFalse: [anInteger])! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 12:25'!classCommentIndicated	"Answer true iff we're viewing the class comment."	^ editSelection == #editComment ! !!Browser methodsFor: 'metaclass' stamp: 'ak 11/24/2000 21:46'!classMessagesIndicated	"Answer whether the messages to be presented should come from the 	metaclass."	^ self metaClassIndicated and: [self classCommentIndicated not]! !!Browser methodsFor: 'metaclass'!classOrMetaClassOrganizer	"Answer the class organizer for the metaclass or class, depending on 	which (instance or class) is indicated."	self metaClassIndicated		ifTrue: [^metaClassOrganizer]		ifFalse: [^classOrganizer]! !!Browser methodsFor: 'metaclass'!indicateClassMessages	"Indicate that the message selection should come from the metaclass 	messages."	self metaClassIndicated: true! !!Browser methodsFor: 'metaclass'!indicateInstanceMessages	"Indicate that the message selection should come from the class (instance) 	messages."	self metaClassIndicated: false! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 13:20'!instanceMessagesIndicated	"Answer whether the messages to be presented should come from the 	class."	^metaClassIndicated not and: [self classCommentIndicated not]! !!Browser methodsFor: 'metaclass' stamp: 'sr 6/21/2000 17:23'!metaClassIndicated	"Answer the boolean flag that indicates which of the method dictionaries, 	class or metaclass."	^ metaClassIndicated! !!Browser methodsFor: 'metaclass' stamp: 'nk 2/14/2004 15:08'!metaClassIndicated: trueOrFalse 	"Indicate whether browsing instance or class messages."	metaClassIndicated _ trueOrFalse.	self setClassOrganizer.	systemCategoryListIndex > 0 ifTrue:		[self editSelection: (classListIndex = 0			ifTrue: [metaClassIndicated				ifTrue: [#none]				ifFalse: [#newClass]]			ifFalse: [#editClass])].	messageCategoryListIndex _ 0.	messageListIndex _ 0.	contents _ nil.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #contents.	self changed: #annotation.	self decorateButtons! !!Browser methodsFor: 'metaclass' stamp: 'tk 4/9/98 10:48'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	| cls |	self metaClassIndicated		ifTrue: [^ (cls _ self selectedClass) ifNil: [nil] ifNotNil: [cls class]]		ifFalse: [^ self selectedClass]! !!Browser methodsFor: 'metaclass'!selectedClassOrMetaClassName	"Answer the selected class name or metaclass name."	^self selectedClassOrMetaClass name! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 13:27'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass class organization.! !!Browser methodsFor: 'system category functions' stamp: 'je 4/30/2001 17:59'!addSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex newName |	self okToChange ifFalse: [^ self].	oldIndex _ systemCategoryListIndex.	newName _ self		request: 'Please type new category name'		initialAnswer: 'Category-Name'.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	systemOrganizer		addCategory: newName		before: (systemCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedSystemCategoryName]).	self systemCategoryListIndex:		(oldIndex = 0			ifTrue: [self systemCategoryList size]			ifFalse: [oldIndex]).	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'brp 8/4/2003 21:38'!alphabetizeSystemCategories	self okToChange ifFalse: [^ false].	systemOrganizer sortCategories.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'sd 1/5/2002 21:11'!browseAllClasses	"Create and schedule a new browser on all classes alphabetically."	| newBrowser |	newBrowser _ HierarchyBrowser new initAlphabeticListing.	self class openBrowserView: (newBrowser openSystemCatEditString: nil)		label: 'All Classes Alphabetically'! !!Browser methodsFor: 'system category functions'!buildSystemCategoryBrowser	"Create and schedule a new system category browser."	self buildSystemCategoryBrowserEditString: nil! !!Browser methodsFor: 'system category functions' stamp: 'sd 1/5/2002 21:12'!buildSystemCategoryBrowserEditString: aString 	"Create and schedule a new system category browser with initial textual 	contents set to aString."	| newBrowser |	systemCategoryListIndex > 0		ifTrue: 			[newBrowser _ self class new.			newBrowser systemCategoryListIndex: systemCategoryListIndex.			newBrowser setClass: self selectedClassOrMetaClass selector: self selectedMessageName.			self class openBrowserView: (newBrowser openSystemCatEditString: aString)				label: 'Classes in category ', newBrowser selectedSystemCategoryName]! !!Browser methodsFor: 'system category functions' stamp: 'di 4/12/98 13:21'!changeSystemCategories: aString 	"Update the class categories by parsing the argument aString."	systemOrganizer changeFromString: aString.	self changed: #systemCategoryList.	^ true! !!Browser methodsFor: 'system category functions' stamp: 'tk 4/2/98 13:43'!classNotFound	self changed: #flash.! !!Browser methodsFor: 'system category functions' stamp: 'nk 2/14/2004 15:09'!editSystemCategories	"Retrieve the description of the class categories of the system organizer."	self okToChange ifFalse: [^ self].	self systemCategoryListIndex: 0.	self editSelection: #editSystemCategories.	self changed: #editSystemCategories.	self contentsChanged! !!Browser methodsFor: 'system category functions' stamp: 'tk 3/31/98 07:52'!fileOutSystemCategory	"Print a description of each class in the selected category onto a file 	whose name is the category name followed by .st."	systemCategoryListIndex ~= 0		ifTrue: [systemOrganizer fileOutCategory: self selectedSystemCategoryName]! !!Browser methodsFor: 'system category functions' stamp: 'stp 01/13/2000 12:26'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |	self okToChange ifFalse: [^ self classNotFound].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self classNotFound].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ self potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self classNotFound].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Smalltalk at: (classNames at: index) asSymbol. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'system category functions' stamp: 'sw 11/8/1999 10:04'!potentialClassNames	"Answer the names of all the classes that could be viewed in this browser.  This hook is provided so that HierarchyBrowsers can indicate their restricted subset.  For generic Browsers, the entire list of classes known to Smalltalk is provided, though of course that really only is accurate in the case of full system browsers."	^ Smalltalk classNames! !!Browser methodsFor: 'system category functions' stamp: 'tk 4/2/98 13:46'!printOutSystemCategory	"Print a description of each class in the selected category as Html."Cursor write showWhile:	[systemCategoryListIndex ~= 0		ifTrue: [systemOrganizer fileOutCategory: self selectedSystemCategoryName								asHtml: true ]]! !!Browser methodsFor: 'system category functions' stamp: 'di 4/12/98 13:55'!removeSystemCategory	"If a class category is selected, create a Confirmer so the user can 	verify that the currently selected class category and all of its classes 	should be removed from the system. If so, remove it."	systemCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self classList size = 0		or: [self confirm: 'Are you sure you want toremove this system category and all its classes?'])		ifTrue: 		[systemOrganizer removeSystemCategory: self selectedSystemCategoryName.		self systemCategoryListIndex: 0.		self changed: #systemCategoryList]! !!Browser methodsFor: 'system category functions' stamp: 'di 4/12/98 13:55'!renameSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	(oldIndex _ systemCategoryListIndex) = 0		ifTrue: [^ self].  "no selection"	self okToChange ifFalse: [^ self].	oldName _ self selectedSystemCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	oldName = newName ifTrue: [^ self].	systemOrganizer		renameCategory: oldName		toBe: newName.	self systemCategoryListIndex: oldIndex.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'sw 11/8/1999 14:07'!systemCatSingletonMenu: aMenu	^ aMenu labels:'browse allbrowseprintOutfileOutupdaterename...remove' 	lines: #(2 4)	selections:		#(browseAllClasses buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory updateSystemCategories		renameSystemCategory removeSystemCategory)! !!Browser methodsFor: 'system category functions' stamp: 'brp 8/4/2003 21:32'!systemCategoryMenu: aMenu^ aMenu labels:'find class... (f)recent classes... (r)browse allbrowseprintOutfileOutreorganizealphabetizeupdateadd item...rename...remove' 	lines: #(2 4 6 8)	selections:		#(findClass recent browseAllClasses buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory		editSystemCategories alphabetizeSystemCategories updateSystemCategories		addSystemCategory renameSystemCategory removeSystemCategory )! !!Browser methodsFor: 'system category functions' stamp: 'di 4/12/98 13:17'!updateSystemCategories	"The class categories were changed in another browser. The receiver must 	reorganize its lists based on these changes."	self okToChange ifFalse: [^ self].	self changed: #systemCategoryList! !!Browser methodsFor: 'system category list' stamp: 'tk 5/4/1998 15:46'!indexIsOne	"When used as a singleton list, index is always one"	^ 1! !!Browser methodsFor: 'system category list' stamp: 'tk 5/4/1998 15:46'!indexIsOne: value	"When used as a singleton list, can't change it"	^ self! !!Browser methodsFor: 'system category list' stamp: 'stp 01/13/2000 12:25'!selectCategoryForClass: theClass	self systemCategoryListIndex: (self systemCategoryList indexOf: theClass category)! !!Browser methodsFor: 'system category list' stamp: 'di 12/6/1999 20:11'!selectedEnvironment	"Answer the name of the selected system category or nil."	systemCategoryListIndex = 0 ifTrue: [^nil].	^ Smalltalk environmentForCategory: self selectedSystemCategoryName! !!Browser methodsFor: 'system category list'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	systemCategoryListIndex = 0 ifTrue: [^nil].	^self systemCategoryList at: systemCategoryListIndex! !!Browser methodsFor: 'system category list'!systemCategoryList	"Answer the class categories modelled by the receiver."	^systemOrganizer categories! !!Browser methodsFor: 'system category list'!systemCategoryListIndex	"Answer the index of the selected class category."	^systemCategoryListIndex! !!Browser methodsFor: 'system category list' stamp: 'nk 2/14/2004 15:06'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	systemCategoryListIndex _ anInteger.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self editSelection: ( anInteger = 0 ifTrue: [#none] ifFalse: [#newClass]).	metaClassIndicated _ false.	self setClassOrganizer.	contents _ nil.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'system category list' stamp: 'tk 4/3/98 10:30'!systemCategorySingleton	| cat |	cat _ self selectedSystemCategoryName.	^ cat ifNil: [Array new]		ifNotNil: [Array with: cat]! !!Browser methodsFor: 'system category list'!toggleSystemCategoryListIndex: anInteger 	"If anInteger is the current system category index, deselect it. Else make 	it the current system category selection."	self systemCategoryListIndex: 		(systemCategoryListIndex = anInteger			ifTrue: [0]			ifFalse: [anInteger])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Browser class	instanceVariableNames: ''!!Browser class methodsFor: 'instance creation' stamp: 'sd 2/2/2004 13:50'!fullOnClass: aClass 	"Open a new full browser set to class."	| brow |	brow _ self new.	brow setClass: aClass selector: nil.	^ self 		openBrowserView: (brow openEditString: nil)		label: 'System Browser'! !!Browser class methodsFor: 'instance creation' stamp: 'jcg 10/29/2003 23:11'!fullOnClass: aClass selector: aSelector	"Open a new full browser set to class."	| brow classToUse |	classToUse _ Preferences browseToolClass.	brow _ classToUse new.	brow setClass: aClass selector: aSelector.	^ classToUse 		openBrowserView: (brow openEditString: nil)		label: brow labelString! !!Browser class methodsFor: 'instance creation' stamp: 'di 10/18/1999 22:03'!new	^super new systemOrganizer: SystemOrganization! !!Browser class methodsFor: 'instance creation' stamp: 'jcg 10/29/2003 23:12'!newOnCategory: aCategory	"Browse the system category of the given name.  7/13/96 sw"	"Browser newOnCategory: 'Interface-Browser'"	| newBrowser catList |	newBrowser _ self new.	catList _ newBrowser systemCategoryList.	newBrowser systemCategoryListIndex: 		(catList indexOf: aCategory asSymbol ifAbsent: [^ self inform: 'No such category']).	^ self 		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: 'Classes in category ', aCategory! !!Browser class methodsFor: 'instance creation' stamp: 'tk 4/18/1998 16:28'!newOnClass: aClass 	"Open a new class browser on this class."	^ self newOnClass: aClass label: 'Class Browser: ', aClass name! !!Browser class methodsFor: 'instance creation' stamp: 'jcg 10/29/2003 23:12'!newOnClass: aClass label: aLabel	"Open a new class browser on this class."	| newBrowser |	newBrowser _ self new.	newBrowser setClass: aClass selector: nil.	^ self 		openBrowserView: (newBrowser openOnClassWithEditString: nil)		label: aLabel! !!Browser class methodsFor: 'instance creation' stamp: 'jcg 10/29/2003 23:12'!newOnClass: aClass selector: aSymbol	"Open a new class browser on this class."	| newBrowser |	newBrowser _ self new.	newBrowser setClass: aClass selector: aSymbol.	^ self 		openBrowserView: (newBrowser openOnClassWithEditString: nil)		label: 'Class Browser: ', aClass name! !!Browser class methodsFor: 'instance creation' stamp: 'jcg 10/29/2003 23:11'!openBrowser	"Create and schedule a BrowserView with default browser label. The	view consists of five subviews, starting with the list view of system	categories of SystemOrganization. The initial text view part is empty."	| br |	br := self new.	^ self		openBrowserView: (br openEditString: nil)		label: br defaultBrowserTitle.! !!Browser class methodsFor: 'instance creation' stamp: 'BG 10/30/2003 21:10'!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."		aBrowserView label: aString.	aBrowserView minimumSize: 300 @ 200.	aBrowserView subViews do: [:each | each controller].	aBrowserView controller open! !!Browser class methodsFor: 'instance creation' stamp: 'sd 1/5/2002 21:10'!openMessageBrowserForClass: aBehavior selector: aSymbol editString: aString	"Create and schedule a message browser for the class, aBehavior, in 	which the argument, aString, contains characters to be edited in the text 	view. These characters are the source code for the message selector 	aSymbol."	| newBrowser |	(newBrowser _ self new) setClass: aBehavior selector: aSymbol.	^ self openBrowserView: (newBrowser openMessageEditString: aString)		label: newBrowser selectedClassOrMetaClassName , ' ' , newBrowser selectedMessageName! !!Browser class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:27'!initialize	"Browser initialize"	RecentClasses := OrderedCollection new.	self registerInFlapsRegistry.	! !!Browser class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:32'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#Browser #prototypicalToolWindow 'Browser' 'A Browser is a tool that allows you to view all the code of all the classes in the system' ) 						forFlapNamed: 'Tools']! !!Browser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:32'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !Switch subclass: #Button	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!Button commentStamp: '<historical>' prior: 0!I am a Switch that turns off automatically after being turned on, that is, I act like a push-button switch.!!Button methodsFor: 'state'!turnOff	"Sets the state of the receiver to 'off'. The off action of the receiver is not  	executed."	on _ false! !!Button methodsFor: 'state'!turnOn	"The receiver remains in the 'off' state'."	self doAction: onAction.	self doAction: offAction! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Button class	instanceVariableNames: ''!!Button class methodsFor: 'instance creation'!newOn 	"Refer to the comment in Switch|newOn."	self error: 'Buttons cannot be created in the on state'.	^nil! !ArrayedCollection variableByteSubclass: #ByteArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!ByteArray commentStamp: '<historical>' prior: 0!I represent an ArrayedCollection whose elements are integers between 0 and 255.!!ByteArray methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:47'!atAllPut: value	"Fill the receiver with the given value"	<primitive: 145>	super atAllPut: value! !!ByteArray methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:52'!byteAt: index	<primitive: 60>	^self at: index! !!ByteArray methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:52'!byteAt: index put: value	<primitive: 61>	^self at: index put: value! !!ByteArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 16:17'!byteSize	^self size! !!ByteArray methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 1! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	h _ ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	h = 0 ifFalse:[w _ (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 8/2/2003 19:29'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b0 _ (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b0 < 0 ifTrue:[b0 := 256 + b0].	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort _ self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/3/1998 14:20'!shortAt: index put: value bigEndian: aBool	"Store a 16 bit integer quantity starting from the given byte index"	self unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:51'!unsignedShortAt: index bigEndian: aBool	"Return a 16 bit unsigned integer quantity starting from the given byte index"	^aBool 		ifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]		ifFalse:[((self at: index+1) bitShift: 8) + (self at: index)].! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:53'!unsignedShortAt: index put: value bigEndian: aBool	"Store a 16 bit unsigned integer quantity starting from the given byte index"	aBool ifTrue:[		self at: index put: (value bitShift: -8).		self at: index+1 put: (value bitAnd: 255).	] ifFalse:[		self at: index+1 put: (value bitShift: -8).		self at: index put: (value bitAnd: 255).	].	^value! !!ByteArray methodsFor: 'converting' stamp: 'sma 5/12/2000 17:35'!asByteArray	^ self! !!ByteArray methodsFor: 'converting'!asString	"Convert to a String with Characters for each byte.	Fast code uses primitive that avoids character conversion"	^ (String new: self size) replaceFrom: 1 to: self size with: self! !!ByteArray methodsFor: 'private'!defaultElement	^0! !!ByteArray methodsFor: 'private'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!ByteArray methodsFor: 'comparing' stamp: 'SqR 8/13/2002 10:52'!hash	"#hash is implemented, because #= is implemented"	^self class		hashBytes: self		startingWith: self species hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ByteArray class	instanceVariableNames: ''!!ByteArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:13'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asCharPtrFrom: anInteger on: aStream! !!ByteArray class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 00:25'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isBytes')! !!ByteArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:13'!ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString! !!ByteArray class methodsFor: 'byte based hash' stamp: 'SqR 8/21/2002 16:21'!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	byteArraySize _ aByteArray size.	hash _ speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash _ hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low _ hash bitAnd: 16383.		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !Model subclass: #CPUWatcher	instanceVariableNames: 'tally watcher threshold'	classVariableNames: 'CurrentCPUWatcher'	poolDictionaries: ''	category: 'Tools-Process Browser'!!CPUWatcher commentStamp: '<historical>' prior: 0!CPUWatcher implements a simple runaway process monitoring toolthat will suspend a process that is taking up too much of Squeak'stime and allow user interaction. By default it watches for a Process thatis taking more than 80% of the time; this threshold can be changed.CPUWatcher can also be used to show cpu percentages for each process from within the ProcessBrowser.	CPUWatcher startMonitoring.	"process period 20 seconds, sample rate 100 msec"	CPUWatcher current monitorProcessPeriod: 10 sampleRate: 20.	CPUWatcher current threshold: 0.5.	"change from 80% to 50%"	CPUWatcher stopMonitoring.!!CPUWatcher methodsFor: 'process operations' stamp: 'nk 3/8/2001 17:13'!debugProcess: aProcess	| uiPriority oldPriority |	uiPriority _ Processor activeProcess priority.	aProcess priority >= uiPriority ifTrue: [		oldPriority _ ProcessBrowser setProcess: aProcess toPriority: uiPriority - 1	].	ProcessBrowser debugProcess: aProcess.! !!CPUWatcher methodsFor: 'process operations' stamp: 'nk 3/8/2001 17:27'!debugProcess: aProcess fromMenu: aMenuMorph	aMenuMorph delete.	self debugProcess: aProcess.! !!CPUWatcher methodsFor: 'process operations' stamp: 'nk 3/8/2001 17:21'!resumeProcess: aProcess fromMenu: aMenuMorph	aMenuMorph delete.	ProcessBrowser resumeProcess: aProcess.! !!CPUWatcher methodsFor: 'process operations' stamp: 'nk 3/8/2001 17:24'!terminateProcess: aProcess fromMenu: aMenuMorph	aMenuMorph delete.	ProcessBrowser terminateProcess: aProcess.! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'nk 3/8/2001 20:47'!catchThePig: aProcess	| rules |	"nickname, allow-stop, allow-debug"	rules _ ProcessBrowser nameAndRulesFor: aProcess.	(ProcessBrowser isUIProcess: aProcess)		ifTrue: [ "aProcess debugWithTitle: 'Interrupted from the CPUWatcher'." ]		ifFalse: [ rules second ifFalse: [ ^self ].				ProcessBrowser suspendProcess: aProcess.				self openWindowForSuspendedProcess: aProcess ]! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'nk 3/8/2001 16:05'!findThePig	"tally has been updated. Look at it to see if there is a bad process.	This runs at a very high priority, so make it fast"	| countAndProcess | 	countAndProcess _ tally sortedCounts first.	(countAndProcess key / tally size > self threshold) ifTrue: [ | proc |		proc _ countAndProcess value.		proc == Processor backgroundProcess ifTrue: [ ^self ].	"idle process? OK"		self catchThePig: proc	].! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'nk 3/8/2001 18:34'!openMVCWindowForSuspendedProcess: aProcess	ProcessBrowser new openAsMVC.! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'BG 10/29/2003 01:06'!openWindowForSuspendedProcess: aProcess	Smalltalk isMorphic		ifTrue: [ ]		ifFalse: [ [ self openMVCWindowForSuspendedProcess: aProcess ] forkAt: Processor userSchedulingPriority ]! !!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'nk 3/14/2001 08:39'!monitorProcessPeriod: secs sampleRate: msecs	self stopMonitoring.	watcher _ [ [ | promise |		promise _ Processor tallyCPUUsageFor: secs every: msecs.		tally _ promise value.		promise _ nil.		self findThePig.	] repeat ] forkAt: Processor highestPriority.	Processor yield ! !!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'nk 3/14/2001 08:07'!startMonitoring	self		monitorProcessPeriod: 20 sampleRate: 100! !!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'nk 3/8/2001 16:24'!stopMonitoring	watcher ifNotNil: [		ProcessBrowser terminateProcess: watcher.		watcher _ nil.	]! !!CPUWatcher methodsFor: 'accessing' stamp: 'nk 3/14/2001 07:56'!isMonitoring	^watcher notNil! !!CPUWatcher methodsFor: 'accessing' stamp: 'nk 3/8/2001 18:36'!tally	^tally copy! !!CPUWatcher methodsFor: 'accessing' stamp: 'nk 3/8/2001 18:49'!threshold	"What fraction of the time can a process be the active process before we stop it?"	^threshold! !!CPUWatcher methodsFor: 'accessing' stamp: 'nk 3/8/2001 18:38'!threshold: thresh	"What fraction of the time can a process be the active process before we stop it?"	threshold _ (thresh max: 0.02) min: 1.0! !!CPUWatcher methodsFor: 'accessing' stamp: 'nk 3/14/2001 08:26'!watcherProcess	^watcher! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPUWatcher class	instanceVariableNames: ''!!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 18:45'!current	^CurrentCPUWatcher! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:28'!currentWatcherProcess	^CurrentCPUWatcher ifNotNil: [ CurrentCPUWatcher watcherProcess ]! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 21:43'!dumpTallyOnTranscript	self current ifNotNil: [		ProcessBrowser dumpTallyOnTranscript: self current tally	]! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:15'!initialize	"CPUWatcher initialize"	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:06'!isMonitoring	^CurrentCPUWatcher notNil and: [ CurrentCPUWatcher isMonitoring ]! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 10/31/2001 10:50'!monitorPreferenceChanged	Preferences cpuWatcherEnabled		ifTrue: [ self startMonitoring ]		ifFalse: [ self stopMonitoring ]! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:14'!shutDown	self stopMonitoring.! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:17'!startMonitoring	"CPUWatcher startMonitoring"	^self startMonitoringPeriod: 20 rate: 100 threshold: 0.8! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:16'!startMonitoringPeriod: pd rate: rt threshold: th	"CPUWatcher startMonitoring"	CurrentCPUWatcher ifNotNil: [ ^CurrentCPUWatcher startMonitoring. ].	CurrentCPUWatcher _ (self new)		monitorProcessPeriod: pd sampleRate: rt;		threshold: th;		yourself.	^CurrentCPUWatcher! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:14'!startUp	self monitorPreferenceChanged.! !!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:05'!stopMonitoring	"CPUWatcher stopMonitoring"	CurrentCPUWatcher ifNotNil: [ CurrentCPUWatcher stopMonitoring. ].	CurrentCPUWatcher _ nil.! !FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!ParseNode subclass: #CascadeNode	instanceVariableNames: 'receiver messages'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!CascadeNode commentStamp: '<historical>' prior: 0!The first message has the common receiver, the rest have receiver == nil, which signifies cascading.!!CascadeNode methodsFor: 'initialize-release'!receiver: receivingObject messages: msgs	" Transcript show: 'abc'; cr; show: 'def' "	receiver _ receivingObject.	messages _ msgs! !!CascadeNode methodsFor: 'code generation'!emitForValue: stack on: aStream	receiver emitForValue: stack on: aStream.	1 to: messages size - 1 do: 		[:i | 		aStream nextPut: Dup.		stack push: 1.		(messages at: i) emitForValue: stack on: aStream.		aStream nextPut: Pop.		stack pop: 1].	messages last emitForValue: stack on: aStream! !!CascadeNode methodsFor: 'code generation'!sizeForValue: encoder	| size |	size _ (receiver sizeForValue: encoder) + (messages size - 1 * 2).	messages do: [:aMessage | size _ size + (aMessage sizeForValue: encoder)].	^size! !!CascadeNode methodsFor: 'printing'!printOn: aStream indent: level	self printOn: aStream indent: level precedence: 0! !!CascadeNode methodsFor: 'printing' stamp: 'di 4/25/2000 19:17'!printOn: aStream indent: level precedence: p 	p > 0 ifTrue: [aStream nextPut: $(].	messages first printReceiver: receiver on: aStream indent: level.	1 to: messages size do: 		[:i | (messages at: i) printOn: aStream indent: level.		i < messages size ifTrue: 				[aStream nextPut: $;.				messages first precedence >= 2 ifTrue: [aStream crtab: level + 1]]].	p > 0 ifTrue: [aStream nextPut: $)]! !!CascadeNode methodsFor: 'accessing' stamp: 'tk 10/22/2000 16:55'!receiver	^receiver! !Object subclass: #Categorizer	instanceVariableNames: 'categoryArray categoryStops elementArray'	classVariableNames: 'Default NullCategory'	poolDictionaries: ''	category: 'Kernel-Classes'!!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!addCategory: newCategory	^ self addCategory: newCategory before: nil ! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!addCategory: catString before: nextCategory	"Add a new category named heading.	If default category exists and is empty, remove it.	If nextCategory is nil, then add the new one at the end,	otherwise, insert it before nextCategory."	| index newCategory |	newCategory _ catString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^self].	"heading already exists, so done"	index _ categoryArray indexOf: nextCategory		ifAbsent: [categoryArray size + 1].	categoryArray _ categoryArray		copyReplaceFrom: index		to: index-1		with: (Array with: newCategory).	categoryStops _ categoryStops		copyReplaceFrom: index		to: index-1		with: (Array with: (index = 1				ifTrue: [0]				ifFalse: [categoryStops at: index-1])).	"remove empty default category"	(newCategory ~= Default			and: [(self listAtCategoryNamed: Default) isEmpty])		ifTrue: [self removeCategory: Default]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!allMethodSelectors	"give a list of all method selectors."	^ elementArray copy sort! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:29'!categories	"Answer an Array of categories (names)."	categoryArray isNil ifTrue: [^ nil].	(categoryArray size = 1 		and: [categoryArray first = Default & (elementArray size = 0)])		ifTrue: [^Array with: NullCategory].	^categoryArray! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!categories: anArray 	"Reorder my categories to be in order of the argument, anArray. If the 	resulting organization does not include all elements, then give an error."	| newCategories newStops newElements catName list runningTotal | 	newCategories _ Array new: anArray size.	newStops _ Array new: anArray size.	newElements _ Array new: 0.	runningTotal _ 0.	1 to: anArray size do:		[:i |		catName _ (anArray at: i) asSymbol.		list _ self listAtCategoryNamed: catName.				newElements _ newElements, list.				newCategories at: i put: catName.				newStops at: i put: (runningTotal _ runningTotal + list size)].	elementArray do:		[:element | "check to be sure all elements are included"		(newElements includes: element)			ifFalse: [^self error: 'New categories must match old ones']].	"Everything is good, now update my three arrays."	categoryArray _ newCategories.	categoryStops _ newStops.	elementArray _ newElements! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!categoryOfElement: element 	"Answer the category associated with the argument, element."	| index |	index _ self numberOfCategoryOfElement: element.	index = 0		ifTrue: [^nil]		ifFalse: [^categoryArray at: index]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:36'!changeFromCategorySpecs: categorySpecs 	"Tokens is an array of categorySpecs as scanned from a browser 'reorganize' pane, or built up by some other process, such as a scan of an environment."	| oldElements newElements newCategories newStops currentStop temp ii cc catSpec |	oldElements _ elementArray asSet.	newCategories _ Array new: categorySpecs size.	newStops _ Array new: categorySpecs size.	currentStop _ 0.	newElements _ WriteStream on: (Array new: 16).	1 to: categorySpecs size do: 		[:i | 		catSpec _ categorySpecs at: i.		newCategories at: i put: catSpec first asSymbol.		catSpec allButFirst asSortedCollection do:			[:elem |			(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:				[newElements nextPut: elem.				currentStop _ currentStop+1]].		newStops at: i put: currentStop].	"Ignore extra elements but don't lose any existing elements!!"	oldElements _ oldElements collect:		[:elem | Array with: (self categoryOfElement: elem) with: elem].	newElements _ newElements contents.	categoryArray _ newCategories.	(cc _ categoryArray asSet) size = categoryArray size ifFalse: ["has duplicate element"		temp _ categoryArray asOrderedCollection.		temp removeAll: categoryArray asSet asOrderedCollection.		temp do: [:dup | 			ii _ categoryArray indexOf: dup.			[dup _ (dup,' #2') asSymbol.  cc includes: dup] whileTrue.			cc add: dup.			categoryArray at: ii put: dup]].	categoryStops _ newStops.	elementArray _ newElements.	oldElements do: [:pair | self classify: pair last under: pair first].! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!changeFromString: aString 	"Parse the argument, aString, and make this be the receiver's structure."	| categorySpecs |	categorySpecs _ Scanner new scanTokens: aString.	"If nothing was scanned and I had no elements before, then default me"	(categorySpecs isEmpty and: [elementArray isEmpty])		ifTrue: [^ self setDefaultList: Array new].	^ self changeFromCategorySpecs: categorySpecs! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!classify: element under: heading 	self classify: element under: heading suppressIfDefault: true! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:54'!classify: element under: heading suppressIfDefault: aBoolean	"Store the argument, element, in the category named heading.   If aBoolean is true, then invoke special logic such that the classification is NOT done if the new heading is the Default and the element already had a non-Default classification -- useful for filein"	| catName catIndex elemIndex realHeading |	((heading = NullCategory) or: [heading == nil])		ifTrue: [realHeading _ Default]		ifFalse: [realHeading _ heading asSymbol].	(catName _ self categoryOfElement: element) = realHeading		ifTrue: [^ self].  "done if already under that category"	catName ~~ nil ifTrue: 		[(aBoolean and: [realHeading = Default])				ifTrue: [^ self].	  "return if non-Default category already assigned in memory"		self removeElement: element].	"remove if in another category"	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].	catIndex _ categoryArray indexOf: realHeading.	elemIndex _ 		catIndex > 1			ifTrue: [categoryStops at: catIndex - 1]			ifFalse: [0].	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 		and: [element >= (elementArray at: elemIndex)]] whileTrue.	"elemIndex is now the index for inserting the element. Do the insertion before it."	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1						with: (Array with: element).	"add one to stops for this and later categories"	catIndex to: categoryArray size do: 		[:i | categoryStops at: i put: (categoryStops at: i) + 1].	(self listAtCategoryNamed: Default) size = 0 ifTrue: [self removeCategory: Default]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!classifyAll: aCollection under: heading	aCollection do:		[:element | self classify: element under: heading]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:20'!elementCategoryDict	| dict firstIndex lastIndex |	elementArray isNil ifTrue: [^ nil].	dict _ Dictionary new: elementArray size.	1to: categoryStops size do: [:cat |		firstIndex _ self firstIndexOfCategoryNumber: cat.		lastIndex _ self lastIndexOfCategoryNumber: cat.		firstIndex to: lastIndex do: [:el |			dict at: (elementArray at: el) put: (categoryArray at: cat)].	].	^ dict.! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!listAtCategoryNamed: categoryName	"Answer the array of elements associated with the name, categoryName."	| i |	i _ categoryArray indexOf: categoryName ifAbsent: [^Array new].	^self listAtCategoryNumber: i! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/6/2004 13:51'!listAtCategoryNumber: anInteger 	"Answer the array of elements stored at the position indexed by anInteger.  Answer nil if anInteger is larger than the number of categories."	| firstIndex lastIndex |	(anInteger < 1 or: [anInteger > categoryStops size])		ifTrue: [^ nil].	firstIndex _ self firstIndexOfCategoryNumber: anInteger.	lastIndex _  self lastIndexOfCategoryNumber: anInteger.	^elementArray copyFrom: firstIndex to: lastIndex! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!numberOfCategoryOfElement: element 	"Answer the index of the category with which the argument, element, is 	associated."	| categoryIndex elementIndex |	categoryIndex _ 1.	elementIndex _ 0.	[(elementIndex _ elementIndex + 1) <= elementArray size]		whileTrue: 			["point to correct category"			[elementIndex > (categoryStops at: categoryIndex)]				whileTrue: [categoryIndex _ categoryIndex + 1].			"see if this is element"			element = (elementArray at: elementIndex) ifTrue: [^categoryIndex]].	^0! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!removeCategory: cat 	"Remove the category named, cat. Create an error notificiation if the 	category has any elements in it."	| index lastStop |	index _ categoryArray indexOf: cat ifAbsent: [^self].	lastStop _ 		index = 1			ifTrue: [0]			ifFalse: [categoryStops at: index - 1].	(categoryStops at: index) - lastStop > 0 		ifTrue: [^self error: 'cannot remove non-empty category'].	categoryArray _ categoryArray copyReplaceFrom: index to: index with: Array new.	categoryStops _ categoryStops copyReplaceFrom: index to: index with: Array new.	categoryArray size = 0		ifTrue:			[categoryArray _ Array with: Default.			categoryStops _ Array with: 0]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!removeElement: element 	"Remove the selector, element, from all categories."	| categoryIndex elementIndex nextStop newElements |	categoryIndex _ 1.	elementIndex _ 0.	nextStop _ 0.	"nextStop keeps track of the stops in the new element array"	newElements _ WriteStream on: (Array new: elementArray size).	[(elementIndex _ elementIndex + 1) <= elementArray size]		whileTrue: 			[[elementIndex > (categoryStops at: categoryIndex)]				whileTrue: 					[categoryStops at: categoryIndex put: nextStop.					categoryIndex _ categoryIndex + 1].			(elementArray at: elementIndex) = element				ifFalse: 					[nextStop _ nextStop + 1.					newElements nextPut: (elementArray at: elementIndex)]].	[categoryIndex <= categoryStops size]		whileTrue: 			[categoryStops at: categoryIndex put: nextStop.			categoryIndex _ categoryIndex + 1].	elementArray _ newElements contents! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!removeEmptyCategories	"Remove empty categories."	| categoryIndex currentStop keptCategories keptStops |	keptCategories _ WriteStream on: (Array new: 16).	keptStops _ WriteStream on: (Array new: 16).	currentStop _ categoryIndex _ 0.	[(categoryIndex _ categoryIndex + 1) <= categoryArray size]		whileTrue: 			[(categoryStops at: categoryIndex) > currentStop				ifTrue: 					[keptCategories nextPut: (categoryArray at: categoryIndex).					keptStops nextPut: (currentStop _ categoryStops at: categoryIndex)]].	categoryArray _ keptCategories contents.	categoryStops _ keptStops contents.	categoryArray size = 0		ifTrue:			[categoryArray _ Array with: Default.			categoryStops _ Array with: 0]	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!renameCategory: oldCatString toBe: newCatString	"Rename a category. No action if new name already exists, or if old name does not exist."	| index oldCategory newCategory |	oldCategory _ oldCatString asSymbol.	newCategory _ newCatString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^ self].	"new name exists, so no action"	(index _ categoryArray indexOf: oldCategory) = 0		ifTrue: [^ self].	"old name not found, so no action"	categoryArray _ categoryArray copy.  "need to change identity so smart list update will notice the change"	categoryArray at: index put: newCategory! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!sortCategories	| privateCategories publicCategories newCategories |	privateCategories _ self categories select:		[:one | (one findString: 'private' startingAt: 1 caseSensitive: false) = 1].	publicCategories _ self categories copyWithoutAll: privateCategories.	newCategories _ publicCategories asSortedCollection asOrderedCollection		addAll: privateCategories asSortedCollection;		asArray.	self categories: newCategories! !!Categorizer methodsFor: 'printing' stamp: 'NS 4/5/2004 17:44'!printOn: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex |	elementIndex _ 1.	1 to: categoryArray size do: 		[:i | 		aStream nextPut: $(.		(categoryArray at: i) asString printOn: aStream.		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream space; nextPutAll: (elementArray at: elementIndex).				elementIndex _ elementIndex + 1].		aStream nextPut: $); cr]! !!Categorizer methodsFor: 'printing' stamp: 'NS 4/5/2004 17:44'!printOnStream: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex  |	elementIndex _ 1.	1 to: categoryArray size do: 		[:i | 		aStream print: '(';		write:(categoryArray at:i).		" is the asString redundant? "		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream print:' '; write:(elementArray at: elementIndex).				elementIndex _ elementIndex + 1].		aStream print:')'.		aStream cr]! !!Categorizer methodsFor: 'fileIn/Out' stamp: 'NS 4/5/2004 17:44'!scanFrom: aStream	"Reads in the organization from the next chunk on aStream.	Categories or elements not found in the definition are not affected.	New elements are ignored."	self changeFromString: aStream nextChunk.	aStream skipStyleChunk.! !!Categorizer methodsFor: 'private' stamp: 'NS 4/5/2004 17:44'!elementArray	^ elementArray! !!Categorizer methodsFor: 'private' stamp: 'NS 4/6/2004 13:51'!firstIndexOfCategoryNumber: anInteger	anInteger < 1 ifTrue: [^ nil].	^ (anInteger > 1			ifTrue: [(categoryStops at: anInteger - 1) + 1]			ifFalse: [1]).! !!Categorizer methodsFor: 'private' stamp: 'NS 4/6/2004 13:52'!lastIndexOfCategoryNumber: anInteger	anInteger > categoryStops size ifTrue: [^ nil].	^ categoryStops at: anInteger! !!Categorizer methodsFor: 'private' stamp: 'NS 4/5/2004 17:50'!setDefaultList: aSortedCollection	categoryArray _ Array with: Default.	categoryStops _ Array with: aSortedCollection size.	elementArray _ aSortedCollection asArray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Categorizer class	instanceVariableNames: ''!!Categorizer class methodsFor: 'class initialization' stamp: 'NS 4/5/2004 17:44'!allCategory	"Return a symbol that represents the virtual all methods category."	^ '-- all --' asSymbol! !!Categorizer class methodsFor: 'class initialization' stamp: 'NS 4/5/2004 17:44'!default 	^ Default! !!Categorizer class methodsFor: 'class initialization' stamp: 'NS 4/6/2004 11:48'!initialize	"	self  initialize	"		Default _ 'as yet unclassified' asSymbol.	NullCategory _ 'no messages' asSymbol.! !!Categorizer class methodsFor: 'class initialization' stamp: 'NS 4/5/2004 17:44'!nullCategory	^ NullCategory! !!Categorizer class methodsFor: 'instance creation' stamp: 'NS 4/5/2004 17:44'!defaultList: aSortedCollection 	"Answer an instance of me with initial elements from the argument, 	aSortedCollection."	^self new setDefaultList: aSortedCollection! !!Categorizer class methodsFor: 'documentation' stamp: 'NS 4/5/2004 17:44'!documentation	"Instances consist of an Array of category names (categoryArray), each of 	which refers to an Array of elements (elementArray). This association is 	made through an Array of stop indices (categoryStops), each of which is 	the index in elementArray of the last element (if any) of the 	corresponding category. For example: categories _ Array with: 'firstCat' 	with: 'secondCat' with: 'thirdCat'. stops _ Array with: 1 with: 4 with: 4. 	elements _ Array with: #a with: #b with: #c with: #d. This means that 	category firstCat has only #a, secondCat has #b, #c, and #d, and 	thirdCat has no elements. This means that stops at: stops size must be the 	same as elements size." ! !CodeHolder subclass: #ChangeList	instanceVariableNames: 'changeList list listIndex listSelections file lostMethodPointer showsVersions'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeList commentStamp: '<historical>' prior: 0!A ChangeList represents a list of changed methods that reside on a file in fileOut format.  The classes and methods in my list are not necessarily in this image!!  Used as the model for both Version Lists and Changed Methods (in Screen Menu, Changes...).  Note that the two kinds of window have different controller classes!!!!It holds three lists:	changeList - a list of ChangeRecords	list - a list of one-line printable headers	listSelections - a list of Booleans (true = selected, false = not selected) multiple OK.	listIndex Items that are removed (removeDoits, remove an item) are removed from all three lists.Most recently clicked item is the one showing in the bottom pane.!!ChangeList methodsFor: 'initialization-release'!addItem: item text: text	| cr |	cr _ Character cr.	changeList addLast: item.	list addLast: (text collect: [:x | x = cr ifTrue: [$/] ifFalse: [x]])! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/7/2000 12:42'!changeListButtonSpecs	^#(		('select all' 			selectAll				'select all entries')		('deselect all'		deselectAll			'deselect all entries')		('select conflicts'	selectAllConflicts	'select all methods that occur in any change set')		('file in selections' 	fileInSelections		'file in all selected entries')		)! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 9/5/2001 13:53'!initialize	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"	contentsSymbol _ Preferences diffsInChangeList		ifTrue:			[self defaultDiffsSymbol]		ifFalse:			[#source].	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	super initialize! !!ChangeList methodsFor: 'initialization-release' stamp: 'sbw 12/30/1999 11:02'!optionalButtonHeight	^ 15! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 11/13/2001 08:50'!optionalButtonsView	"Answer the a View containing the optional buttons"	| view bHeight vWidth first offset previousView bWidth button |	vWidth _ 200.	bHeight _ self optionalButtonHeight.	previousView _ nil.	offset _ 0.	first _ true.	view _ View new		model: self;		window: (0 @ 0 extent: vWidth @ bHeight).	self changeListButtonSpecs do: [:triplet |		button _ PluggableButtonView			on: self			getState: nil			action: triplet second.		button label: triplet first asParagraph.		bWidth _ button label boundingBox width // 2.		button			window: (offset@0 extent: bWidth@bHeight);			borderWidthLeft: 0 right: 1 top: 0 bottom: 0.		offset _ offset + bWidth.		first			ifTrue:				[view addSubView: button.				first _ false.]			ifFalse:				[view addSubView: button toRightOf: previousView].		previousView _ button].	button _ PluggableButtonView		on: self		getState: #showingAnyKindOfDiffs		action: #toggleDiffing.	button		label: 'diffs' asParagraph;		window: (offset@0 extent: (vWidth - offset)@bHeight).	view addSubView: button toRightOf: previousView.	^ view! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 8/15/2002 22:34'!wantsPrettyDiffOption	"Answer whether pretty-diffs are meaningful for this tool"	^ true! !!ChangeList methodsFor: 'scanning' stamp: 'sw 1/15/98 21:56'!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp isComment anIndex |	itemPosition _ file position.	item _ file nextChunk.	isComment _ (item includesSubString: 'commentStamp:').	(isComment or: [item includesSubString: 'methodsFor:']) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens _ Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp _ ''.		anIndex _ tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp _ tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].		tokens second == #commentStamp:			ifTrue:				[stamp _ tokens third.				self addItem:						(ChangeRecord new file: file position: file position type: #classComment										class: tokens first category: nil meta: false stamp: stamp)						text: 'class comment for ' , tokens first, 							  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).				file nextChunk.				^ file skipStyleChunk]! !!ChangeList methodsFor: 'scanning' stamp: 'di 1/13/98 16:56'!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method |	[itemPosition _ file position.	method _ file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, (Parser new parseSelector: method)				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'scanning' stamp: 'sw 10/19/1999 15:13'!scanFile: aFile from: startPosition to: stopPosition	| itemPosition item prevChar |	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar _ file next].		(file peekFor: $!!)		ifTrue:			[(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [self scanCategory]]		ifFalse:			[itemPosition _ file position.			item _ file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'menu actions' stamp: 'jm 5/3/1998 19:15'!acceptFrom: aView	aView controller text = aView controller initialText ifFalse: [		aView flash.		^ self inform: 'You can only accept this version as-is.If you want to edit, copy the text to a browser'].	(aView setText: aView controller text from: self) ifTrue:		[aView ifNotNil: [aView controller accept]].	"initialText"! !!ChangeList methodsFor: 'menu actions' stamp: 'nk 1/7/2004 11:08'!browseAllVersionsOfSelections	"Opens a Versions browser on all the currently selected methods, showing each alongside all of their historical versions."	|  oldSelection aList |	oldSelection _ self listIndex.	aList _ OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				listIndex _ i.				self browseVersions.				aList add: i.				]]].	listIndex _ oldSelection.	aList size == 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].! !!ChangeList methodsFor: 'menu actions' stamp: 'RAA 5/28/2001 11:37'!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	|  aClass aChange aList |	aList _ OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				aChange _ changeList at: i.				(aChange type = #method					and: [(aClass _ aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue: [							aList add: (								MethodReference new									setStandardClass: aClass  									methodSymbol: aChange methodSelector							)						]]]].	aList size == 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	MessageSet 		openMessageList: aList 		name: 'Current versions of selected methods in ', file localName! !!ChangeList methodsFor: 'menu actions' stamp: 'nk 1/7/2004 10:23'!browseVersions	| change class browser |	listIndex = 0		ifTrue: [^ nil ].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifFalse: [ ^nil ].	browser _ super browseVersions.	browser ifNotNil: [ browser addedChangeRecord: change ].	^browser! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/25/2001 07:22'!changeListKey: aChar from: view	"Respond to a Command key in the list pane."	aChar == $D ifTrue: [^ self toggleDiffing].	aChar == $a ifTrue: [^ self selectAll].	^ self arrowKey: aChar from: view! !!ChangeList methodsFor: 'menu actions' stamp: 'BG 10/28/2003 20:46'!changeListMenu: aMenu	"Fill aMenu up so that it comprises the primary changelist-browser menu"	aMenu addList: #(	('fileIn selections'							fileInSelections						'import the selected items into the image')	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')	-	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')	-	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')	-	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')	-	('select all (a)'								selectAll								'select all the items in the list')	('deselect all'								deselectAll							'deselect all the items in the list')	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')	-	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')	-	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')	('remove selected items'						removeSelections					'remove the selected items from the change-list')	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).	^ aMenu! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 5/20/2001 21:18'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change class s1 s2 |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifTrue: [s1 _ (class sourceCodeAt: change methodSelector) asString.			s2 _ change string.			s1 = s2				ifTrue: [^ self inform: 'Exact Match'].			(StringHolder new				textContents: (TextDiffBuilder buildDisplayPatchFrom: s1 to: s2 inClass: class  prettyDiffs: self showingPrettyDiffs))				openLabel: 'Comparison to Current Version']		ifFalse: [self flash]! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/25/2001 08:38'!deselectAll 	"Deselect all items in the list pane, and clear the code pane"	listIndex _ 0.	listSelections atAllPut: false.	self changed: #allSelections.	self contentsChanged! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/25/2001 09:04'!destroyCurrentCodeOfSelections	"Actually remove from the system any in-memory methods with class and selector identical to items current selected.  This may seem rather arcane but believe me it has its great uses, when trying to split out code.  To use effectively, first file out a change set that you wish to split off.  Then open a ChangeList browser on that fileout.  Now look through the methods, and select any of them which you want to remove completely from the system, then issue this command.  For those methods where you have made changes to pre-existing versions, of course, you won't want to remove them from the system, so use this mechanism with care!!"	|  aClass aChange aList |	aList _ OrderedCollection new.	1 to: changeList size do:		[:index |			(listSelections at: index) ifTrue:				[aChange _ changeList at: index.				(aChange type = #method					and: [(aClass _ aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue:							[aList add: {aClass. aChange methodSelector}]]].	aList size > 0 ifTrue:		[(self confirm: 'Warning!! This will actually remove ', aList size printString,  ' method(s) from the system!!') ifFalse: [^ self]].	aList do:		[:aPair | Transcript cr; show: 'Removed: ', aPair first printString, '.', aPair second.			aPair first removeSelector: aPair second]! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 10/11/1999 17:10'!fileInSelections 	| any |	any _ false.	listSelections with: changeList do: 		[:selected :item | selected ifTrue: [any _ true. item fileIn]].	any ifFalse:		[self inform: 'nothing selected, so nothing done']! !!ChangeList methodsFor: 'menu actions' stamp: 'sma 2/5/2000 19:13'!fileOutSelections 	| f |	f _ FileStream newFileNamed: (FillInTheBlank request: 'Enter file name' initialAnswer: 'Filename.st').	f ifNil: [^ self].	f header; timeStamp.	listSelections with: changeList do: 		[:selected :item | selected ifTrue: [item fileOutOn: f]].	f close! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/25/2001 08:35'!invertSelections	"Invert the selectedness of each item in the changelist"	listSelections _ listSelections collect: [ :ea | ea not].	listIndex _ 0.	self changed: #allSelections.	self contentsChanged! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 10/11/1999 17:18'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If I can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	(#accept == selector) ifTrue:		[otherTarget isMorph ifFalse: [^ self acceptFrom: otherTarget view]].			"weird special case just for mvc changlist"	^ super perform: selector orSendTo: otherTarget! !!ChangeList methodsFor: 'menu actions' stamp: 'tk 4/8/98 12:38'!removeDoIts	"Remove doits from the receiver, other than initializes. 1/26/96 sw"	| newChangeList newList |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	changeList with: list do:		[:chRec :str |			(chRec type ~~ #doIt or:				[str endsWith: 'initialize'])					ifTrue:						[newChangeList add: chRec.						newList add: str]].	newChangeList size < changeList size		ifTrue:			[changeList _ newChangeList.			list _ newList.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	self changed: #list.	! !!ChangeList methodsFor: 'menu actions' stamp: 'ar 2/24/2001 18:29'!removeExistingMethodVersions	"Remove all up to date version of entries from the receiver"	| newChangeList newList str keep cls sel |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	changeList with: list do:[:chRec :strNstamp | 			keep _ true.			(cls _ chRec methodClass) ifNotNil:[				str _ chRec string.				sel _ cls parserClass new parseSelector: str.				keep _ (cls sourceCodeAt: sel ifAbsent:['']) asString ~= str.			].			keep ifTrue:[					newChangeList add: chRec.					newList add: strNstamp]].	newChangeList size < changeList size		ifTrue:			[changeList _ newChangeList.			list _ newList.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 9/18/2000 12:21'!removeNonSelections	"Remove the unselected items from the receiver."	| newChangeList newList |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	1 to: changeList size do:		[:i | (listSelections at: i) ifTrue:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size == 0 ifTrue:		[^ self inform: 'That would remove everything.Why would you want to do that?'].	newChangeList size < changeList size		ifTrue:			[changeList _ newChangeList.			list _ newList.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	self changed: #list	! !!ChangeList methodsFor: 'menu actions' stamp: 'di 6/13/97 23:10'!removeOlderMethodVersions	"Remove older versions of entries from the receiver."	| newChangeList newList found str |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	found _ OrderedCollection new.	changeList reverseWith: list do:		[:chRec :strNstamp | str _ strNstamp copyUpTo: $;.			(found includes: str)				ifFalse:					[found add: str.					newChangeList add: chRec.					newList add: strNstamp]].	newChangeList size < changeList size		ifTrue:			[changeList _ newChangeList reversed.			list _ newList reversed.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	self changed: #list! !!ChangeList methodsFor: 'menu actions'!removeSelections	"Remove the selected items from the receiver.  9/18/96 sw"	| newChangeList newList |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	1 to: changeList size do:		[:i | (listSelections at: i) ifFalse:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size < changeList size		ifTrue:			[changeList _ newChangeList.			list _ newList.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	self changed: #list	! !!ChangeList methodsFor: 'menu actions'!selectAll	listIndex _ 0.	listSelections atAllPut: true.	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 6/6/2001 12:54'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | aChange _ changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass _ aChange methodClass) notNil				and: [ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'sd 5/23/2003 14:24'!selectConflicts	"Selects all method definitions for which there is ALSO an entry in changes"	| change class  |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change _ changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class _ change methodClass) notNil			and: [(ChangeSet current atSelector: change methodSelector						class: class) ~~ #none]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions'!selectConflicts: changeSetOrList	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList"	| change class systemChanges |	Cursor read showWhile: 	[(changeSetOrList isKindOf: ChangeSet) ifTrue: [	1 to: changeList size do:		[:i | change _ changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class _ change methodClass) notNil			and: [(changeSetOrList atSelector: change methodSelector						class: class) ~~ #none]])]]	ifFalse: ["a ChangeList"	1 to: changeList size do:		[:i | change _ changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class _ change methodClass) notNil			and: [changeSetOrList list includes: (list at: i)]])]]	].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'di 4/6/2001 09:03'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream _ WriteStream on: (String new: 200).	(all _ ChangeSorter allChangeSets copy) do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index _ (PopUpMenu labels: aStream contents) startUp.	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeList methodsFor: 'menu actions' stamp: 'ls 11/14/1998 14:30'!selectMethodsForThisClass	| name |	self currentChange ifNil: [ ^self ].	name _ self currentChange methodClassName.	name ifNil: [ ^self ].	^self selectSuchThat: [ :change |		change methodClassName = name ].! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 12/3/2002 22:27'!selectNewMethods	"Selects all method definitions for which there is no counterpart method in the current image"	| change class |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | change _ changeList at: i.			listSelections at: i put:				((change type = #method and:					[((class _ change methodClass) isNil) or:						[(class includesSelector: change methodSelector) not]]))]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 15:04'!selectSuchThat	"query the user for a selection criterio.  By Lex Spoon.  NB: the UI for invoking this from a changelist browser is currently commented out; to reenfranchise it, you'll need to mild editing to ChangeList method #changeListMenu:"	| code block |	code _ FillInTheBlank request: 'selection criteria for a change named aChangeRecord?\For instance, ''aChangeRecord category = ''System-Network''''' withCRs.	code isEmpty ifTrue: [^ self ].	block _ Compiler evaluate: '[:aChangeRecord | ', code, ']'.	self selectSuchThat: block! !!ChangeList methodsFor: 'menu actions' stamp: 'ls 5/12/1999 07:56'!selectSuchThat: aBlock	"select all changes for which block returns true"	listSelections _ changeList collect: [ :change | aBlock value: change ].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'nk 1/7/2004 09:16'!selectUnchangedMethods	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"	| change class |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change _ changeList at: i.		listSelections at: i put:			((change type = #method and:				[(class _ change methodClass) notNil]) and:					[(class includesSelector: change methodSelector) and:						[change string withBlanksCondensed = (class sourceCodeAt: change methodSelector) asString withBlanksCondensed ]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 6/18/2001 10:44'!annotation	"Answer the string to be shown in an annotation pane.  Make plain that the annotation is associated with the current in-image version of the code, not of the selected disk-based version, and if the corresponding method is missing from the in-image version, mention that fact."	| annot aChange aClass |	annot _ super annotation.	annot asString = '------' ifTrue: [^ annot].	^ ((aChange _ self currentChange) notNil and: [aChange methodSelector notNil])		ifFalse:			[annot]		ifTrue:			[((aClass _ aChange methodClass) isNil or: [(aClass includesSelector: aChange methodSelector) not])				ifTrue:					[aChange methodClassName, ' >> ', aChange methodSelector, ' is not present in the current image.']				ifFalse:					['current version: ', annot]]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 9/5/2001 13:52'!contents	"Answer the contents string, obeying diffing directives if needed"	^ self showingAnyKindOfDiffs		ifFalse:			[self undiffedContents]		ifTrue:			[self showsVersions				ifTrue:					[self diffedVersionContents]				ifFalse:					[self contentsDiffedFromCurrent]]! !!ChangeList methodsFor: 'viewing access' stamp: 'tk 4/10/1998 09:25'!contents: aString	listIndex = 0 ifTrue: [self changed: #flash. ^ false].	lostMethodPointer ifNotNil: [^ self restoreDeletedMethod].	self okToChange "means not dirty" ifFalse: ["is dirty"		self inform: 'This is a view of a method on a file.\Please cancel your changes.  You may\accept, but only when the method is untouched.' withCRs.  ^ false].		"Can't accept changes here.  Method text must be unchanged!!"	(changeList at: listIndex) fileIn.	^ true! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 5/19/2001 10:59'!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange _ changeList at: listIndex.	^ ((aChange type == #method and: [(aClass _ aChange methodClass) notNil]) and: [aClass includesSelector: aChange methodSelector])		ifTrue:			 [Utilities methodDiffFor: aChange text class: aClass selector: aChange methodSelector prettyDiffs: self showingPrettyDiffs]		ifFalse:			[(changeList at: listIndex) text]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 11/13/2001 09:12'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane"	^ self sourceAndDiffsQuintsOnly! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 6/7/2001 23:54'!diffedVersionContents	"Answer diffed version contents, maybe pretty maybe not"	| change class earlier later |	(listIndex = 0			or: [changeList size < listIndex])		ifTrue: [^ ''].	change _ changeList at: listIndex.	later _ change text.	class _ change methodClass.	(listIndex == changeList size or: [class == nil])		ifTrue: [^ later].	earlier _ (changeList at: listIndex + 1) text.	^ TextDiffBuilder buildDisplayPatchFrom: earlier to: later inClass: class prettyDiffs: self showingPrettyDiffs! !!ChangeList methodsFor: 'viewing access'!list	^ list! !!ChangeList methodsFor: 'viewing access'!listIndex	^ listIndex! !!ChangeList methodsFor: 'viewing access'!listSelectionAt: index	^ listSelections at: index! !!ChangeList methodsFor: 'viewing access' stamp: 'di 1/13/1999 14:59'!listSelectionAt: index put: value	^ listSelections at: index put: value! !!ChangeList methodsFor: 'viewing access' stamp: 'NS 1/28/2004 11:18'!restoreDeletedMethod	"If lostMethodPointer is not nil, then this is a version browser for a method that has been removed.  In this case we want to establish a sourceCode link to prior versions.  We do this by installing a dummy method with the correct source code pointer prior to installing this version."	| dummyMethod class selector |	dummyMethod _ CompiledMethod toReturnSelf setSourcePointer: lostMethodPointer.	class _ (changeList at: listIndex) methodClass.	selector _ (changeList at: listIndex) methodSelector.	class addSelectorSilently: selector withMethod: dummyMethod.	(changeList at: listIndex) fileIn.	"IF for some reason, the dummy remains, remove it, but (N.B.!!) we might not get control back if the compile (fileIn above) fails."	(class compiledMethodAt: selector) == dummyMethod		ifTrue: [class basicRemoveSelector: selector].	^ true! !!ChangeList methodsFor: 'viewing access' stamp: 'nk 2/26/2004 13:50'!selectedClass	^(self selectedClassOrMetaClass ifNil: [ ^nil ]) theNonMetaClass ! !!ChangeList methodsFor: 'viewing access' stamp: 'sma 2/5/2000 19:09'!selectedClassOrMetaClass	| c |	^ (c _ self currentChange) ifNotNil: [c methodClass]! !!ChangeList methodsFor: 'viewing access' stamp: 'sma 2/5/2000 19:10'!selectedMessageName	| c |	^ (c _ self currentChange) ifNotNil: [c methodSelector]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/28/1999 12:30'!toggleListIndex: newListIndex	listIndex ~= 0 ifTrue: [listSelections at: listIndex put: false].	newListIndex ~= 0 ifTrue: [listSelections at: newListIndex put: true].	listIndex _ newListIndex.	self changed: #listIndex.	self contentsChanged! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/25/1999 14:45'!undiffedContents	^ listIndex = 0		ifTrue: ['']		ifFalse: [(changeList at: listIndex) text]! !!ChangeList methodsFor: 'accessing'!changeList	^ changeList! !!ChangeList methodsFor: 'accessing' stamp: 'ls 5/12/1999 07:55'!currentChange	"return the current change being viewed, or nil if none"	listIndex = 0 ifTrue: [ ^nil ].	^changeList at: listIndex! !!ChangeList methodsFor: 'accessing'!file	^file! !!ChangeList methodsFor: 'accessing' stamp: 'TPR 11/28/1998 17:38'!listHasSingleEntry	"does the list of changes have only a single item?"	^list size = 1! !!ChangeList methodsFor: 'accessing' stamp: 'tk 6/21/1999 20:43'!listSelections	listSelections ifNil: [		list ifNotNil: [			listSelections _ Array new: list size withAll: false]].	^ listSelections! !!ChangeList methodsFor: 'accessing' stamp: 'di 6/15/97 15:13'!setLostMethodPointer: sourcePointer	lostMethodPointer _ sourcePointer! !!ChangeList methodsFor: 'accessing' stamp: 'sw 10/19/1999 15:11'!showsVersions	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChangeList class	instanceVariableNames: ''!!ChangeList class methodsFor: 'public access' stamp: 'di 1/18/2001 15:30'!browseFile: fileName    "ChangeList browseFile: 'AutoDeclareFix.st'"	"Opens a changeList on the file named fileName"	^ self browseStream: (FileStream readOnlyFileNamed: fileName)! !!ChangeList class methodsFor: 'public access' stamp: 'HK 4/18/2002 15:02'!browseRecent: charCount 	"ChangeList browseRecent: 5000"	"Opens a changeList on the end of the changes log file"	^ self browseRecent: charCount on: (SourceFiles at: 2) ! !!ChangeList class methodsFor: 'public access' stamp: 'HK 4/18/2002 15:02'!browseRecent: charCount on: origChangesFile 	"Opens a changeList on the end of the specified changes log file"	| changeList end changesFile |	changesFile _ origChangesFile readOnlyCopy.	end _ changesFile size.	Cursor read		showWhile: [changeList _ self new						scanFile: changesFile						from: (0 max: end - charCount)						to: end].	changesFile close.	self		open: changeList		name: 'Recent changes'		multiSelect: true! !!ChangeList class methodsFor: 'public access' stamp: 'sd 11/16/2003 14:10'!browseRecentLog	"ChangeList browseRecentLog"	"Prompt with a menu of how far back to go to browse the current image's changes log file"	^ self		browseRecentLogOn: (SourceFiles at: 2)		startingFrom: SmalltalkImage current lastQuitLogPosition! !!ChangeList class methodsFor: 'public access' stamp: 'nk 7/8/2003 13:56'!browseRecentLogOn: origChangesFile 	"figure out where the last snapshot or quit was, then browse the recent entries."	| end done block pos chunk changesFile positions prevBlock |	changesFile _ origChangesFile readOnlyCopy.	positions _ SortedCollection new.	end _ changesFile size.	prevBlock _ end.	block _ end - 1024 max: 0.	done _ false.	[done		or: [positions size > 0]]		whileFalse: [changesFile position: block.			"ignore first fragment"			changesFile nextChunk.			[changesFile position < prevBlock]				whileTrue: [pos _ changesFile position.					chunk _ changesFile nextChunk.					((chunk indexOfSubCollection: '----' startingAt: 1) = 1) ifTrue: [						({ '----QUIT'. '----SNAPSHOT' } anySatisfy: [ :str |							chunk beginsWith: str ])								ifTrue: [positions add: pos]]].			block = 0				ifTrue: [done _ true]				ifFalse: [prevBlock _ block.					block _ block - 1024 max: 0]].	changesFile close.	positions isEmpty		ifTrue: [self inform: 'File ' , changesFile name , ' does not appear to be a changes file']		ifFalse: [self browseRecentLogOn: origChangesFile startingFrom: positions last]! !!ChangeList class methodsFor: 'public access' stamp: 'sw 1/2/2003 21:39'!browseRecentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile _ origChangesFile readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk _ changesFile nextChunk.			i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos _ Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos _ 0]].	changesFile close.	banners size == 0 ifTrue: [^ self inform: 'this image has never been savedsince changes were compressed'].	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	self browseRecent: end - pos on: origChangesFile! !!ChangeList class methodsFor: 'public access' stamp: 'nb 6/17/2003 12:25'!browseRecentLogOnPath: fullName 	"figure out where the last snapshot or quit was, then browse the recent  entries."	fullName		ifNotNil:			[self browseRecentLogOn: (FileStream readOnlyFileNamed: fullName)]		ifNil:			[Beeper beep]	! !!ChangeList class methodsFor: 'public access' stamp: 'di 1/18/2001 15:23'!browseStream: changesFile	"Opens a changeList on a fileStream"	| changeList charCount |	changesFile readOnly.	charCount _ changesFile size.	charCount > 1000000 ifTrue:		[(self confirm: 'The file ', changesFile name , 'is really long (' , charCount printString , ' characters).Would you prefer to view only the last million characters?')			ifTrue: [charCount _ 1000000]].	Cursor read showWhile:		[changeList _ self new			scanFile: changesFile from: changesFile size-charCount to: changesFile size].	changesFile close.	self open: changeList name: changesFile localName , ' log' multiSelect: true! !!ChangeList class methodsFor: 'public access' stamp: 'sd 11/16/2003 14:11'!getRecentLocatorWithPrompt: aPrompt	"Prompt with a menu of how far back to go.  Return nil if user backs out.  Otherwise return the number of characters back from the end of the .changes file the user wishes to include"	 "ChangeList getRecentPosition"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ SmalltalkImage current lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: aPrompt.	pos == nil ifTrue: [^ nil].	^ end - pos! !!ChangeList class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:46'!open: aChangeList name: aString multiSelect: multiSelect	"Create a standard system view for the messageSet, whose label is aString.	The listView may be either single or multiple selection type"	| topView listHeight annoHeight optButtonHeight codeHeight aListView underPane annotationPane buttonsView aBrowserCodeView |		listHeight _ 70.	annoHeight _ 10.	optButtonHeight _ aChangeList optionalButtonHeight.	codeHeight _ 110.	topView _ (StandardSystemView new)		model: aChangeList;		label: aString;		minimumSize: 200 @ 120;		borderWidth: 1.	aListView _ (multiSelect			ifTrue: [PluggableListViewOfMany						on: aChangeList						list: #list						primarySelection: #listIndex						changePrimarySelection: #toggleListIndex:						listSelection: #listSelectionAt:						changeListSelection: #listSelectionAt:put:						menu: (aChangeList showsVersions								ifTrue: [#versionsMenu:]								ifFalse: [#changeListMenu:])]			ifFalse: [PluggableListView						on: aChangeList						list: #list						selected: #listIndex						changeSelected: #toggleListIndex:						menu: (aChangeList showsVersions								ifTrue: [#versionsMenu:]								ifFalse: [#changeListMenu:])]).	aListView window: (0 @ 0 extent: 200 @ listHeight).	topView addSubView: aListView.	underPane _ aListView.	aChangeList wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView				on: aChangeList				text: #annotation				accept: nil				readSelection: nil				menu: nil.			annotationPane window: (0 @ 0 extent: 200 @ 10).			topView addSubView: annotationPane below: underPane.			underPane _ annotationPane.			codeHeight _ codeHeight - annoHeight].	aChangeList wantsOptionalButtons		ifTrue:			[buttonsView _ aChangeList optionalButtonsView.			buttonsView borderWidth: 1.			topView addSubView: buttonsView below: underPane.			underPane _ buttonsView.			codeHeight _ codeHeight - optButtonHeight].	aBrowserCodeView _ PluggableTextView			on: aChangeList			text: #contents			accept: #contents:			readSelection: #contentsSelection			menu: #codePaneMenu:shifted:.	aBrowserCodeView			controller: ReadOnlyTextController new;			window: (0 @ 0 extent: 200 @ codeHeight).	topView addSubView: aBrowserCodeView below: underPane.	topView controller open.! !!ChangeList class methodsFor: 'initialize-release' stamp: 'hg 8/3/2000 18:14'!initialize	FileList registerFileReader: self! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'md 10/22/2003 16:13'!browseChangesFile: fullName	"Browse the selected file in fileIn format."	fullName		ifNotNil:			[ChangeList browseStream: (FileStream readOnlyFileNamed:  fullName)]		ifNil:			[Beeper beep]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:49'!fileReaderServicesForFile: fullName suffix: suffix	| services |	services _ OrderedCollection new.	(FileStream isSourceFileSuffix: suffix) | (suffix = '*')		ifTrue: [ services add: self serviceBrowseChangeFile ].	(suffix = 'changes') | (suffix = '*')		ifTrue: [ services add: self serviceBrowseDotChangesFile ].	^services! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'nk 4/29/2004 10:35'!serviceBrowseChangeFile	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'changelist browser'		selector: #browseStream:		description: 'open a changelist tool on this file'		buttonLabel: 'changes')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'sw 7/4/2002 18:37'!serviceBrowseDotChangesFile	"Answer a service for opening a changelist browser on the tail end of a .changes file"	^ SimpleServiceEntry 		provider: self 		label: 'recent changes in file'		selector: #browseRecentLogOnPath:		description: 'open a changelist tool on recent changes in file'		buttonLabel: 'recent changes'! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:49'!services	"Answer potential file services associated with this class"	^ { self serviceBrowseChangeFile. 		self serviceBrowseDotChangesFile.		 }! !!ChangeList class methodsFor: 'class initialization' stamp: 'SD 11/15/2001 22:21'!unload	FileList unregisterFileReader: self ! !Object subclass: #ChangeRecord	instanceVariableNames: 'file position type class category meta stamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeRecord commentStamp: '<historical>' prior: 0!A ChangeRecord represents a change recorded on a file in fileOut format.It includes a type (more needs to be done here), and additional informationfor certain types such as method defs which need class and category.!!ChangeRecord methodsFor: 'access'!category	^category! !!ChangeRecord methodsFor: 'access' stamp: 'nk 1/7/2004 10:28'!fileName	^(file ifNotNil: [ file name ]) 			ifNil: [ '<no file>' ]! !!ChangeRecord methodsFor: 'access' stamp: 'sw 10/20/2002 02:53'!fileOutOn: aFileStream	"File the receiver out on the given file stream"	| aString |	type == #method		ifTrue:			[aFileStream nextPut: $!!.			aString _  class asString							, (meta ifTrue: [' class methodsFor: ']									ifFalse: [' methodsFor: '])							, category asString printString.			stamp ifNotNil:				[aString _ aString, ' stamp: ''', stamp, ''''].			aFileStream nextChunkPut: aString.			aFileStream cr].	type == #preamble ifTrue: [aFileStream nextPut: $!!].	type == #classComment		ifTrue:			[aFileStream nextPut: $!!.			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.			aFileStream cr].	aFileStream nextChunkPut: self string.	type == #method ifTrue: [aFileStream nextChunkPut: ' '].	aFileStream cr! !!ChangeRecord methodsFor: 'access'!isMetaClassChange	^meta! !!ChangeRecord methodsFor: 'access'!methodClass 	| methodClass |	type == #method ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	methodClass _ Smalltalk at: class asSymbol.	meta ifTrue: [^ methodClass class]		ifFalse: [^ methodClass]! !!ChangeRecord methodsFor: 'access'!methodClassName	^class! !!ChangeRecord methodsFor: 'access'!methodSelector	type == #method ifFalse: [^ nil].	^ Parser new parseSelector: self string! !!ChangeRecord methodsFor: 'access' stamp: '6/6/97 08:56 dhhi'!stamp	^ stamp! !!ChangeRecord methodsFor: 'access' stamp: 'tk 9/7/2000 15:09'!stamp: threePartString	stamp _ threePartString! !!ChangeRecord methodsFor: 'access' stamp: 'di 1/13/98 16:57'!string 	| string |	file openReadOnly.	file position: position.	string _ file nextChunk.	file close.	^ string! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/23/1999 08:20'!text	| text |	^ file ifNil: ['']		ifNotNil: [			file openReadOnly.			file position: position.			text _ file nextChunkText.			file close.			text]! !!ChangeRecord methodsFor: 'access' stamp: 'nk 11/25/2003 09:44'!timeStamp	"Answer a TimeStamp that corresponds to my (text) stamp"	| tokens date time |	tokens := self stamp findTokens: Character separators.	^ tokens size > 2		ifTrue: [[date := Date						fromString: (tokens at: tokens size - 1).			time := Time fromString: tokens last.			TimeStamp date: date time: time]				on: Error				do: [:ex | ex						return: (TimeStamp fromSeconds: 0)]]		ifFalse: [TimeStamp fromSeconds: 0]! !!ChangeRecord methodsFor: 'access'!type	^ type! !!ChangeRecord methodsFor: 'initialization'!file: f position: p type: t	file _ f.	position _ p.	type _ t! !!ChangeRecord methodsFor: 'initialization' stamp: '6/6/97 08:48 dhhi'!file: f position: p type: t class: c category: cat meta: m stamp: s	self file: f position: p type: t.	class _ c.	category _ cat.	meta _ m.	stamp _ s! !!ChangeRecord methodsFor: 'initialization' stamp: 'nk 11/26/2002 12:07'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."	| methodClass s aSelector |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil.			(aSelector _ self methodSelector) ifNotNil:				[Utilities noteMethodSubmission: aSelector forClass: methodClass]].		(type == #doIt) ifTrue:			[((s _ self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]].		(type == #classComment) ifTrue:			[ | cls | (cls _ Smalltalk at: class asSymbol) comment: self text stamp: stamp.			Utilities noteMethodSubmission: #Comment forClass: cls ]]! !Object subclass: #ChangeSet	instanceVariableNames: 'name preamble postscript revertable isolationSet isolatedProject changeRecords structures superclasses'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSet commentStamp: '<historical>' prior: 0!ChangeSets keep track of the changes made to a system, so they can be written on a file as source code (a "fileOut").  Every project has an associated changeSet.  For simple projects, a different changeSet may be designated to capture changes at any time.This implementation of ChangeSet is capable of remembering and manipulating methods for which the classes are not present in the system.  However at the present time, this capability is not used in normal rearranging and fileOuts, but only for invoking and revoking associated with isolation layers.For isolated projects (see Project class comment), the changeSet binding is semi-permanent.  Every project exists in an isolation layer defined by its closest enclosing parent (or itself) that is isolated.  If a project is not isolated, then changes reported to its designated changeSet must also be reported to the permanent changeSet for that layer, designated in the isolated project.  This ensures that that outer project will be able to revert all changes upon exit.Note that only certain changes may be reverted.  Classes may not be added, removed, renamed or reshaped except in the layer in which they are defined because these operations on non-local classes are not revertable.If a Squeak Project is established as being isolated, then its associated changeSet will be declared to be revertable.  In this case all changes stored can be reverted.  The changeSet associated with an isolated project is tied to that project, and cannot be edited in a changeSorter.------name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.revertable - a BooleanIf this variable is true, then all of the changes recorded by this changeSet can be reverted.isolationSet - a ChangeSet or nilThe isolationSet is the designated changeSet for an isolation layer.  If this changeSet is an isolationSet, then this variable will be nil.  If not, then it points to the isolationSet for this layer, and all changes reported here will also be reported to the isolationSet.isolatedProject - a Project or nilIf this is an isolationSet, then this variable points to the project with which it is associated.changeRecords -  Dictionary {class name -> a ClassChangeRecord}.These classChangeRecords (qv) remember all of the system changes.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.Of all classes in classChanges, and all of their superclasses.Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).NOTE:  It should be fairly simple, by adding a bit more information to the classChangeRecords, to reconstruct the information now stored in 'structures' and 'superclasses'.  This would be a welcome simplification.!!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/29/2000 20:42'!beIsolationSetFor: aProject	self isEmpty ifFalse: [self error: 'Must be empty at the start.'].	isolatedProject _ aProject.	revertable _ true.! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/1/2000 12:00'!clear 	"Reset the receiver to be empty.  "	changeRecords _ Dictionary new.	preamble _ nil.	postscript _ nil! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/6/2001 09:40'!initialize 	"Initialize the receiver to be empty."	name ifNil:		[^ self error: 'All changeSets must be registered, as in ChangeSorter newChangeSet'].	revertable _ false.	self clear.! !!ChangeSet methodsFor: 'initialize-release'!isMoribund	"Answer whether the receiver is obsolete and about to die; part of an effort to get such guys cleared out from the change sorter.  2/7/96 sw"	^ name == nil ! !!ChangeSet methodsFor: 'initialize-release' stamp: 'sw 3/6/1999 09:31'!veryDeepCopyWith: deepCopier	"Return self; this is NOT the way to launch new change sets!! Having this method here allows Change Sorters to be in parts bins"! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/23/2000 12:14'!wither	"The receiver is to be clobbered.  Clear it out.  2/7/96 sw"	self clear.	name _ nil! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 9/21/2000 15:29'!zapHistory 	"Much stronger than trimHistory, but it should still leave the changeSet in good shape.	Must not be done on revertable changeSets		ChangeSet allInstancesDo: [:cs | cs zapHistory]."	revertable ifTrue: [^ self].  "No can do"	changeRecords do: [:chgRecord | chgRecord zapHistory]! !!ChangeSet methodsFor: 'change logging' stamp: 'di 3/29/2000 13:10'!addClass: class 	"Include indication that a new class was created."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet addClass: class].	self atClass: class add: #new.	self atClass: class add: #change.	self addCoherency: class name! !!ChangeSet methodsFor: 'change logging' stamp: 'NS 1/19/2004 18:30'!changeClass: class from: oldClass	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifFalse: [^ self]. 	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet changeClass: class from: oldClass].	class isMeta 		ifFalse: [self atClass: class add: #change]	"normal"		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass				is not recorded, even though it was added.  A further change is				really just part of the original add."			ifFalse: [self atClass: class add: #change]].	self addCoherency: class name.	(self changeRecorderFor: class) notePriorDefinition: oldClass.	self noteClassStructure: oldClass! !!ChangeSet methodsFor: 'change logging' stamp: 'NS 4/12/2004 22:44'!event: anEvent	"Hook for SystemChangeNotifier"	(anEvent isRemoved and: [anEvent itemKind = SystemChangeNotifier classKind]) 		ifTrue: [self noteRemovalOf: anEvent item].	(anEvent isAdded and: [anEvent itemKind = SystemChangeNotifier classKind]) 		ifTrue: [self addClass: anEvent item].	(anEvent isModified and: [anEvent itemKind = SystemChangeNotifier classKind])		ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].	(anEvent isCommented and: [anEvent itemKind = SystemChangeNotifier classKind])		ifTrue: [self commentClass: anEvent item].	(anEvent isAdded and: [anEvent itemKind = SystemChangeNotifier methodKind])		ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].	(anEvent isModified and: [anEvent itemKind = SystemChangeNotifier methodKind])		ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].	(anEvent isRemoved and: [anEvent itemKind = SystemChangeNotifier methodKind])		ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].	(anEvent isRenamed and: [anEvent itemKind = SystemChangeNotifier classKind])		ifTrue: [self renameClass: anEvent item as: anEvent newName].	(anEvent isReorganized and: [anEvent itemKind = SystemChangeNotifier classKind])		ifTrue: [self reorganizeClass: anEvent item].	(anEvent isRecategorized and: [anEvent itemKind = SystemChangeNotifier methodKind])		ifTrue: [self reorganizeClass: anEvent itemClass].! !!ChangeSet methodsFor: 'change logging' stamp: 'di 3/29/2000 11:08'!noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet noteNewMethod: newMethod forClass: class selector: selector				priorMethod: methodOrNil].	(self changeRecorderFor: class)		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil! !!ChangeSet methodsFor: 'change logging' stamp: 'di 3/29/2000 12:29'!removeSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info	"Include indication that a method has been forgotten.	info is a pair of the source code pointer and message category	for the method that was removed."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet removeSelector: selector class: class				priorMethod: priorMethod lastMethodInfo: info].	(self changeRecorderFor: class)		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info! !!ChangeSet methodsFor: 'change logging' stamp: 'tk 6/8/2001 09:27'!renameClass: class as: newName 	"Include indication that a class has been renamed."	| recorder |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: class)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: class name.	self noteClassStructure: class.	recorder _ changeRecords at: class class name ifAbsent: [^ nil].	changeRecords at: (newName, ' class') put: recorder.	changeRecords removeKey: class class name.	recorder noteNewName: newName , ' class'! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 4/1/2000 09:25'!compileAll: newClass from: oldClass	"If I have changes for this class, recompile them"	(changeRecords at: newClass ifAbsent: [^ self])		compileAll: newClass from: oldClass! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:47'!invoke	"Do the first part of the invoke operation -- no particular hurry."	changeRecords do: [:changeRecord | changeRecord invokePhase1].	"Complete the invoke process -- this must be very simple."	"Replace method dicts for any method changes."	changeRecords do: [:changeRecord | changeRecord invokePhase2].	Behavior flushCache.! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 4/13/2000 12:47'!isolatedProject	"Return the isolated project for which I am the changeSet."	^ isolatedProject! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 13:59'!isolationSet: setOrNil	setOrNil == self		ifTrue: [isolationSet _ nil]  "Means this IS the isolation set"		ifFalse: [isolationSet _ setOrNil]! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:47'!revoke	"Do the first part of the revoke operation -- this must be very simple."	"Replace original method dicts if there are method changes."	changeRecords do: [:changeRecord | changeRecord revokePhase1].	Behavior flushCache.	"Complete the revoke process -- no particular hurry."	changeRecords do: [:changeRecord | changeRecord revokePhase2].! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/23/2000 12:00'!uninstall	self halt.! !!ChangeSet methodsFor: 'accessing' stamp: 'BJP 4/24/2001 00:23'!author	| author |	self assurePreambleExists.	author _ self preambleString lineNumber: 3.	author _ author copyFrom: 8 to: author size. "Strip the 'Author:' prefix. Ugly ugly."		^author withBlanksTrimmed.	! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!classRemoves	^ changeRecords keys select:		[:className | (changeRecords at: className) isClassRemoval]! !!ChangeSet methodsFor: 'accessing' stamp: 'ssa 9/3/2008 11:02'!editPostscript	"edit the receiver's postscript, in a separate window.  "	| deps found |	self assurePostscriptExists.	deps _ postscript dependents select:		[:m | m isKindOf: StandardSystemView].	deps size > 0 ifTrue:		[Smalltalk isMorphic			ifTrue:				[]			ifFalse:				[found _ deps detect: [:obj | (obj isKindOf: StandardSystemView) and: [ScheduledControllers scheduledControllers includes: obj controller]] ifNone: [nil].				found ifNotNil: [^ ScheduledControllers activateController: found controller]]..		self inform:'Caution -- there', (deps size isOrAreStringWith: 'other window'), 'already open on this postscript elsewhere'].	postscript openLabel: 'Postscript for ChangeSet named ', name! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:44'!hasPostscript	^ postscript notNil! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!methodChanges	| methodChangeDict changeTypes |	methodChangeDict _ Dictionary new.	changeRecords associationsDo:		[:assn |		changeTypes _ assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!ChangeSet methodsFor: 'accessing' stamp: 'di 3/29/2000 16:22'!methodInfoFromRemoval: classAndSelector	^ (self changeRecorderFor: classAndSelector first)		infoFromRemoval: classAndSelector last! !!ChangeSet methodsFor: 'accessing'!name	"The name of this changeSet.	 2/7/96 sw: If name is nil, we've got garbage.  Help to identify."	^ name == nil		ifTrue:			['<no name -- garbage?>']		ifFalse:			[name]! !!ChangeSet methodsFor: 'accessing'!name: anObject	name _ anObject! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 20:51'!postscriptHasDependents	^ postscript dependents size > 0! !!ChangeSet methodsFor: 'accessing'!printOn: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOn: aStream.	aStream nextPutAll: ' named ', self name! !!ChangeSet methodsFor: 'accessing' stamp: 'MPW 1/1/1901 22:02'!printOnStream: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOnStream: aStream.	aStream print: ' named ', self name! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:48'!removePostscript	postscript _ nil! !!ChangeSet methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!structures	^structures! !!ChangeSet methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!superclasses	^superclasses! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 10/1/2000 12:28'!belongsToAProject	Smalltalk at: #Project ifPresent:		[:projClass | projClass allProjects do:			[:proj | proj projectChangeSet == self ifTrue: [^ true]]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/10/2002 22:21'!containsMethodAtPosition: aFilePosition	"Answer whether the receiver contains the method logged at the given file position"	"class: aClassSymbol" "(need class parameter to speed up?)"  "<- dew 9/6/2001"	changeRecords values do:		[:classChangeRecord |		classChangeRecord methodChanges values do:			[:methodChangeRecord | | changeType |			changeType _ methodChangeRecord changeType.			((changeType == #add or: [changeType == #change]) and:				[methodChangeRecord currentMethod notNil and: [methodChangeRecord currentMethod filePosition = aFilePosition]])					ifTrue: [^ true]]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 11/13/2000 17:15'!correspondingProject	"If the receiver is the current change set for any project, answer it, else answer nil"	^Project allProjects 		detect: [ :proj |			proj projectChangeSet == self		]		ifNone: [nil]! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 10/19/2000 13:17'!isEmpty	"Answer whether the receiver contains any elements."		changeRecords ifNil: [^true].	^ changeRecords isEmpty ! !!ChangeSet methodsFor: 'testing' stamp: 'nk 7/2/2003 10:47'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified aSelector |	notClassified _ {'as yet unclassified' asSymbol. #all}.	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (aClass selectors includes:  (aSelector _ mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSet methodsFor: 'testing' stamp: 'sd 5/23/2003 14:24'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == self class current ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 9/27/2000 22:40'!projectsBelongedTo	"Answer a list of all the projects for which the receiver is the current change set"	^ Project allProjects select: [:proj | proj projectChangeSet == self]! !!ChangeSet methodsFor: 'converting' stamp: 'RAA 12/20/2000 16:02'!convertApril2000: varDict using: smartRefStrm	| cls info selector pair classChanges methodChanges methodRemoves classRemoves |	"These variables are automatically stored into the new instance:		('name' 'preamble' 'postscript' 'structures' 'superclasses' ).	This method is for additional changes.	It initializes the isolation variables, and then duplicates the logic fo		assimilateAllChangesFoundIn:."	revertable _ false.	isolationSet _ nil.	isolatedProject _ nil.	changeRecords _ Dictionary new.	classChanges _ varDict at: 'classChanges'.	classChanges keysDo:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[info _ classChanges at: className ifAbsent: [Set new].			info do: [:each | self atClass: cls add: each]]].	methodChanges _ varDict at: 'methodChanges'.	methodRemoves _ varDict at: 'methodRemoves'.	methodChanges keysDo:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[info _ methodChanges at: className ifAbsent: [Dictionary new].			info associationsDo:				[:assoc | selector _ assoc key.				(assoc value == #remove or: [assoc value == #addedThenRemoved])					ifTrue:						[assoc value == #addedThenRemoved							ifTrue: [self atSelector: selector class: cls put: #add].						pair _ methodRemoves at: {cls name. selector} ifAbsent: [nil] .						self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]					ifFalse: 						[self atSelector: selector class: cls put: assoc value]]]].	classRemoves _ varDict at: 'classRemoves'.	classRemoves do:		[:className | self noteRemovalOf: className].! !!ChangeSet methodsFor: 'converting' stamp: 'RAA 12/20/2000 17:57'!convertToCurrentVersion: varDict refStream: smartRefStrm		"major change - 4/4/2000"	varDict at: 'classChanges' ifPresent: [ :x | 		self convertApril2000: varDict using: smartRefStrm	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 12/28/2000 18:08'!adoptSelector: aSelector forClass: aClass	"Adopt the given selector/class combination as a change in the receiver"	self noteNewMethod: (aClass methodDictionary at: aSelector)			forClass: aClass selector: aSelector priorMethod: nil! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/29/2000 11:01'!atSelector: selector class: class put: changeType	(selector == #DoIt or: [selector == #DoItIn:]) ifTrue: [^ self].	(self changeRecorderFor: class) atSelector: selector put: changeType.! !!ChangeSet methodsFor: 'method changes' stamp: 'sd 4/16/2003 09:15'!browseMessagesWithPriorVersions	"Open a message list browser on the new and changed methods in the receiver which have at least one prior version.  6/28/96 sw"	| aList |	aList _ self 		messageListForChangesWhich: [ :aClass :aSelector |			(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1		]		ifNone: [^self inform: 'None!!'].	self systemNavigation 		browseMessageList: aList 		name: self name, ' methods that have prior versions'! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 6/26/2001 12:15'!changedMessageList	"Used by a message set browser to access the list view information."	| messageList classNameInFull classNameInParts |	messageList _ OrderedCollection new.	changeRecords associationsDo: [:clAssoc |		classNameInFull _ clAssoc key asString.		classNameInParts _ classNameInFull findTokens: ' '.		(clAssoc value allChangeTypes includes: #comment) ifTrue:			[messageList add:				(MethodReference new					setClassSymbol: classNameInParts first asSymbol					classIsMeta: false 					methodSymbol: #Comment 					stringVersion: classNameInFull, ' Comment')].		clAssoc value methodChangeTypes associationsDo: [:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add:					(MethodReference new						setClassSymbol: classNameInParts first asSymbol						classIsMeta: classNameInParts size > 1 						methodSymbol: mAssoc key 						stringVersion: classNameInFull, ' ' , mAssoc key)]]].	^ messageList asSortedArray! !!ChangeSet methodsFor: 'method changes' stamp: 'tk 6/7/1999 18:57'!changedMessageListAugmented	"Even added classes have all messages in changedMessageList."	^ self changedMessageList asArray! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 4/19/2001 19:45'!hasAnyChangeForSelector: aSelector	"Answer whether the receiver has any change under the given selector, whether it be add, change, or remove, for any class"	changeRecords do:		[:aRecord | (aRecord changedSelectors  includes: aSelector)			ifTrue:	[^ true]].	^ false! !!ChangeSet methodsFor: 'method changes' stamp: 'RAA 5/28/2001 12:05'!messageListForChangesWhich: aBlock ifNone: ifEmptyBlock	| answer |	answer _ self changedMessageListAugmented select: [ :each |		aBlock value: each actualClass value: each methodSymbol	].	answer isEmpty ifTrue: [^ifEmptyBlock value].	^answer! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!methodChangesAtClass: className	"Return an old-style dictionary of method change types."	^(changeRecords at: className ifAbsent: [^ Dictionary new])		methodChangeTypes! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/4/2000 11:14'!removeSelectorChanges: selector class: class 	"Remove all memory of changes associated with the argument, selector, in 	this class."	| chgRecord |	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])		removeSelector: selector.	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !!ChangeSet methodsFor: 'method changes' stamp: 'SqR 6/13/2000 19:16'!selectorsInClass: aClassName	"Used by a ChangeSorter to access the list methods."	^ (changeRecords at: aClassName ifAbsent: [^#()]) changedSelectors! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!changedClassNames	"Answer a OrderedCollection of the names of changed or edited classes.	DOES include removed classes.  Sort alphabetically."	^ changeRecords keysSortedSafely ! !!ChangeSet methodsFor: 'class changes' stamp: 'di 3/23/2000 08:12'!changedClasses	"Answer an OrderedCollection of changed or edited classes.	Does not include removed classes.  Sort alphabetically by name."	"Much faster to sort names first, then convert back to classes.  Because metaclasses reconstruct their name at every comparison in the sorted collection.	8/91 sw chgd to filter out non-existent classes (triggered by problems with class-renames"	^ self changedClassNames		collect: [:className | Smalltalk classNamed: className]		thenSelect: [:aClass | aClass notNil]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!classChangeAt: className	"Return what we know about class changes to this class."	^ (changeRecords at: className ifAbsent: [^ Set new])		allChangeTypes! !!ChangeSet methodsFor: 'class changes' stamp: 'NS 1/26/2004 09:46'!commentClass: class 	"Include indication that a class comment has been changed."	class wantsChangeSetLogging ifFalse: [^ self].	self atClass: class add: #comment! !!ChangeSet methodsFor: 'class changes' stamp: 'nk 6/26/2002 12:30'!containsClass: aClass	^ self changedClasses includes: aClass! !!ChangeSet methodsFor: 'class changes' stamp: 'RAA 6/16/2000 15:13'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |	newDef _ class definition.	oldDef _ (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm _ ReadStream on: oldDef.	newStrm _ ReadStream on: newDef.	outStrm _ WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.	outStrm 		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 		nextPutAll: 'instanceVariableNames:'.	newStrm peek = $: ifTrue: [newStrm next].	"may or may not be there, but already written"	outStrm		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars _ (oldStrm upTo: $') findTokens: Character separators.	newVars _ (newStrm upTo: $') findTokens: Character separators.	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars _ (oldStrm upTo: $') findTokens: Character separators.		newVars _ (newStrm upTo: $') findTokens: Character separators.		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!ChangeSet methodsFor: 'class changes' stamp: 'tk 6/9/1999 19:54'!noteClassForgotten: className	"Remove from structures if class is not a superclass of some other one we are remembering"	structures ifNil: [^ self].	Smalltalk at: className ifPresent: [:cls |		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [			^ self]]].  "No delete"	structures removeKey: className ifAbsent: [].! !!ChangeSet methodsFor: 'class changes' stamp: 'tk 6/9/1999 21:51'!noteClassStructure: aClass	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."	| clsName |	aClass ifNil: [^ self].	structures ifNil: [structures _ Dictionary new.				superclasses _ Dictionary new].	clsName _ (aClass name asLowercase beginsWith: 'anobsolete') 		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]		ifFalse: [aClass name].	(structures includesKey: clsName) ifFalse: [		structures at: clsName put: 			((Array with: aClass classVersion), (aClass allInstVarNames)).		superclasses at: clsName put: aClass superclass name].	"up the superclass chain"	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].! !!ChangeSet methodsFor: 'class changes' stamp: 'NS 1/19/2004 17:49'!noteRemovalOf: class	"The class is about to be removed from the system.	Adjust the receiver to reflect that fact."	class wantsChangeSetLogging ifFalse: [^ self].	(self changeRecorderFor: class)		noteChangeType: #remove fromClass: class.	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSet methodsFor: 'class changes'!reorganizeClass: class 	"Include indication that a class was reorganized."	self atClass: class add: #reorganize! !!ChangeSet methodsFor: 'class changes' stamp: 'di 5/16/2000 09:03'!trimHistory 	"Drop non-essential history:  methods added and then removed, as well as rename and reorganization of newly-added classes."	changeRecords do: [:chgRecord | chgRecord trimHistory]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 09:37'!absorbClass: className from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.	*** Classes renamed in otherChangeSet may have problems"	| cls |	(self changeRecorderFor: className)			assimilateAllChangesIn: (otherChangeSet changeRecorderFor: className).	(cls _ Smalltalk classNamed: className) ifNotNil:		[self absorbStructureOfClass: cls from: otherChangeSet].! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 3/23/2000 11:52'!absorbMethod: selector class: aClass from: aChangeSet	"Absorb into the receiver all the changes for the method in the class in the other change set."	| info |	info _ aChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	self atSelector: selector class: aClass put: (info at: selector).! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 1/30/2001 15:41'!absorbStructureOfClass: aClass from: otherChangeSet	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSet structures ifNil: [^ self].	(otherChangeSet structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil:		[structures _ Dictionary new.		superclasses _ Dictionary new].	sup _ aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [self flag: #noteToDan.  "sw 1/30/2001 13:57 emergency workaround -- a case arose where the otherChangeSet's structures did not have the key, and it gummed up the works."				(otherChangeSet structures includesKey: sup) ifTrue:					[structures at: sup put: (otherChangeSet structures at: sup)].				next _ otherChangeSet superclasses at: sup.				superclasses at: sup put: next.				(sup _ next) = 'nil']	] whileFalse.! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:21'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now."	otherChangeSet changedClassNames do:		[:className | self absorbClass: className from: otherChangeSet]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/8/2000 23:16'!editPreamble	"edit the receiver's preamble, in a separate window.  "	self assurePreambleExists.	preamble openLabel: 'Preamble for ChangeSet named ', name! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:49'!expungeEmptyClassChangeEntries	changeRecords keysAndValuesRemove:		[:className :classRecord | classRecord hasNoChanges]! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 4/19/2000 16:17'!expungeUniclasses	changeRecords keysAndValuesRemove:		[:className :classRecord | className endsWithDigit]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:40'!forgetAllChangesFoundIn: otherChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner."	otherChangeSet == self ifTrue: [^ self].	otherChangeSet changedClassNames do:		[:className | self forgetChangesForClass: className in: otherChangeSet].	self expungeEmptyClassChangeEntries."  Old code...	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	aChangeSet classRemoves do:		[:className | (recorder _ changeRecords at: className ifAbsent: [])			ifNotNil: [recorder forgetClassRemoval]].	self expungeEmptyClassChangeEntries"! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:04'!forgetChangesForClass: className in: otherChangeSet	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	(self changeRecorderFor: className)			forgetChangesIn: (otherChangeSet changeRecorderFor: className).	self noteClassForgotten: className! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:27'!hasPreamble	^ preamble notNil! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 3/30/2002 09:13'!methodsWithAnyInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one, even historically"	| slips method aTimeStamp |	slips _ Set new.	self changedClasses do: [:aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].				method ifNotNil: [					(aClass changeRecordsAt: mAssoc key) do: [ :chg |						aTimeStamp _ chg stamp.						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 7/2/2003 10:47'!methodsWithInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one"	| slips method aTimeStamp |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[((aTimeStamp _ Utilities timeStampForMethod: method) notNil and:							[(aTimeStamp beginsWith: myInits) not])								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'"! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 7/2/2003 10:47'!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass selectors includes:  mAssoc key) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassAndMetaClassChanges: class	"Remove all memory of changes associated with this class and its metaclass.  7/18/96 sw"	changeRecords removeKey: class name ifAbsent: [].	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	changeRecords removeKey: cname ifAbsent: [].	self noteClassForgotten: cname.! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:32'!removePreamble	preamble _ nil! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 6/8/2001 20:28'!askAddedInstVars: classList	| pairList pairClasses index pls newStruct oldStruct |	"Ask the author whether these newly added inst vars need to be non-nil"	pairList _ OrderedCollection new.	pairClasses _ OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls |		newStruct _ (cls allInstVarNames).		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		newStruct do: [:instVarName |			(oldStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index _ PopUpMenu withCaption: 'These instance variables were added.When an old project comes in, newly added instance variables will have the value nil.Click on items to remove them from the list.Click on any for which nil is an OK value.'		chooseFrom: pairList, #('all of these need a non-nil value'						'all of these are OK with a nil value').	(index <= (pls _ pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 6/8/2001 20:29'!askRemovedInstVars: classList	| pairList pairClasses index pls newStruct oldStruct |	"Ask the author whether these newly removed inst vars need to have their info saved"	pairList _ OrderedCollection new.	pairClasses _ OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls |		newStruct _ (cls allInstVarNames).		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		oldStruct do: [:instVarName |			(newStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index _ PopUpMenu withCaption: 'These instance variables were removed.When an old project comes in, instance variables that have been removed will lose their contents.Click on items to remove them from the list.Click on any whose value is unimportant and need not be saved.'		chooseFrom: pairList, #('all of these need a conversion method'						'all of these have old values that can be erased').	(index <= (pls _ pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 6/8/2001 11:12'!askRenames: renamed addTo: msgSet using: smart	| list rec ans oldStruct newStruct |	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."	list _ OrderedCollection new.	renamed do: [:cls |		rec _ changeRecords at: cls name.		rec priorName ifNotNil: [			ans _ PopUpMenu withCaption: 'You renamed class ', rec priorName, 				' to be ', rec thisName,				'.\Could an instance of ', rec priorName, 				' be in a project on someone''s disk?'			chooseFrom: #('Yes, write code to convert those instances'				'No, no instances are in projects').			ans = 1 ifTrue: [					oldStruct _ structures at: rec priorName ifAbsent: [nil].					newStruct _ (Array with: cls classVersion), (cls allInstVarNames).					oldStruct ifNotNil: [						smart writeConversionMethodIn: cls fromInstVars: oldStruct 								to: newStruct renamedFrom: rec priorName.						smart writeClassRename: cls name was: rec priorName.						list add: cls name, ' convertToCurrentVersion:refStream:']]				ifFalse: [structures removeKey: rec priorName ifAbsent: []]]].	list isEmpty ifTrue: [^ msgSet].	msgSet messageList ifNil: [msgSet initializeMessageList: list]		ifNotNil: [list do: [:item | msgSet addItem: item]].	^ msgSet! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/11/1998 16:13'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 4/7/1999 17:45'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents isEmptyOrNil])		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:15'!checkForAlienAuthorship	"Check to see if there are any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials _ Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	(aList _ self methodsWithInitialsOtherThan: initials) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"have authoring stamps which start with "', initials, '"']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" whose authoring stamps do not start with "', initials, '"']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForAnyAlienAuthorship	"Check to see if there are any versions of any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials _ Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	(aList _ self methodsWithAnyInitialsOtherThan: initials) size > 0		ifFalse: [^ self inform: 'All versions of all methods in "', self name, '"have authoring stamps which start with "', initials, '"']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" with any authoring stamps not starting with "', initials, '"']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:51'!checkForConversionMethods	"See if any conversion methods are needed"	| oldStruct newStruct tell choice list needsel renamed rec nn |	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"	structures ifNil: [^ self].	list _ OrderedCollection new.	renamed _ OrderedCollection new.	self changedClasses do: [:class |		need _ (self atClass: class includes: #new) not.		need ifTrue: ["Renamed classes."			(self atClass: class includes: #rename) ifTrue: [				rec _ changeRecords at: class name.				rec priorName ifNotNil: [					(structures includesKey: rec priorName) ifTrue: [						renamed add: class.  need _ false]]]].		need ifTrue: [need _ (self atClass: class includes: #change)].		need ifTrue: [oldStruct _ structures at: class name 									ifAbsent: [need _ false.  #()]].		need ifTrue: [			newStruct _ (Array with: class classVersion), (class allInstVarNames).			need _ (oldStruct ~= newStruct)].		need ifTrue: [sel _ #convertToCurrentVersion:refStream:.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				list add: class]].		].	list isEmpty & renamed isEmpty ifTrue: [^ self].	"Ask user if want to do this"	tell _ 'If there might be instances of ', (list asArray, renamed asArray) printString,		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'			withCRs,		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.	choice _ (PopUpMenu labels: 'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.') startUpWithCaption: tell. 	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"			list do: [:cls | structures removeKey: cls name ifAbsent: []].			renamed do: [:cls | 				nn _ (changeRecords at: cls name) priorName.				structures removeKey: nn ifAbsent: []]].	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"	self error:'No support for writing conversion methods in this stripped image'! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/26/2000 10:06'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips method |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized,"	| aList |	(aList _ self methodsWithoutClassifications) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"are categorized.']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" which have not been categorized']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 7/19/2002 20:21'!checkForUncommentedClasses	"Check to see if any classes involved in this change set do not have class comments.  Open up a browser showing all such classes."	| aList |	aList _ self changedClasses		select:			[:aClass | aClass theNonMetaClass organization classComment isEmptyOrNil]		thenCollect:			[:aClass  | aClass theNonMetaClass name].	aList size > 0		ifFalse:			[^ self inform: 'All classes involved in this change set have class comments']		ifTrue:			[ClassListBrowser new initForClassesNamed: aList asSet asSortedArray title: 'Classes in Change Set ', self name, ': classes that lack class comments']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForUncommentedMethods	| aList |	"Check to see if there are any methods in the receiver that have no comments, and open a browser on all found"	(aList _ self methodsWithoutComments) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '" have comments']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" that lack comments']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/29/2003 20:19'!checkForUnsentMessages	"Check the change set for unsent messages, and if any are found, open 	up a message-list browser on them"	| nameLine allChangedSelectors augList unsent |	nameLine _ '"' , self name , '"'.	allChangedSelectors _ Set new.	(augList _ self changedMessageListAugmented)		do: [:each | each isValid				ifTrue: [allChangedSelectors add: each methodSymbol]].	unsent _ self systemNavigation allUnSentMessagesIn: allChangedSelectors.	unsent size = 0		ifTrue: [^ self inform: 'There are no unsent messages in change set' , nameLine].	self systemNavigation		browseMessageList: (augList				select: [:each | unsent includes: each methodSymbol])		name: 'Unsent messages in ' , nameLine! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'FBS 1/6/2004 16:59'!chooseSubjectPrefixForEmail	| subjectIndex |	subjectIndex _		(PopUpMenu labels: 'Bug fix [FIX]\Enhancement [ENH]\Goodie [GOODIE]\Test suite [TEST]\None of the above (will not be archived)' withCRs)			startUpWithCaption: 'What type of change set\are you submitting to the list?' withCRs.	^ #('[CS] ' '[FIX] ' '[ENH] ' '[GOODIE] ' '[TEST] ' '[CS] ') at: subjectIndex + 1! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 10/15/2003 09:55'!defaultChangeSetDirectory	^self class defaultChangeSetDirectory! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 1/4/2004 17:07'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| file slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: 'cs']				ifFalse: [(self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'cs') asFileName].	(Preferences warningForMacOSFileNameLength			and: [nameToUse size > 31])		ifTrue: [nameToUse := FillInTheBlank						request: (nameToUse , '\has ' , nameToUse size asString , ' letters - too long for Mac OS.\Suggested replacement is:') withCRs						initialAnswer: (nameToUse contractTo: 30).			nameToUse = ''				ifTrue: [^ self]].	Cursor write		showWhile: [[file := self defaultChangeSetDirectory newFileNamed: nameToUse.			file header; timeStamp.			self fileOutPreambleOn: file.			self fileOutOn: file.			self fileOutPostscriptOn: file.			file trailer]				ensure: [file close]].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 09:35'!fileOutChangesFor: class on: stream 	"Write out all the method changes for this class."	| changes |	changes _ Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | (mAssoc value = #remove or: [mAssoc value = #addedThenRemoved])			ifFalse: [changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 5/23/2001 13:29'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].	classList _ ChangeSet superclassOrder: self changedClasses asOrderedCollection.	"First put out rename, max classDef and comment changes."	classList do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	classList do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	classList reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 5/8/2000 20:47'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict changeType classRecord currentDef |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	dict keysSortedSafely do:		[:key | changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((classRecord includesChangeType: #change)		and: [(currentDef _ class definition) ~= (self fatDefForClass: class)]) ifTrue:		[stream command: 'H3'; nextChunkPut: currentDef; cr; command: '/H3'].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 13:35'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	aString _ self postscriptString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 14:58'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	aString _ self preambleString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!lookForSlips	"Scan the receiver for changes that the user may regard as slips to be remedied"	| slips nameLine msg |	nameLine _ '"', self name, '"'.	(slips _ self checkForSlips) size == 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg _ slips size == 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(PopUpMenu withCaption: msg chooseFrom: 'Ignore\Browse slips') = 2		ifTrue: [self systemNavigation  browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 5/7/1998 12:16'!postscriptString	"Answer the string representing the postscript.  "	^ postscript == nil		ifTrue:			[postscript]		ifFalse:			[postscript contents asString]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!postscriptString: aString	"Establish aString as the new contents of the postscript.  "	postscript _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 5/7/1998 12:08'!preambleString	"Answer the string representing the preamble"	^ preamble == nil		ifTrue:			[preamble]		ifFalse:			[preamble contents asString]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 7/2/2003 10:47'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"ChangeSet current preambleTemplate"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 3/30/2001 13:47'!setPreambleToSay: aString	"Make aString become the preamble of this change set"	preamble _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:33'!summaryString	"Answer the string summarizing this changeSet"	^ self summaryStringDelta: 0"To summarize all recent changeSets on a file...(FileStream newFileNamed: 'Summaries.txt') nextPutAll:	(String streamContents:		[:s | (ChangeSorter changeSetsNamedSuchThat:			[:name | name first isDigit and: [name initialIntegerOrNil >= 948]])			 do: [:cs | s nextPutAll: cs summaryString; cr]]);		closeTo list all changeSets with a certain string in the preamble...	(FileStream newFileNamed: 'MyUpdates.txt') nextPutAll:		(String streamContents:			[:s | ChangeSorter gatherChangeSetRevertables do:				[:cs | (cs preambleString notNil					and: [cs preambleString includesSubString: 'Author Name'])				 	ifTrue: [s nextPutAll: cs summaryString; cr]]]);		close"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:27'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"	| ps s2 date author line intName |	^ String streamContents:		[:s |		intName _ self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date _ s2 upTo: Character cr.			s2 match: 'Author:'; skipSeparators.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 1/16/2004 21:31'!verboseFileOut	"File out the receiver, to a file whose name is a function of the change-set name and either of the date & time or chosen to have a unique numeric tag, depending on the preference 'changeSetVersionNumbers'"	ChangeSet current fileOut.	Transcript cr; show: 'Changes filed out ', Date dateAndTimeNow printString! !!ChangeSet methodsFor: 'private' stamp: 'di 3/23/2000 08:37'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	(self changeRecorderFor: className)		checkCoherence."	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]"! !!ChangeSet methodsFor: 'private' stamp: 'di 3/28/2000 14:40'!atClass: class add: changeType	(self changeRecorderFor: class)		noteChangeType: changeType fromClass: class! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atClass: class includes: changeType	^(changeRecords at: class name ifAbsent: [^false])		includesChangeType: changeType! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atSelector: selector class: class	^ (changeRecords at: class name ifAbsent: [^ #none])		atSelector: selector ifAbsent: [^ #none]! !!ChangeSet methodsFor: 'private' stamp: 'di 3/29/2000 20:46'!changeRecorderFor: class	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname			ifAbsent: [^ changeRecords at: cname							put: (ClassChangeRecord new initFor: cname revertable: revertable)]! !!ChangeSet methodsFor: 'private' stamp: 'ssa 9/3/2008 10:28'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'.			] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3'.				].	].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!oldNameFor: class	^ (changeRecords at: class name) priorName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChangeSet class	instanceVariableNames: 'current'!!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 5/22/2003 19:59'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	current isEmpty ifTrue: [^ self inform: 'There are no changed messagesin the current change set.'].	ChangedMessageSet openFor: current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 5/22/2003 21:53'!current	"return the current changeset"	^ current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 5/22/2003 22:24'!currentChangeSetString	"ChangeSet current currentChangeSetString"	^ 'Current Change Set: ', self current name! !!ChangeSet class methodsFor: 'current changeset' stamp: 'NS 1/16/2004 14:49'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: current.	current isolationSet: nil.	current _ aChangeSet.	SystemChangeNotifier uniqueInstance notify: aChangeSet ofAllSystemChangesUsing: #event:.	Smalltalk currentProjectDo:		[:proj |		proj setChangeSet: aChangeSet.		aChangeSet isolationSet: proj isolationSet]! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 5/22/2003 22:18'!noChanges 	"Initialize the system ChangeSet."	current initialize! !!ChangeSet class methodsFor: 'defaults' stamp: 'nk 7/18/2004 16:13'!defaultChangeSetDirectory	"Answer the directory in which to store ChangeSets. 	Answer the default directory if the preferred directory doesn't exist."	| dir directoryName |	directoryName := Preferences				parameterAt: #defaultChangeSetDirectoryName				ifAbsentPut: [''].	dir := directoryName isEmptyOrNil		ifTrue: [ FileDirectory default ]		ifFalse: [ FileDirectory default directoryNamed: directoryName ].	dir exists		ifTrue: [^ dir].	^ FileDirectory default! !!ChangeSet class methodsFor: 'defaults' stamp: 'nk 3/24/2004 15:52'!defaultChangeSetDirectory: dirOrName 	"Set the Preference for storing change sets to the given directory or name (possibly relative).	Rewrite directory names below the default directory as relative names.	If dirOrName is an empty string, use the default directory."	"ChangeSet defaultChangeSetDirectory: 'changeSets'"	| dirName defaultFullName |	dirName := dirOrName isString				ifTrue: [FileDirectory default fullNameFor: dirOrName]				ifFalse: [dirOrName fullName].	defaultFullName := FileDirectory default fullName.	dirName = defaultFullName		ifTrue: [dirName := '']		ifFalse: [(dirName beginsWith: defaultFullName , FileDirectory slash)				ifTrue: [dirName := dirName copyFrom: defaultFullName size + 2 to: dirName size]].	Preferences setParameter: #defaultChangeSetDirectoryName to: dirName! !!ChangeSet class methodsFor: 'defaults' stamp: 'dgd 9/6/2003 19:56'!defaultName	^ self uniqueNameLike: 'Unnamed' translated! !!ChangeSet class methodsFor: 'defaults' stamp: 'BG 8/18/2004 15:19'!promptForDefaultChangeSetDirectoryIfNecessary	"Check the Preference (if any), and prompt the user to change it if necessary.	The default if the Preference is unset is the current directory.	Answer the directory."	"ChangeSet promptForDefaultChangeSetDirectoryIfNecessary"	| choice directoryName dir |	directoryName := Preferences				parameterAt: #defaultChangeSetDirectoryName				ifAbsentPut: [''].	[dir := FileDirectory default directoryNamed: directoryName.	dir exists]		whileFalse: [choice := PopUpMenu withCaption: 			('The preferred change set directory (''{1}'') does not exist.Create it or use the default directory ({2})?' translated format: { directoryName. FileDirectory default pathName })	chooseFrom: (#('Create directory' 'Use default directory and forget preference' 'Choose another directory' ) collect: [ :ea | ea translated ]).			choice = 1				ifTrue: [dir assureExistence ].			choice = 3				ifTrue: [dir := FileList modalFolderSelector.					directoryName := dir					ifNil: [ '' ]						ifNotNil: [dir pathName ]]].		self defaultChangeSetDirectory: directoryName.		^dir! !!ChangeSet class methodsFor: 'defaults' stamp: 'di 4/5/2001 21:31'!uniqueNameLike: aString	| try |	1 to: 999999 do:		[:i | try _ aString , i printString.		(ChangeSorter changeSetNamed: try) ifNil: [^ try]]! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'SqR 11/14/2000 11:36'!doWeFileOut: aClass given: aSet cache: cache	| aClassAllSuperclasses aClassSoleInstanceAllSuperclasses |	aClassAllSuperclasses _ cache at: aClass		ifAbsent: [cache at: aClass put: aClass allSuperclasses asArray].	(aSet includesAnyOf: aClassAllSuperclasses) ifTrue: [^false].	aClass isMeta ifFalse: [^true].	(aSet includes: aClass soleInstance) ifTrue: [^false].	aClassSoleInstanceAllSuperclasses _ cache at: aClass soleInstance		ifAbsent: [cache at: aClass soleInstance put: aClass soleInstance allSuperclasses asArray].	(aSet includesAnyOf: aClassSoleInstanceAllSuperclasses) ifTrue: [^false].	^true! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'SqR 11/14/2000 11:37'!superclassOrder: classes	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections.	SqR 4/12/2000 22:04"	| all list aClass inclusionSet aClassIndex cache |	list _ classes copy. "list is indexable"	inclusionSet _ list asSet. cache _ Dictionary new.	all _ OrderedCollection new: list size.	list size timesRepeat:		[			aClassIndex _ list findFirst: [:one | one isNil not and: 				[self doWeFileOut: one given: inclusionSet cache: cache]].			aClass _ list at: aClassIndex.			all addLast: aClass.			inclusionSet remove: aClass.			list at: aClassIndex put: nil		].	^all! !!ChangeSet class methodsFor: 'instance creation' stamp: 'di 4/6/2001 09:43'!basicNewNamed: aName	^ (self basicNew name: aName) initialize! !!ChangeSet class methodsFor: 'instance creation' stamp: 'di 4/6/2001 10:02'!new	"All current changeSets must be registered in the AllChangeSets collection.	Due to a quirk of history, this is maintained as class variable of ChangeSorter."	^ ChangeSorter basicNewChangeSet: ChangeSet defaultName! !ChangeSorter subclass: #ChangeSetBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSetBrowser commentStamp: '<historical>' prior: 0!A tool allowing you to browse the methods of a single change set.!!ChangeSetBrowser methodsFor: 'initialization' stamp: 'BG 10/28/2003 20:47'!addModelItemsToWindowMenu: aMenu	"Add model-related items to the given window menu"	| oldTarget |	oldTarget _ aMenu defaultTarget.	aMenu defaultTarget: self.	aMenu addLine.	aMenu add: 'rename change set' action: #rename.	aMenu add: 'make changes go to me' action: #newCurrent.	aMenu addLine.	aMenu add: 'file out' action: #fileOut.	aMenu add: 'browse methods' action: #browseChangeSet.	aMenu addLine.	myChangeSet hasPreamble		ifTrue:			[aMenu add: 'edit preamble' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse:			[aMenu add: 'add preamble' action: #addPreamble].	myChangeSet hasPostscript		ifTrue:			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse:			[aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.		aMenu add: 'destroy change set' action: #remove.	aMenu addLine.		aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	aMenu defaultTarget: oldTarget.	^ aMenu! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 3/14/2001 10:03'!wantsAnnotationPane	"This kind of browser always wants annotation panes, so answer true"	^ true! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 3/9/2001 15:02'!wantsOptionalButtons	"Sure, why not?"	^ true! !!ChangeSetBrowser methodsFor: 'menu' stamp: 'sw 3/12/2001 14:07'!offerUnshiftedChangeSetMenu	"The user chose 'more' from the shifted window menu; go back to the regular window menu"	self containingWindow ifNotNil: [self containingWindow offerWindowMenu] ! !!ChangeSetBrowser methodsFor: 'menu' stamp: 'BG 10/28/2003 20:47'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	aMenu add: 'check for uncommented classes' action: #checkForUncommentedClasses.	aMenu balloonTextForLastItem:'Check for classes with code in this changeset which lack class comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'.		aMenu add: 'check for any other authors' action: #checkForAnyAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods any of whose previous authoring stamps do not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'expunge uniclasses' action: #expungeUniclasses.	aMenu balloonTextForLastItem:'Remove from the change set all memory of uniclasses, e.g. classes added on behalf of etoys, fabrik, etc., whose classnames end with a digit.'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !ElementCategory subclass: #ChangeSetCategory	instanceVariableNames: 'membershipSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSetCategory commentStamp: '<historical>' prior: 0!A ChangeSetCategory represents a list of change sets to be shown in a ChangeSorter.  It computes whether a given change set is in the list by sending its membershipSelector to ChangeSorter (i.e. the class object) with the change set as message argument.!!ChangeSetCategory methodsFor: 'initialization' stamp: 'sw 3/30/2001 12:35'!membershipSelector: aSelector	"Set the membershipSelector"	membershipSelector _ aSelector! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/11/2001 16:11'!acceptsManualAdditions	"Answer whether the user is allowed manually to manipulate the contents of the change-set-category."	^ false! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 3/30/2001 14:39'!changeSetList	"Answer the list of change-set names in the category"	| aChangeSet |	self reconstituteList.	keysInOrder size == 0 ifTrue:		["don't tolerate emptiness, because ChangeSorters gag when they have no change-set selected"		aChangeSet _ ChangeSorter assuredChangeSetNamed: 'New Changes'.		self elementAt: aChangeSet name put: aChangeSet].	^ keysInOrder reversed! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/5/2001 17:26'!hasChangeForClassName: aClassName selector: aSelector otherThanIn: excludedChangeSet	"Answer whether any change set in this category, other than the excluded one, has a change marked for the given class and selector"	self elementsInOrder do:		[:aChangeSet |			(aChangeSet ~~ excludedChangeSet and:				[((aChangeSet methodChangesAtClass: aClassName) includesKey: aSelector)]) ifTrue:	[^ true]].	^ false! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 3/30/2001 14:04'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangeSorter perform: membershipSelector with: aChangeSet! !!ChangeSetCategory methodsFor: 'services' stamp: 'sd 1/16/2004 21:37'!fileOutAllChangeSets	"File out all the nonempty change sets in the current category, suppressing the checks for slips that might otherwise ensue.  Obtain user confirmation before undertaking this possibly prodigious task."	| aList |	aList _ self elementsInOrder select:		[:aChangeSet  | aChangeSet isEmpty not].	aList size == 0 ifTrue: [^ self inform: 'sorry, all the change sets in this category are empty'].	(self confirm: 'This will result in filing out ', aList size printString, ' change set(s)Are you certain you want to do this?') ifFalse: [^ self].	Preferences setFlag: #checkForSlips toValue: false during: 		[ChangeSorter fileOutChangeSetsNamed: (aList collect: [:m | m name]) asSortedArray]! !!ChangeSetCategory methodsFor: 'services' stamp: 'BG 10/28/2003 20:38'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet _  ChangeSorter assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet setPreambleToSay: '"Change Set:		AggregateCreated at ', Time now printString, ' on ', Date today printString, ' by combining all the changes in all the change sets in the category ', categoryName printString, '"'.	(self elementsInOrder copyWithout: aggChangeSet) do:		[:aChangeSet  | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'sd 5/23/2003 14:25'!defaultChangeSetToShow	"Answer the name of a change-set to show"	^ ChangeSet current! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'di 4/6/2001 10:37'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers _ ChangeSorter allChangeSets select:		[:aChangeSet | ChangeSorter perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !ChangeSetCategory subclass: #ChangeSetCategoryWithParameters	instanceVariableNames: 'parameters'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2002 12:34'!acceptsManualAdditions	"Answer whether the user is allowed manually to manipulate the contents of the change-set-category."	^ true! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2002 12:43'!addChangeSet: aChangeSet	self inform: 'sorry, you can''t do that'! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2002 12:08'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangeSorter perform: membershipSelector withArguments: { aChangeSet } , parameters! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2002 12:04'!parameters: anArray	parameters _ anArray! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2002 12:16'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers _ ChangeSorter allChangeSets select:		[:aChangeSet | ChangeSorter perform: membershipSelector withArguments: { aChangeSet }, parameters].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet]! !CodeHolder subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList changeSetCategory'	classVariableNames: 'AllChangeSets ChangeSetCategories ChangeSetNamesInRelease PreviousSet RecentUpdateMarker'	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSorter commentStamp: '<historical>' prior: 0!I display a ChangeSet.  Two of me are in a DualChangeSorter.!!ChangeSorter methodsFor: 'creation' stamp: 'BG 11/26/2003 14:18'!open	"ChangeSorterPluggable new open"	| topView |	topView _ StandardSystemView new.	topView model: self.	myChangeSet ifNil: [self myChangeSet: ChangeSet current]. 	topView label: self labelString.	topView borderWidth: 1; minimumSize: 360@360.	self openView: topView offsetBy: 0@0.	topView controller open.! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 2/26/2001 12:00'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView cngSetListView basePane annoPane annoHeight |	contents _ ''.	annoHeight _ 20.	self addDependent: topView. "so it will get changed: #relabel"	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:shifted:		keystroke: #changeSetListKey:from:.	cngSetListView window: ((0@0 extent: 180@100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classListMenu:shifted:		keystroke: #classListKey:from:.	classView window: ((0@0 extent: 180@100) translateBy: offset).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView menuTitleSelector: #messageListSelectorTitle.	messageView window: ((0@0 extent: 360@100) translateBy: offset).	topView addSubView: messageView below: cngSetListView.	 self wantsAnnotationPane		ifFalse:			[basePane _ messageView]		ifTrue:			[annoPane _ PluggableTextView on: self				text: #annotation				accept: nil				readSelection: nil				menu: nil.			annoPane window: ((0@0 extent: 360@annoHeight) translateBy: offset).			topView addSubView: annoPane below: messageView.			basePane _ annoPane].	codeView _ PluggableTextView on: self 		text: #contents		accept: #contents:notifying:		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	codeView window: ((0 @ 0 extent: 360 @ 180) translateBy: offset).	topView addSubView: codeView below: basePane.! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 3/29/2001 14:46'!setDefaultChangeSetCategory	"Set a default ChangeSetCategory for the receiver, and answer it"	^ changeSetCategory _ self class changeSetCategoryNamed: #All! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 12/7/1999 12:53'!veryDeepFixupWith: deepCopier	super veryDeepFixupWith: deepCopier.	parent _ deepCopier references at: parent ifAbsent: [parent].	self updateIfNecessary! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 3/29/2001 13:01'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared."super veryDeepInner: deepCopier."parent _ parent.		Weakly copied""myChangeSet _ myChangeSet.		Weakly copied"currentClassName _ currentClassName veryDeepCopyWith: deepCopier."currentSelector _ currentSelector.		Symbol"priorChangeSetList _ priorChangeSetList veryDeepCopyWith: deepCopier.changeSetCategory _ changeSetCategory.! !!ChangeSorter methodsFor: 'access' stamp: 'tk 4/29/1998 08:22'!changeSet	^ myChangeSet! !!ChangeSorter methodsFor: 'access' stamp: 'sw 3/29/2001 14:45'!changeSetCategory	"Answer the current changeSetCategory object that governs which change sets are shown in this ChangeSorter"	^ changeSetCategory ifNil:		[self setDefaultChangeSetCategory]! !!ChangeSorter methodsFor: 'access' stamp: 'sw 1/27/2000 11:19'!changeSetCurrentlyDisplayed	^ myChangeSet! !!ChangeSorter methodsFor: 'access' stamp: 'tk 4/30/1998 13:37'!label	^ self labelString! !!ChangeSorter methodsFor: 'access' stamp: 'sd 5/23/2003 14:25'!labelString	"The label for my entire window.  The large button that displays my name is gotten via mainButtonName"	^ String streamContents:		[:aStream |			aStream nextPutAll: (ChangeSet current == myChangeSet				ifTrue: ['Changes go to "', myChangeSet name, '"']				ifFalse: ['ChangeSet: ', myChangeSet name]).		(self changeSetCategory categoryName ~~ #All)			ifTrue:				[aStream nextPutAll:  ' - ', self parenthesizedCategoryName]]! !!ChangeSorter methodsFor: 'access' stamp: 'sma 11/11/2000 23:28'!modelWakeUp	"A window with me as model is being entered.	Make sure I am up-to-date with the changeSets."	self canDiscardEdits ifTrue: [self update]! !!ChangeSorter methodsFor: 'access' stamp: 'tk 4/24/1998 08:43'!myChangeSet: anObject	myChangeSet _ anObject! !!ChangeSorter methodsFor: 'access' stamp: 'tk 4/24/1998 08:42'!parent	^ parent! !!ChangeSorter methodsFor: 'access' stamp: 'tk 4/24/1998 08:42'!parent: anObject	parent _ anObject! !!ChangeSorter methodsFor: 'access' stamp: 'sw 3/29/2001 22:51'!parenthesizedCategoryName	"Answer my category name in parentheses"	^ ' (', self changeSetCategory categoryName, ')'! !!ChangeSorter methodsFor: 'access' stamp: 'sw 1/28/1999 12:31'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'access' stamp: 'di 4/5/2001 21:20'!showChangeSetNamed: aName	self showChangeSet: (ChangeSorter changeSetNamed: aName) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/6/1999 23:22'!addPreamble	myChangeSet assurePreambleExists.	self okToChange ifTrue:		[currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:30'!addToCategoryOpposite	"Add the current change set to the category viewed on the opposite side, if it's of the sort to accept things like that"	| categoryOpposite |	categoryOpposite _ (parent other: self) changeSetCategory.	categoryOpposite acceptsManualAdditions		ifTrue:			[categoryOpposite addChangeSet: myChangeSet.			categoryOpposite reconstituteList.			self update]		ifFalse:			[self inform: 'sorry, this command only makes senseif the category showing on the oppositeside is a static category whosemembers are manually maintained']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 4/24/1998 13:27'!browseChangeSet	"Open a message list browser on the new and changed methods in the current change set"	ChangedMessageSet openFor: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'RAA 5/28/2001 12:06'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList _ myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(ChangeSorter allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ self inform: 'No other change set has changesfor any method in this change set.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 8/12/2002 17:29'!categorySubmenu: aMenu  shifted: shiftedIgnored	"Fill aMenu with less-frequently-needed category items"		aMenu title: 'Change set category'.	aMenu addStayUpItem.	aMenu addList: #(		('make a new category...' makeNewCategory 'Creates a new change-set-category (you will be asked to supply a name) which will start out its life with this change set in it')		('make a new category with class...' makeNewCategoryShowingClassChanges 'Creates a new change-set-category that includes change sets that change a particular class (you will be asked to supply a name)')		('rename this category' renameCategory 'Rename this change-set category.   Only applies when the current category being shown is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.')		('remove this category' removeCategory 'Remove this change-set category.   Only applies when the current category being shown is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.')		('show categories of this changeset' showCategoriesOfChangeSet 'Show a list of all the change-set categories that contain this change-set; if the you choose one of the categories from this pop-up, that category will be installed in this change sorter')	-).	parent ifNotNil:		[aMenu addList: #(			('add change set to category opposite' addToCategoryOpposite 'Adds this change set to the category on the other side of the change sorter.  Only applies if the category shown on the opposite side is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.'))].	aMenu addList: #(		('remove change set from this category' removeFromCategory 'Removes this change set from the current category.  Only applies when the current category being shown is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.')		-		('file out category''s change sets' fileOutAllChangeSets 'File out every change set in this category that has anything in it.  The usual checks for slips are suppressed when this command is done.')		('set recent-updates marker' setRecentUpdatesMarker 'Allows you to specify a number that will demarcate which updates are considered "recent" and which are not.  This will govern which updates are included in the RecentUpdates category in a change sorter')		('fill aggregate change set' fillAggregateChangeSet 'Creates a change-set named Aggregate into which all the changes in all the change sets in this category will be copied.')		-		('back to main menu' offerUnshiftedChangeSetMenu 'Takes you back to the shifted change-set menu.')		('back to shifted menu' offerShiftedChangeSetMenu 'Takes you back to the primary change-set menu.')).	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 00:00'!changeSetList	"Answer a list of ChangeSet names to be shown in the change sorter."	^ self changeSetCategory changeSetList! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/17/2002 11:37'!changeSetListKey: aChar from: view	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."	aChar == $b ifTrue: [^ self browseChangeSet].	aChar == $B ifTrue: [^ self openChangeSetBrowser].	aChar == $c ifTrue: [^ self copyAllToOther].	aChar == $D ifTrue: [^ self toggleDiffing]. 	aChar == $f ifTrue: [^ self findCngSet].	aChar == $m ifTrue: [^ self newCurrent].	aChar == $n ifTrue: [^ self newSet].	aChar == $o ifTrue: [^ self fileOut].	aChar == $p ifTrue: [^ self addPreamble].	aChar == $r ifTrue: [^ self rename].	aChar == $s ifTrue: [^ self chooseChangeSetCategory].	aChar == $x ifTrue: [^ self remove].	aChar == $- ifTrue: [^ self subtractOtherSide].	^ self messageListKey: aChar from: view! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/29/2003 08:09'!changeSetMenu: aMenu shifted: isShifted 	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"	isShifted ifTrue: [^ self shiftedChangeSetMenu: aMenu].	Smalltalk isMorphic		ifTrue:			[]		ifFalse:			[aMenu title: 'Change Set:' , myChangeSet name].	aMenu add: 'make changes go to me (m)' action: #newCurrent.	aMenu addLine.	aMenu add: 'new change set... (n)' action: #newSet.	aMenu add: 'find...(f)' action: #findCngSet.	aMenu add: 'show category... (s)' action:  #chooseChangeSetCategory.	aMenu balloonTextForLastItem:'Lets you choose which change sets should be listed in this change sorter'.	aMenu add: 'select change set...' action: #chooseCngSet.	aMenu addLine.	aMenu add: 'rename change set (r)' action: #rename.	aMenu add: 'file out (o)' action: #fileOut."	aMenu add: 'mail to list' action: #mailOut. "	aMenu add: 'browse methods (b)' action: #browseChangeSet.	aMenu add: 'browse change set (B)' action: #openChangeSetBrowser.	aMenu addLine.	parent		ifNotNil: 			[aMenu add: 'copy all to other side (c)' action: #copyAllToOther.			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.			aMenu add: 'subtract other side (-)' action: #subtractOtherSide.			aMenu addLine].	myChangeSet hasPreamble		ifTrue: 			[aMenu add: 'edit preamble (p)' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse: [aMenu add: 'add preamble (p)' action: #addPreamble].	myChangeSet hasPostscript		ifTrue: 			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.	aMenu add: 'category functions...' action: #offerCategorySubmenu.	aMenu balloonTextForLastItem:'Various commands relating to change-set-categories'.	aMenu addLine.	aMenu add: 'destroy change set (x)' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 10/30/2000 10:48'!checkForAlienAuthorship	"Open a message list browser on all uncommented methods in the current change set that have alien authorship"	myChangeSet checkForAlienAuthorship! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'nk 3/30/2002 08:56'!checkForAnyAlienAuthorship	"Open a message list browser on all uncommented methods in the current change set that have alien authorship, even historically"	myChangeSet checkForAnyAlienAuthorship! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/29/2001 12:47'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized"	myChangeSet checkForUnclassifiedMethods! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/18/2002 17:58'!checkForUncommentedClasses	"Open a class list browser on classes in the change set that lack class comments"	myChangeSet checkForUncommentedClasses! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 10/30/2000 10:39'!checkForUncommentedMethods	"Open a message list browser on all uncommented methods in the current change set"	myChangeSet checkForUncommentedMethods! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 10/27/1999 14:20'!checkForUnsentMessages	"Open a message list browser on all unsent messages in the current change set"	myChangeSet checkForUnsentMessages! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/8/1999 13:36'!checkThatSidesDiffer: escapeBlock	"If the change sets on both sides of the dual sorter are the same, put up an error message and escape via escapeBlock, else proceed happily"	(myChangeSet == (parent other: self) changeSet)		ifTrue:			[self inform: 'This command requires that thechange sets selected on the twosides of the change sorter *not*be the same.'.			^ escapeBlock value]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/28/2003 20:47'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].		cats _ ChangeSetCategories elementsInOrder.	aMenu _ SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result _ aMenu startUp.	result ifNotNil:		[changeSetCategory _ result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangeSorter changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 17:56'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically _ self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen _ (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangeSorter changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/28/1999 12:30'!clearChangeSet	"Clear out the current change set, after getting a confirmation."	| message |	self okToChange ifFalse: [^ self].	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to\forget all the changes in this set?' withCRs.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/27/2000 11:21'!copyAllToOther	"Copy this entire change set into the one on the other side"	| companionSorter |	self checkThatSidesDiffer: [^ self].	(companionSorter _ parent other: self) changeSetCurrentlyDisplayed assimilateAllChangesFoundIn: myChangeSet.	companionSorter changed: #classList.	"Later the changeSet itself will notice..."	companionSorter changed: #messageList! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/5/1998 06:47'!currentCngSet	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 4/28/1998 08:06'!editPostscript	"Allow the user to edit the receiver's change-set's postscript -- in a separate window"	myChangeSet editPostscript! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 4/28/1998 08:06'!editPreamble	"Allow the user to edit the receiver's change-set's preamble -- in a separate window."	myChangeSet editPreamble! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/19/2000 16:18'!expungeUniclasses	"remove all memory of uniclasses in the receiver"	self okToChange ifFalse: [^ self].	myChangeSet expungeUniclasses.	self changed: #classList.	self changed: #messageList.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'nk 1/4/2004 17:07'!fileIntoNewChangeSet	"Obtain a file designation from the user, and file its contents into a  	new change set whose name is a function of the filename. Show the  	new set and leave the current changeSet unaltered."	| aNewChangeSet stream |	self okToChange		ifFalse: [^ self].	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	stream := StandardFileMenu oldFileStreamFrom: ChangeSet defaultChangeSetDirectory.	stream		ifNil: [^ self].	aNewChangeSet := self class				newChangesFromStream: stream				named: (FileDirectory localNameFor: stream name).	aNewChangeSet		ifNotNil: [self showChangeSet: aNewChangeSet]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/10/1999 12:44'!fileOut	"File out the current change set."	myChangeSet fileOut.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 00:57'!fileOutAllChangeSets	"File out all nonempty change sets in the current category, probably"	self changeSetCategory fileOutAllChangeSets! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 01:26'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	self changeSetCategory fillAggregateChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'nb 6/17/2003 12:25'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates nameList |	self okToChange ifFalse: [^ self].	pattern _ FillInTheBlank request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	nameList _ self changeSetList asSet.	candidates _ AllChangeSets select:			[:c | (nameList includes: c name) and: 				[c name includesSubstring: pattern caseSensitive: false]].	candidates size = 0 ifTrue: [^ Beeper beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index _ (PopUpMenu labels: 		(candidates collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 10/26/1999 14:24'!goToChangeSetsProject	"Transport the user to a project which bears the selected changeSet as its current changeSet"	| aProject |	(aProject _ myChangeSet correspondingProject) 		ifNotNil:			[aProject enter: false revert: false saveForRevert: false]		ifNil:			[self inform: 'Has no project']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/10/1999 01:01'!inspectChangeSet	"Open a message list browser on the new and changed methods in the current change set"	myChangeSet inspectWithLabel: 'Change set: ', myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 2/17/1999 11:05'!lookForSlips	"Open a message list browser on the new and changed methods in the current change set"	myChangeSet lookForSlips! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'dvf 5/13/2000 05:08'!mailOut	"Create a mail with a gzipped attachment holding out the current change 	set. "	myChangeSet mailOut.	parent modelWakeUp! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 4/24/1998 13:10'!mainButtonName	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:43'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName _ FillInTheBlank request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName _ catName asSymbol.	(ChangeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory _ StaticChangeSetCategory new categoryName: catName.	ChangeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'nk 6/26/2002 12:28'!makeNewCategoryShowingClassChanges	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory clsName |	clsName _ self selectedClass ifNotNil: [self selectedClass name ] ifNil: [''].	clsName _ FillInTheBlank request: 'Which class?' initialAnswer: clsName.	clsName isEmptyOrNil ifTrue: [^ self].	catName _ ('Changes to ', clsName) asSymbol.	(ChangeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory _ ChangeSetCategoryWithParameters new categoryName: catName.	aCategory membershipSelector: #changeSet:containsClass: ; parameters: { clsName }.	ChangeSetCategories elementAt: catName put: aCategory.	aCategory reconstituteList.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'RAA 5/28/2001 12:07'!methodConflictsWithOppositeCategory	"Check to see if ANY change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList otherCategory |	otherCategory _ (parent other: self) changeSetCategory.	aList _ myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			aClass notNil and: 				[otherCategory 					hasChangeForClassName: aClass name 					selector: aSelector 					otherThanIn: myChangeSet]		]		ifNone: [^ self inform: 'There are no methods that appear both inthis change set and in any change set(other than this one) on the other side.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" also in some other change set in category ', otherCategory categoryName,' (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'RAA 5/28/2001 12:07'!methodConflictsWithOtherSide	"Check to see if the change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList other |	self checkThatSidesDiffer: [^ self].	other _ (parent other: self) changeSet.	aList _ myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			aClass notNil and: [(other methodChangesAtClass: aClass name) includesKey: aSelector]		]		ifNone:  [^ self inform: 'There are no methods that appearboth in this change set andin the one on the other side.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in ', other name,' (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sd 5/23/2003 15:15'!newCurrent	"make my change set be the current one that changes go into"	ChangeSet  newChanges: myChangeSet.	self update.  "Because list of changes in a category may thus have changed"	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:26'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[self changeSetCategory acceptsManualAdditions ifTrue:			[changeSetCategory addChangeSet: aSet].		self update.		(changeSetCategory includesChangeSet: aSet) ifTrue:			[self showChangeSet: aSet].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 17:41'!offerCategorySubmenu	"Offer a menu of category-related items"	self offerMenuFrom: #categorySubmenu:shifted: shifted: false! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 2/27/2001 21:55'!offerShiftedChangeSetMenu	"Offer the shifted version of the change set menu"	self offerMenuFrom: #changeSetMenu:shifted: shifted: true! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/6/2001 14:41'!offerUnshiftedChangeSetMenu	"Offer the unshifted version of the change set menu"	self offerMenuFrom: #changeSetMenu:shifted: shifted: false! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/29/2003 00:38'!openChangeSetBrowser	"Open a ChangeSet browser on the current change set"	Smalltalk isMorphic		ifFalse:			[self browseChangeSet]  "msg-list browser only"		ifTrue:			[]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 12/13/2003 18:14'!promoteToTopChangeSet	"Move the selected change-set to the top of the list"	self class promoteToTop: myChangeSet.	(parent ifNil: [self]) modelWakeUp! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:00'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 20:03'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only remove manually-added categories.'].	(self confirm: 'Really remove the change-set-categorynamed ', (itsName _ changeSetCategory categoryName), '?') ifFalse: [^ self].	ChangeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'MU 7/1/2002 18:38'!removeContainedInClassCategories	| matchExpression |	myChangeSet removePreamble.	matchExpression :=  FillInTheBlank request: 'Enter class category name (wildcard is ok)' initialAnswer: 'System-*'. 	(SystemOrganization categories		select: [:each | matchExpression match: each])		do: [:eachCat | 			| classNames | 			classNames := SystemOrganization listAtCategoryNamed: eachCat.			classNames				do: [:eachClassName | 					myChangeSet removeClassChanges: eachClassName.					myChangeSet removeClassChanges: eachClassName , ' class'].			self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:31'!removeFromCategory	"Add the current change set to the category viewed on the opposite side, if it's of the sort to accept things like that"	| aCategory |	(aCategory _ self changeSetCategory) acceptsManualAdditions		ifTrue:			[aCategory removeElementAt: myChangeSet name.			aCategory reconstituteList.			self update]		ifFalse:			[self inform: 'sorry, this command only makessense for static categories whosemembers are manually maintained']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 6/29/1999 20:53'!removePostscript	(myChangeSet hasPostscript and: [myChangeSet postscriptHasDependents]) ifTrue:		[^ self inform:'Cannot remove the postscript rightnow because there is at least onewindow open on that postscript.Close that window and try again.'].	myChangeSet removePostscript.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/5/1999 19:32'!removePreamble	myChangeSet removePreamble.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sd 5/23/2003 14:26'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg _ myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(self confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber _ myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangeSorter removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'nb 6/17/2003 12:25'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ FillInTheBlank request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ Beeper beep].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 18:18'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only rename manually-added categories.'].	catName _ FillInTheBlank request: 'Please give the new category a name' initialAnswer:  (oldName _ changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName _ catName asSymbol) = oldName ifTrue: [^ self inform: 'no change.'].	(ChangeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	ChangeSetCategories removeElementAt: oldName.	ChangeSetCategories elementAt: catName put: changeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/5/2001 11:03'!reorderChangeSets	"apply a standard reordering -- let the class handle this"	^ self class reorderChangeSets! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/28/2003 20:37'!setRecentUpdatesMarker	"Allow the user to change the recent-updates marker"	| result |	result _ FillInTheBlank request: ('Enter the lowest change-set numberthat you wish to consider "recent"?(note: highest change-set numberin this image at this time is ', self class highestNumberedChangeSet asString, ')') initialAnswer: self class recentUpdateMarker asString.	(result notNil and: [result startsWithDigit]) ifTrue:		[self class recentUpdateMarker: result asInteger.]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/28/2003 20:48'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"		"CONFLICTS SECTION"	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	parent ifNotNil:		[aMenu add: 'conflicts with change set opposite' action: #methodConflictsWithOtherSide.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'.			aMenu add: 'conflicts with category opposite' action: #methodConflictsWithOppositeCategory.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in ANY change set in the category list on the opposite side of this change sorter, other of course than this change set itself.  (Caution -- this could be VERY slow)'].	aMenu addLine.	"CHECKS SECTION"	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	aMenu add: 'check for uncommented classes' action: #checkForUncommentedClasses.	aMenu balloonTextForLastItem:'Check for classes with code in this changeset which lack class comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'.	aMenu add: 'check for any other authors' action: #checkForAnyAlienAuthorship.	aMenu balloonTextForLastItem:'Check this change set for methods any of whose authoring stamps do not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'promote to top of list' action: #promoteToTopChangeSet.	aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'expunge uniclasses' action: #expungeUniclasses.	aMenu balloonTextForLastItem:'Remove from the change set all memory of uniclasses, e.g. classes added on behalf of etoys, fabrik, etc., whose classnames end with a digit.'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'file into new...' action: #fileIntoNewChangeSet.	aMenu balloonTextForLastItem: 'Load a fileout from disk and place its changes into a new change set (seldom needed -- much better to do this from a file-list browser these days.)'.	aMenu add: 'reorder all change sets' action: #reorderChangeSets.	aMenu balloonTextForLastItem:'Applies a standard reordering of all change-sets in the system -- at the bottom will come the sets that come with the release; next will come all the numbered updates; finally, at the top, will come all other change sets'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/28/2003 20:51'!showCategoriesOfChangeSet	"Show a list of all the categories in which the selected change-set occurs at the moment.  Install the one the user chooses, if any."	Smalltalk isMorphic		ifFalse:			[self inform:'Only available in morphic, right now, sorry.It would not take much to make thisalso work in mvc, so if you areinclined to do that, thanks in advance...']		ifTrue:			[]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 13:27'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory _ aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangeSorter changeSetNamed: self changeSetList first)].	self changed: #relabel! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 21:22'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	(myChangeSet hasPreamble or: [myChangeSet hasPostscript]) ifTrue:		[(self confirm: 'Caution!!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [^ self]].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	parent modelWakeUp.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/8/1999 12:32'!subtractOtherSide	"Subtract the changes found on the other side from the requesting side."	self checkThatSidesDiffer: [^ self].	myChangeSet forgetAllChangesFoundIn: ((parent other: self) changeSet).	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 5/12/2000 15:03'!trimHistory	"Drop non-essential history (rename, reorg, method removals) from newly-added classes."	myChangeSet trimHistory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 3/8/2000 14:18'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(self confirm: 'Uninstalling a changeSet is unreliable at best.It will only work if the changeSet consists only of singlechanges, additions and removals of methods, and ifno subsequent changes have been to any of them.No changes to classes will be undone.The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self changed: #relabel.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/20/2001 09:37'!updateIfNecessary	"Recompute all of my panes."	| newList |	self okToChange ifFalse: [^ self].	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"	(myChangeSet isMoribund or: [(changeSetCategory notNil and: [changeSetCategory includesChangeSet: myChangeSet]) not]) ifTrue:		[self changed: #changeSetList.		^ self showChangeSet: self changeSetCategory defaultChangeSetToShow].	newList _ self changeSetList.	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])		ifTrue:			[priorChangeSetList _ newList.			self changed: #changeSetList].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 3/29/2001 15:19'!classList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 3/5/2001 18:24'!classListKey: aChar from: view	"Respond to a Command key in the class-list pane."	aChar == $x ifTrue: [^ self removeClass].	aChar == $d ifTrue: [^ self forgetClass]. 	^ self messageListKey: aChar from: view "picks up b,h,p"! !!ChangeSorter methodsFor: 'class list' stamp: 'BG 10/28/2003 20:48'!classListMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the class list"	aMenu title: 'class list'.	(parent notNil and: [shifted not])		ifTrue: [aMenu addList: #( "These two only apply to dual change sorters"			('copy class chgs to other side'			copyClassToOther)				('move class chgs to other side'			moveClassToOther))].	aMenu addList: (shifted		ifFalse: [#(			-			('delete class from change set (d)'		forgetClass)			('remove class from system (x)'			removeClass)			-			('browse full (b)'						browseMethodFull)			('browse hierarchy (h)'					spawnHierarchy)			('browse protocol (p)'					browseFullProtocol)			-			('printOut'								printOutClass)			('fileOut'								fileOutClass)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class vars'								browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('more...'								offerShiftedClassListMenu))]		ifTrue: [#(			-			('unsent methods'						browseUnusedMethods)			('unreferenced inst vars'				showUnreferencedInstVars)			('unreferenced class vars'				showUnreferencedClassVars)			-			('sample instance'						makeSampleInstance)			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)			-			('more...'								offerUnshiftedClassListMenu ))]).	^ aMenu! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 2/26/2001 12:00'!classMenu: aMenu	"Set up aMenu for the class-list.  Retained for backward compatibility with old change sorters in image segments"	^ self classListMenu: aMenu shifted: false! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 3/6/2001 12:40'!classMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the class list.  Retained for bkwd compatibility"	^ self classListMenu: aMenu shifted: shifted! !!ChangeSorter methodsFor: 'class list' stamp: 'nb 6/17/2003 12:25'!copyClassToOther	"Place these changes in the other changeSet also"	| otherSorter otherChangeSet |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ Beeper beep].	currentClassName ifNil: [^ Beeper beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	otherSorter showChangeSet: otherChangeSet.! !!ChangeSorter methodsFor: 'class list' stamp: 'tk 4/24/1998 09:14'!currentClassName	^ currentClassName! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 1/28/1999 12:30'!currentClassName: aString	currentClassName _ aString.	currentSelector _ nil.	"fix by wod"	self changed: #currentClassName.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'class list' stamp: 'kfr 6/16/2000 16:27'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet _ self class newChangeSet: currentClassName.	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'class list' stamp: 'ls 8/12/1998 23:47'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 3/5/2001 18:30'!messageListKey: aChar from: view	"Respond to a Command key in the message-list pane."	aChar == $d ifTrue: [^ self forget].	super messageListKey: aChar from: view! !!ChangeSorter methodsFor: 'class list' stamp: 'nb 6/17/2003 12:25'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	self checkThatSidesDiffer: [^ self].	(self okToChange and: [currentClassName notNil]) ifFalse: [^ Beeper beep].	self copyClassToOther.	self forgetClass! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 12/7/1998 09:43'!selectedClass	"Answer the currently-selected class.  If there is no selection, or if the selection refers to a class no longer extant, return nil"	| c |	^ currentClassName ifNotNil: [(c _ self selectedClassOrMetaClass)		ifNotNil: [c theNonMetaClass]]! !!ChangeSorter methodsFor: 'class list' stamp: 'tk 5/7/1998 13:48'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName |	currentClassName ifNil: [^ nil].	(currentClassName endsWith: ' class')		ifTrue: [cName _ (currentClassName copyFrom: 1 to: currentClassName size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class]		ifFalse: [cName _ currentClassName asSymbol.				^ Smalltalk at: cName ifAbsent: [nil]]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 3/23/2000 13:34'!browseVersions	"Create and schedule a changelist browser on the versions of the 	selected message."	| class selector method category pair sourcePointer |	(selector _ self selectedMessageName) ifNil: [^ self].	class _ self selectedClassOrMetaClass.	(class includesSelector: selector)		ifTrue: [method _ class compiledMethodAt: selector.				category _ class whichCategoryIncludesSelector: selector.				sourcePointer _ nil]		ifFalse: [pair _ myChangeSet methodInfoFromRemoval: {class name. selector}.				pair ifNil: [^ nil].				sourcePointer _ pair first.				method _ CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category _ pair last].	VersionsBrowser		browseVersionsOf: method		class: self selectedClass meta: class isMeta		category: category selector: selector		lostMethodPointer: sourcePointer.! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 7/8/1999 12:31'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'tk 4/24/1998 09:15'!currentSelector	^ currentSelector! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 1/28/1999 12:31'!currentSelector: messageName	currentSelector _ messageName.	self changed: #currentSelector.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 4/25/2000 10:33'!messageList 	| probe newSelectors |	currentClassName ifNil: [^ #()].	probe _ (currentClassName endsWith: ' class')		ifTrue: [currentClassName]		ifFalse: [currentClassName asSymbol].	newSelectors _ myChangeSet selectorsInClass: probe.	(newSelectors includes: currentSelector) ifFalse: [currentSelector _ nil].	^ newSelectors asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 3/9/2001 14:27'!messageListMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	^ self messageMenu: aMenu shifted: shifted! !!ChangeSorter methodsFor: 'message list' stamp: 'BG 10/28/2003 20:48'!messageMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	aMenu title: 'message list'.		parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther))].	aMenu addList: #(			('delete method from changeSet (d)'	forget)			-			('remove method from system (x)'	removeMessage)				-			('browse full (b)'					browseMethodFull)			('browse hierarchy (h)'				spawnHierarchy)			('browse method (O)'				openSingleMessageBrowser)			('browse protocol (p)'				browseFullProtocol)			-			('fileOut'							fileOutMessage)			('printOut'							printOutMessage)			-			('senders of... (n)'					browseSendersOfMessages)			('implementors of... (m)'				browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'						browseVersions)			-			('more...'							shiftedYellowButtonActivity)).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'nb 6/17/2003 12:25'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ Beeper beep].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'sd 5/11/2003 18:38'!removeMessage	"Remove the selected msg from the system. Real work done by the 	parent, a ChangeSorter"	| confirmation sel |	self okToChange		ifFalse: [^ self].	currentSelector		ifNotNil: [confirmation _ self systemNavigation   confirmRemovalOf: (sel _ self selectedMessageName) on: self selectedClassOrMetaClass.			confirmation == 3				ifTrue: [^ self].			self selectedClassOrMetaClass removeSelector: sel.			self update.			confirmation == 2				ifTrue: [self systemNavigation browseAllCallsOn: sel]]! !!ChangeSorter methodsFor: 'message list' stamp: 'jm 5/4/1998 07:32'!selectedMessageName	currentSelector ifNil: [^ nil].	^ currentSelector asSymbol! !!ChangeSorter methodsFor: 'message list' stamp: 'BG 11/1/2003 13:24'!shiftedMessageMenu: aMenu	"Arm the menu so that it holds items appropriate to the message-list while the shift key is down.  Answer the menu."	^ aMenu addList: #(		-		('toggle diffing (D)'					toggleDiffing)		('implementors of sent messages'		browseAllMessages)		('change category...'				changeCategory)			-		('sample instance'					makeSampleInstance)		('inspect instances'					inspectInstances)		('inspect subinstances'				inspectSubInstances)		-		('change sets with this method'		findMethodInChangeSets)		('revert to previous version'			revertToPreviousVersion)		('revert & remove from changes'	revertAndForget)		-		('more...'							unshiftedYellowButtonActivity))! !!ChangeSorter methodsFor: 'code pane' stamp: 'tk 5/10/1999 17:24'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class _ self selectedClassOrMetaClass) ifNil:		[(myChangeSet preambleString == nil or: [aString size == 0]) ifTrue: [ ^ false].		(aString count: [:char | char == $"]) odd 			ifTrue: [self inform: 'unmatched double quotes in preamble']			ifFalse: [(Scanner new scanTokens: aString) size > 0 ifTrue: [				self inform: 'Part of the preamble is not within double-quotes.To put a double-quote inside a comment, type two double-quotes in a row.(Ignore this warning if you are including a doIt in the preamble.)']].		myChangeSet preambleString: aString.		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"		^ true].	oldSelector _ self selectedMessageName.	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector ifNil: [^ false].	(self messageList includes: selector)		ifTrue: [self currentSelector: selector]		ifFalse: [self currentSelector: oldSelector].	self update.	^ true! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 11/13/2001 07:35'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs altSyntax) includes: contentsSymbol) ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			self showingAnyKindOfDiffs				ifTrue: [contents _ self diffFromPriorSourceFor: contents].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents _ strm contents].! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 11/13/2001 07:34'!toggleDiffing	"Toggle whether diffs should be shown in the code pane"	self okToChange ifTrue:		[super toggleDiffing.		self changed: #contents.		self update]! !!ChangeSorter methodsFor: 'code pane' stamp: 'JW 2/2/2001 21:41'!wantsOptionalButtons	"No optional buttons for ChangeSorter"	^false! !!ChangeSorter methodsFor: 'annotation' stamp: 'sw 2/22/2001 10:35'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior version is pointed to by the lost-method pointer in the change held on to by the changeset"	(aClass includesSelector: aSelector) ifTrue:		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].	aStream nextPutAll:		((myChangeSet methodInfoFromRemoval: {aClass name. aSelector})			ifNil:				['no prior versions']			ifNotNil:				['version(s) retrievable here']), self annotationSeparator! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChangeSorter class	instanceVariableNames: ''!!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:33'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:27'!allChangeSets	"Return the list of all current ChangeSets"	^ AllChangeSets! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:34'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'nk 6/26/2002 12:39'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass _ Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 19:42'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ AllChangeSets			detect: [:aChangeSet | aChangeSet name = aName]			ifNone: [nil]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 19:42'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	^ AllChangeSets select: [:aChangeSet | nameBlock value: aChangeSet name]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/6/2001 09:49'!existingOrNewChangeSetNamed: aName	| newSet |	^(self changeSetNamed: aName) ifNil: [		newSet _ ChangeSet basicNewNamed: aName.		AllChangeSets add: newSet.		newSet	]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/3/2000 14:51'!gatherChangeSets		"ChangeSorter gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets obsolete |	allChangeSets _ AllChangeSets asSet.	ChangeSet allSubInstances do: [:each |		(allChangeSets includes: each) == (obsolete _ each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'sw 8/20/1999 10:27'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList _ (self allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:37'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits _ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'BG 10/28/2003 20:38'!promoteToTop: aChangeSet	"make aChangeSet the first in the list from now on"	AllChangeSets remove: aChangeSet ifAbsent: [^ self].	AllChangeSets add: aChangeSet.! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 16:01'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:38'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:47'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:45'!belongsInNumbered:  aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:49'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:44'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString _ aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:56'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/29/2001 14:44'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 4/16/2002 00:47'!changeSetNamesInReleaseImage	"Answer a list of names of project change sets that come pre-shipped in the latest sytem release.  On the brink of shipping a new release, call 'ChangeSorter noteChangeSetsInRelease'  "	^ ChangeSetNamesInRelease ifNil:		[ChangeSetNamesInRelease _ self changeSetNamesInThreeOh]! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 4/16/2002 00:45'!changeSetNamesInThreeOh	"Hard-coded: answer a list of names of project change sets that came pre-shipped in Squeak 3.0"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:41'!initialize	"Initialize the class variables"	AllChangeSets == nil ifTrue:		[AllChangeSets _ OrderedCollection new].	self gatherChangeSets.	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker _ 0.	"ChangeSorter initialize"	FileList registerFileReader: self.	self registerInFlapsRegistry.! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 13:30'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories _ ElementCategory new categoryName: #ChangeSetCategories.	aCategory _ ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 4/16/2002 00:47'!noteChangeSetsInRelease	"Freshly compute what the change sets in the release are; to be called manually just before a release"	ChangeSetNamesInRelease _ (Project allProjects collect: [:p | p name]) asSet asOrderedCollection."ChangeSorter noteChangeSetsInRelease"! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:42'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(ChangeSorter			prototypicalToolWindow		'Change Set'			'A tool that allows you to view and manipulate all the code changes in a single change set')						forFlapNamed: 'Tools']! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:32'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangeSorter class methodsFor: 'adding' stamp: 'di 4/6/2001 09:46'!basicNewChangeSet: newName	| newSet |	newName ifNil: [^ nil].	(self changeSetNamed: newName) ifNotNil:		[self inform: 'Sorry that name is already used'.		^ nil].	newSet _ ChangeSet basicNewNamed: newName.	AllChangeSets add: newSet.	^ newSet! !!ChangeSorter class methodsFor: 'adding' stamp: 'sd 5/23/2003 15:15'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet _ self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!ChangeSorter class methodsFor: 'adding' stamp: 'sma 11/11/2000 23:23'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName _ aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!ChangeSorter class methodsFor: 'adding' stamp: 'sd 5/23/2003 15:15'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet |	oldChanges _ ChangeSet current.	PreviousSet _ oldChanges name. 		"so a Bumper update can find it"	newName _ aName sansPeriodSuffix.	newSet _ self basicNewChangeSet: newName.	[newSet ifNotNil:		[ChangeSet  newChanges: newSet.		aStream fileInAnnouncing: 'Loading ', newName, '...'.		Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName].	aStream close] ensure: [			ChangeSet  newChanges: oldChanges].	^ newSet! !!ChangeSorter class methodsFor: 'removing' stamp: 'sw 1/6/2001 06:21'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	ChangeSorter removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangeSorter deleteChangeSetsNumberedLowerThan: (ChangeSorter highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!ChangeSorter class methodsFor: 'removing' stamp: 'sw 8/18/1999 09:44'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	AllChangeSets remove: aChangeSet ifAbsent: [].	aChangeSet wither! !!ChangeSorter class methodsFor: 'removing' stamp: 'di 4/5/2001 21:12'!removeChangeSetsNamedSuchThat: nameBlock	(ChangeSorter changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangeSorter class methodsFor: 'removing' stamp: 'di 4/5/2001 21:13'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo _ (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 13:43'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing _ self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 5/23/2001 13:30'!browseChangeSetsWithClass: class selector: selector	"Put up a menu comprising a list of change sets that hold changes for the given class and selector.  If the user selects one, open a single change-sorter onto it"	| hits index |	hits _ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ self inform: class name, '.', selector , 'is not in any change set'].	index _ hits size == 1		ifTrue:	[1]		ifFalse:	[(PopUpMenu labelArray: (hits collect: [:cs | cs name])					lines: #()) startUp].	index = 0 ifTrue: [^ self].	(ChangeSorter new myChangeSet: (hits at: index)) open.! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 5/23/2001 13:31'!browseChangeSetsWithSelector: aSelector	"Put up a list of all change sets that contain an addition, deletion, or change of any method with the given selector"	| hits index |	hits _ self allChangeSets select: 		[:cs | cs hasAnyChangeForSelector: aSelector].	hits isEmpty ifTrue: [^ self inform: aSelector , 'is not in any change set'].	index _ hits size == 1		ifTrue:	[1]		ifFalse:	[(PopUpMenu labelArray: (hits collect: [:cs | cs name])					lines: #()) startUp].	index = 0 ifTrue: [^ self].	(ChangeSetBrowser new myChangeSet: (hits at: index)) open"ChangeSorter browseChangeSetsWithSelector: #clearPenTrails"! !!ChangeSorter class methodsFor: 'services' stamp: 'di 4/5/2001 21:36'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet _ self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 6/6/2001 12:51'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 6/6/2001 12:52'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 00:30'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker _ 0]! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 00:30'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker _ aNumber! !!ChangeSorter class methodsFor: 'services' stamp: 'BG 10/28/2003 20:38'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead _ OrderedCollection new.	newMid _ OrderedCollection new.	newTail _ OrderedCollection new.	AllChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	AllChangeSets _ newHead, newMid, newTail.! !!ChangeSorter class methodsFor: 'services' stamp: 'sd 5/23/2003 14:27'!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  "	AllChangeSets size = 1 ifTrue: [^ AllChangeSets first].	AllChangeSets last == ChangeSet current		ifTrue: 	[^ AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[^ AllChangeSets last]! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:33'!fileIntoNewChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fn ff |	fullName ifNil: [^ Beeper beep].	ff _ FileStream readOnlyFileNamed: (fn _  fullName).	((FileDirectory extensionFor: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].	self newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'sd 2/6/2002 21:29'!fileReaderServicesForFile: fullName suffix: suffix	^(suffix = 'st') | (suffix = 'cs') | (suffix = '*')		ifTrue: [ self services]		ifFalse: [#()]! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'sw 2/17/2002 01:36'!serviceFileIntoNewChangeSet	"Answer a service for installing a file into a new change set"	^ SimpleServiceEntry 		provider: self 		label: 'install into new change set'		selector: #fileIntoNewChangeSet:		description: 'install the file as a body of code in the image: create a new change set and file-in the selected file into it'		buttonLabel: 'install'! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'sd 2/1/2002 22:47'!services	^ Array with: self serviceFileIntoNewChangeSet	! !!ChangeSorter class methodsFor: 'utilities' stamp: 'sd 1/16/2004 21:36'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound _ OrderedCollection new.	empty _ OrderedCollection new.	nameList do:		[:aName | (aChangeSet _ self changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString _ (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString _ infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString _ infoString, '', aName]].	empty size > 0 ifTrue:		[infoString _ infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString _ infoString, '', aName]].	self inform: infoString! !MessageSet subclass: #ChangedMessageSet	instanceVariableNames: 'changeSet'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!ChangedMessageSet commentStamp: '<historical>' prior: 0!A ChangedMessageSet is a message set associated with a change-set; it bears an entry for every method added or changed in the change set, as well as for every class-comment of which the change-set bears a note.!!ChangedMessageSet methodsFor: 'initialization'!changeSet: aChangeSet	changeSet _ aChangeSet! !!ChangedMessageSet methodsFor: 'acceptance' stamp: 'sw 6/26/2001 11:42'!contents: aString notifying: aController	"Accept the string as new source for the current method, and make certain the annotation pane gets invalidated"	| existingSelector existingClass superResult newSelector |	existingSelector _ self selectedMessageName.	existingClass _ self selectedClassOrMetaClass.	superResult _ super contents: aString notifying: aController.	superResult ifTrue:  "succeeded"		[newSelector _ Parser new parseSelector: aString.		newSelector ~= existingSelector			ifTrue:   "Selector changed -- maybe an addition"				[self reformulateList.				self changed: #messageList.				self messageList doWithIndex:					[:aMethodReference :anIndex |						(aMethodReference actualClass == existingClass and:									[aMethodReference methodSymbol == newSelector])							ifTrue:								[self messageListIndex: anIndex]]]].	^ superResult! !!ChangedMessageSet methodsFor: 'message list' stamp: 'sw 1/28/2001 20:59'!growable	"Answer whether the receiver can be changed by manual additions & deletions"	^ false! !!ChangedMessageSet methodsFor: 'reformulation' stamp: 'sw 6/26/2001 11:20'!reformulateList	"Reformulate the message list of the receiver"	self initializeMessageList: (changeSet changedMessageListAugmented select: 		[:each | each isValid])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChangedMessageSet class	instanceVariableNames: ''!!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'RAA 5/29/2001 10:19'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message-list consists of all the methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic"	| messageSet |	messageSet _ aChangeSet changedMessageListAugmented select: [ :each | each isValid].	self 		openMessageList: messageSet 		name: 'Methods in Change Set ', aChangeSet name		autoSelect: nil		changeSet: aChangeSet! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'BG 10/28/2003 20:51'!openMessageList: messageList name: labelString autoSelect: autoSelectString changeSet: aChangeSet	| messageSet |	messageSet _ self messageList: messageList.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: autoSelectString.	Smalltalk isMorphic		ifTrue: []		ifFalse: [ScheduledControllers scheduleActive:  (self open: messageSet name: labelString)]! !Magnitude subclass: #Character	instanceVariableNames: 'value'	classVariableNames: 'CharacterTable ClassificationTable LetterBits LowercaseBit UppercaseBit'	poolDictionaries: ''	category: 'Collections-Text'!!Character commentStamp: '<historical>' prior: 0!I represent a character by storing its associated ASCII code (extended to 256 codes). My instances are created uniquely, so that all instances of a character ($R, for example) are identical.!!Character methodsFor: 'accessing'!asciiValue	"Answer the value of the receiver that represents its ascii encoding."	^value! !!Character methodsFor: 'accessing'!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	value <= $9 asciiValue 		ifTrue: [^value - $0 asciiValue].	value >= $A asciiValue 		ifTrue: [value <= $Z asciiValue ifTrue: [^value - $A asciiValue + 10]].	^ -1! !!Character methodsFor: 'comparing'!< aCharacter 	"Answer true if the receiver's value < aCharacter's value."	^self asciiValue < aCharacter asciiValue! !!Character methodsFor: 'comparing'!= aCharacter 	"Primitive. Answer true if the receiver and the argument are the same	object (have the same object pointer) and false otherwise. Optional. See	Object documentation whatIsAPrimitive."	<primitive: 110>	^self == aCharacter! !!Character methodsFor: 'comparing'!> aCharacter 	"Answer true if the receiver's value > aCharacter's value."	^self asciiValue > aCharacter asciiValue! !!Character methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^value! !!Character methodsFor: 'testing'!isAlphaNumeric	"Answer whether the receiver is a letter or a digit."	^self isLetter or: [self isDigit]! !!Character methodsFor: 'testing'!isDigit	"Answer whether the receiver is a digit."	^value >= 48 and: [value <= 57]! !!Character methodsFor: 'testing' stamp: 'dgd 8/24/2003 14:50'!isLetter	"Answer whether the receiver is a letter."	^ (ClassificationTable at: value + 1)		anyMask: LetterBits! !!Character methodsFor: 'testing' stamp: 'dgd 8/24/2003 14:51'!isLowercase	"Answer whether the receiver is a lowercase letter.	(The old implementation answered whether the receiver is not an uppercase letter.)"	^ ((ClassificationTable at: value + 1)		bitAnd: LowercaseBit)		= LowercaseBit! !!Character methodsFor: 'testing' stamp: 'dgd 8/24/2003 14:52'!isSafeForHTTP	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"	^ value < 128		and: [self isAlphaNumeric				or: ['.~-_' includes: self]]! !!Character methodsFor: 'testing'!isSeparator	"Answer whether the receiver is one of the separator characters--space, 	cr, tab, line feed, or form feed."	value = 32 ifTrue: [^true].	"space"	value = 13 ifTrue: [^true].	"cr"	value = 9 ifTrue: [^true].	"tab"	value = 10 ifTrue: [^true].	"line feed"	value = 12 ifTrue: [^true].	"form feed"	^false! !!Character methodsFor: 'testing' stamp: 'di 4/3/1999 00:38'!isSpecial	"Answer whether the receiver is one of the special characters"	^'+-/\*~<>=@,%|&?!!' includes: self! !!Character methodsFor: 'testing' stamp: 'dgd 8/24/2003 14:52'!isUppercase	"Answer whether the receiver is an uppercase letter.	(The old implementation answered whether the receiver is not a lowercase letter.)"	^ ((ClassificationTable at: value + 1)		bitAnd: UppercaseBit)		= UppercaseBit! !!Character methodsFor: 'testing'!isVowel	"Answer whether the receiver is one of the vowels, AEIOU, in upper or 	lower case."	^'AEIOU' includes: self asUppercase! !!Character methodsFor: 'testing'!tokenish	"Answer whether the receiver is a valid token-character--letter, digit, or 	colon."	^self isLetter or: [self isDigit or: [self = $:]]! !!Character methodsFor: 'copying' stamp: 'tk 12/9/2000 11:46'!clone	"Answer with the receiver, because Characters are unique."! !!Character methodsFor: 'copying'!copy	"Answer with the receiver because Characters are unique."! !!Character methodsFor: 'copying'!deepCopy	"Answer with the receiver because Characters are unique."! !!Character methodsFor: 'copying' stamp: 'tk 1/7/1999 16:50'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied."! !!Character methodsFor: 'printing'!hex	^ String with: ('0123456789ABCDEF' at: value//16+1)			with:  ('0123456789ABCDEF' at: value\\16+1)! !!Character methodsFor: 'printing'!isLiteral	^true! !!Character methodsFor: 'printing'!printOn: aStream	aStream nextPut: $$.	aStream nextPut: self! !!Character methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:04'!printOnStream: aStream	aStream print:'$', (String with:self).! !!Character methodsFor: 'printing'!storeOn: aStream	"Character literals are preceded by '$'."	aStream nextPut: $$; nextPut: self! !!Character methodsFor: 'converting'!asCharacter	"Answer the receiver itself."	^self! !!Character methodsFor: 'converting' stamp: 'ls 9/5/1998 01:18'!asIRCLowercase	"convert to lowercase, using IRC's rules"	self == $[ ifTrue: [ ^ ${ ].	self == $] ifTrue: [ ^ $} ].	self == $\ ifTrue: [ ^ $| ].	^self asLowercase! !!Character methodsFor: 'converting'!asInteger	"Answer the value of the receiver."	^value! !!Character methodsFor: 'converting' stamp: 'dgd 8/24/2003 14:53'!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."		^ Character		value: ((ClassificationTable at: value + 1)				bitAnd: 255)! !!Character methodsFor: 'converting' stamp: 'sma 3/11/2000 17:21'!asString	^ String with: self! !!Character methodsFor: 'converting' stamp: 'raa 5/26/2001 09:54'!asSymbol 	"Answer a Symbol consisting of the receiver as the only element."	^Symbol internCharacter: self! !!Character methodsFor: 'converting' stamp: 'tk 9/4/2000 12:05'!asText	^ self asString asText! !!Character methodsFor: 'converting' stamp: 'dgd 8/24/2003 14:53'!asUppercase	"If the receiver is lowercase, answer its matching uppercase Character."		^ Character		value: (((ClassificationTable at: value + 1)				bitShift: -8)				bitAnd: 255)! !!Character methodsFor: 'converting' stamp: 'sma 3/15/2000 22:57'!isoToSqueak	"Convert receiver from iso8895-1 (actually CP1252) to mac encoding.	Does not do lf/cr conversion!! Characters not available in MacRoman	encoding have been remapped to their base characters or to $?."	value < 128 ifTrue: [^ self].	^ Character value: (#(		219 63 226 196 227 201 160 224 246 228 83 220 206 63 90 63		"80-8F"		63 212 213 210 211 165 208 209 247 170 115 221 207 63 122 217		"90-9F"		202 193 162 163 63 180 124 164 172 169 187 199 194 45 168 248	 	"A0-AF"		161 177 50 51 171 181 166 225 252 49 188 200 63 63 63 192 			"B0-BF"		203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 	"C0-CF"		63 132 241 238 239 205 133 42 175 244 242 243 134 89 63 167	 	"D0-DF"		136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149		"E0-EF"		63 150 152 151 153 155 154 214 191 157 156 158 159 121 63 216		"F0-FF"	) at: value - 127)! !!Character methodsFor: 'converting' stamp: 'bf 3/9/2000 16:52'!squeakToIso	"Convert from mac to iso8895-1 encoding. Does not do lf/cr conversion!!"	value < 128 ifTrue: [^self].	^ Character value: (#(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 185 176 162 163 167 130 182 223 174 169 142 180 168 173 198 216 141 177 178 179 165 181 166 183 184 160 188 170 186 189 230 248 191 161 172 146 128 129 140 171 187 131 190 192 195 213 145 147 208 132 150 148 149 144 247 215 255 221 152 151 134 153 222 164 136 135 137 139 138 194 202 193 203 200 205 206 207 204 211 212 240 210 218 219 217 155 154 133 143 157 156 158 159 253 254 175) at: value - 127)! !!Character methodsFor: 'converting'!to: other	"Answer with a collection in ascii order -- $a to: $z"	^ (self asciiValue to: other asciiValue) collect:				[:ascii | Character value: ascii]! !!Character methodsFor: 'object fileIn' stamp: 'tk 1/17/2000 11:27'!comeFullyUpOnReload: smartRefStream	"Use existing an Character.  Don't use the new copy."	^ self class value: value! !!Character methodsFor: 'object fileIn' stamp: 'tk 2/16/2001 14:52'!objectForDataStream: refStrm	"I am being collected for inclusion in a segment.  Do not include Characters!!  Let them be in outPointers."	refStrm insideASegment		ifFalse: ["Normal use" ^ self]		ifTrue: ["recording objects to go into an ImageSegment"						"remove it from references.  Do not trace."			refStrm references removeKey: self ifAbsent: [].			^ nil]! !!Character methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:15'!escapeEntities	#($< '&lt;' $> '&gt;' $& '&amp;') pairsDo:		[:k :v |		self = k ifTrue: [^ v]].	^ String with: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Character class	instanceVariableNames: ''!!Character class methodsFor: 'class initialization' stamp: 'dgd 8/24/2003 14:47'!initialize	"Create the table of unique Characters."	self initializeClassificationTable! !!Character class methodsFor: 'class initialization' stamp: 'dgd 8/24/2003 15:10'!initializeClassificationTable	"	Initialize the classification table. The classification table is a	compact encoding of upper and lower cases of characters with		- bits 0-7: The lower case value of this character.		- bits 8-15: The upper case value of this character.		- bit 16: lowercase bit (e.g., isLowercase == true)		- bit 17: uppercase bit (e.g., isUppercase == true)	"	| ch1 ch2 |	LowercaseBit := 1 bitShift: 16.	UppercaseBit := 1 bitShift: 17.	"Initialize the letter bits (e.g., isLetter == true)"	LetterBits := LowercaseBit bitOr: UppercaseBit.	ClassificationTable := Array new: 256.	"Initialize the defaults (neither lower nor upper case)"	0 to: 255 do:[:i|		ClassificationTable at: i+1 put: (i bitShift: 8) + i.	].	"Initialize character pairs (upper-lower case)"	#(		"Basic roman"		($A $a) 	($B $b) 	($C $c) 	($D $d) 		($E $e) 	($F $f) 	($G $g) 	($H $h) 		($I $i) 		($J $j) 		($K $k) 	($L $l) 		($M $m)	($N $n)	($O $o)	($P $p) 		($Q $q) 	($R $r) 	($S $s) 	($T $t) 		($U $u)	($V $v)	($W $w)	($X $x)		($Y $y)	($Z $z)		"International"		($ $)	($ $)	($ $)	($ $)		($ $)	($ $)	($ $)	($ $)		($ $)	($ $)	($ $)	($ $)		"International - Spanish"		($ $)	($ $)		($ $)	($ $)		"International - PLEASE CHECK"		($ $)	($ $)		($ $)	($ $)		($ $)	($ $)		($ $)	($ $)	($ $)	($ $)	($ $)	) do:[:pair|		ch1 := pair first asciiValue.		ch2 := pair last asciiValue.		ClassificationTable at: ch1+1 put: (ch1 bitShift: 8) + ch2 + UppercaseBit.		ClassificationTable at: ch2+1 put: (ch1 bitShift: 8) + ch2 + LowercaseBit.	].	"Initialize a few others for which we only have lower case versions."	#($ $ $ $) do:[:char|		ch1 := char asciiValue.		ClassificationTable at: ch1+1 put: (ch1 bitShift: 8) + ch1 + LowercaseBit.	].! !!Character class methodsFor: 'instance creation' stamp: 'ls 8/15/1998 06:56'!allCharacters	^ (0 to: 255)		collect: [:v | Character value: v]	! !!Character class methodsFor: 'instance creation'!digitValue: x 	"Answer the Character whose digit value is x. For example, answer $9 for 	x=9, $0 for x=0, $A for x=10, $Z for x=35."	| index |	index _ x asInteger.	^CharacterTable at: 		(index < 10			ifTrue: [48 + index]			ifFalse: [55 + index])		+ 1! !!Character class methodsFor: 'instance creation'!new	"Creating new characters is not allowed."	self error: 'cannot create new characters'! !!Character class methodsFor: 'instance creation'!separators	^ #(32 "space"		13 "cr"		9 "tab"		10 "line feed"		12 "form feed")		collect: [:v | Character value: v]	! !!Character class methodsFor: 'instance creation'!value: anInteger 	"Answer the Character whose value is anInteger."	^CharacterTable at: anInteger + 1! !!Character class methodsFor: 'accessing untypeable characters'!backspace	"Answer the Character representing a backspace."	^self value: 8! !!Character class methodsFor: 'accessing untypeable characters'!cr	"Answer the Character representing a carriage return."	^self value: 13! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:19'!delete	^ self value: 127! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:21'!end	^ self value: 4! !!Character class methodsFor: 'accessing untypeable characters'!enter	"Answer the Character representing enter."	^self value: 3! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'sma 3/15/2000 22:33'!euro	"The Euro currency sign, that E with two dashes. The key code is a wild guess"	^ Character value: 219! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:21'!home	^ self value: 1! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:19'!insert	^ self value: 5! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/8/1998 22:15'!lf	"Answer the Character representing a linefeed."	^self value: 10! !!Character class methodsFor: 'accessing untypeable characters'!linefeed	"Answer the Character representing a linefeed."	^self value: 10! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'sma 3/11/2000 20:47'!nbsp	"non-breakable space."	^ Character value: 202! !!Character class methodsFor: 'accessing untypeable characters'!newPage	"Answer the Character representing a form feed."	^self value: 12! !!Character class methodsFor: 'accessing untypeable characters'!space	"Answer the Character representing a space."	^self value: 32! !!Character class methodsFor: 'accessing untypeable characters'!tab	"Answer the Character representing a tab."	^self value: 9! !!Character class methodsFor: 'constants' stamp: 'rhi 9/8/2000 14:57'!alphabet	"($a to: $z) as: String"	^ 'abcdefghijklmnopqrstuvwxyz' copy! !!Character class methodsFor: 'constants'!characterTable	"Answer the class variable in which unique Characters are stored."	^CharacterTable! !Rectangle subclass: #CharacterBlock	instanceVariableNames: 'stringIndex text textLine'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!CharacterBlock commentStamp: '<historical>' prior: 0!My instances contain information about displayed characters. They are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the instance obsolete.!!CharacterBlock methodsFor: 'accessing' stamp: 'di 6/7/2000 17:33'!copy	"Overridden because Rectangle does a deepCopy, which goes nuts with the text"	^ self clone! !!CharacterBlock methodsFor: 'accessing'!stringIndex	"Answer the position of the receiver in the string it indexes."	^stringIndex! !!CharacterBlock methodsFor: 'comparing'!< aCharacterBlock 	"Answer whether the string index of the receiver precedes that of 	aCharacterBlock."	^stringIndex < aCharacterBlock stringIndex! !!CharacterBlock methodsFor: 'comparing'!<= aCharacterBlock 	"Answer whether the string index of the receiver does not come after that 	of aCharacterBlock."	^(self > aCharacterBlock) not! !!CharacterBlock methodsFor: 'comparing'!= aCharacterBlock	self species = aCharacterBlock species		ifTrue: [^stringIndex = aCharacterBlock stringIndex]		ifFalse: [^false]! !!CharacterBlock methodsFor: 'comparing'!> aCharacterBlock 	"Answer whether the string index of the receiver comes after that of 	aCharacterBlock."	^aCharacterBlock < self! !!CharacterBlock methodsFor: 'comparing'!>= aCharacterBlock 	"Answer whether the string index of the receiver does not precede that of 	aCharacterBlock."	^(self < aCharacterBlock) not! !!CharacterBlock methodsFor: 'comparing' stamp: 'th 9/17/2002 11:54'!max: aCharacterBlock	aCharacterBlock ifNil:[^self].	^aCharacterBlock > self		ifTrue:[ aCharacterBlock]		ifFalse:[self].! !!CharacterBlock methodsFor: 'comparing' stamp: 'th 9/17/2002 11:54'!min: aCharacterBlock	aCharacterBlock ifNil:[^self].	^aCharacterBlock < self		ifTrue:[ aCharacterBlock]		ifFalse:[self].! !!CharacterBlock methodsFor: 'printing' stamp: 'di 12/2/97 19:15'!printOn: aStream	aStream nextPutAll: 'a CharacterBlock with index '.	stringIndex printOn: aStream.	(text ~~ nil and: [text size> 0 and: [stringIndex between: 1 and: text size]])		ifTrue: [aStream nextPutAll: ' and character '.				(text at: stringIndex) printOn: aStream].	aStream nextPutAll: ' and rectangle '.	super printOn: aStream.	textLine ifNotNil: [aStream cr; nextPutAll: ' in '.				textLine printOn: aStream].! !!CharacterBlock methodsFor: 'private'!moveBy: aPoint 	"Change the corner positions of the receiver so that its area translates by 	the amount defined by the argument, aPoint."	origin _ origin + aPoint.	corner _ corner + aPoint! !!CharacterBlock methodsFor: 'private' stamp: 'di 10/23/97 22:33'!stringIndex: anInteger text: aText topLeft: topLeft extent: extent	stringIndex _ anInteger.	text _ aText.	super setOrigin: topLeft corner: topLeft + extent ! !CharacterScanner subclass: #CharacterBlockScanner	instanceVariableNames: 'characterPoint characterIndex lastCharacter lastCharacterExtent lastSpaceOrTabExtent nextLeftMargin specialWidth'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!CharacterBlockScanner commentStamp: '<historical>' prior: 0!My instances are used to scan text to compute the CharacterBlock for a character specified by its index in the text or its proximity to the cursor location.!!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'RAA 2/25/2001 14:55'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex _ characterIndex.			characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab _ true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab _ false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:51'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad _ 0.	spaceCount _ spaceCount + 1.	pad _ line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex _ lastIndex + 1.	destX _ destX + lastSpaceOrTabExtent x.	^ false! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:32'!setFont	specialWidth _ nil.	super setFont! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	alignment = Justified ifTrue:[		"Make a local copy of stop conditions so we don't modify the default"		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!tab	| currentX |	currentX _ (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent _ lastSpaceOrTabExtent copy.			^ self crossedX].	destX _ currentX.	lastIndex _ lastIndex + 1.	^false! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 12/19/2001 11:24'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1 alignment: (alignment ifNil:[textStyle alignment]))								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment])).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1 alignment: (alignment ifNil:[textStyle alignment]).	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop _ line last  "characterBlockAtPoint"]		ifFalse:	[lineStop _ characterIndex  "characterBlockForIndex"].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	self handleIndentation.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!characterPointSetX: xVal	characterPoint _ xVal @ characterPoint y! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastCharacterExtentSetX: xVal	lastCharacterExtent _ xVal @ lastCharacterExtent y! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent _ xVal @ lastSpaceOrTabExtent y! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint _ aPoint.	^self buildCharacterBlockIn: aParagraph! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex _ targetIndex.	characterPoint _ 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'hmm 2/2/2001 15:07'!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin _ leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin _ textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 12/16/2001 19:27'!placeEmbeddedObject: anchoredMorph	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth _ anchoredMorph width.	^ true! !Object subclass: #CharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks'	classVariableNames: 'DefaultStopConditions'	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!CharacterScanner commentStamp: '<historical>' prior: 0!My instances hold the state associated with scanning text. My subclasses scan characters for specified purposes, such as computing a CharacterBlock or placing characters into Forms.!!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addKern: kernDelta	"Set the current kern amount."	kern _ kern + kernDelta! !!CharacterScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:13'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text _ aParagraph text.	textStyle _ aParagraph textStyle. ! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont! !!CharacterScanner methodsFor: 'private' stamp: 'ar 12/15/2001 23:31'!setAlignment: style	alignment _ style.	! !!CharacterScanner methodsFor: 'private' stamp: 'di 9/3/2000 13:47'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont _ font.	text == nil ifFalse:[		emphasisCode _ 0.		kern _ 0.		indentationLevel _ 0.		alignment _ textStyle alignment.		font _ nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font _ font emphasized: emphasisCode.	priorFont ifNotNil: [destX _ destX + priorFont descentKern].	destX _ destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX _ destX max: leftMargin].	kern _ kern - font baseKern.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions.! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!setFont: fontNumber	"Set the font by number from the textStyle."	self setActualFont: (textStyle fontAt: fontNumber)! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!text: t textStyle: ts	text _ t.	textStyle _ ts! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!textColor: ignored	"Overridden in DisplayScanner"! !!CharacterScanner methodsFor: 'scanning' stamp: 'RAA 5/4/2001 13:53'!columnBreak	^true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/17/2001 01:50'!embeddedObject	| savedIndex |	savedIndex _ lastIndex.	text attributesAt: lastIndex do:[:attr| 		attr anchoredMorph ifNotNil:[			"Following may look strange but logic gets reversed.			If the morph fits on this line we're not done (return false for true) 			and if the morph won't fit we're done (return true for false)"			(self placeEmbeddedObject: attr anchoredMorph) ifFalse:[^true]]].	lastIndex _ savedIndex + 1. "for multiple(!!) embedded morphs"	^false! !!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/15/2000 22:40'!handleIndentation	self indentationLevel timesRepeat: [		self plainTab]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 18:20'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel ifNil:[0]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!leadingTab	"return true if only tabs lie to the left"	line first to: lastIndex do:		[:i | (text at: i) == Tab ifFalse: [^ false]].	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/31/2001 00:52'!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX _ destY _ lastIndex _ 0.	xTable _ aFont xTable.	map _ aFont characterToGlyphMap.	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/16/2001 19:27'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	destX _ destX + (w _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/15/2001 23:28'!plainTab	"This is the basic method of adjusting destX for a tab."	destX _ (alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/17/2001 02:08'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'initialize' stamp: 'ls 1/14/2002 21:26'!initialize	destX _ destY _ leftMargin _ 0.! !!CharacterScanner methodsFor: 'initialize' stamp: 'ar 12/31/2001 00:52'!initializeStringMeasurer	stopConditions _ Array new: 258.	stopConditions at: CrossedX put: #crossedX.	stopConditions at: EndOfRun put: #endOfRun.! !!CharacterScanner methodsFor: 'accessing' stamp: 'ssa 8/19/2008 21:15'!destX: x	destX := x! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CharacterScanner class	instanceVariableNames: ''!!CharacterScanner class methodsFor: 'class initialization' stamp: 'ar 12/17/2001 02:17'!initialize	"CharacterScanner initialize"	"NewCharacterScanner initialize"	| stopConditions |	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	stopConditions at: 1+1 put: #embeddedObject.	stopConditions at: Space asciiValue + 1 put: nil.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX.	DefaultStopConditions _ stopConditions.! !Collection subclass: #CharacterSet	instanceVariableNames: 'map'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!CharacterSet commentStamp: '<historical>' prior: 0!A set of characters.  Lookups for inclusion are very fast.!!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:33'!add: aCharacter	map at: aCharacter asciiValue+1  put: 1.! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:41'!do: aBlock	"evaluate aBlock with each character in the set"	Character allCharacters do: [ :c |		(self includes: c) ifTrue: [ aBlock value: c ] ]! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:31'!includes: aCharacter	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:34'!remove: aCharacter	map at: aCharacter asciiValue + 1  put: 0! !!CharacterSet methodsFor: 'conversion' stamp: 'ls 8/17/1998 20:39'!complement	"return a character set containing precisely the characters the receiver does not"	| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'comparison' stamp: 'tk 7/5/2001 21:58'!= anObject	^self species == anObject species and: [		self byteArrayMap = anObject byteArrayMap ]! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!hash	^self byteArrayMap hash! !!CharacterSet methodsFor: 'comparison' stamp: 'tk 7/5/2001 21:57'!species	^CharacterSet! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:35'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^map! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map _ ByteArray new: 256 withAll: 0.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CharacterSet class	instanceVariableNames: ''!!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set _ self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:36'!empty 	"return an empty set of characters"	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 1/3/1999 12:52'!newFrom: aCollection	| newCollection |	newCollection _ self new.	newCollection addAll: aCollection.	^newCollection! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set _ self empty.	set addAll: Character separators.	^set! !SharedPool subclass: #ChronologyConstants	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'DayNames DaysInMonth MonthNames NanosInMillisecond NanosInSecond SecondsInDay SecondsInHour SecondsInMinute SqueakEpoch'	poolDictionaries: ''	category: 'Kernel-Chronology'!!ChronologyConstants commentStamp: 'brp 3/12/2004 14:34' prior: 0!ChronologyConstants is a SharedPool for the constants used by the Kernel-Chronology classes.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChronologyConstants class	instanceVariableNames: ''!!ChronologyConstants class methodsFor: 'as yet unclassified' stamp: 'brp 9/25/2003 10:49'!initialize
	"ChronologyConstants initialize" 	SqueakEpoch _ 2415386. 		"Julian day number of 1 Jan 1901" 
	SecondsInDay _ 86400.
	SecondsInHour _ 3600.
	SecondsInMinute _ 60.
	NanosInSecond _ 10 raisedTo: 9.
	NanosInMillisecond _ 10 raisedTo: 6.
	DayNames _ #(Sunday Monday Tuesday Wednesday Thursday Friday Saturday).
		
	MonthNames _ #(January February March April May June July
 			August September October November December).
	DaysInMonth _ #(31 28 31 30 31 30 31 31 30 31 30 31).
! !Arc subclass: #Circle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!Circle commentStamp: '<historical>' prior: 0!I represent a full circle. I am made from four Arcs.!!Circle methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	1 to: 4 do:		[:i |		super quadrant: i.		super displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Circle methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	1 to: 4 do:		[:i |		super quadrant: i.		super displayOn: aDisplayMedium			transformation: aTransformation			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Circle methodsFor: 'display box access'!computeBoundingBox	^center - radius + form offset extent: form extent + (radius * 2) asPoint! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Circle class	instanceVariableNames: ''!!Circle class methodsFor: 'examples'!exampleOne 	"Click any button somewhere on the screen. The point will be the center	of the circcle of radius 150."	| aCircle aForm |	aForm _ Form extent: 1@30.	aForm fillBlack.	aCircle _ Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display		"Circle exampleOne"! !!Circle class methodsFor: 'examples'!exampleTwo	"Designate a rectangular area that should be used as the brush for	displaying the circle. Click any button at a point on the screen which	will be the center location for the circle. The curve will be displayed	with a long black form."	| aCircle aForm |	aForm _ Form fromUser.	aCircle _ Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display at: 0 @ 0 rule: Form reverse 	 "Circle exampleTwo"! !ClassDescription subclass: #Class	instanceVariableNames: 'subclasses name classPool sharedPools environment category'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!Class commentStamp: '<historical>' prior: 0!I add a number of facilities to those in ClassDescription:	A set of all my subclasses (defined in ClassDescription, but only used here and below)	A name by which I can be found in a SystemDictionary	A classPool for class variables shared between this class and its metaclass	A list of sharedPools which probably should be supplanted by some better mechanism.My instances describe the representation and behavior of objects. I add more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.The slot 'subclasses' is a redundant structure.  It is never used during execution, but is used by the development system to simplify or speed certain operations.  !!Class methodsFor: 'initialize-release' stamp: 'hg 10/30/2001 13:38'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'initialize-release' stamp: 'ar 5/17/2003 14:14'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |	newVars _ 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first isLowercase			ifTrue: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts _ false.	classPool == nil 		ifFalse: [(classPool keys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) notNil				ifTrue: 					[self error: var , ' is defined elsewhere'.					conflicts _ true]].	newVars size > 0		ifTrue: 			[classPool _ self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !!Class methodsFor: 'initialize-release' stamp: 'ar 9/10/1999 17:34'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue:[^self error:'Object is NOT obsolete'].	name _ 'AnObsolete' , name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	classPool _ nil.	sharedPools _ nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'ar 3/1/2001 22:28'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'initialize-release' stamp: 'NS 1/16/2004 15:16'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'sd 3/28/2003 16:09'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools found |	oldPools _ self sharedPools.	sharedPools _ OrderedCollection new.	(Scanner new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (self environment at: poolName asSymbol ifAbsent:[			(self confirm: 'The pool dictionary ', poolName,' does not exist.',						'\Do you want it automatically created?' withCRs)				ifTrue:[self environment at: poolName asSymbol put: Dictionary new]				ifFalse:[^self error: poolName,' does not exist']])].	sharedPools isEmpty ifTrue: [sharedPools _ nil].	oldPools do: [:pool | found _ false.				self sharedPools do: [:p | p == pool ifTrue: [found _ true]].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!Class methodsFor: 'initialize-release' stamp: 'NS 4/6/2004 15:32'!superclass: sup methodDict: md format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ sup.	methodDict _ md.	format _ ft.	name _ nm.	instanceVariables _ nilOrArray.	classPool _ pool.	sharedPools _ poolSet.	self organization: org.! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/20/1999 11:23'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	subclasses _ nil. "Important for moving down the subclasses field into Class"! !!Class methodsFor: 'initialize-release' stamp: 'hg 12/12/2001 12:00'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'accessing'!classPool	"Answer the dictionary of class variables."	classPool == nil		ifTrue: [^Dictionary new]		ifFalse: [^classPool]! !!Class methodsFor: 'accessing'!name	"Answer the name of the receiver."	name == nil		ifTrue: [^super name]		ifFalse: [^name]! !!Class methodsFor: 'testing'!hasMethods	"Answer a Boolean according to whether any methods are defined for the 	receiver (includes whether there are methods defined in the receiver's 	metaclass)."	^super hasMethods or: [self class hasMethods]! !!Class methodsFor: 'testing' stamp: 'ar 7/15/1999 15:36'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent:[nil]) ~~ self! !!Class methodsFor: 'testing' stamp: 'tk 8/12/1999 15:47'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'testing' stamp: 'tk 8/12/1999 15:49'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'copying' stamp: 'di 2/17/2000 22:43'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'class name' stamp: 'sw 12/1/2000 20:39'!externalName	"Answer a name by which the receiver can be known."	^ name! !!Class methodsFor: 'class name' stamp: 'sw 12/18/2000 15:50'!nameForViewer	"Answer the name to be shown in the header of a viewer looking at the receiver"	^ self name ifNil: ['Unnamed class']! !!Class methodsFor: 'class name' stamp: 'NS 1/15/2004 15:41'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName _ aString asSymbol) ~= self name		ifFalse: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	self environment renameClass: self as: newName.	name _ newName! !!Class methodsFor: 'class name' stamp: 'sw 12/1/2000 20:40'!uniqueNameForReference	"Answer a unique name by which the receiver can be referred to from user scripts, for example"	^ name! !!Class methodsFor: 'instance variables' stamp: 'sw 12/26/2003 19:30'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: self instanceVariablesString, ' ', aString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'class variables' stamp: 'NS 1/27/2004 14:19'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol oldState |	oldState _ self copy.	aString first isLowercase		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		(subclass bindingOf: symbol) ifNotNil:[			^ self error: aString 				, ' is already used as a variable name in class ' 				, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		classPool declare: symbol from: Undeclared.		SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: oldState to: self]! !!Class methodsFor: 'class variables'!allClassVarNames	"Answer a Set of the names of the receiver's class variables, including those	defined in the superclasses of the receiver."	| aSet |	superclass == nil		ifTrue: 			[^self classVarNames]  "This is the keys so it is a new Set."		ifFalse: 			[aSet _ superclass allClassVarNames.			aSet addAll: self classVarNames.			^aSet]! !!Class methodsFor: 'class variables'!classVarNames	"Answer a Set of the names of the class variables defined in the receiver."	^self classPool keys! !!Class methodsFor: 'class variables' stamp: 'jm 7/24/1999 12:58'!removeClassVarName: aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| aSymbol |	aSymbol _ aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:subclass |		(Array with: subclass with: subclass class) do:[:classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				isEmpty ifFalse: [					(self confirm: (aString,' is still used in code of class ', classOrMeta name,						'.\Is it okay to move it to Undeclared?') withCRs)						ifTrue:[^Undeclared declare: aSymbol from: classPool]						ifFalse:[^self]]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [classPool _ nil].! !!Class methodsFor: 'pool variables'!allSharedPools	"Answer a Set of the pools the receiver shares, including those defined  	in the superclasses of the receiver."	| aSet | 	^ superclass == nil		ifTrue: [self sharedPools copy]		ifFalse: [aSet _ superclass allSharedPools.			aSet addAll: self sharedPools.			aSet]! !!Class methodsFor: 'pool variables'!sharedPools	"Answer a Set of the pool dictionaries declared in the receiver."	sharedPools == nil		ifTrue: [^OrderedCollection new]		ifFalse: [^sharedPools]! !!Class methodsFor: 'compiling' stamp: 'ar 5/17/2003 14:06'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"Next look in declared environment."	binding := self environment bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ nil]		ifFalse: [^ superclass bindingOf: aSymbol].! !!Class methodsFor: 'compiling' stamp: 'ar 7/14/1999 04:56'!compileAll	super compileAll.	self class compileAll.! !!Class methodsFor: 'compiling'!compileAllFrom: oldClass	"Recompile all the methods in the receiver's method dictionary (not the	subclasses). Also recompile the methods in the metaclass."	super compileAllFrom: oldClass.	self class compileAllFrom: oldClass class! !!Class methodsFor: 'compiling' stamp: 'sd 3/28/2003 15:24'!possibleVariablesFor: misspelled continuedFrom: oldResults	| results |	results _ misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.	self sharedPools do: [:pool | 		results _ misspelled correctAgainstDictionary: pool continuedFrom: results ].	superclass == nil		ifTrue: 			[ ^ misspelled correctAgainstDictionary: self environment continuedFrom: results ]		ifFalse:			[ ^ superclass possibleVariablesFor: misspelled continuedFrom: results ]! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:57'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	^(ClassBuilder new)		superclass: self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:57'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'dwh 11/20/1999 23:44'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 09:58'!fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	^ self fileOutAsHtml: false! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 3/7/2001 13:57'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name, FileDirectory dot, 'html') asHtml]		ifFalse: [FileStream newFileNamed: self name, FileDirectory dot, 'st'].	fileStream header; timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream trailer; close.	"DeepCopier new checkVariables."! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:32'!fileOutInitializerOn: aStream	^self class fileOutInitializerOn: aStream! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:30'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: true! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:29'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."	Transcript cr; show: name.	super		fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	self class nonTrivial		ifTrue:			[aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self class				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex				initializing: aBool]! !!Class methodsFor: 'fileIn/Out' stamp: 'tpr 5/30/2003 13:01'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName _ self environment keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :aKey |		aValue _ aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!Class methodsFor: 'fileIn/Out' stamp: 'sd 3/28/2003 15:24'!fileOutSharedPoolsOn: aFileStream	"file out the shared pools of this class after prompting the user about each pool"	| poolsToFileOut |	poolsToFileOut _ self sharedPools select: 		[:aPool | (self shouldFileOutPool: (self environment keyAtIdentityValue: aPool))].	poolsToFileOut do: [:aPool | self fileOutPool: aPool onFileStream: aFileStream].	! !!Class methodsFor: 'fileIn/Out'!shouldFileOutPool: aPoolName	"respond with true if the user wants to file out aPoolName"	^self confirm: ('FileOut the sharedPool ', aPoolName, '?')! !!Class methodsFor: 'fileIn/Out'!shouldFileOutPools	"respond with true if the user wants to file out the shared pools"	^self confirm: 'FileOut selected sharedPools?'! !!Class methodsFor: 'accessing class hierarchy' stamp: 'tk 10/17/1999 13:31'!addSubclass: aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [^self error: aSubclass name , ' is not my subclass'].	subclasses == nil		ifTrue:	[subclasses _ Array with: aSubclass.				^self].	subclasses do:[:cl| cl == aSubclass ifTrue:[^self]]. "Already my subclass"	subclasses _ subclasses copyWith: aSubclass.! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:54'!removeSubclass: aSubclass 	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."	subclasses == nil ifFalse:		[subclasses _  subclasses copyWithout: aSubclass.		subclasses isEmpty ifTrue: [subclasses _ nil]].! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 11:00'!subclasses	"Answer a Set containing the receiver's subclasses."	^subclasses == nil		ifTrue: [#()]		ifFalse: [subclasses copy]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 11:00'!subclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil 		ifFalse:[subclasses do: aBlock]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'tk 8/18/1999 17:42'!subclassesDoGently: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil 		ifFalse: [subclasses do: aBlock]! !!Class methodsFor: 'private' stamp: 'ar 7/15/1999 15:37'!setName: aSymbol	"Private - set the name of the class"	name _ aSymbol.! !!Class methodsFor: 'organization' stamp: 'di 11/16/1999 16:25'!environment	environment == nil ifTrue: [^ super environment].	^ environment! !!Class methodsFor: 'organization' stamp: 'di 12/23/1999 11:42'!environment: anEnvironment	environment _ anEnvironment! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Class class	instanceVariableNames: ''!!Class class methodsFor: 'instance creation' stamp: 'di 6/7/2000 22:01'!template: aSystemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class."	^ self templateForSubclassOf: Object name category: aSystemCategoryName ! !!Class class methodsFor: 'instance creation' stamp: 'di 6/7/2000 21:57'!templateForSubclassOf: priorClassName category: systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	Preferences printAlternateSyntax 		ifTrue: [^ priorClassName asString, ' subclass (#NameOfSubclass)	instanceVariableNames ('''')	classVariableNames ('''')	poolDictionaries ('''')	category (''' , systemCategoryName asString , ''')']		ifFalse: [^ priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , '''']! !Object subclass: #ClassBuilder	instanceVariableNames: 'environ classMap instVarMap progress maxClassIndex currentClassIndex'	classVariableNames: 'QuietMode'	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassBuilder commentStamp: 'ar 2/27/2003 22:55' prior: 0!Responsible for creating a new class or changing the format of an existing class (from a class definition in a browser or a fileIn). This includes validating the definition, computing the format of instances, creating or modifying the accompanying Metaclass, setting up the class and metaclass objects themselves, registering the class as a global, recompiling methods, modifying affected subclasses, mutating existing instances to the new format, and more.You typically only need to use or modify this class, or even know how it works, when making fundamental changes to how the Smalltalk system and language works.Implementation notes:ClassBuilder relies on the assumption that it can see ALL subclasses of some class. If there are any existing subclasses of some class, regardless of whether they have instances or not, regardless of whether they are considered obsolete or not, ClassBuilder MUST SEE THEM.!!ClassBuilder methodsFor: 'initialize' stamp: 'ar 3/3/2001 00:29'!doneCompiling: aClass	"The receiver has finished modifying the class hierarchy.	Do any necessary cleanup."	aClass doneCompiling.	Behavior flushObsoleteSubclasses.! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 8/29/1999 12:32'!initialize	environ _ Smalltalk.	instVarMap _ IdentityDictionary new.! !!ClassBuilder methodsFor: 'class definition' stamp: 'NS 1/21/2004 09:20'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass needNew copyOfOldClass |	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass or not"	needNew _ self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.	needNew ifNil:[^nil]. "some error"	needNew ifFalse:[^oldClass]. "no new class needed"	"Create the new class"	copyOfOldClass _ oldClass copy.	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass.			newClass _ self recompile: false from: oldClass to: newClass mutate: false.	self doneCompiling: newClass.	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:34'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category	"Define a new class in the given environment"	^self 		name: className 		inEnvironment: env 		subclassOf: newSuper 		type: type 		instanceVariableNames: instVarString 		classVariableNames: classVarString 		poolDictionaries: poolString 		category: category		unsafe: false! !!ClassBuilder methodsFor: 'class definition' stamp: 'NS 1/20/2004 19:46'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	copyOfOldClass _ oldClass copy.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined!! \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass _ self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass _ oldClass.	].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory _ category asSymbol.	organization _ environ ifNotNil:[environ organization].	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory.	newClass environment: environ.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	self doneCompiling: newClass.		"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 02:57'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	| newFormat |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	newFormat = oldClass format ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 2/27/2003 22:56'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newFormat newClass |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass _ self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass _ oldClass clone].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'NS 1/21/2004 09:53'!recompile: force from: oldClass to: newClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	oldClass == nil ifTrue:[^ newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		self mutate: oldClass to: newClass.	].	^oldClass "now mutated to newClass"! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 9/10/1999 12:55'!computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex	"Compute the new format for making oldClass a subclass of newSuper.	Return the format or nil if there is any problem."	| instSize isVar isWords isPointers isWeak |	instSize _ newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).	instSize > 254 ifTrue:[		self error: 'Class has too many instance variables (', instSize printString,')'.		^nil].	type == #compiledMethod		ifTrue:[^CompiledMethod instSpec].	type == #normal ifTrue:[isVar _ isWeak _ false. isWords _ isPointers _ true].	type == #bytes ifTrue:[isVar _ true. isWords _ isPointers _ isWeak _ false].	type == #words ifTrue:[isVar _ isWords _ true. isPointers _ isWeak _ false].	type == #variable ifTrue:[isVar _ isPointers _ isWords _ true. isWeak _ false].	type == #weak ifTrue:[isVar _ isWeak _ isWords _ isPointers _ true].	(isPointers not and:[instSize > 0]) ifTrue:[		self error:'A non-pointer class cannot have instance variables'.		^nil].	^(self format: instSize 		variable: isVar 		words: isWords 		pointers: isPointers 		weak: isWeak) + (ccIndex bitShift: 11).! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 7/11/1999 06:39'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Compute the format for the given instance specfication."	| cClass instSpec sizeHiBits fmt |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	fmt _ sizeHiBits.	fmt _ (fmt bitShift: 5) + cClass.	fmt _ (fmt bitShift: 4) + instSpec.	fmt _ (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	fmt _ (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"	^fmt! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/13/1999 05:26'!validateClassName: aString	"Validate the new class name"	aString first isUppercase ifFalse:[		self error: 'Class names must be capitalized'.		^false].	environ at: aString ifPresent:[:old|		(old isKindOf: Behavior) ifFalse:[			self notify: aString asText allBold, 						' already exists!!\Proceed will store over it.' withCRs]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:48'!validateClassvars: classVarArray from: oldClass forSuper: newSuper	"Check if any of the classVars of oldClass conflict with the new superclass"	| usedNames classVars temp |	classVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the class var names"	usedNames _ classVarArray asSet.	usedNames size = classVarArray size 		ifFalse:[	classVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allClassVarNames asSet.		classVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl classVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv, ' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl classVarNames].		classVars _ classVarArray.		newSuper == nil ifFalse:[classVars _ classVars, newSuper allClassVarNames asArray].		classVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ajh 10/17/2002 11:10'!validateInstvars: instVarArray from: oldClass forSuper: newSuper	"Check if any of the instVars of oldClass conflict with the new superclass"	| instVars usedNames temp |	instVarArray isEmpty ifTrue:[^true]. "Okay"	newSuper allowsSubInstVars ifFalse: [		self error: newSuper printString, ' does not allow subclass inst vars. See allowsSubInstVars.'. ^ false].	"Validate the inst var names"	usedNames _ instVarArray asSet.	usedNames size = instVarArray size 		ifFalse:[	instVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allInstVarNames asSet.		instVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl instVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv,' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].		instVars _ instVarArray.		newSuper == nil ifFalse:[instVars _ instVars, newSuper allInstVarNames].		instVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'bkv 4/2/2003 17:13'!validateSubclass: subclass canKeepLayoutFrom: oldClass forSubclassFormat: newType 	"Returns whether the immediate subclasses of oldClass can keep its layout"	"Note: Squeak does not appear to model classFormat relationships.. so I'm putting some logic here. bkv 4/2/2003"	 "isWeak implies isVariant"						 (oldClass isVariable and: [ subclass isWeak ])		ifFalse: [ "In general we discourage format mis-matches"				  (subclass typeOfClass == newType) 				   	ifFalse: [ self error: subclass name,' cannot be recompiled'.							  ^ false ]].	^ true! !!ClassBuilder methodsFor: 'validation' stamp: 'BG 1/5/2004 20:29'!validateSubclassFormat: newType from: oldClass forSuper: newSuper extra: newInstSize	"Validate the # of instVars and the format of the subclasses"	| deltaSize |	oldClass == nil ifTrue: [^ true]. "No subclasses"	"Compute the # of instvars needed for all subclasses"	deltaSize _ newInstSize.	(oldClass notNil)		ifTrue: [deltaSize _ deltaSize - oldClass instVarNames size].	(newSuper notNil)		ifTrue: [deltaSize _ deltaSize + newSuper instSize].	(oldClass notNil and: [oldClass superclass notNil]) 		ifTrue: [deltaSize _ deltaSize - oldClass superclass instSize].	(oldClass == nil)		 ifTrue: [ (deltaSize > 254)					ifTrue: [ self error: 'More than 254 instance variables'.							^ false].				  ^ true].	oldClass withAllSubclassesDo:	    [:sub |  ( sub instSize + deltaSize > 254 )					ifTrue: [ self error: sub name,' has more than 254 instance variables'.					 		^ false]		].	newType ~~ #normal ifTrue:		["And check if the immediate subclasses of oldClass can keep its layout"		 oldClass subclassesDo: [:sub |			 self validateSubclass: sub canKeepLayoutFrom: oldClass forSubclassFormat: newType]		].	^ true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:50'!validateSuperclass: aSuperClass forSubclass: aClass	"Check if it is okay to use aSuperClass as the superclass of aClass"	aClass == nil ifTrue:["New class"		(aSuperClass == nil or:[aSuperClass isBehavior and:[aSuperClass isMeta not]])			ifFalse:[self error: aSuperClass name,' is not a valid superclass'.					^false].		^true].	aSuperClass == aClass superclass ifTrue:[^true]. "No change"	(aClass isMeta) "Not permitted - meta class hierarchy is derived from class hierarchy"		ifTrue:[^self error: aClass name, ' must inherit from ', aClass superclass name].	"Check for circular references"	(aSuperClass ~~ nil and:[aSuperClass == aClass or:[aSuperClass inheritsFrom: aClass]])		ifTrue:[self error: aSuperClass name,' inherits from ', aClass name.				^false].	^true! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 13:03'!informUserDuring: aBlock	self class isSilent ifTrue:[^aBlock value].	Utilities informUserDuring:[:bar|		progress _ bar.		aBlock value].	progress _ nil.! !!ClassBuilder methodsFor: 'private' stamp: 'ar 2/27/2003 22:56'!privateNewSubclassOf: newSuper	"Create a new meta and non-meta subclass of newSuper"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta newMeta |	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	newMeta _ Metaclass new.	newMeta 		superclass: newSuperMeta 		methodDictionary: MethodDictionary new 		format: newSuperMeta format.	^newMeta new! !!ClassBuilder methodsFor: 'private' stamp: 'ar 2/27/2003 22:56'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: MethodDictionary new		format: (self computeFormat: oldMeta typeOfClass 					instSize: oldMeta instVarNames size 					forSuper: newSuperMeta					ccIndex: 0);		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'private' stamp: 'NS 1/27/2004 14:21'!recordClass: oldClass replacedBy: newClass	"Keep the changes up to date when we're moving instVars around"	(instVarMap includesKey: oldClass name) ifTrue:[		SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: oldClass to: newClass.	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 13:39'!reservedNames	"Return a list of names that must not be used for variables"	^#('self' 'super' 'thisContext' 'true' 'false' 'nil' 		self super thisContext true false nil).! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/5/2001 12:00'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	aClass isObsolete ifTrue:[^self].	currentClassIndex _ currentClassIndex + 1.	(aClass hasMethods and: [aClass wantsRecompilationProgressReported]) ifTrue:		[progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')]! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 15:43'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod TranslatedMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!ClassBuilder methodsFor: 'public' stamp: 'ar 8/29/1999 15:38'!class: oldClass instanceVariableNames: instVarString	"This is the basic initialization message to change the definition of	an existing Metaclass"	oldClass isMeta ifFalse:[^self error: oldClass name, 'is not a Metaclass'].	^self class: oldClass instanceVariableNames: instVarString unsafe: false! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: newSuper	subclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class."	^self 		name: t		inEnvironment: newSuper environment		subclassOf: newSuper		type: newSuper typeOfClass		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #bytes		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: aClass	variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #variable		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:30'!superclass: aClass	variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable word-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a word subclass of a class with named fields'].	(aClass isVariable and: [aClass isBytes])		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a word subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #words		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:30'!superclass: aClass	weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #weak		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 2/27/2003 22:44'!mutate: oldClass to: newClass	"Mutate the old class and subclasses into newClass and subclasses.	Note: This method is slightly different from: #mutate:toSuper: since	here we are at the root of reshaping and have two distinct roots."	| newSubclass |	self showProgressFor: oldClass.	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass| 		newSubclass _ self reshapeClass: oldSubclass toSuper: newClass.		self mutate: oldSubclass to: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			newSubclass _ self reshapeClass: oldSubclass toSuper: newClass.			self mutate: oldSubclass to: newSubclass.		].	].	self update: oldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 9/22/2002 03:16'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	"ar 9/22/2002: The following is a left-over from some older code. 	I do *not* know why we uncompact oldClass here. If you do, then 	please let me know so I can put a comment here..."	oldClass becomeUncompact.	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 2/27/2003 23:42'!update: oldClass to: newClass	"Convert oldClass, all its instances and possibly its meta class into newClass, instances of newClass and possibly its meta class. The process is surprisingly simple in its implementation and surprisingly complex in its nuances and potentially bad side effects. 	We can rely on two assumptions (which are critical):		#1: The method #updateInstancesFrom: will not create any lasting pointers to 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do a become of the old vs. the new instances and therefore it will not create pointers to *new* instances before the #become: which are *old* afterwards)		#2: The non-preemptive execution of the critical piece of code guarantees that nobody can get a hold by 'other means' (such as process interruption and reflection) on the old instances.	Given the above two, we know that after #updateInstancesFrom: there are no pointer to any old instances. After the forwarding become there will be no pointers to the old class or meta class either. Meaning that if we throw in a nice fat GC at the end of the critical block, everything will be gone (but see the comment right there). There's no need to worry.	"	| meta |	meta _ oldClass isMeta.	"Note: Everything from here on will run without the ability to get interrupted	to prevent any other process to create new instances of the old class."	[		"Note: The following removal may look somewhat obscure and needs an explanation. When we mutate the class hierarchy we create new classes for any existing subclass. So it may look as if we don't have to remove the old class from its superclass. However, at the top of the hierarchy (the first class we reshape) that superclass itself is not newly created so therefore it will hold both the oldClass and newClass in its (obsolete or not) subclasses. Since the #become: below will transparently replace the pointers to oldClass with newClass the superclass would have newClass in its subclasses TWICE. With rather unclear effects if we consider that we may convert the meta-class hierarchy itself (which is derived from the non-meta class hierarchy).		Due to this problem ALL classes are removed from their superclass just prior to converting them. Here, breaking the superclass/subclass invariant really doesn't matter since we will effectively remove the oldClass (become+GC) just a few lines below."		oldClass superclass removeSubclass: oldClass.		oldClass superclass removeObsoleteSubclass: oldClass.		"Convert the instances of oldClass into instances of newClass"		newClass updateInstancesFrom: oldClass.		meta			ifTrue:[oldClass becomeForward: newClass]			ifFalse:[(Array with: oldClass with: oldClass class)						elementsForwardIdentityTo:							(Array with: newClass with: newClass class)].		Smalltalk garbageCollect.		"Warning: Read this before you even think about removing the GC. Yes, it slows us down. Quite heavily if you have a large image. However, there's no good and simple alternative here, since unfortunately, #become: does change class pointers. What happens is that after the above become all of the instances of the old class will have a class pointer identifying them as instances of newClass. If we get our hands on any of these instances we will break immediately since their expected instance layout (that of its class, e.g., newClass) will not match their actual instance layout (that of oldClass). And getting your hands on any of those instances is really simple - just reshaping one class two times in rapid succession will do it. Reflection techniques, interrupts, etc. will only add to this problem. In the case of Metaclass things get even worse since when we recompile the entire class hierarchy we will recompile both, Metaclass and its instances (and some of its instances will have the old and some the new layout).		The only easy solution to this problem would be to 'fix up' the class pointers of the old instances to point to the old class (using primitiveChangeClassTo:). But this won't work either - as we do a one-way become we would have to search the entire object memory for the oldClass and couldn't even clearly identify it unless we give it some 'special token' which sounds quite error-prone. If you really need to get rid of the GC here are some alternatives:		On the image level, one could create a copy of the oldClass before becoming it into the new class and, after becoming it, 'fix up' the old instances. That would certainly work but it sounds quite complex, as we need to make sure we're not breaking any of the superclass/subclass meta/non-meta class variants.		Alternatively, fix up #becomeForward on the VM-level to 'dump the source objects' of #become. This would be quite doable (just 'convert' them into a well known special class such as bitmap) yet it has problems if (accidentally or not) one of the objects in #become: appears on 'both sides of the fence' (right now, this will work ... in a way ... even though the consequences are unclear).		Another alternative is to provide a dedicated primitive for this (instead of using it implicitly in become) which would allow us to dump all the existing instances right here. This is equivalent to a more general primitiveChangeClassTo: and might be worthwhile but it would likely have to keep in mind the differences between bits and pointer thingies etc.		Since all of the alternatives seem rather complex and magical compared to a straight-forward GC it seems best to stick with the GC solution for now. If someone has a real need to fix this problem, that person will likely be motivated enough to check out the alternatives. Personally I'd probably go for #1 (copy the old class and remap the instances to it) since it's a solution that could be easily reverted from within the image if there's any problem with it."	] valueUnpreemptively.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassBuilder class	instanceVariableNames: ''!!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:48'!isSilent	^QuietMode == true! !Object subclass: #ClassCategoryReader	instanceVariableNames: 'class category changeStamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassCategoryReader commentStamp: '<historical>' prior: 0!I represent a mechanism for retrieving class descriptions stored on a file.!!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'tk 12/15/97 16:26'!scanFrom: aStream 	"File in methods from the stream, aStream."	| methodText |	[methodText _ aStream nextChunkText.	 methodText size > 0]		whileTrue:		[class compile: methodText classified: category			withStamp: changeStamp			notifying: (SyntaxError new category: category)]! !!ClassCategoryReader methodsFor: 'private' stamp: '6/5/97 di'!setClass: aClass category: aCategory	^ self setClass: aClass category: aCategory changeStamp: String new! !!ClassCategoryReader methodsFor: 'private' stamp: '6/5/97 di'!setClass: aClass category: aCategory changeStamp: aString	class _ aClass.	category _ aCategory.	changeStamp _ aString! !!ClassCategoryReader methodsFor: 'private' stamp: 'ajh 1/18/2002 01:14'!theClass	^ class! !Object subclass: #ClassChangeRecord	instanceVariableNames: 'inForce revertable changeTypes thisDefinition priorDefinition thisName priorName thisOrganization priorOrganization thisComment priorComment thisMD priorMD methodChanges'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ClassChangeRecord commentStamp: '<historical>' prior: 0!A ClassChangeRecorder keeps track of most substantive changes premissible in a project, isolated or not.Structure:inForce		a boolean			Tells whether these changes are in effect.			true for all changeSets in and above the current project.			It should be sufficient only to record this for the changeSet			as a whole, but this redundancy could help in error recovery.classIsLocal	a boolean			True if and only if this class is defined in this layer of the			project structure.changeTypes an identitySet			Summarizes which changes have been made in this class.			Values include #comment, #reorganize, #rename,			and the four more summarized below.thisName	a string			Retains the class name for this layer.priorName	a string			Preserves the prior name.thisComment	a text			Retains the class comment for this layer.priorComment	a text			Preserves the prior comment.thisOrganization	a classOrganizer			Retains the class organization for this layer.priorOrganization	a classOrganizer			Preserves the prior organization.thisMD	a methodDictionary			Used to prepare changes for nearly atomic invocation			of this layer (see below).priorMD	a methodDictionary			Preserves the state of an altered class as it exists in the next			outer layer of the project structure.methodChanges		a dictionary of classChangeRecords			Retains all the method changes for this layer.Four of the possible changeTypes are maintained in a mutually exclusive set, analogously to MethodChangeRecords.  Here is a simple summary of the relationship between these four changeType symbols and the recording of prior state			|	prior == nil			|	prior not nil		---------	|----------------------------	|--------------------	add		|	add					|	change	---------	|----------------------------	|--------------------	remove	|	addedThenRemoved	|	removeA classChangeRecorder is notified of changes by the method		noteMethodChange: <ClassChangeRecord>.ClassChangeRecorders are designed to invoke a set of changes relative to the definition of a class in an prior layer.  It is important that both invocation and revocation of these changes take place in a nearly atomic fashion so that interdependent changes will be adopted as a whole, and so that only one flush of the method cache should be necessary.  A further reason for revocation to be simple is that it may be requested as an attempt to recover from an error in a project that is failing.!!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:39'!allChangeTypes	| chgs |	(priorName ~~ nil and: [changeTypes includes: #rename]) ifTrue:		[(chgs _ changeTypes copy) add: 'oldName: ' , priorName.		^ chgs].	^ changeTypes! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:59'!assimilateAllChangesIn: otherRecord	| selector changeRecord changeType |	otherRecord isClassRemoval ifTrue: [^ self noteChangeType: #remove].	otherRecord allChangeTypes do:		[:chg | self noteChangeType: chg fromClass: self realClass].	otherRecord methodChanges associationsDo:		[:assn | selector _ assn key. changeRecord _ assn value.		changeType _ changeRecord changeType.		(changeType == #remove or: [changeType == #addedThenRemoved])			ifTrue:				[changeType == #addedThenRemoved					ifTrue: [self atSelector: selector put: #add].				self noteRemoveSelector: selector priorMethod: nil						lastMethodInfo: changeRecord methodInfoFromRemoval]			ifFalse: 				[self atSelector: selector put: changeType]].! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 10:59'!hasNoChanges	^ changeTypes isEmpty and: [methodChanges isEmpty]! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/24/2000 09:36'!includesChangeType: changeType	changeType == #new ifTrue: [^ changeTypes includes: #add].  "Backwd compat"	^ changeTypes includes: changeType! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 15:14'!noteChangeType: changeSymbol	^ self noteChangeType: changeSymbol fromClass: nil! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'sw 4/3/2001 14:16'!noteChangeType: changeSymbol fromClass: class	(changeSymbol = #new or: [changeSymbol = #add]) ifTrue:		[changeTypes add: #add.		changeTypes remove: #change ifAbsent: [].		revertable _ false.		^ self].	changeSymbol = #change ifTrue:		[(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol == #addedThenRemoved ifTrue:		[^ self].  "An entire class was added but then removed"	changeSymbol = #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue:		["Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName _ changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	changeSymbol = #remove ifTrue:		[(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAllFoundIn: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 5/16/2000 08:43'!trimHistory	"Drop non-essential history."	"Forget methods added and later removed"	methodChanges keysAndValuesRemove:		[:sel :chgRecord | chgRecord changeType == #addedThenRemoved].	"Forget renaming and reorganization of newly-added classes."	(changeTypes includes: #add) ifTrue:		[changeTypes removeAllFoundIn: #(rename reorganize)].! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 22:00'!invokePhase1	| selector changeRecord type elements |	revertable ifFalse: [^ self].	inForce ifTrue: [self error: 'Can invoke only when not in force.'].	"Do the first part of the invoke operation -- no particular hurry."	"Save the outer method dictionary for quick revert of method changes."	priorMD _ self realClass methodDict.	"Prepare a methodDictionary for switcheroo."	thisMD _ self realClass methodDict copy.	methodChanges associationsDo:		[:assn | selector _ assn key. changeRecord _ assn value.		type _ changeRecord changeType.		type = #remove ifTrue: [thisMD removeKey: selector].		type = #add ifTrue: [thisMD at: selector put: changeRecord currentMethod].		type = #change ifTrue: [thisMD at: selector put: changeRecord currentMethod].		].	"Replace the original organization (and comment)."	priorOrganization _ self realClass organization.	thisOrganization elementArray copy do:		[:sel | (thisMD includesKey: sel) ifFalse: [thisOrganization removeElement: sel]].	#(DoIt DoItIn:) do: [:sel | thisMD removeKey: sel ifAbsent: []].	thisOrganization elementArray size = thisMD size ifFalse:		[elements _ thisOrganization elementArray asSet.		thisMD keysDo:			[:sel | (elements includes: sel) ifFalse:				[thisOrganization classify: sel					under: (priorOrganization categoryOfElement: sel)]]].	self realClass organization: thisOrganization.! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!invokePhase2	revertable ifFalse: [^ self].	"Do the second part of the revert operation.  This must be very simple."	"Replace original method dicts if there are method changes."	self realClass methodDictionary: thisMD.  "zap.  Must flush Cache in outer loop."	inForce _ true.! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/30/2000 18:03'!realClass	"Return the actual class (or meta), as determined from my name."	thisName ifNil: [^ nil].	(thisName endsWith: ' class')		ifTrue: [^ (Smalltalk at: (thisName copyFrom: 1 to: thisName size - 6) asSymbol						ifAbsent: [^ nil]) class]		ifFalse: [^ Smalltalk at: thisName ifAbsent: [^ nil]]! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!revokePhase1	revertable ifFalse: [^ self].	inForce ifFalse: [self error: 'Can revoke only when in force.'].	"Do the first part of the revoke operation.  This must be very simple."	"Replace original method dict if there are method changes."	self realClass methodDictionary: priorMD  "zap.  Must flush Cache in outer loop."! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!revokePhase2	revertable ifFalse: [^ self].	"Replace the original organization (and comment)."	thisOrganization _ self realClass organization.	self realClass organization: priorOrganization.	inForce _ false.! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:06'!checkCoherence	"If I recreate the class then don't remove it"	(changeTypes includes: #remove) ifTrue:		[changeTypes remove: #remove.		changeTypes add: #change].	(changeTypes includes: #addedThenRemoved) ifTrue:		[changeTypes remove: #addedThenRemoved.		changeTypes add: #add].! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:08'!notePriorDefinition: oldClass	oldClass ifNil: [^ self].	priorDefinition ifNil: [priorDefinition _ oldClass definition]! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/28/2000 09:12'!priorDefinition	^ priorDefinition! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 5/8/2000 20:39'!noteNewName: newName	thisName _ newName! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 3/24/2000 09:38'!priorName	^ priorName! !!ClassChangeRecord methodsFor: 'rename' stamp: 'tk 6/8/2001 09:11'!thisName	^ thisName! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 4/4/2000 12:49'!forgetChangesIn: otherRecord	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	| cls otherMethodChanges selector actionToSubtract |	(cls _ self realClass) == nil ifTrue: [^ self].  "We can do better now, though..."	otherMethodChanges _ otherRecord methodChangeTypes.	otherMethodChanges associationsDo:		[:assoc | selector _ assoc key. actionToSubtract _ assoc value.		(cls includesSelector: selector)			ifTrue: [(#(add change) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]			ifFalse: [(#(remove addedThenRemoved) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]].	changeTypes isEmpty ifFalse:		[changeTypes removeAllFoundIn: otherRecord allChangeTypes.		(changeTypes includes: #rename) ifFalse:			[changeTypes removeAllSuchThat: [:x | x beginsWith: 'oldName: ']]]! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 4/1/2000 23:05'!isClassRemoval	"NOTE: there are other removals with changeType #addedThenRemoved,	but this message is used to write out removals in fileOut, and those	cases should not be written out."	^ (changeTypes includes: #remove) or: [changeTypes includes: #removeClass]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 10:38'!atSelector: selector ifAbsent: absentBlock	^ (methodChanges at: selector ifAbsent: absentBlock)		changeType! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 11:01'!atSelector: selector put: changeType	(self findOrMakeMethodChangeAt: selector priorMethod: nil)		noteChangeType: changeType! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 10:07'!changedSelectors	"Return a set of the changed or removed selectors."	^ methodChanges keys! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 4/1/2000 10:45'!compileAll: newClass from: oldClass	"Something about this class has changed.  Locally retained methods must be recompiled.	NOTE:  You might think that if this changeSet is in force, then we can just note	the new methods but a lower change set may override and be in force which	would mean that only the overriding copies go recompiled.  Just do it."	| sel changeType changeRecord newMethod |	methodChanges associationsDo:		[:assn | sel _ assn key.  changeRecord _ assn value.		changeType _ changeRecord changeType.		(changeType == #add or: [changeType == #change]) ifTrue:			[newMethod _ newClass				recompileNonResidentMethod: changeRecord currentMethod				atSelector: sel from: oldClass.			changeRecord noteNewMethod: newMethod]]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 11:01'!findOrMakeMethodChangeAt: selector priorMethod: priorMethod	^ methodChanges at: selector		ifAbsent: [methodChanges at: selector						put: (MethodChangeRecord new priorMethod: priorMethod)]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/29/2000 16:26'!infoFromRemoval: selector	^ (methodChanges at: selector ifAbsent: [^ nil])		methodInfoFromRemoval! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/24/2000 09:46'!methodChangeTypes	"Return an old-style dictionary of method change types."	| dict selector record |	dict _ IdentityDictionary new.	methodChanges associationsDo:		[:assn | selector _ assn key.  record _ assn value.		dict at: selector put: record changeType].	^ dict! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 4/1/2000 23:49'!methodChanges	^ methodChanges! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 23:28'!noteNewMethod: newMethod selector: selector priorMethod: methodOrNil	| methodChange |	methodChange _ self findOrMakeMethodChangeAt: selector priorMethod: methodOrNil.	methodOrNil == nil		ifTrue: [methodChange noteChangeType: #add]		ifFalse: [methodChange noteChangeType: #change].	methodChange noteNewMethod: newMethod.! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/23/2000 23:00'!noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: infoOrNil	| methodChange |	methodChange _ self findOrMakeMethodChangeAt: selector priorMethod: priorMethod.	methodChange changeType == #add		ifTrue: [methodChange noteChangeType: #addedThenRemoved]		ifFalse: [methodChange noteChangeType: #remove].	infoOrNil ifNotNil:		["Save the source code pointer and category so can still browse old versions"		methodChange noteMethodInfoFromRemoval: infoOrNil]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'sw 8/14/2002 11:11'!removeSelector: selector	"Remove all memory of changes associated with the argument, selector, in this class."	selector == #Comment		ifTrue:			[changeTypes remove: #comment ifAbsent: []]		ifFalse:			[methodChanges removeKey: selector ifAbsent: []]! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'di 4/5/2000 08:11'!initFor: className revertable: isRevertable	inForce _ isRevertable.	changeTypes _ IdentitySet new.	methodChanges _ IdentityDictionary new.	priorName _ thisName _ className.	revertable _ isRevertable and: [self realClass notNil].	revertable ifTrue:		[priorMD _ self realClass methodDict copy.		priorOrganization _ self realClass organization deepCopy].! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'di 9/21/2000 12:34'!zapHistory	"Drop all recorded information not needed to simply keep track of what has been changed.	Saves a lot of space."	methodChanges do: [:r | r noteNewMethod: nil].  "Drop all refes to old methods"	thisOrganization _ nil.	priorOrganization _ nil.	thisComment _ nil.	priorComment _ nil.	thisMD _ nil.	priorMD _ nil.! !ClassCategoryReader subclass: #ClassCommentReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassCommentReader methodsFor: 'as yet unclassified' stamp: 'sw 7/31/2002 10:40'!scanFrom: aStream 	"File in the class comment from aStream.  Not string-i-fied, just a text, exactly as it is in the browser.  Move to changes file."	class theNonMetaClass classComment: (aStream nextChunkText) stamp: changeStamp		"Writes it on the disk and saves a RemoteString ref"! !VersionsBrowser subclass: #ClassCommentVersionsBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ClassCommentVersionsBrowser commentStamp: 'asm 8/13/2002 23:20' prior: 0!A class-comment-versions-browser tool!!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'asm 8/13/2002 21:33'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change s1 s2 |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	s1 _ classOfMethod organization classComment.	s2 _ change string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match'].			(StringHolder new				textContents: (TextDiffBuilder buildDisplayPatchFrom: s1 to: s2 inClass: classOfMethod  prettyDiffs: self showingPrettyDiffs))				openLabel: 'Comparison to Current Version'! !!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'sd 4/16/2003 08:52'!openSingleMessageBrowser	| mr |	"Create and schedule a message list browser populated only by the currently selected message"	mr _ MethodReference new				setStandardClass: self selectedClass				methodSymbol: #Comment.	self systemNavigation 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'BG 10/28/2003 20:48'!versionsMenu: aMenu	"Fill aMenu with menu items appropriate to the receiver"		^ aMenu addList: #(		('compare to current'		compareToCurrentVersion		'compare selected version to the current version')		('revert to selected version'	fileInSelections					'resubmit the selected version, so that it becomes the current version')		('remove from changes'		removeMethodFromChanges		'remove this method from the current change set, if present')		('edit current method (O)'	openSingleMessageBrowser		'open a single-message browser on the current version of this method')				-		('toggle diffing (D)'			toggleDiffing					'toggle whether or not diffs should be shown here')		('update list'				reformulateList					'reformulate the list of versions, in case it somehow got out of synch with reality')		-		('help...'					offerVersionsHelp				'provide an explanation of the use of this tool'))! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'asm 8/13/2002 22:26'!diffedVersionContents	"Answer diffed version contents, maybe pretty maybe not"	| change class earlier later |	(listIndex = 0			or: [changeList size < listIndex])		ifTrue: [^ ''].	change _ changeList at: listIndex.	later _ change text.	class _ self selectedClass.	(listIndex == changeList size or: [class == nil])		ifTrue: [^ later].	earlier _ (changeList at: listIndex + 1) text.	^ TextDiffBuilder buildDisplayPatchFrom: earlier to: later inClass: class prettyDiffs: self showingPrettyDiffs! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'asm 8/13/2002 21:28'!reformulateList     classOfMethod organization classComment ifNil: [^ self].	self scanVersionsOf: classOfMethod.	self changed: #list. "for benefit of mvc"	listIndex _ 1.	self changed: #listIndex.	self contentsChanged! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'asm 1/3/2003 16:06'!scanVersionsOf: class 	"Scan for all past versions of the class comment of the given class"	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |	classOfMethod _ class.	oldCommentRemoteStr _ class  organization commentRemoteStr.	currentCompiledMethod _ oldCommentRemoteStr.	selectorOfMethod _ #Comment.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	position _ oldCommentRemoteStr position.	file _ sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  " Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		prevPos _ nil.		stamp _ ''.		(preamble findString: 'commentStamp:' startingAt: 1) > 0			ifTrue: [tokens _ Scanner new scanTokens: preamble.				(tokens at: tokens size-3) = #commentStamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]]			ifFalse: ["The stamp get lost, maybe after a condenseChanges"					stamp _ '<historical>']. 		self addItem:				(ChangeRecord new file: file position: position type: #classComment						class: class name category: nil meta: class stamp: stamp)			text: stamp , ' ' , class name , ' class comment'. 		prevPos = 0 ifTrue:[prevPos _ nil].		position _ prevPos.		prevPos notNil 					ifTrue:[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'asm 8/13/2002 21:33'!updateListsAndCodeIn: aWindow	| aComment |	aComment _ classOfMethod organization commentRemoteStr.	aComment == currentCompiledMethod		ifFalse:			["Do not attempt to formulate if there is no source pointer.			It probably means it has been recompiled, but the source hasn't been written			(as during a display of the 'save text simply?' confirmation)."			aComment last ~= 0 ifTrue: [self reformulateList]].	^ true! !!ClassCommentVersionsBrowser methodsFor: 'misc' stamp: 'sw 8/17/2002 21:57'!classCommentIndicated	"Answer whether the receiver is pointed at a class comment"	^ true! !!ClassCommentVersionsBrowser methodsFor: 'misc' stamp: 'sw 8/15/2002 22:38'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane"	^ #((source			togglePlainSource 		showingPlainSourceString	'source'			'the textual source code as writen')(showDiffs		toggleRegularDiffing	showingRegularDiffsString	'showDiffs'		'the textual source diffed from its prior version'))! !!ClassCommentVersionsBrowser methodsFor: 'misc' stamp: 'asm 8/13/2002 22:14'!priorSourceOrNil	"If the currently-selected method has a previous version, return its source, else return nil"	| aClass aSelector  changeRecords |	(aClass _ self selectedClass) ifNil: [^ nil].	(aSelector _ self selectedMessageName) ifNil: [^ nil].	changeRecords _  self class commentRecordsOf: self selectedClass.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].	^ (changeRecords at: 2) string ! !!ClassCommentVersionsBrowser methodsFor: 'misc' stamp: 'asm 8/13/2002 20:59'!selectedClass	"Answer the class currently selected in the browser.  In the case of a VersionsBrowser, the class and selector are always the same, regardless of which version is selected and indeed whether or not any entry is selected in the list pane"	^ classOfMethod! !!ClassCommentVersionsBrowser methodsFor: 'misc' stamp: 'sw 8/15/2002 22:35'!wantsPrettyDiffOption	"Answer whether pretty-diffs are meaningful for this tool"	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassCommentVersionsBrowser class	instanceVariableNames: ''!!ClassCommentVersionsBrowser class methodsFor: 'instance creation' stamp: 'asm 8/12/2002 22:46'!browseCommentOf: class	| changeList |	Cursor read showWhile:		[changeList _ self new scanVersionsOf: class.	 	 changeList ifNil: [^ self inform: 'No versions available'].		 self open: changeList name: 'Recent versions of ',class name,'''s comments' multiSelect: false ]! !!ClassCommentVersionsBrowser class methodsFor: 'utilities' stamp: 'asm 8/13/2002 22:09'!commentRecordsOf: aClass	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	| aList |	aList _ self new			scanVersionsOf: aClass.	^ aList ifNotNil: [aList changeList]! !!ClassCommentVersionsBrowser class methodsFor: 'utilities' stamp: 'asm 8/13/2002 20:54'!timeStampFor: aSelector class: aClass reverseOrdinal: anInteger	"Answer the time stamp corresponding to some version of the given method, nil if none.  The reverseOrdinal parameter is interpreted as:  1 = current version; 2 = last-but-one version, etc."		| aChangeList |	aChangeList _  self new scanVersionsOf: aClass.	^ aChangeList ifNil: [nil] ifNotNil:		[aChangeList list size >= anInteger			ifTrue:				[(aChangeList changeList at: anInteger) stamp]			ifFalse:				[nil]]! !Behavior subclass: #ClassDescription	instanceVariableNames: 'instanceVariables organization'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassDescription commentStamp: '<historical>' prior: 0!I add a number of facilities to basic Behaviors:	Named instance variables	Category organization for methods	The notion of a name of this class (implemented as subclass responsibility)	The maintenance of a ChangeSet, and logging changes on a file	Most of the mechanism for fileOut.	I am an abstract class, in particular, my facilities are intended for inheritance by two subclasses, Class and Metaclass.The slots 'organization' and 'methodDict' should ONLY be accessed by message in order for things to work during ImageSegment>>discoverActiveClasses (q.v.).!!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 11/22/1999 10:09'!doneCompiling	"A ClassBuilder has finished the compilation of the receiver.	This message is a notification for a class that needs to do some	cleanup / reinitialization after it has been recompiled."! !!ClassDescription methodsFor: 'initialize-release' stamp: 'NS 4/6/2004 15:32'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'NS 4/6/2004 15:31'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	instanceVariables _ nil.	self organization: nil.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/1/2001 23:25'!updateInstances: oldInstances from: oldClass isMeta: isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| map variable instSize newInstances |	oldInstances isEmpty ifTrue:[^#()]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		self soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map _ self instVarMappingFrom: oldClass.	variable _ self isVariable.	instSize _ self instSize.	newInstances _ Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.	^newInstances "which are now old"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'BG 10/29/2003 09:09'!updateInstancesFrom: oldClass	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary. Return the array of old instances (none of which should be	pointed to legally by anyone but the array)."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| oldInstances |	oldInstances _ oldClass allInstances asArray.	oldInstances _ self updateInstances: oldInstances from: oldClass isMeta: self isMeta.	"Now fix up instances in segments that are out on the disk."	" ImageSegment allSubInstancesDo: [:seg |		seg segUpdateInstancesOf: oldClass toBe: self isMeta: self isMeta]. "	^oldInstances"	| crashingBlock class |	class _ Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar _ value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock _ (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!ClassDescription methodsFor: 'accessing' stamp: 'sd 6/27/2003 23:57'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'accessing' stamp: 'di 2/9/2000 17:54'!comment	"Answer the receiver's comment. (If missing, supply a template) "	| aString |	aString _ self theNonMetaClass organization classComment.	aString isEmpty ifFalse: [^ aString].	^'Main comment stating the purpose of this class and relevant relationship to other classes.Possible useful expressions for doIt or printIt.Structure: instVar1		type -- comment about the purpose of instVar1 instVar2		type -- comment about the purpose of instVar2Any further useful comments about the general approach of this implementation.'! !!ClassDescription methodsFor: 'accessing' stamp: 'NS 1/27/2004 14:54'!comment: aStringOrText	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText.! !!ClassDescription methodsFor: 'accessing' stamp: 'NS 1/27/2004 14:54'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.! !!ClassDescription methodsFor: 'accessing' stamp: 'ls 10/28/2003 12:32'!hasComment	"return whether this class truly has a comment other than the default"	| org |	org := self theNonMetaClass organization.	^org classComment notNil and: [		org classComment isEmpty not ].! !!ClassDescription methodsFor: 'accessing'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self! !!ClassDescription methodsFor: 'copying' stamp: 'di 2/17/2000 22:35'!copy: sel from: class classified: cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	| code category |	"Useful when modifying an existing class"	code _ class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category _ class organization categoryOfElement: sel]				ifFalse: [category _ cat].			(self methodDict includesKey: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self error: self name 										, ' ' 										, sel 										, ' will be redefined if you proceed.']].			self compile: code classified: category]! !!ClassDescription methodsFor: 'copying'!copyAll: selArray from: class classified: cat 	"Install all the methods found in the method dictionary of the second 	argument, class, as the receiver's methods. Classify the messages under 	the third argument, cat."	selArray do: 		[:s | self copy: s				from: class				classified: cat]! !!ClassDescription methodsFor: 'copying'!copyAllCategoriesFrom: aClass 	"Specify that the categories of messages for the receiver include all of 	those found in the class, aClass. Install each of the messages found in 	these categories into the method dictionary of the receiver, classified 	under the appropriate categories."	aClass organization categories do: [:cat | self copyCategory: cat from: aClass]! !!ClassDescription methodsFor: 'copying'!copyCategory: cat from: class 	"Specify that one of the categories of messages for the receiver is cat, as 	found in the class, class. Copy each message found in this category."	self copyCategory: cat		from: class		classified: cat! !!ClassDescription methodsFor: 'copying'!copyCategory: cat from: aClass classified: newCat 	"Specify that one of the categories of messages for the receiver is the 	third argument, newCat. Copy each message found in the category cat in 	class aClass into this new category."	self copyAll: (aClass organization listAtCategoryNamed: cat)		from: aClass		classified: newCat! !!ClassDescription methodsFor: 'printing' stamp: 'lr 11/24/2003 17:21'!classVariablesString	"Answer a string of my class variable names separated by spaces."	^String streamContents: [ :stream | 		self classPool keys asSortedCollection 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: 'printing' stamp: 'lr 11/24/2003 17:20'!instanceVariablesString	"Answer a string of my instance variable names separated by spaces."	^String streamContents: [ :stream |		self instVarNames 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self name! !!ClassDescription methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:05'!printOnStream: aStream 	aStream print: self name! !!ClassDescription methodsFor: 'printing' stamp: 'lr 11/24/2003 17:24'!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	^String streamContents: [ :stream |		self sharedPools 			do: [ :each |				stream nextPutAll: (self environment 					keyAtIdentityValue: each 					ifAbsent: [ 'private' ]) ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: 'printing'!storeOn: aStream	"Classes and Metaclasses have global names."	aStream nextPutAll: self name! !!ClassDescription methodsFor: 'instance variables'!addInstVarName: aString 	"Add the argument, aString, as one of the receiver's instance variables."	self subclassResponsibility! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 10/23/2000 18:05'!allInstVarNamesEverywhere	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"	| aList |	aList _ OrderedCollection new.	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:		[:cls | aList addAll: cls instVarNames].	^ aList asSet	"BorderedMorph allInstVarNamesEverywhere"! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 11/9/1998 20:21'!checkForInstVarsOK: instVarString	"Return true if instVarString does no include any names used in a subclass"	| instVarArray |	instVarArray _ Scanner new scanFieldNames: instVarString.	self allSubclasses do:		[:cl | cl instVarNames do:			[:n | (instVarArray includes: n)				ifTrue: [self error: n , ' is already used in ' , cl name.						^ false]]].	^ true! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 9/28/1999 17:04'!chooseInstVarAlphabeticallyThenDo: aBlock	| allVars index |	"Put up a menu of all the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."	allVars _ self allInstVarNames asSortedArray.	allVars isEmpty ifTrue: [^ self inform: 'There are noinstance variables'].	index _ (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Instance variables in', self name.	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: 'instance variables' stamp: 'ls 12/5/199913:40'!chooseInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| lines labelStream vars allVars index count offerAlpha |	(count _ self allInstVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noinstance variables.'].	allVars _ OrderedCollection new.	lines _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	(offerAlpha _ count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	self withAllSuperclasses reverseDo:		[:class |		vars _ class instVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index _ (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Instance variables in', self name.	index = 0 ifTrue: [^ self].	(index = 1 and: [offerAlpha]) ifTrue: [^ selfchooseInstVarAlphabeticallyThenDo: aBlock].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 5/27/1999 16:46'!classThatDefinesInstanceVariable: instVarName	(instanceVariables notNil and: [instanceVariables includes: instVarName asString]) ifTrue: [^ self]. 	^ superclass ifNotNil: [superclass classThatDefinesInstanceVariable: instVarName]! !!ClassDescription methodsFor: 'instance variables'!instVarNames	"Answer an Array of the receiver's instance variable names."	instanceVariables == nil		ifTrue: [^#()]		ifFalse: [^instanceVariables]! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'NS 1/28/2004 14:12'!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor	| priorMethodOrNil |	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: [nil].	self addSelectorSilently: selector withMethod: compiledMethod.	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: self requestor: requestor].! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'NS 1/28/2004 14:10'!addSelector: selector withMethod: compiledMethod notifying: requestor	| priorMethodOrNil |	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: [nil].	self addSelectorSilently: selector withMethod: compiledMethod.	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inClass: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: self requestor: requestor].! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'sw 1/5/2001 06:53'!allMethodCategoriesIntegratedThrough: mostGenericClass	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"	| aColl |	aColl _ OrderedCollection new.	self withAllSuperclasses do:		[:aClass |			(aClass includesBehavior: mostGenericClass)				ifTrue:	[aColl addAll: aClass organization categories]].	aColl remove: 'no messages' asSymbol ifAbsent: [].	^ (aColl asSet asSortedCollection: [:a :b | a asLowercase < b asLowercase]) asArray"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'sw 12/11/2000 14:00'!isUniClass	"Answer whether the receiver is a uniclass."	^ self name endsWithDigit! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'di 3/7/2001 17:05'!recoverFromMDFault	"This method handles methodDict faults to support, eg, discoverActiveClasses (qv)."	(organization isMemberOf: Array) ifFalse: [^ self error: 'oops'].	methodDict _ organization first.	organization _ organization second.! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'sd 3/28/2003 15:32'!recoverFromMDFaultWithTrace	"This method handles emthodDict faults to support, eg, discoverActiveClasses (qv)."	self recoverFromMDFault.	self environment at: #MDFaultDict ifPresent:		[:faultDict | faultDict at: self name put:			(String streamContents:				[:strm | (thisContext stackOfSize: 20) do: [:item | strm print: item; cr]])]"Execute the following statement to induce MD fault tracing.  This means that, not only will all active classes be recorded but, after a test run, MDFaultDict will contain, for every class used, a stack trace showing how it came to be used.  This statement should be executed just prior to any such text, in order to clear the traces.	Smalltalk at: #MDFaultDict put: Dictionary new."! !!ClassDescription methodsFor: 'accessing method dictionary'!removeCategory: aString 	"Remove each of the messages categorized under aString in the method 	dictionary of the receiver. Then remove the category aString."	| categoryName |	categoryName _ aString asSymbol.	(self organization listAtCategoryNamed: categoryName) do:		[:sel | self removeSelector: sel].	self organization removeCategory: categoryName! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'NS 4/7/2004 13:33'!removeSelector: selector 	| priorMethod priorProtocol | 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance doSilently: [		self organization removeElement: selector].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'sw 5/18/1999 10:11'!ultimateSourceCodeAt: selector ifAbsent: aBlock	"Return the source code at selector, deferring to superclass if necessary"	^ self sourceCodeAt: selector ifAbsent:		[superclass			ifNil:				[aBlock value]			 ifNotNil:				[superclass ultimateSourceCodeAt: selector ifAbsent: aBlock]]! !!ClassDescription methodsFor: 'organization'!category	"Answer the system organization category for the receiver."	^SystemOrganization categoryOfElement: self name! !!ClassDescription methodsFor: 'organization' stamp: 'rw 8/2/2003 11:05'!category: cat 	"Categorize the receiver under the system category, cat, removing it from 	any previous categorization."	| oldCat |	oldCat := self category.	(cat isKindOf: String)		ifTrue: [SystemOrganization classify: self name under: cat asSymbol]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance class: self recategorizedFrom: oldCat to: cat asSymbol! !!ClassDescription methodsFor: 'organization' stamp: 'BG 11/11/2003 09:51'!compactOrganization	"Remove the organization of this class by message categories.	This is typically done to save space in small systems.  Classes and methods	created or filed in subsequently will, nonetheless, be organized"	organization notNil       ifTrue: [organization updateFor: self].	self isMeta ifFalse: [self class compactOrganization]! !!ClassDescription methodsFor: 'organization' stamp: 'NS 4/7/2004 13:33'!forgetDoIts	"get rid of old DoIt methods and bogus entries in the ClassOrganizer."	SystemChangeNotifier uniqueInstance doSilently: [		self organization			removeElement: #DoIt;			removeElement: #DoItIn:.	].	super forgetDoIts.! !!ClassDescription methodsFor: 'organization' stamp: 'NS 4/6/2004 15:46'!organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	organization ifNil:		[self organization: (ClassOrganizer defaultList: self methodDict keys asSortedCollection asArray)].	(organization isMemberOf: Array) ifTrue:		[self recoverFromMDFaultWithTrace].		"Making sure that subject is set correctly. It should not be necessary."	organization ifNotNil: [organization setSubject: self].	^ organization! !!ClassDescription methodsFor: 'organization' stamp: 'NS 4/6/2004 15:26'!organization: aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	aClassOrg ifNotNil: [aClassOrg setSubject: self].	organization _ aClassOrg! !!ClassDescription methodsFor: 'organization' stamp: 'di 7/17/97 00:06'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!ClassDescription methodsFor: 'organization' stamp: 'NS 4/6/2004 15:30'!zapOrganization	"Remove the organization of this class by message categories.	This is typically done to save space in small systems.  Classes and methods	created or filed in subsequently will, nonetheless, be organized"	self organization: nil.	self isMeta ifFalse: [self class zapOrganization]! !!ClassDescription methodsFor: 'compiling'!acceptsLoggingOfCompilation	"weird name is so that it will come lexically before #compile, so that a clean build can make it through.  7/7/96 sw"	^ true! !!ClassDescription methodsFor: 'compiling'!compile: code classified: heading 	"Compile the argument, code, as source code in the context of the 	receiver and install the result in the receiver's method dictionary under 	the classification indicated by the second argument, heading. nil is to be 	notified if an error occurs. The argument code is either a string or an 	object that converts to a string or a PositionableStream on an object that 	converts to a string."	^self		compile: code		classified: heading		notifying: (SyntaxError new category: heading)! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 8/21/97 00:26'!compile: text classified: category notifying: requestor	| stamp |	stamp _ self acceptsLoggingOfCompilation ifTrue: [Utilities changeStamp] ifFalse: [nil].	^ self compile: text classified: category		withStamp: stamp notifying: requestor ! !!ClassDescription methodsFor: 'compiling' stamp: 'di 5/4/2001 11:35'!compile: text classified: category withStamp: changeStamp notifying: requestor	^ self compile: text classified: category withStamp: changeStamp notifying: requestor logSource: self acceptsLoggingOfCompilation! !!ClassDescription methodsFor: 'compiling' stamp: 'NS 1/28/2004 14:25'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource	| methodAndNode |	methodAndNode _ self basicCompile: text asString notifying: requestor 							trailer: self defaultMethodTrailer ifFail: [^nil].	logSource ifTrue: [		self logMethodSource: text forMethodWithNode: methodAndNode 			inCategory: category withStamp: changeStamp notifying: requestor.	].	self addAndClassifySelector: methodAndNode selector withMethod: methodAndNode 		method inProtocol: category notifying: requestor.	self theNonMetaClass noteCompilationOf: methodAndNode selector meta: self isMeta.	^ methodAndNode selector! !!ClassDescription methodsFor: 'compiling'!compile: code notifying: requestor 	"Refer to the comment in Behavior|compile:notifying:." 	^self compile: code		 classified: ClassOrganizer default		 notifying: requestor! !!ClassDescription methodsFor: 'compiling' stamp: 'NS 1/28/2004 14:45'!compileSilently: code classified: category	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."	^ self compileSilently: code classified: category notifying: nil.! !!ClassDescription methodsFor: 'compiling' stamp: 'NS 1/28/2004 14:45'!compileSilently: code classified: category notifying: requestor	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."	^ SystemChangeNotifier uniqueInstance 		doSilently: [self compile: code classified: category withStamp: nil notifying: requestor logSource: false].! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 9/25/2001 02:11'!noteCompilationOf: aSelector meta: isMeta	"A hook allowing some classes to react to recompilation of certain selectors"! !!ClassDescription methodsFor: 'compiling' stamp: 'NS 1/28/2004 14:48'!wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.  7/12/96 sw"	^ true! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 7/31/2000 12:55'!wantsRecompilationProgressReported	"Answer whether the receiver would like progress of its recompilation reported interactively to the user."	^ true! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/8/1998 14:44'!classComment: aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	^ self classComment: aString stamp: '<historical>'! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'NS 4/8/2004 11:35'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue:		[SystemChangeNotifier uniqueInstance classCommented: self.		^ self organization classComment: aString stamp: aStamp].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil:		[file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.	SystemChangeNotifier uniqueInstance classCommented: self.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/2/1998 14:22'!commentStamp: changeStamp	self organization commentStamp: changeStamp.    ^ self commentStamp: changeStamp prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 14:21'!commentStamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCommentReader new setClass: self				category: #Comment				changeStamp: changeStamp! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:46'!definition	"Answer a String that defines the receiver in good old ST-80."	^ self definitionST80! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ls 10/9/2001 00:12'!definitionST80	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ls 10/9/2001 00:12'!definitionST80: isST80	"Answer a String that defines the receiver."	| aStream path |	isST80 ifTrue: [^ self definitionST80].	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutKeyword: self kindOfSubclass			withArg: self name.	aStream cr; tab; nextPutKeyword: 'instanceVariableNames: '			withArg: self instanceVariablesString.	aStream cr; tab; nextPutKeyword: 'classVariableNames: 'withArg: self classVariablesString.	aStream cr; tab; nextPutKeyword: 'poolDictionaries: '			withArg: self sharedPoolsString.	aStream cr; tab; nextPutKeyword: 'category: '			withArg: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass (nil)'. ].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 10:06'!fileOutCategory: catName 	^ self fileOutCategory: catName asHtml: false! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 10:05'!fileOutCategory: catName asHtml: useHtml	"FileOut the named category, possibly in Html format."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name , '-' , catName , '.html') asHtml]		ifFalse: [FileStream newFileNamed: self name , '-' , catName , '.st'].	fileStream header; timeStamp.	self fileOutCategory: catName on: fileStream moveSource: false toFile: 0.	fileStream trailer; close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 10/15/1999 14:45'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!ClassDescription methodsFor: 'fileIn/Out'!fileOutChangedMessages: aSet on: aFileStream 	"File a description of the messages of the receiver that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream."	self fileOutChangedMessages: aSet		on: aFileStream		moveSource: false		toFile: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/26/97 21:41'!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org sels |	(org _ self organization) categories do: 		[:cat | 		sels _ (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels do:			[:sel |  self printMethodChunk: sel withPreamble: true on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 15:52'!fileOutMethod: selector	"Write source code of a single method on a file.  Make up a name for the file."	self fileOutMethod: selector asHtml: false! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 8/1/2002 14:39'!fileOutMethod: selector asHtml: useHtml	"Write source code of a single method on a file in .st or .html format"	| fileStream nameBody |	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asString, ' not found'].	nameBody _ self name , '-' , (selector copyReplaceAll: ':' with: '').	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: nameBody , '.html') asHtml]		ifFalse: [FileStream newFileNamed: nameBody , '.st'].	fileStream header; timeStamp.	self printMethodChunk: selector withPreamble: true		on: fileStream moveSource: false toFile: 0.	fileStream close! !!ClassDescription methodsFor: 'fileIn/Out'!fileOutOn: aFileStream 	"File a description of the receiver on aFileStream."	self fileOutOn: aFileStream		moveSource: false		toFile: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 1/15/98 23:38'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	"File a description of the receiver on aFileStream. If the boolean 	argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the 	source code."	aFileStream command: 'H3'.		aFileStream nextChunkPut: self definition.		aFileStream command: '/H3'.	self organization		putCommentOnFile: aFileStream		numbered: fileIndex		moveSource: moveSource		forClass: self.	self organization categories do: 		[:heading |		self fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 20:35'!fileOutOrganizationOn: aFileStream	"File a description of the receiver's organization on aFileStream."	aFileStream cr; nextPut: $!!.	aFileStream nextChunkPut: self name, ' reorganize'; cr.	aFileStream nextChunkPut: self organization printString; cr! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 13:00'!methodsFor: categoryName 	"Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."	^ ClassCategoryReader new setClass: self category: categoryName asSymbol	"(False methodsFor: 'logical operations') inspect"! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/13/97 13:51'!methodsFor: categoryName stamp: changeStamp 	^ self methodsFor: categoryName stamp: (Utilities fixStamp: changeStamp) prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 22:02'!methodsFor: categoryName stamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(65 333 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 1/2/2003 21:50'!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes _ self methodDict keys select: [:sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 4/4/1999 11:43'!printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod 	"Print a method category preamble.  This must have a category name.	It may have an author/date stamp, and it may have a prior source link.	If it has a prior source link, it MUST have a stamp, even if it is empty.""The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."	aFileStream cr; command: 'H3'; nextPut: $!!.	aFileStream nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.		(changeStamp ~~ nil and:			[changeStamp size > 0 or: [priorMethod ~~ nil]]) ifTrue:			[strm nextPutAll: ' stamp: '; print: changeStamp].		priorMethod ~~ nil ifTrue:			[strm nextPutAll: ' prior: '; print: priorMethod sourcePointer]]).	aFileStream command: '/H3'.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'RAA 5/5/2000 09:08'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile position: oldPos.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos _ outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'NS 4/8/2004 11:32'!putClassCommentToCondensedChangesFile: aFileStream	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."	| header aStamp aCommentRemoteStr |	self isMeta ifTrue: [^ self].  "bulletproofing only"	((aCommentRemoteStr _ self organization commentRemoteStr) isNil or:		[aCommentRemoteStr sourceFileNumber == 1]) ifTrue: [^ self].	aFileStream cr; nextPut: $!!.	header _ String streamContents: [:strm | strm nextPutAll: self name;		nextPutAll: ' commentStamp: '.		(aStamp _ self organization commentStamp ifNil: ['<historical>']) storeOn: strm.		strm nextPutAll: ' prior: 0'].	aFileStream nextChunkPut: header.	aFileStream cr.	self organization classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream) stamp: aStamp! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'NS 4/7/2004 23:01'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	^self organization!]style[(10 156 22 38)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'private'!errorCategoryName	self error: 'Category name must be a String'! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/11/1999 11:41'!instVarMappingFrom: oldClass	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."	| oldInstVarNames |	oldInstVarNames _ oldClass allInstVarNames.	^self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].! !!ClassDescription methodsFor: 'private' stamp: 'NS 1/28/2004 14:22'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor	| priorMethodOrNil newText |	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [].	newText _ ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [aText askIfAddStyle: priorMethodOrNil req: requestor]			ifFalse: [aText].	aCompiledMethodWithNode method putSource: newText		fromParseNode: aCompiledMethodWithNode node		class: self category: category withStamp: changeStamp 		inFile: 2 priorMethod: priorMethodOrNil.! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/10/1999 11:17'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| new |	variable		ifTrue: [new _ self basicNew: oldInstance basicSize]		ifFalse: [new _ self basicNew].	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[new instVarAt: offset					put: (oldInstance instVarAt: (map at: offset))]].	variable 		ifTrue: [1 to: oldInstance basicSize do: 					[:offset |					new basicAt: offset put: (oldInstance basicAt: offset)]].	^new! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/15/1999 17:04'!setInstVarNames: instVarArray	"Private - for class initialization only"	| required |	required _ self instSize.	superclass notNil ifTrue:[required _ required - superclass instSize].	instVarArray size = required		ifFalse:[^self error: required printString, ' instvar names are required'].	instVarArray isEmpty		ifTrue:[instanceVariables _ nil]		ifFalse:[instanceVariables _ instVarArray asArray].! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:57'!printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subclassNames |	aStream crtab: level.	aStream nextPutAll: self name.	aStream space; print: self instVarNames.	self == Class		ifTrue: 			[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.			^self].	subclassNames _ self subclasses asSortedCollection:[:c1 :c2| c1 name <= c2 name].	"Print subclasses in alphabetical order"	subclassNames do:		[:subclass | subclass printSubclassesOn: aStream level: level + 1]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 7/21/1999 11:05'!subclasses	^ Array new! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/10/1999 08:22'!subclassesDo: aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	^self subclasses do: aBlock! !TextDiffBuilder subclass: #ClassDiffBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!ClassDiffBuilder methodsFor: 'initialize'!split: aString	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) isSeparator ifTrue:[			out nextPut: c.			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!ClassDiffBuilder methodsFor: 'printing' stamp: 'nk 4/24/2004 08:49'!printPatchSequence: ps on: aStream 	| type line |	ps do: [:assoc | 			type := assoc key.			line := assoc value.			aStream				withAttributes: (self attributesOf: type)				do: [aStream nextPutAll: line]]! !HierarchyBrowser subclass: #ClassListBrowser	instanceVariableNames: 'defaultTitle'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!ClassListBrowser commentStamp: '<historical>' prior: 0!A ClassListBrowser displays the code for an arbitrary list of classes.ClassListBrowser example1.  "all classes that have the string 'Pluggable' in their names"ClassListBrowser example2.  "all classes whose names start with the letter S"ClassListBrowser example3.  "all variable classes"ClassListBrowser example4.  "all classes with more than 100 methods"ClassListBrowser example5.  "all classes that lack class comments"ClassListBrowser example6.  "all classes that have class instance variables"ClassListBrowser new initForClassesNamed: #(Browser Boolean) title: 'Browser and Boolean!!'.!!ClassListBrowser methodsFor: 'initialization' stamp: 'sw 7/18/2002 22:43'!initForClassesNamed: nameList title: aTitle	"Initialize the receiver for the class-name-list and title provided"	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	defaultTitle _ aTitle.	classList _ nameList copy.	self class openBrowserView:  (self openSystemCatEditString: nil)		label: aTitle	"ClassListBrowser new initForClassesNamed: #(Browser CategoryViewer) title: 'Frogs'"! !!ClassListBrowser methodsFor: 'title' stamp: 'sw 7/18/2002 22:42'!defaultTitle: aTitle	"Set the browser's default title"	defaultTitle _ aTitle! !!ClassListBrowser methodsFor: 'title' stamp: 'sw 7/18/2002 22:43'!labelString	"Answer the label strilng to use on the browser"	^ defaultTitle ifNil: [super labelString]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassListBrowser class	instanceVariableNames: ''!!ClassListBrowser class methodsFor: 'examples' stamp: 'sw 7/27/2002 16:01'!example1	"Put up a ClassListBrowser that shows all classes that have the string 'Pluggable' in their names"	self browseClassesSatisfying: [:cl | cl name includesSubString: 'Pluggable'] title: 'Pluggables'"ClassListBrowser example1"	! !!ClassListBrowser class methodsFor: 'examples' stamp: 'sd 4/17/2003 21:21'!example2	"Put up a ClassListBrowser that shows all classes whose names start with 	the letter S"	self new		initForClassesNamed: (self systemNavigation allClasses				collect: [:c | c name]				thenSelect: [:aName | aName first == $S])		title: 'All classes starting with S'	"ClassListBrowser example2"! !!ClassListBrowser class methodsFor: 'examples' stamp: 'sw 7/27/2002 16:03'!example3	"Put up a ClassListBrowser that shows all Variable classes"	self browseClassesSatisfying:  [:c | c isVariable] title: 'All Variable classes'"ClassListBrowser example3"	! !!ClassListBrowser class methodsFor: 'examples' stamp: 'sw 7/27/2002 16:04'!example4	"Put up a ClassListBrowser that shows all classes implementing more than 100 methods"	self browseClassesSatisfying:		[:c | (c selectors size + c class selectors size) > 100] title: 'Classes with more than 100 methods'"ClassListBrowser example4"	! !!ClassListBrowser class methodsFor: 'examples' stamp: 'sw 7/27/2002 14:32'!example5	"Put up a ClassListBrowser that shows all classes that lack class comments"	self		browseClassesSatisfying: 			[:c | c organization classComment isEmptyOrNil] 		title: 'Classes lacking class comments'"ClassListBrowser example5"	! !!ClassListBrowser class methodsFor: 'examples' stamp: 'sw 7/27/2002 14:33'!example6	"Put up a ClassListBrowser that shows all classes that have class instance variables"	self		browseClassesSatisfying: 			[:c | c class instVarNames size > 0]		title:			'Classes that define class-side instance variables'"ClassListBrowser example6"! !!ClassListBrowser class methodsFor: 'instance creation' stamp: 'sd 4/17/2003 21:21'!browseClassesSatisfying: classBlock title: aTitle	"Put up a ClassListBrowser showing all classes that satisfy the classBlock."	self new		initForClassesNamed:			(self systemNavigation allClasses select:					[:c | (classBlock value: c) == true]				thenCollect:					[:c | c name])		title:			aTitle! !BasicClassOrganizer subclass: #ClassOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassOrganizer commentStamp: 'NS 4/6/2004 16:13' prior: 0!I represent method categorization information for classes.  The handling of class comments has gone through a tortuous evolution.   Grandfathered class comments (before late aug 98) have no time stamps, and historically, fileouts of class comments always substituted the timestamp reflecting the author and date/time at the moment of fileout; and historically any timestamps in a filed out class comment were dropped on the floor, with the author & time prevailing at the moment of filein being substituted.   Such grandfathered comments now go out on fileouts with '<historical>' timestamp; class comments created after the 8/98 changes will have their correct timestamps preserved, though there is not yet a decent ui for reading those stamps other than filing out and looking at the file; nor is there yet any ui for browsing and recovering past versions of such comments.  Everything in good time!!!!ClassOrganizer methodsFor: 'private' stamp: 'NS 4/7/2004 10:15'!notifyOfChangedCategoriesFrom: oldCollectionOrNil to: newCollectionOrNil	(self hasSubject and: [oldCollectionOrNil ~= newCollectionOrNil]) 		ifTrue: [SystemChangeNotifier uniqueInstance classReorganized: self subject].! !!ClassOrganizer methodsFor: 'private' stamp: 'NS 4/7/2004 23:02'!notifyOfChangedCategoryFrom: oldNameOrNil to: newNameOrNil	(self hasSubject and: [oldNameOrNil ~= newNameOrNil]) 		ifTrue: [SystemChangeNotifier uniqueInstance classReorganized: self subject].! !!ClassOrganizer methodsFor: 'private' stamp: 'NS 4/7/2004 22:52'!notifyOfChangedSelector: element from: oldCategory to: newCategory	(self hasSubject and: [(oldCategory ~= newCategory)]) ifTrue: [		SystemChangeNotifier uniqueInstance selector: element recategorizedFrom: oldCategory to: newCategory inClass: self subject	].! !!ClassOrganizer methodsFor: 'private' stamp: 'NS 4/12/2004 20:56'!notifyOfChangedSelectorsOldDict: oldDictionaryOrNil newDict: newDictionaryOrNil	| newCat |	(oldDictionaryOrNil isNil and: [newDictionaryOrNil isNil])		ifTrue: [^ self].			oldDictionaryOrNil isNil ifTrue: [	newDictionaryOrNil keysAndValuesDo: [:el :cat |		self notifyOfChangedSelector: el from: nil to: cat].		^ self.	].	newDictionaryOrNil isNil ifTrue: [	oldDictionaryOrNil keysAndValuesDo: [:el :cat |		self notifyOfChangedSelector: el from: cat to: nil].		^ self.	].			oldDictionaryOrNil keysAndValuesDo: [:el :cat |		newCat _ newDictionaryOrNil at: el.		self notifyOfChangedSelector: el from: cat to: newCat.	].! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!addCategory: catString before: nextCategory	| oldCategories |	oldCategories _ self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super addCategory: catString before: nextCategory].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/15/2004 12:28'!changeFromCategorySpecs: categorySpecs	| oldDict oldCategories |	oldDict _ self elementCategoryDict.	oldCategories _ self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super changeFromCategorySpecs: categorySpecs].	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!classify: element under: heading suppressIfDefault: aBoolean	| oldCat newCat |	oldCat _ self categoryOfElement: element.	SystemChangeNotifier uniqueInstance doSilently: [		super classify: element under: heading suppressIfDefault: aBoolean].	newCat _ self categoryOfElement: element.	self notifyOfChangedSelector: element from: oldCat to: newCat.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!removeCategory: cat 	| oldCategories |	oldCategories _ self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super removeCategory: cat].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!removeElement: element	| oldCat |	oldCat _ self categoryOfElement: element.	SystemChangeNotifier uniqueInstance doSilently: [		super removeElement: element].	self notifyOfChangedSelector: element from: oldCat to: (self categoryOfElement: element).! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:38'!removeEmptyCategories	| oldCategories |	oldCategories _ self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super removeEmptyCategories].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:38'!renameCategory: oldCatString toBe: newCatString	| oldCat newCat oldElementsBefore oldElementsAfter |	oldCat _ oldCatString asSymbol.	newCat _ newCatString asSymbol.	oldElementsBefore _ self listAtCategoryNamed: oldCat.	SystemChangeNotifier uniqueInstance doSilently: [		super renameCategory: oldCatString toBe: newCatString].	oldElementsAfter _ (self listAtCategoryNamed: oldCat) asSet.	oldElementsBefore do: [:each |		(oldElementsAfter includes: each)			ifFalse: [self notifyOfChangedSelector: each from: oldCat to: newCat].	].	self notifyOfChangedCategoryFrom: oldCat to: newCat.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/12/2004 20:57'!setDefaultList: aSortedCollection	| oldDict oldCategories |	oldDict _ self elementCategoryDict.	oldCategories _ self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super setDefaultList: aSortedCollection].	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:38'!sortCategories	| oldCategories |	oldCategories _ self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super sortCategories].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'updating' stamp: 'BG 10/31/2003 20:44'!updateFor: aClass  | stream selector changed | changed := false. stream := ReadStream on: elementArray copy. [stream atEnd]   whileFalse:     [selector := stream next.      (aClass methodDictionary includesKey: selector)         ifFalse: [self removeElement: selector.                   changed := true].     ].  changed ifTrue: [self removeEmptyCategories.]! !Object subclass: #Clipboard	instanceVariableNames: 'contents recent'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!Clipboard commentStamp: '<historical>' prior: 0!The Clipboard class implements a basic buffering scheme for text. The currently selected text is also exported to the OS so that text can be copied from and to other applications. Commonly only a single instance is used (the default clipboard) but applications are free to use other than the default clipboard if necessary.!!Clipboard methodsFor: 'initialize' stamp: 'ar 1/15/2001 18:34'!initialize	contents _ '' asText.	recent _ OrderedCollection new.! !!Clipboard methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:32'!chooseRecentClipping  "Clipboard chooseRecentClipping"	"Choose by menu from among the recent clippings"	recent ifNil: [^ nil].	^ (SelectionMenu		labelList: (recent collect: [:txt | ((txt asString contractTo: 50)									copyReplaceAll: Character cr asString with: '\')									copyReplaceAll: Character tab asString with: '|'])		selections: recent) startUp.! !!Clipboard methodsFor: 'accessing' stamp: 'RAA 2/6/2001 11:18'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ self primitiveClipboardText.	(s isEmpty or: [s = contents asString])		ifTrue: [^ contents]		ifFalse: [^ s asText]! !!Clipboard methodsFor: 'accessing' stamp: 'RAA 2/6/2001 11:21'!clipboardText: text	"Set text currently on the clipboard.  Also export to OS"	contents _ text.	self noteRecentClipping: text asText.	self primitiveClipboardText: text asString! !!Clipboard methodsFor: 'primitives' stamp: 'ar 1/15/2001 18:28'!primitiveClipboardText	"Get the current clipboard text. Return the empty string if the primitive fails."	<primitive: 141>	^ ''! !!Clipboard methodsFor: 'primitives' stamp: 'ar 1/15/2001 18:30'!primitiveClipboardText: aString	"Set the current clipboard text to the given string."	<primitive: 141>	"don't fail if the primitive is not implemented"! !!Clipboard methodsFor: 'private' stamp: 'ar 1/15/2001 18:34'!noteRecentClipping: text	"Keep most recent clippings in a queue for pasteRecent (paste... command)"	text isEmpty ifTrue: [^ self].	text size > 50000 ifTrue: [^ self].	(recent includes: text) ifTrue: [^ self].	recent addFirst: text.	[recent size > 5] whileTrue: [recent removeLast].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clipboard class	instanceVariableNames: ''!!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:45'!chooseRecentClipping  "Clipboard chooseRecentClipping"	"Choose by menu from among the recent clippings"	^self default chooseRecentClipping! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:35'!clipboardText "Clipboard clipboardText"	^self default clipboardText.! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:35'!clipboardText: aText 	^self default clipboardText: aText! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:33'!default	^Default ifNil:[Default _ self new].! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:48'!default: aClipboard	"So that clients can switch between different default clipboards"	Default _ aClipboard.! !StringHolder subclass: #CodeHolder	instanceVariableNames: 'currentCompiledMethod contentsSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!CodeHolder commentStamp: '<historical>' prior: 0!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!CodeHolder methodsFor: 'annotation' stamp: 'sw 2/22/2001 10:00'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"add an annotation detailing the prior versions count"	| versionsCount |	versionsCount _ VersionsBrowser versionCountForSelector: aSelector class: aClass.	aStream nextPutAll: 				((versionsCount > 1					ifTrue:						[versionsCount == 2 ifTrue:							['1 prior version']							ifFalse:								[versionsCount printString, ' prior versions']]					ifFalse:						['no prior versions']), self annotationSeparator)! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 1/25/2001 06:40'!annotation	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."	|  aSelector aClass |	((aSelector _ self selectedMessageName) == nil or: [(aClass _ self selectedClassOrMetaClass) == nil])		ifTrue: [^ '------'].	^ self annotationForSelector: aSelector ofClass: aClass! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 9/11/2002 21:30'!annotationForClassCommentFor: aClass	"Provide a line of content for an annotation pane, given that the receiver is pointing at the clas comment of the given class."	| aStamp nonMeta |	aStamp _  (nonMeta _ aClass theNonMetaClass) organization commentStamp.	^ aStamp		ifNil:			[nonMeta name, ' has no class comment']		ifNotNil:			['class comment for ', nonMeta name,				(aStamp = '<historical>'					ifFalse:						[' - ', aStamp]					ifTrue:						[''])]! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 8/26/2002 10:19'!annotationForClassDefinitionFor: aClass	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."	^ 'Class definition for ', aClass name! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 8/26/2002 10:19'!annotationForHierarchyFor: aClass	"Provide a line of content for an annotation pane, given that the receiver is pointing at the hierarchy of the given class."	^ 'Hierarchy for ', aClass name! !!CodeHolder methodsFor: 'annotation' stamp: 'sd 4/29/2003 11:54'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream _ ReadWriteStream on: ''.	requestList _ self annotationRequests.	separator _ requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment _ aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment _ aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment _ aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp _ self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory _ aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount _ (self systemNavigation allCallsOn: aSelector) size.					sendersCount _ sendersCount == 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount _ self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount _ implementorsCount == 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp _ VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString _ ChangeSorter mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList _ ChangeSorter allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!CodeHolder methodsFor: 'annotation' stamp: 'RAA 1/13/2001 07:20'!annotationPaneMenu: aMenu shifted: shifted	^ aMenu 		labels: 'change pane size'		lines: #()		selections: #(toggleAnnotationPaneSize)! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 9/27/1999 14:13'!annotationRequests	^ Preferences defaultAnnotationRequests! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 2/22/2001 10:02'!annotationSeparator	"Answer the separator to be used between annotations"	^ '  '! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 9/28/2001 08:43'!defaultAnnotationPaneHeight	"Answer the receiver's preferred default height for new annotation panes."	^ Preferences parameterAt: #defaultAnnotationPaneHeight ifAbsentPut: [25]! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 9/28/2001 08:44'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!CodeHolder methodsFor: 'categories' stamp: 'sd 2/1/2004 17:56'!categoryFromUserWithPrompt: aPrompt for: aClass	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"	|  labels myCategories reject lines cats newName menuIndex |	labels _ OrderedCollection with: 'new...'.	labels addAll: (myCategories _ aClass organization categories asSortedCollection:		[:a :b | a asLowercase < b asLowercase]).	reject _ myCategories asSet.	reject		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection with: 1 with: (myCategories size + 1).	aClass allSuperclasses do:		[:cls |			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse:				[lines add: labels size.				labels addAll: (cats asSortedCollection:					[:a :b | a asLowercase < b asLowercase]).				reject addAll: cats]].	newName _ (labels size = 1 or:		[menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: aPrompt.		menuIndex = 0 ifTrue: [^ nil].		menuIndex = 1])			ifTrue:				[FillInTheBlank request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: 				[labels at: menuIndex].	^ newName ifNotNil: [newName asSymbol]! !!CodeHolder methodsFor: 'categories' stamp: 'sd 2/1/2004 17:55'!categoryOfCurrentMethod	"Answer the category that owns the current method.  If unable to determine a category, answer nil."	| aClass aSelector |	^ (aClass _ self selectedClassOrMetaClass) 		ifNotNil: [(aSelector _ self selectedMessageName) 			            ifNotNil: [aClass whichCategoryIncludesSelector: aSelector]]! !!CodeHolder methodsFor: 'categories' stamp: 'sd 2/1/2004 17:55'!changeCategory	"Present a menu of the categories of messages for the current class, 	and let the user choose a new category for the current message"	| aClass aSelector |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(aSelector _ self selectedMessageName) ifNotNil:			[(self letUserReclassify: aSelector in: aClass) ifTrue:				["ChangeSet current reorganizeClass: aClass."				"Decided on further review that the above, when present, could cause more                    unexpected harm than good"				self methodCategoryChanged]]]! !!CodeHolder methodsFor: 'categories' stamp: 'sd 2/1/2004 17:54'!letUserReclassify: anElement in: aClass	"Put up a list of categories and solicit one from the user.  	Answer true if user indeed made a change, else false"		| currentCat newCat |	currentCat _ aClass organization categoryOfElement: anElement.	newCat _ self 				categoryFromUserWithPrompt: 'choose category (currently "', currentCat, '")' 				for: aClass.	(newCat ~~ nil and: [newCat ~= currentCat])		ifTrue:			[aClass organization classify: anElement under: newCat suppressIfDefault: false.			^ true]		ifFalse:			[^ false]! !!CodeHolder methodsFor: 'categories' stamp: 'sw 9/27/1999 14:11'!methodCategoryChanged	self changed: #annotation! !!CodeHolder methodsFor: 'categories' stamp: 'sw 3/22/2000 23:04'!selectedMessageCategoryName	"Answer the name of the message category of the message of the currently selected context."	^ self selectedClass organization categoryOfElement: self selectedMessageName! !!CodeHolder methodsFor: 'contents' stamp: 'sw 12/11/2000 10:42'!commentContents	"documentation for the selected method"	| poss aClass aSelector |	^ (poss _ (aClass _ self selectedClassOrMetaClass)						ifNil:							['----']						ifNotNil:							[(aSelector _ self selectedMessageName)								ifNil:									['---']								ifNotNil:									[(aClass precodeCommentOrInheritedCommentFor: aSelector)", String cr, String cr, self timeStamp""which however misses comments that are between the temps  declaration and the body of the method; those are picked up by aClass commentOrInheritedCommentFor: aSelector but that method will get false positives from comments *anywhere* in the method source"]])		isEmptyOrNil			ifTrue:				[aSelector					ifNotNil:						[((aClass methodHeaderFor: aSelector), 'Has no comment') asText makeSelectorBoldIn: aClass]					ifNil:						['Hamna']]			ifFalse:	[aSelector				ifNotNil: [((aClass methodHeaderFor: aSelector), '', poss) asText makeSelectorBoldIn: aClass]				ifNil: [poss]]! !!CodeHolder methodsFor: 'contents' stamp: 'di 10/1/2001 22:25'!contents	"Answer the source code or documentation for the selected method"	self showingByteCodes ifTrue:		[^ self selectedBytecodes].	self showingDocumentation ifTrue:		[^ self commentContents].	^ self selectedMessage! !!CodeHolder methodsFor: 'contents' stamp: 'rhi 12/3/2001 22:25'!contentsChanged	super contentsChanged.	self changed: #annotation! !!CodeHolder methodsFor: 'contents' stamp: 'sw 5/20/2001 10:21'!contentsSymbol	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"	^ contentsSymbol ifNil: [contentsSymbol _ 		Preferences printAlternateSyntax			ifTrue:				[#altSyntax]			ifFalse:				[Preferences browseWithPrettyPrint					ifTrue:						[Preferences colorWhenPrettyPrinting							ifTrue:	[#colorPrint]							ifFalse:	[#prettyPrint]]					ifFalse:						[#source]]]! !!CodeHolder methodsFor: 'contents' stamp: 'sw 11/29/2000 09:51'!contentsSymbol: aSymbol	"Set the contentsSymbol as indicated.  #source means to show source code, #comment means to show the first comment found in the source code"	contentsSymbol _ aSymbol! !!CodeHolder methodsFor: 'commands' stamp: 'sw 7/30/2001 16:31'!abbreviatedWordingFor: aButtonSelector	"Answer the abbreviated form of wording, from a static table which you're welcome to edit.  Answer nil if there is no entry -- in which case the long firm will be used on the corresponding browser button."	#(	(browseMethodFull				'browse')	(browseSendersOfMessages	   	'senders')	(browseMessages				'impl')	(browseVersions					'vers')	(methodHierarchy				'inher')	(classHierarchy					'hier')	(browseInstVarRefs				'iVar')	(browseClassVarRefs				'cVar')	(offerMenu						'menu')) do:		[:pair | pair first == aButtonSelector ifTrue: [^ pair second]].	^ nil! !!CodeHolder methodsFor: 'commands' stamp: 'sd 5/23/2003 14:35'!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self setClassAndSelectorIn: [:cl :sel |		cl ifNotNil:			[ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotation]]! !!CodeHolder methodsFor: 'commands' stamp: 'sd 4/16/2003 09:33'!browseImplementors	"Create and schedule a message set browser on all implementors of the currently selected message selector. Do nothing if no message is selected."	| aMessageName |	(aMessageName _ self selectedMessageName) ifNotNil: 		[self systemNavigation browseAllImplementorsOf: aMessageName]! !!CodeHolder methodsFor: 'commands' stamp: 'nk 6/26/2003 21:43'!browseSenders	"Create and schedule a message set browser on all senders of the currently selected message selector.  Of there is no message currently selected, offer a type-in"	self sendQuery: #browseAllCallsOn: to: self systemNavigation! !!CodeHolder methodsFor: 'commands' stamp: 'BG 10/28/2003 20:51'!copyUpOrCopyDown	"Used to copy down code from a superclass to a subclass or vice-versa in one easy step, if you know what you're doing.  Prompt the user for which class to copy down or copy up to, then spawn a fresh browser for that class, with the existing code planted in it, and with the existing method category also established."	| |	Smalltalk isMorphic ifFalse: [^ self inform: 'Sorry, for the moment you have to be inMorphic to use this feature.'].! !!CodeHolder methodsFor: 'commands' stamp: 'BG 10/28/2003 20:51'!makeSampleInstance	| aClass nonMetaClass anInstance |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ self].	nonMetaClass _ aClass theNonMetaClass.	anInstance _ self sampleInstanceOfSelectedClass.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(Smalltalk isMorphic and: [anInstance isMorph])		ifTrue:			[]		ifFalse:			[anInstance inspectWithLabel: 'An instance of ', nonMetaClass name]! !!CodeHolder methodsFor: 'commands' stamp: 'sw 5/18/2001 17:51'!offerMenu	"Offer a menu to the user from the bar of tool buttons"	self offerDurableMenuFrom: #messageListMenu:shifted: shifted: false! !!CodeHolder methodsFor: 'commands' stamp: 'sw 2/27/2001 12:14'!offerShiftedClassListMenu	"Offer the shifted class-list menu."	^ self offerMenuFrom: #classListMenu:shifted: shifted: true! !!CodeHolder methodsFor: 'commands' stamp: 'sw 2/27/2001 12:15'!offerUnshiftedClassListMenu	"Offer the shifted class-list menu."	^ self offerMenuFrom: #classListMenu:shifted: shifted: false! !!CodeHolder methodsFor: 'commands' stamp: 'nb 6/17/2003 12:25'!removeClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove result |	self okToChange ifFalse: [^ false].	classToRemove _ self selectedClassOrMetaClass ifNil: [Beeper beep. ^ false].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove name.	message _ 'Are you certain that youwant to REMOVE the class ', className, 'from the system?'.	(result _ self confirm: message)		ifTrue: 			[classToRemove subclasses size > 0				ifTrue: [(self confirm: 'class has subclasses: ' , message)					ifFalse: [^ false]].			classToRemove removeFromSystem.			self changed: #classList.			true].	^ result! !!CodeHolder methodsFor: 'commands' stamp: 'sw 3/6/2001 15:18'!shiftedYellowButtonActivity	"Offer the shifted selector-list menu"	^ self offerMenuFrom: #messageListMenu:shifted: shifted: true! !!CodeHolder methodsFor: 'commands' stamp: 'sd 4/29/2003 13:09'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	(cls _ self selectedClass)		ifNil: [^ self].	aList _ self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size == 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport _ String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList)		startUpWithCaption: 'Unreferencedclass variables in ' , cls name! !!CodeHolder methodsFor: 'commands' stamp: 'sw 9/26/2001 01:55'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	(cls _ self selectedClassOrMetaClass) ifNil: [^ self].	aList _ cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport _ String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!CodeHolder methodsFor: 'commands' stamp: 'sw 2/22/2001 06:38'!spawn: aString 	"Create and schedule a spawned message category browser for the currently selected message category.  The initial text view contains the characters in aString.  In the spawned browser, preselect the current selector (if any) as the going-in assumption, though upon acceptance this will often change"	| newBrowser aCategory aClass |	(aClass _ self selectedClassOrMetaClass) isNil ifTrue:		[^ aString isEmptyOrNil ifFalse: [(Workspace new contents: aString) openLabel: 'spawned workspace']].	(aCategory _ self categoryOfCurrentMethod)		ifNil:			[self buildClassBrowserEditString: aString]		ifNotNil:			[newBrowser _ Browser new setClass: aClass selector: self selectedMessageName.			self suggestCategoryToSpawnedBrowser: newBrowser.			Browser openBrowserView: (newBrowser openMessageCatEditString: aString)		label: 'category "', aCategory, '" in ', 				newBrowser selectedClassOrMetaClassName]! !!CodeHolder methodsFor: 'commands' stamp: 'sw 12/4/2000 12:07'!spawnFullProtocol	"Create and schedule a new protocol browser on the currently selected class or meta."	| aClassOrMetaclass |	(aClassOrMetaclass _ self selectedClassOrMetaClass) ifNotNil:       	[ProtocolBrowser openFullProtocolForClass: aClassOrMetaclass]! !!CodeHolder methodsFor: 'commands' stamp: 'BG 10/28/2003 20:52'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass _ self selectedClassOrMetaClass)		ifNil: [^ self].	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	((aSymbol _ self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])		ifTrue:			[aBehavior _ selectedClassOrMetaClass.			messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.			newBrowser messageCategoryListIndex: messageCatIndex + 1.			newBrowser messageListIndex:				((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol)].	Browser		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString.	! !!CodeHolder methodsFor: 'commands' stamp: 'sw 5/8/2000 14:24'!spawnProtocol	| aClassOrMetaclass |	"Create and schedule a new protocol browser on the currently selected class or meta."	(aClassOrMetaclass _ self selectedClassOrMetaClass) ifNotNil:       	[ProtocolBrowser openSubProtocolForClass: aClassOrMetaclass]! !!CodeHolder methodsFor: 'commands' stamp: 'sw 3/20/2001 15:10'!spawnToClass: aClass	"Used to copy down code from a superclass to a subclass in one easy step, if you know what you're doing.  Spawns a new message-category browser for the indicated class, populating it with the source code seen in the current tool."	| aCategory newBrowser org |		(aCategory _ self categoryOfCurrentMethod)		ifNil:			[self buildClassBrowserEditString: self contents]		ifNotNil:			[((org _ aClass organization) categories includes: aCategory)				ifFalse:	[org addCategory: aCategory].			newBrowser _ Browser new setClass: aClass selector: nil.			newBrowser selectMessageCategoryNamed: aCategory.			Browser openBrowserView: (newBrowser openMessageCatEditString: self contents)		label: 'category "', aCategory, '" in ', 				newBrowser selectedClassOrMetaClassName]! !!CodeHolder methodsFor: 'commands' stamp: 'sw 3/20/2001 15:11'!spawnToCollidingClass: aClass	"Potentially used to copy down code from a superclass to a subclass in one easy step, in the case where the given class already has its own version of code, which would consequently be clobbered if the spawned code were accepted."	self inform: 'That would be destructive ofsome pre-existing code already in thatclass for this selector.  For the moment,we will not let you do this to yourself.'! !!CodeHolder methodsFor: 'commands' stamp: 'sw 3/6/2001 15:19'!unshiftedYellowButtonActivity	"Offer the unshifted shifted selector-list menu"	^ self offerMenuFrom: #messageListMenu:shifted: shifted: false! !!CodeHolder methodsFor: 'construction' stamp: 'sw 1/4/2001 12:34'!buildClassBrowserEditString: aString 	"Create and schedule a new class browser for the current selection, with initial textual contents set to aString.  This is used specifically in spawning where a class is established but a method-category is not."	| newBrowser  |	newBrowser _ Browser new.	newBrowser setClass: self selectedClassOrMetaClass selector: nil.	newBrowser editSelection: #newMessage.	Browser openBrowserView: (newBrowser openOnClassWithEditString: aString)			label: 'Class Browser: ', self selectedClassOrMetaClass name! !!CodeHolder methodsFor: 'controls' stamp: 'BG 10/29/2003 09:43'!buttonWithSelector: aSelector	"If receiver has a control button with the given action selector answer it, else answer nil.  morphic only at this point"	^nil! !!CodeHolder methodsFor: 'controls' stamp: 'sw 5/19/2001 01:12'!codePaneProvenanceString	"Answer a string that reports on code-pane-provenance"	| symsAndWordings |	(symsAndWordings _ self contentsSymbolQuints) do:		[:aQuad |			contentsSymbol == aQuad first ifTrue: [^ aQuad fourth]].	^ symsAndWordings first fourth "default to plain source, for example if nil as initially"! !!CodeHolder methodsFor: 'controls' stamp: 'sw 11/13/2001 07:48'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source			togglePlainSource 			showingPlainSourceString	'source'		'the textual source code as writen')(documentation	toggleShowDocumentation	showingDocumentationString	'documentation'		'the first comment in the method')-(prettyPrint		togglePrettyPrint 			prettyPrintString			'prettyPrint'			'the method source presented in a standard text format')(colorPrint		toggleColorPrint				colorPrintString				'colorPrint'			'the method source in a standard text format with colors to distinguish structural parts') (altSyntax		toggleAltSyntax				showingAltSyntaxString		'altSyntax'			'alternative syntax')-(showDiffs		toggleRegularDiffing		showingRegularDiffsString	'showDiffs'				'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing			showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version')-(decompile		toggleDecompile				showingDecompileString		'decompile'			'source code decompiled from byteCodes')(byteCodes		toggleShowingByteCodes		showingByteCodesString		'byteCodes'			'the bytecodes that comprise the compiled method')-(tiles			toggleShowingTiles 			showingTilesString			'tiles'				'universal tiles representing the method'))! !!CodeHolder methodsFor: 'controls' stamp: 'sw 1/5/2001 07:19'!decorateButtons	"Change screen feedback for any buttons in the UI of the receiver that may wish it.  Initially, it is only the Inheritance button that is decorated, but one can imagine others."	self decorateForInheritance ! !!CodeHolder methodsFor: 'controls' stamp: 'nk 7/6/2003 08:29'!decorateForInheritance	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."	| aColor aButton flags |	(aButton _ self inheritanceButton) ifNil: [^ self].	((currentCompiledMethod isKindOf: CompiledMethod) and: [Preferences decorateBrowserButtons])		ifFalse: [^aButton offColor: Color transparent].	"This table duplicates the old logic, but adds two new colors for the cases where there is a superclass definition, but this method doesn't call it."	flags _ 0.	self isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].	currentCompiledMethod sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].	self isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].	aColor _ {		Color transparent.		Color tan lighter.		Color green muchLighter.		Color blue muchLighter.		Color red muchLighter.	"has super but doesn't call it"		(Color r: 0.94 g: 0.823 b: 0.673).	"has sub; has super but doesn't call it"		Color green muchLighter.		Color blue muchLighter.	} at: flags + 1.	aButton offColor: aColor! !!CodeHolder methodsFor: 'controls' stamp: 'sw 1/25/2001 14:44'!inheritanceButton	"If receiver has an Inheritance button, answer it, else answer nil.  morphic only at this point"	^ self buttonWithSelector: #methodHierarchy! !!CodeHolder methodsFor: 'controls' stamp: 'nk 7/7/2003 11:39'!optionalButtonPairs	"Answer a tuple (formerly pairs) defining buttons, in the format:			button label			selector to send			help message"	| aList |	aList _ #(	('browse'			browseMethodFull			'view this method in a browser')	('senders' 			browseSendersOfMessages	'browse senders of...')	('implementors'		browseMessages				'browse implementors of...')	('versions'			browseVersions				'browse versions')), 	(Preferences decorateBrowserButtons		ifTrue:			[{#('inheritance'		methodHierarchy 'browse method inheritancegreen: sends to supertan: has override(s)mauve: both of the abovepink: is an override but doesn''t call superpinkish tan: has override(s), also is an override but doesn''t call super' )}]		ifFalse:			[{#('inheritance'		methodHierarchy			'browse method inheritance')}]),	#(	('hierarchy'		classHierarchy				'browse class hierarchy')	('inst vars'			browseInstVarRefs			'inst var refs...')	('class vars'			browseClassVarRefs			'class var refs...')).	^ aList! !!CodeHolder methodsFor: 'controls' stamp: 'sw 11/13/2001 09:12'!sourceAndDiffsQuintsOnly	"Answer a list of quintuplets representing information on the alternative views available in the code pane for the case where the only plausible choices are showing source or either of the two kinds of diffs"	^ #((source			togglePlainSource 		showingPlainSourceString	'source'			'the textual source code as writen')(showDiffs		toggleRegularDiffing	showingRegularDiffsString	'showDiffs'		'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing		showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version'))! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 9/5/2001 13:36'!defaultDiffsSymbol	"Answer the code symbol to use when generically switching to diffing"	^ Preferences diffsWithPrettyPrint 		ifTrue:			[#prettyDiffs]		ifFalse:			[#showDiffs]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/20/2001 21:14'!diffFromPriorSourceFor: sourceCode 	"If there is a prior version of source for the selected method, return a diff, else just return the source code"	| prior |	^ (prior _ self priorSourceOrNil)		ifNil: [sourceCode]		ifNotNil: [TextDiffBuilder buildDisplayPatchFrom: prior to: sourceCode inClass: self selectedClass prettyDiffs: self showingPrettyDiffs]! !!CodeHolder methodsFor: 'diffs' stamp: 'BG 10/29/2003 07:56'!restoreTextualCodingPane	"If the receiver is showing tiles, restore the textual coding pane"	contentsSymbol _ #source.! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:49'!showDiffs	"Answer whether the receiver is showing diffs of source code.  The preferred protocol here is #showingRegularDiffs, but this message is still sent by some preexisting buttons so is retained."	^ contentsSymbol == #showDiffs! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 9/5/2001 13:36'!showDiffs: aBoolean	"Set whether I'm showing diffs as indicated; use the global preference to determine which kind of diffs to institute."	self showingAnyKindOfDiffs		ifFalse:			[aBoolean ifTrue:				[contentsSymbol _ self defaultDiffsSymbol]]		ifTrue:			[aBoolean ifFalse:				[contentsSymbol _ #source]].	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/22/2001 18:25'!showPrettyDiffs: aBoolean	"Set whether I'm showing pretty diffs as indicated"	self showingPrettyDiffs		ifFalse:			[aBoolean ifTrue:				[contentsSymbol _ #prettyDiffs]]		ifTrue:			[aBoolean ifFalse:				[contentsSymbol _ #source]].	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:50'!showRegularDiffs: aBoolean	"Set whether I'm showing regular diffs as indicated"	self showingRegularDiffs		ifFalse:			[aBoolean ifTrue:				[contentsSymbol _ #showDiffs]]		ifTrue:			[aBoolean ifFalse:				[contentsSymbol _ #source]].	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 9/5/2001 13:32'!showingAnyKindOfDiffs	"Answer whether the receiver is currently set to show any kind of diffs"	^ #(showDiffs prettyDiffs) includes: contentsSymbol! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 09:10'!showingDiffsString	"Answer a string representing whether I'm showing diffs.  Not sent any more but retained so that prexisting buttons that sent this will not raise errors."	^ (self showingRegularDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'showDiffs'! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/19/2001 00:07'!showingPrettyDiffs	"Answer whether the receiver is showing pretty diffs of source code"	^ contentsSymbol == #prettyDiffs! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/22/2001 16:41'!showingPrettyDiffsString	"Answer a string representing whether I'm showing pretty diffs"	^ (self showingPrettyDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'prettyDiffs'! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:07'!showingRegularDiffs	"Answer whether the receiver is showing regular diffs of source code"	^ contentsSymbol == #showDiffs! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:43'!showingRegularDiffsString	"Answer a string representing whether I'm showing regular diffs"	^ (self showingRegularDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'showDiffs'! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 23:50'!toggleColorPrint	"Toggle whether color-print is in effect in the code pane"	self restoreTextualCodingPane.	self okToChange ifTrue:		[self showingColorPrint			ifTrue:				[contentsSymbol _ #source]			ifFalse:				[contentsSymbol _ #colorPrint].		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 1/18/2001 13:58'!toggleDiff	"Retained for backward compatibility with existing buttons in existing images"	self toggleDiffing! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:30'!toggleDiffing	"Toggle whether diffs should be shown in the code pane.  If any kind of diffs were being shown, stop showing diffs.  If no kind of diffs were being shown, start showing whatever kind of diffs are called for by default."	| wasShowingDiffs |	self okToChange ifTrue:		[wasShowingDiffs _ self showingAnyKindOfDiffs.		self restoreTextualCodingPane.		self showDiffs: wasShowingDiffs not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:57'!togglePlainSource	"Toggle whether plain source shown in the code pane"		| wasShowingPlainSource |	self okToChange ifTrue:		[wasShowingPlainSource _ self showingPlainSource.		self restoreTextualCodingPane.		wasShowingPlainSource			ifTrue:				[self showDocumentation: true]			ifFalse:				[contentsSymbol _ #source].		self setContentsToForceRefetch.		self changed: #contents]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/19/2001 00:02'!togglePrettyDiffing	"Toggle whether pretty-diffing should be shown in the code pane"	| wasShowingDiffs |	self okToChange ifTrue:		[wasShowingDiffs _ self showingPrettyDiffs.		self restoreTextualCodingPane.		self showPrettyDiffs: wasShowingDiffs not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:54'!togglePrettyPrint	"Toggle whether pretty-print is in effectin the code pane"	self restoreTextualCodingPane.	self okToChange ifTrue:		[self showingPrettyPrint			ifTrue:				[contentsSymbol _ #source]			ifFalse:				[contentsSymbol _ #prettyPrint].		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:27'!toggleRegularDiffing	"Toggle whether regular-diffing should be shown in the code pane"	| wasShowingDiffs |	self okToChange ifTrue:		[wasShowingDiffs _ self showingRegularDiffs.		self restoreTextualCodingPane.		self showRegularDiffs: wasShowingDiffs not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 11/13/2001 07:24'!wantsDiffFeedback	"Answer whether the receiver is showing diffs of source code"	^ self showingAnyKindOfDiffs! !!CodeHolder methodsFor: 'misc' stamp: 'nk 4/10/2001 07:52'!getSelectorAndSendQuery: querySelector to: queryPerformer	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained as its argument.  If no message is currently selected, then obtain a method name from a user type-in"	self getSelectorAndSendQuery: querySelector to: queryPerformer with: { }.! !!CodeHolder methodsFor: 'misc' stamp: 'nk 4/10/2001 07:53'!getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"	| strm array |	strm _ WriteStream on: (array _ Array new: queryArgs size + 1).	strm nextPut: nil.	strm nextPutAll: queryArgs.	self selectedMessageName ifNil: [ | selector |		selector _ FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.		^ selector isEmptyOrNil ifFalse: [			(Symbol hasInterned: selector				ifTrue: [ :aSymbol |					array at: 1 put: aSymbol.					queryPerformer perform: querySelector withArguments: array])				ifFalse: [ self inform: 'no such selector']		]	].	self selectMessageAndEvaluate: [:selector |		array at: 1 put: selector.		queryPerformer perform: querySelector withArguments: array	]! !!CodeHolder methodsFor: 'misc' stamp: 'nk 7/6/2003 07:49'!isThereAnOverride	"Answer whether any subclass of my selected class implements my 	selected selector"	| aName aClass |	aName _ self selectedMessageName				ifNil: [^ false].	aClass _ self selectedClassOrMetaClass.	aClass allSubclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].	^ false! !!CodeHolder methodsFor: 'misc' stamp: 'nk 7/6/2003 07:52'!isThisAnOverride	"Answer whether any superclass of my selected class implements my selected selector"	| aName aClass |	aName _ self selectedMessageName				ifNil: [^ false].	aClass _ self selectedClassOrMetaClass.	aClass allSuperclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].	^ false! !!CodeHolder methodsFor: 'misc' stamp: 'sw 9/27/2001 01:26'!modelWakeUpIn: aWindow	"The window has been activated.  Respond to possible changes that may have taken place while it was inactive"	self updateListsAndCodeIn: aWindow.	self decorateButtons.	self refreshAnnotation.	super modelWakeUpIn: aWindow! !!CodeHolder methodsFor: 'misc' stamp: 'sw 11/13/2001 07:42'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	self showingDocumentation ifTrue:		[self inform: 'Sorry, for the moment you canonly submit changes here whenyou are showing source.  Later, youwill be able to edit the isolated commenthere and save it back, but only if YOUimplement it!!.'.		^ false].	self showingAnyKindOfDiffs ifFalse:		[^ true]. 	^ SelectionMenu confirm: 'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display'	trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider'! !!CodeHolder methodsFor: 'misc' stamp: 'sw 9/27/1999 14:09'!priorSourceOrNil	"If the currently-selected method has a previous version, return its source, else return nil"	| aClass aSelector  changeRecords |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	(aSelector _ self selectedMessageName) ifNil: [^ nil].	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].	^ (changeRecords at: 2) string ! !!CodeHolder methodsFor: 'misc' stamp: 'BG 11/1/2003 13:26'!refreshAnnotation	"If the receiver has an annotation pane that does not bear unaccepted edits, refresh it"	(self dependents detect: [:m | (m inheritsFromAnyIn: #('PluggableTextView')) and: [m getTextSelector == #annotation]] ifNone: [nil]) ifNotNilDo:		[:aPane | aPane hasUnacceptedEdits ifFalse:			[aPane update: #annotation]]! !!CodeHolder methodsFor: 'misc' stamp: 'sw 5/22/2001 16:47'!refusesToAcceptCode	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"	^ (#(byteCodes documentation altSyntax tiles) includes: self contentsSymbol)! !!CodeHolder methodsFor: 'misc' stamp: 'tk 9/9/2000 21:08'!releaseCachedState	"Can always be found again.  Don't write on a file."	currentCompiledMethod _ nil.! !!CodeHolder methodsFor: 'misc' stamp: 'sw 5/8/2000 12:34'!sampleInstanceOfSelectedClass	| aClass |	"Return a sample instance of the class currently being pointed at"	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	^ aClass theNonMetaClass initializedInstance! !!CodeHolder methodsFor: 'misc' stamp: 'sw 3/19/2001 06:06'!sendQuery: querySelector to: queryPerformer	"Apply a query to the primary selector associated with the current context.  If no such selection exists, obtain one by user type-in. Then send querySelector to queryPerformer with the selector as its argument."	| aSelector aString |	aSelector _ self selectedMessageName ifNil:		[aString _FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.		^ aString isEmptyOrNil ifFalse:			[(Symbol hasInterned: aString ifTrue:				[:aSymbol | queryPerformer perform: querySelector with: aSymbol])				ifFalse:					[self inform: 'no such selector']]].	queryPerformer perform: querySelector with: aSelector! !!CodeHolder methodsFor: 'misc' stamp: 'sw 12/28/2000 15:32'!setClassAndSelectorIn: csBlock	"Evaluate csBlock with my selected class and and selector as its arguments; provide nil arguments if I don't have a method currently selected"	| aName |	(aName _ self selectedMessageName)		ifNil:			[csBlock value: nil value: nil]		ifNotNil:			[csBlock value: self selectedClassOrMetaClass value: aName]! !!CodeHolder methodsFor: 'misc' stamp: 'sw 2/22/2001 06:37'!suggestCategoryToSpawnedBrowser: aBrowser	"aBrowser is a message-category browser being spawned from the receiver.  Tell it what it needs to know to get its category info properly set up."	aBrowser setOriginalCategoryIndexForCurrentMethod! !!CodeHolder methodsFor: 'misc' stamp: 'sw 3/20/2001 09:26'!useSelector: incomingSelector orGetSelectorAndSendQuery: querySelector to: queryPerformer	"If incomingSelector is not nil, use it, else obtain a selector from user type-in.   Using the determined selector, send the query to the performer provided."	| aSelector |	incomingSelector		ifNotNil:			[queryPerformer perform: querySelector with: incomingSelector]		ifNil:			[aSelector _FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.			aSelector isEmptyOrNil ifFalse:				[(Symbol hasInterned: aSelector ifTrue:					[:aSymbol | queryPerformer perform: querySelector with: aSymbol])					ifFalse:						[self inform: 'no such selector']]]! !!CodeHolder methodsFor: 'self-updating' stamp: 'sw 7/31/2002 13:11'!didCodeChangeElsewhere	"Determine whether the code for the currently selected method and class has been changed somewhere else."	| aClass aSelector aCompiledMethod |	currentCompiledMethod ifNil: [^ false].	(aClass _ self selectedClassOrMetaClass) ifNil: [^ false].	(aSelector _ self selectedMessageName) ifNil: [^ false].	aSelector == #Comment ifTrue:		[^ currentCompiledMethod ~~ aClass organization commentRemoteStr].	^ ((aCompiledMethod _ aClass compiledMethodAt: aSelector ifAbsent: [^ false]) ~~ currentCompiledMethod)		and: [aCompiledMethod last ~= 0 "either not yet installed"				or: [currentCompiledMethod last = 0 "or these methods don't have source pointers"]]	! !!CodeHolder methodsFor: 'self-updating' stamp: 'sw 10/19/1999 08:37'!stepIn: aSystemWindow	self updateListsAndCodeIn: aSystemWindow! !!CodeHolder methodsFor: 'self-updating' stamp: 'sw 2/14/2001 15:34'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue:			[self hasUnacceptedEdits				ifFalse:					[self setContentsToForceRefetch.					self contentsChanged]				ifTrue:					[self changed: #codeChangedElsewhere]]! !!CodeHolder methodsFor: 'self-updating' stamp: 'sw 10/19/1999 14:14'!updateListsAndCodeIn: aWindow	super updateListsAndCodeIn: aWindow.	self updateCodePaneIfNeeded! !!CodeHolder methodsFor: 'self-updating' stamp: 'sw 10/20/1999 12:22'!wantsStepsIn: aWindow	^ Preferences smartUpdating! !!CodeHolder methodsFor: 'what to show' stamp: 'ssa 9/3/2008 11:02'!addContentsTogglesTo: aMenu 	"Add updating menu toggles governing contents to aMenu."	self contentsSymbolQuints		do: [:aQuint | aQuint == #-				ifTrue: [aMenu addLine]				ifFalse: [Smalltalk isMorphic						ifTrue: []						ifFalse: [aMenu								add: (('<yes>*' match: (self perform: aQuint third)) ifTrue: ['*'] ifFalse: ['']), aQuint fourth								target: self								selector: #contentsSymbol: 								argumentList: { aQuint first } ]]]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 16:36'!colorPrintString	"Answer whether the receiver is showing colorPrint"	^ (self showingColorPrint		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'colorPrint'! !!CodeHolder methodsFor: 'what to show' stamp: 'ssa 9/3/2008 10:29'!offerWhatToShowMenu	"Offer a menu governing what to show"	| aMenu |	Smalltalk isMorphic		ifTrue: []		ifFalse: [aMenu := CustomMenu new.			self addContentsTogglesTo: aMenu.			aMenu title: 'What to show' translated.			aMenu invokeOn: self.			self changed: #contents ]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 16:36'!prettyPrintString	"Answer whether the receiver is showing pretty-print"	^ ((contentsSymbol == #prettyPrint)		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'prettyPrint'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 2/14/2001 15:25'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	contents _ nil! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:26'!showAltSyntax: aBoolean	"Set the decompile toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#altSyntax])! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 21:13'!showByteCodes: aBoolean	"Get into or out of bytecode-showoing mode"	self okToChange ifFalse: [^ self changed: #flash].	aBoolean		ifTrue:			[contentsSymbol _ #byteCodes]		ifFalse:			[contentsSymbol == #byteCodes ifTrue: [contentsSymbol _ #source]].	self contentsChanged! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 12/5/2000 11:32'!showComment	"Answer whether the receiver should show documentation rather than, say, source code"	^ self contentsSymbol == #documentation! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:14'!showDecompile: aBoolean	"Set the decompile toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#decompile])! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 12/5/2000 12:25'!showDocumentation: aBoolean	"Set the showDocumentation toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#documentation])! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:27'!showingAltSyntax	"Answer whether the receiver should show alt syntax rather than, say, source code"	^ self contentsSymbol == #altSyntax! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 16:37'!showingAltSyntaxString	"Answer a string characerizing whether altSyntax is showing"	^ (self showingAltSyntax		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'altSyntax'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 18:05'!showingByteCodes	"Answer whether the receiver is showing bytecodes"	^ contentsSymbol == #byteCodes! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 18:28'!showingByteCodesString	"Answer whether the receiver is showing bytecodes"	^ (self showingByteCodes		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'byteCodes'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 23:50'!showingColorPrint	"Answer whether the receiver is showing color-pretty-print"	^ contentsSymbol == #colorPrint! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 06:52'!showingDecompile	"Answer whether the receiver should show decompile rather than, say, source code"	^ self contentsSymbol == #decompile! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 06:50'!showingDecompileString	"Answer a string characerizing whether decompilation is showing"	^ (self showingDecompile		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'decompile'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 12/5/2000 12:12'!showingDocumentation	"Answer whether the receiver should show documentation rather than, say, source code"	^ self contentsSymbol == #documentation! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 20:05'!showingDocumentationString	"Answer a string characerizing whether documentation is showing"	^ (self showingDocumentation		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'documentation'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 19:43'!showingPlainSource	"Answer whether the receiver is showing plain source"	^ contentsSymbol == #source! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 09:31'!showingPlainSourceString	"Answer a string telling whether the receiver is showing plain source"	^ (self showingPlainSource		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'source'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 18:36'!showingPrettyPrint	"Answer whether the receiver is showing pretty-print"	^ contentsSymbol == #prettyPrint! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 12/5/2000 11:48'!showingSource	"Answer whether the receiver is currently showing source code"	^ self contentsSymbol == #source! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:28'!toggleAltSyntax	"Toggle the setting of the showingAltSyntax flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing _ self showingAltSyntax.		self restoreTextualCodingPane.		self showAltSyntax: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 06:48'!toggleDecompile	"Toggle the setting of the showingDecompile flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing _ self showingDecompile.		self restoreTextualCodingPane.		self showDecompile: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 20:15'!toggleShowDocumentation	"Toggle the setting of the showingDocumentation flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing _ self showingDocumentation.		self restoreTextualCodingPane.		self showDocumentation: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 20:09'!toggleShowingByteCodes	"Toggle whether the receiver is showing bytecodes"	self restoreTextualCodingPane.	self showByteCodes: self showingByteCodes not.	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'tiles' stamp: 'ssa 9/3/2008 11:03'!addModelItemsToWindowMenu: aMenu	"Add model-related item to the window menu"	super addModelItemsToWindowMenu: aMenu. ! !!CodeHolder methodsFor: 'tiles' stamp: 'rhi 1/4/2002 11:15'!showTiles: aBoolean	"Set the showingTiles as indicated.  The fact that there are initially no senders of this reflects that fact that initially this trait is only directly settable through the UI; later there may be senders, such as if one wanted to set a system up so that all newly-opened browsers showed tiles rather than text."	aBoolean		ifTrue:			[contentsSymbol _ #tiles]		ifFalse:			[contentsSymbol == #tiles ifTrue: [contentsSymbol _ #source]].	self setContentsToForceRefetch.	self changed: #contents! !!CodeHolder methodsFor: 'tiles' stamp: 'sw 2/3/2001 00:10'!showingTiles	"Answer whether the receiver is currently showing tiles"	^ contentsSymbol == #tiles! !!CodeHolder methodsFor: 'tiles' stamp: 'sw 5/20/2001 21:12'!showingTilesString	"Answer a string characterizing whether tiles are currently showing or not"	^ (self showingTiles		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'tiles'! !!CodeHolder methodsFor: 'categories & search pane' stamp: 'sw 3/7/2001 12:22'!searchPane	"Answer the search pane associated with the receiver in its window, or nil if none.  Morphic only"	^ self textPaneWithSelector: #lastSearchString! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50'!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:41'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new						parse: method getSourceFromFile asString						in: class						notifying: nil) tempNames.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !!CodeHolder methodsFor: 'message list' stamp: 'sw 8/16/2002 23:23'!selectedBytecodes	"Answer text to show in a code pane when in showing-byte-codes mode"	^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName ifAbsent: [^ '' asText]) symbolic asText! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:46'!selectedMessage	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."	| class selector method |	contents ifNotNil: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].	class _ self selectedClassOrMetaClass.	(class isNil or: [(selector _ self selectedMessageName) isNil]) ifTrue: [^ ''].	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ contents _ (self showComment		ifFalse: [self sourceStringPrettifiedAndDiffed]		ifTrue:	[ self commentContents])			copy asText makeSelectorBoldIn: class! !!CodeHolder methodsFor: 'message list' stamp: 'sw 7/23/2002 13:05'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^ 'missing'].	sourceString _ class ultimateSourceCodeAt: selector ifAbsent: [^ 'error'].	self validateMessageSource: sourceString forSelector: selector.	(#(prettyPrint colorPrint prettyDiffs altSyntax) includes: contentsSymbol) ifTrue:		[sourceString _ class compilerClass new			format: sourceString in: class notifying: nil contentsSymbol: contentsSymbol].	self showingAnyKindOfDiffs ifTrue:		[sourceString _ self diffFromPriorSourceFor: sourceString].	^ sourceString! !!CodeHolder methodsFor: 'message list' stamp: 'sd 9/30/2003 14:01'!validateMessageSource: sourceString forSelector: aSelector	"Check whether there is evidence that method source is invalid"	| sourcesName |	(self selectedClass compilerClass == Object compilerClass 			and: [(sourceString asString findString: aSelector keywords first ) ~= 1])		ifTrue: [sourcesName _ FileDirectory localNameFor: SmalltalkImage current sourcesName.			self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'].! !!CodeHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 09:33'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel _ self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: self systemNavigation].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: self systemNavigation].	"The following require a class selection"	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage].		(aChar == $C and: [self canShowMultipleMessageCategories])			ifTrue: [^ self showHomeCategory]].	^ self arrowKey: aChar from: view! !!CodeHolder methodsFor: 'message category functions' stamp: 'sw 10/8/2001 14:19'!canShowMultipleMessageCategories	"Answer whether the receiver is capable of showing multiple message categories"	^ false! !Object subclass: #Collection	instanceVariableNames: ''	classVariableNames: 'MutexForPicking RandomForPicking'	poolDictionaries: ''	category: 'Collections-Abstract'!!Collection commentStamp: '<historical>' prior: 0!I am the abstract superclass of all classes that represent a group of elements.!!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:33'!anyOne	"Answer a representative sample of the receiver. This method can	be helpful when needing to preinfer the nature of the contents of 	semi-homogeneous collections."	self emptyCheck.	self do: [:each | ^ each]! !!Collection methodsFor: 'accessing' stamp: 'sd 11/4/2003 22:05'!atRandom	"Answer a random element of the receiver.  Uses a shared random 	number generator owned by class Collection.  If you use this a lot, 	define your own instance of Random and use #atRandom:.  Causes 	an error if self has no elements."	^ self class mutexForPicking critical: [		self atRandom: self class randomForPicking ]"Examples:	#('one' 'or' 'the' 'other') atRandom	(1 to: 10) atRandom	'Just pick one of these letters at random' atRandom	#(3 7 4 9 21) asSet atRandom		(just to show it also works for Sets)"! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:41'!capacity	"Answer the current capacity of the receiver."	^ self size! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:34'!size	"Answer how many elements the receiver contains."	| tally |	tally _ 0.	self do: [:each | tally _ tally + 1].	^ tally! !!Collection methodsFor: 'adapting' stamp: 'di 11/6/1998 13:34'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with another Collection, return a Collection of	the results of each element combined with the scalar in that expression."	rcvr isSequenceable & self isSequenceable ifFalse:		[self error: 'Only sequenceable collections may be combined arithmetically'].	^ rcvr with: self collect:		[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]! !!Collection methodsFor: 'adapting' stamp: 'di 11/9/1998 12:16'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'adapting' stamp: 'di 11/6/1998 13:37'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'adapting' stamp: 'di 11/6/1998 13:37'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Collection methodsFor: 'adding'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject. 	ArrayedCollections cannot respond to this message."	self subclassResponsibility! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:21'!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:26'!addAll: aCollection 	"Include all the elements of aCollection as the receiver's elements. Answer 	aCollection. Actually, any object responding to #do: can be used as argument."	aCollection do: [:each | self add: each].	^ aCollection! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:23'!addIfNotPresent: anObject	"Include anObject as one of the receiver's elements, but only if there	is no such element already. Anwser anObject."	(self includes: anObject) ifFalse: [self add: anObject].	^ anObject! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!* arg	^ arg adaptToCollection: self andSend: #*! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!+ arg	^ arg adaptToCollection: self andSend: #+! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!- arg	^ arg adaptToCollection: self andSend: #-! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!/ arg	^ arg adaptToCollection: self andSend: #/! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!// arg	^ arg adaptToCollection: self andSend: #//! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!\\ arg	^ arg adaptToCollection: self andSend: #\\! !!Collection methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 00:17'!raisedTo: arg	^ arg adaptToCollection: self andSend: #raisedTo:! !!Collection methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:36'!hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash _ self species hash.	self size <= 10 ifTrue:		[self do: [:elem | hash _ hash bitXor: elem hash]].	^hash bitXor: self size hash! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array _ Array new: self size.	index _ 0.	self do: [:each | array at: (index _ index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:10'!asBag	"Answer a Bag whose elements are the elements of the receiver."	^ Bag withAll: self! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver.	Implementation note: Cannot use ''ByteArray withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array _ ByteArray new: self size.	index _ 0.	self do: [:each | array at: (index _ index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:26'!asCharacterSet	"Answer a CharacterSet whose elements are the unique elements of the receiver.	The reciever should only contain characters."	^ CharacterSet newFrom: self! !!Collection methodsFor: 'converting' stamp: 'ar 9/22/2000 10:12'!asIdentitySet	^(IdentitySet new: self size) addAll: self; yourself! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:43'!asOrderedCollection	"Answer an OrderedCollection whose elements are the elements of the	receiver. The order in which elements are added depends on the order	in which the receiver enumerates its elements. In the case of unordered	collections, the ordering is not necessarily the same for multiple 	requests for the conversion."	^ self as: OrderedCollection! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:29'!asSet	"Answer a Set whose elements are the unique elements of the receiver."	^ Set withAll: self! !!Collection methodsFor: 'converting' stamp: 'LC 6/18/2001 18:46'!asSkipList: aSortBlock 	"Answer a SkipList whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| skipList |	skipList _ SortedCollection new: self size.	skipList sortBlock: aSortBlock.	skipList addAll: self.	^ skipList! !!Collection methodsFor: 'converting'!asSortedArray	"Return a copy of the receiver in sorted order, as an Array.  6/10/96 sw"	^ self asSortedCollection asArray! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:44'!asSortedCollection	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is the default less than or equal."	^ self as: SortedCollection! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:46'!asSortedCollection: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection _ SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!Collection methodsFor: 'converting' stamp: 'hg 12/26/2001 23:53'!topologicallySortedUsing: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver, but topologically sorted. The topological order is defined 	by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection _ SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	self do: [:each | aSortedCollection addLast: each].	"avoids sorting"	^ aSortedCollection sortTopologically! !!Collection methodsFor: 'copying' stamp: 'al 12/12/2003 14:31'!, aCollection	^self copy addAll: aCollection; yourself! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 14:41'!copyWith: newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	^ self copy		add: newElement;		yourself! !!Collection methodsFor: 'copying' stamp: 'ar 2/11/2001 01:55'!copyWithDependent: newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	^self copyWith: newElement! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 14:43'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self reject: [:each | each = oldElement]"Examples:	'fred the bear' copyWithout: $e	#(2 3 4 5 5 6) copyWithout: 5"! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 18:08'!copyWithoutAll: aCollection	"Answer a copy of the receiver that does not contain any elements 	equal to those in aCollection."	^ self reject: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'sma 4/30/2000 11:17'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!Collection methodsFor: 'enumerating' stamp: 'sma 4/30/2000 11:17'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!Collection methodsFor: 'enumerating'!associationsDo: aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:45'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:51'!collect: collectBlock thenSelect: selectBlock	"Utility method to improve readability."	^ (self collect: collectBlock) select: selectBlock! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum _ 0.	self do: [:each | (aBlock value: each) ifTrue: [sum _ sum + 1]].	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:20'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!Collection methodsFor: 'enumerating'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val _ aBlock value: each) > maxValue ifTrue: [					maxElement _ each.					maxValue _ val]]			ifTrue: ["first element"				maxElement _ each.				maxValue _ aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!Collection methodsFor: 'enumerating'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val _ aBlock value: each) < minValue ifTrue: [					minElement _ each.					minValue _ val]]			ifTrue: ["first element"				minElement _ each.				minValue _ aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!Collection methodsFor: 'enumerating'!detectSum: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Return the sum of the answers."	| sum |	sum _ 0.	self do: [:each | 		sum _ (aBlock value: each) + sum].  	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 17:52'!difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating'!do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	self subclassResponsibility! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:57'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst _ true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst _ false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:59'!do: aBlock without: anItem 	"Enumerate all elements in the receiver. 	Execute aBlock for those elements that are not equal to the given item"	^ self do: [:each | anItem = each ifFalse: [aBlock value: each]]! !!Collection methodsFor: 'enumerating'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue _ thisValue.	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].	^nextValue! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 17:52'!intersection: aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'gh 9/18/2001 15:59'!noneSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:item | (aBlock value: item) ifTrue: [^ false]].	^ true! !!Collection methodsFor: 'enumerating'!reject: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^self select: [:element | (aBlock value: element) == false]! !!Collection methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:59'!select: selectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 17:54'!union: aCollection	"Answer the set theoretic union of two collections."	^ self asSet addAll: aCollection; yourself! !!Collection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 12:07'!contents	^ self! !!Collection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 12:08'!flattenOnStream: aStream 	^ aStream writeCollection: self! !!Collection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 12:07'!write: anObject 	^ self add: anObject! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!abs	"Absolute value of all elements in the collection"	^ self collect: [:a | a abs]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!arcCos	^self collect: [:each | each arcCos]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!arcSin	^self collect: [:each | each arcSin]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!arcTan	^self collect: [:each | each arcTan]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:57'!average	^ self sum / self size! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!ceiling	^ self collect: [:a | a ceiling]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!cos	^self collect: [:each | each cos]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!degreeCos	^self collect: [:each | each degreeCos]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:21'!degreeSin	^self collect: [:each | each degreeSin]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:21'!exp	^self collect: [:each | each exp]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!floor	^ self collect: [:a | a floor]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:21'!ln	^self collect: [:each | each ln]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:52'!log	^ self collect: [:each | each log]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:58'!max	^ self inject: self anyOne into: [:max :each | max max: each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!median	^ self asSortedCollection median! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!min	^ self inject: self anyOne into: [:min :each | min min: each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:52'!negated	"Negated value of all elements in the collection"	^ self collect: [:a | a negated]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!range	^ self max - self min! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!reciprocal	"Return the reciever full of reciprocated elements"	^ self collect: [:a | a reciprocal]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!rounded	^ self collect: [:a | a rounded]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:23'!sign	^self collect: [:each | each sign]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:22'!sin	^self collect: [:each | each sin]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!sqrt	^ self collect: [:each | each sqrt]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!squared	^ self collect: [:each | each * each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:02'!sum	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample _ self anyOne.	sum _ self inject: sample into: [:accum :each | accum + each].	^ sum - sample! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:22'!tan	^self collect: [:each | each tan]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:54'!truncated	^ self collect: [:a | a truncated]! !!Collection methodsFor: 'printing' stamp: 'sma 6/1/2000 09:39'!printElementsOn: aStream	aStream nextPut: $(.	self do: [:element | aStream print: element; space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!Collection methodsFor: 'printing' stamp: 'sma 6/1/2000 09:41'!printNameOn: aStream	super printOn: aStream! !!Collection methodsFor: 'printing' stamp: 'sma 6/1/2000 09:41'!printOn: aStream 	"Append a sequence of characters that identify the receiver to aStream."	self printNameOn: aStream.	self printElementsOn: aStream! !!Collection methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet _ true.	self do: 		[:each | 		noneYet			ifTrue: [noneYet _ false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' add: '.		aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Collection methodsFor: 'private'!emptyCheck	self isEmpty ifTrue: [self errorEmptyCollection]! !!Collection methodsFor: 'private'!errorEmptyCollection	self error: 'this collection is empty'! !!Collection methodsFor: 'private'!errorNoMatch	self error: 'collection sizes do not match'! !!Collection methodsFor: 'private' stamp: 'sma 5/12/2000 11:22'!errorNotFound: anObject	"Actually, this should raise a special Exception not just an error."	self error: 'Object is not in the collection.'! !!Collection methodsFor: 'private' stamp: 'yo 6/29/2004 13:14'!errorNotKeyed	self error: ('Instances of {1} do not respond to keyed accessing messages.' translated format: {self class name})! !!Collection methodsFor: 'private'!toBraceStack: itsSize 	"Push receiver's elements onto the stack of thisContext sender.  Error if receiver does	 not have itsSize elements or if receiver is unordered.	 Do not call directly: this is called by {a. b} _ ... constructs."	self size ~= itsSize ifTrue:		[self error: 'Trying to store ', self size printString,					' values into ', itsSize printString, ' variables.'].	thisContext sender push: itsSize fromIndexable: self! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:22'!remove: oldObject 	"Remove oldObject from the receiver's elements. Answer oldObject 	unless no element is equal to oldObject, in which case, raise an error.	ArrayedCollections cannot respond to this message."	^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:14'!remove: oldObject ifAbsent: anExceptionBlock 	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject. ArrayedCollections cannot 	respond to this message."	self subclassResponsibility! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:14'!removeAll: aCollection 	"Remove each element of aCollection from the receiver. If successful for 	each, answer aCollection. Otherwise create an error notification.	ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:16'!removeAllFoundIn: aCollection 	"Remove each element of aCollection which is present in the receiver 	from the receiver. Answer aCollection. No error is raised if an element	isn't found. ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each ifAbsent: []].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:19'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element and remove all that elements from	the receiver for that aBlock evaluates to true.  Use a copy to enumerate 	collections whose order changes when an element is removed (i.e. Sets)."	self copy do: [:each | (aBlock value: each) ifTrue: [self remove: each]]! !!Collection methodsFor: 'testing' stamp: 'ls 3/27/2000 17:25'!identityIncludes: anObject 	"Answer whether anObject is one of the receiver's elements."	self do: [:each | anObject == each ifTrue: [^true]].	^false! !!Collection methodsFor: 'testing' stamp: 'jf 12/1/2003 15:37'!ifEmpty: aBlock	"Evaluate the block if I'm empty"	^ self isEmpty ifTrue: aBlock! !!Collection methodsFor: 'testing' stamp: 'md 1/30/2004 15:11'!ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	^ self isEmpty ifTrue: emptyBlock ifFalse: [notEmptyBlock valueWithPossibleArgs: {self}]! !!Collection methodsFor: 'testing' stamp: 'md 1/30/2004 15:08'!ifNotEmpty: aBlock	"Evaluate the block unless I'm empty"	^self isEmpty ifFalse: [aBlock valueWithPossibleArgs: {self}].! !!Collection methodsFor: 'testing' stamp: 'md 1/30/2004 15:11'!ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	^ self isEmpty ifFalse: [notEmptyBlock valueWithPossibleArgs: {self}] ifTrue: emptyBlock! !!Collection methodsFor: 'testing' stamp: 'sma 5/12/2000 14:07'!includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^ self anySatisfy: [:each | each = anObject]! !!Collection methodsFor: 'testing'!includesAllOf: aCollection 	"Answer whether all the elements of aCollection are in the receiver."	aCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].	^ true! !!Collection methodsFor: 'testing'!includesAnyOf: aCollection 	"Answer whether any element of aCollection is one of the receiver's elements."	aCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].	^ false! !!Collection methodsFor: 'testing' stamp: 'sw 8/12/97 20:59'!includesSubstringAnywhere: testString	"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring"	self do:		[:element |			(element isKindOf: String)				ifTrue:					[(element includesSubString: testString) ifTrue: [^ true]].			(element isKindOf: Collection)				ifTrue:					[(element includesSubstringAnywhere: testString) ifTrue: [^ true]]].	^ false"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'"! !!Collection methodsFor: 'testing' stamp: 'ar 8/17/1999 19:43'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^true! !!Collection methodsFor: 'testing'!isEmpty	"Answer whether the receiver contains any elements."	^self size = 0! !!Collection methodsFor: 'testing' stamp: 'bf 3/10/2000 09:29'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ self isEmpty! !!Collection methodsFor: 'testing' stamp: 'di 11/6/1998 09:16'!isSequenceable	^ false! !!Collection methodsFor: 'testing' stamp: 'dgd 4/4/2004 12:14'!isZero	"Answer whether the receiver is zero"	^ false! !!Collection methodsFor: 'testing' stamp: 'sma 5/12/2000 17:49'!notEmpty	"Answer whether the receiver contains any elements."	^ self isEmpty not! !!Collection methodsFor: 'testing'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| tally |	tally _ 0.	self do: [:each | anObject = each ifTrue: [tally _ tally + 1]].	^tally! !!Collection methodsFor: '*packageinfo-base' stamp: 'ab 9/30/2002 19:26'!gather: aBlock	^ Array streamContents:		[:stream |		self do: [:ea | stream nextPutAll: (aBlock value: ea)]]! !!Collection methodsFor: '*connectors-truncation and round-off' stamp: 'nk 12/30/2003 15:47'!roundTo: quantum	^self collect: [ :ea | ea roundTo: quantum ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Collection class	instanceVariableNames: ''!!Collection class methodsFor: 'instance creation' stamp: 'apb 10/15/2000 22:05'!ofSize: n	"Create a new collection of size n with nil as its elements.	This method exists because OrderedCollection new: n creates an	empty collection,  not one of size n."	^ self new: n! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 19:58'!with: anObject 	"Answer an instance of me containing anObject."	^ self new		add: anObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:01'!with: firstObject with: secondObject 	"Answer an instance of me containing the two arguments as elements."	^ self new		add: firstObject;		add: secondObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:03'!with: firstObject with: secondObject with: thirdObject 	"Answer an instance of me containing the three arguments as elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	"Answer an instance of me, containing the four arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer an instance of me, containing the six arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		add: sixthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:07'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size)		addAll: aCollection;		yourself! !!Collection class methodsFor: 'private' stamp: 'lr 11/4/2003 12:07'!initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking _ Random new.	MutexForPicking _ Semaphore forMutualExclusion! !!Collection class methodsFor: 'private' stamp: 'lr 11/4/2003 12:08'!mutexForPicking	^ MutexForPicking! !!Collection class methodsFor: 'private' stamp: 'sma 5/12/2000 12:31'!randomForPicking	^ RandomForPicking! !Object subclass: #Color	instanceVariableNames: 'rgb cachedDepth cachedBitPattern'	classVariableNames: 'Black Blue BlueShift Brown CachedColormaps ColorChart ColorNames ComponentMask ComponentMax Cyan DarkGray Gray GrayToIndexMap Green GreenShift HalfComponentMask HighLightBitmaps IndexedColors LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightRed LightYellow Magenta MaskingMap Orange PaleBlue PaleBuff PaleGreen PaleMagenta PaleOrange PalePeach PaleRed PaleTan PaleYellow PureBlue PureCyan PureGreen PureMagenta PureRed PureYellow RandomStream Red RedShift TranslucentPatterns Transparent VeryDarkGray VeryLightGray VeryPaleRed VeryVeryDarkGray VeryVeryLightGray White Yellow'	poolDictionaries: ''	category: 'Graphics-Primitives'!!Color commentStamp: '<historical>' prior: 0!This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:	r	amount of red, a Float between 0.0 and 1.0.	g	amount of green, a Float between 0.0 and 1.0.	b	amount of blue, a Float between 0.0 and 1.0.(But, in fact, the three are encoded as values from 0 to 1023 and combined in a single integer, rgb.  The user does not need to know this.)	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.	Here are some fun things to run in when your screen has color:		Pen new mandala: 30 diameter: Display height-100.		Pen new web  "Draw with the mouse, opt-click to end"		Display fillWhite.  Pen new hilberts: 5.		Form toothpaste: 30  "Draw with mouse, opt-click to end"You might also want to try the comment in	Form>class>examples>tinyText...Messages:	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.	+ 	add two colors	- 	subtract two colors	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.	/	divide a color by a factor or an array of three factors.	errorForDepth: d     How close the nearest color at this depth is to this abstract color.  Sum of the squares of the RGB differences, square rooted and normalized to 1.0.  Multiply by 100 to get percent.	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.	saturation	Returns the saturation of the color.  0.0 to 1.0	brightness	Returns the brightness of the color.  0.0 to 1.0	name    Look to see if this Color has a name.	display	Show a swatch of this color tracking the cursor.	lightShades: thisMany		An array of thisMany colors from white to the receiver. 	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. Messages to Class Color.	red: r green: g blue: b		Return a color with the given r, g, and b components.	r: g: b:		Same as above, for fast typing. 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.	pink 	blue	red ...	Many colors have messages that return an instance of Color.	canUnderstand: #brown	  Returns true if #brown is a defined color.	names		An OrderedCollection of the names of the colors.	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array.    colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.(See also comments in these classes: Form, Bitmap, BitBlt, Pattern, MaskedForm.)!!Color methodsFor: 'access'!alpha	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TransparentColors."	^ 1.0! !!Color methodsFor: 'access'!blue	"Return the blue component of this color, a float in the range [0.0..1.0]."	^ self privateBlue asFloat / ComponentMax! !!Color methodsFor: 'access'!brightness	"Return the brightness of this color, a float in the range [0.0..1.0]."	^ ((self privateRed max:	    self privateGreen) max:	    self privateBlue) asFloat / ComponentMax! !!Color methodsFor: 'access'!green	"Return the green component of this color, a float in the range [0.0..1.0]."	^ self privateGreen asFloat / ComponentMax! !!Color methodsFor: 'access'!hue	"Return the hue of this color, an angle in the range [0.0..360.0]."	| r g b max min span h |	r _ self privateRed.	g _ self privateGreen.	b _ self privateBlue. 	max _ ((r max: g) max: b).	min _ ((r min: g) min: b).	span _ (max - min) asFloat.	span = 0.0 ifTrue: [ ^ 0.0 ].	r = max ifTrue: [		h _ ((g - b) asFloat / span) * 60.0.	] ifFalse: [		g = max			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].	].	h < 0.0 ifTrue: [ h _ 360.0 + h ].	^ h! !!Color methodsFor: 'access'!luminance	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."	^ ((299 * self privateRed) +	   (587 * self privateGreen) +	   (114 * self privateBlue)) / (1000 * ComponentMax)! !!Color methodsFor: 'access'!red	"Return the red component of this color, a float in the range [0.0..1.0]."	^ self privateRed asFloat / ComponentMax! !!Color methodsFor: 'access'!saturation	"Return the saturation of this color, a value between 0.0 and 1.0."	| r g b max min |	r _ self privateRed.	g _ self privateGreen.	b _ self privateBlue. 	max _ min _ r.	g > max ifTrue: [max _ g].	b > max ifTrue: [max _ b].	g < min ifTrue: [min _ g].	b < min ifTrue: [min _ b].	max = 0		ifTrue: [ ^ 0.0 ]		ifFalse: [ ^ (max - min) asFloat / max asFloat ].! !!Color methodsFor: 'equality' stamp: 'di 1/6/1999 20:26'!= aColor	"Return true if the receiver equals the given color. This method handles TranslucentColors, too."	aColor isColor ifFalse: [^ false].	^ aColor privateRGB = rgb and:		[aColor privateAlpha = self privateAlpha]! !!Color methodsFor: 'equality' stamp: 'di 9/27/2000 08:07'!diff: theOther	"Returns a number between 0.0 and 1.0"	^ ((self privateRed - theOther privateRed) abs		+ (self privateGreen - theOther privateGreen) abs		+ (self privateBlue - theOther privateBlue) abs)		/ 3.0 / ComponentMax! !!Color methodsFor: 'equality'!hash	^ rgb! !!Color methodsFor: 'queries' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Color! !!Color methodsFor: 'queries' stamp: 'ar 1/14/1999 15:27'!isBitmapFill	^false! !!Color methodsFor: 'queries' stamp: 'ar 11/12/1998 19:43'!isBlack	"Return true if the receiver represents black"	^rgb = 0! !!Color methodsFor: 'queries'!isColor	^ true! !!Color methodsFor: 'queries' stamp: 'ar 6/18/1999 06:58'!isGradientFill	^false! !!Color methodsFor: 'queries' stamp: 'ar 11/12/1998 19:44'!isGray	"Return true if the receiver represents a shade of gray"	^(self privateRed = self privateGreen) and:[self privateRed = self privateBlue]! !!Color methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!isOpaque	^true! !!Color methodsFor: 'queries' stamp: 'ar 6/18/1999 07:57'!isOrientedFill	"Return true if the receiver keeps an orientation (e.g., origin, direction, and normal)"	^false! !!Color methodsFor: 'queries' stamp: 'ar 11/7/1998 20:20'!isSolidFill	^true! !!Color methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ false! !!Color methodsFor: 'queries' stamp: 'di 1/3/1999 12:23'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ false! !!Color methodsFor: 'queries'!isTransparent	^ false! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:05'!* aNumber	"Answer this color with its RGB multiplied by the given number. "	"(Color brown * 2) display"	^ Color basicNew		setPrivateRed: (self privateRed * aNumber) asInteger		green: (self privateGreen * aNumber) asInteger		blue: (self privateBlue * aNumber) asInteger! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:05'!+ aColor	"Answer this color mixed with the given color in an additive color space.  "	"(Color blue + Color green) display"	^ Color basicNew		setPrivateRed: self privateRed + aColor privateRed		green: self privateGreen + aColor privateGreen		blue: self privateBlue + aColor  privateBlue! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:05'!- aColor	"Answer aColor is subtracted from the given color in an additive color space.  "	"(Color white - Color red) display"	^ Color basicNew		setPrivateRed: self privateRed - aColor privateRed		green: self privateGreen - aColor privateGreen		blue: self privateBlue - aColor  privateBlue! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:07'!/ aNumber	"Answer this color with its RGB divided by the given number. "	"(Color red / 2) display"	^ Color basicNew		setPrivateRed: (self privateRed / aNumber) asInteger		green: (self privateGreen / aNumber) asInteger		blue: (self privateBlue / aNumber) asInteger! !!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:50'!adjustBrightness: brightness	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"	^ Color		h: self hue		s: self saturation		v: (self brightness + brightness min: 1.0 max: 0.005)		alpha: self alpha! !!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:51'!adjustSaturation: saturation brightness: brightness	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"	^ Color		h: self hue		s: (self saturation + saturation min: 1.0 max: 0.005)		v: (self brightness + brightness min: 1.0 max: 0.005)		alpha: self alpha! !!Color methodsFor: 'transformations' stamp: 'sma 6/25/2000 15:36'!alpha: alphaValue 	"Answer a new Color with the given amount of opacity ('alpha')."	alphaValue = 1.0		ifFalse: [^ TranslucentColor basicNew setRgb: rgb alpha: alphaValue]! !!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55'!alphaMixed: proportion with: aColor 	"Answer this color mixed with the given color. The proportion, a number 	between 0.0 and 1.0, determines what what fraction of the receiver to  	use in the mix. For example, 0.9 would yield a color close to the  	receiver. This method uses RGB interpolation; HSV interpolation can lead 	to surprises.  Mixes the alphas (for transparency) also."	| frac1 frac2 |	frac1 _ proportion asFloat min: 1.0 max: 0.0.	frac2 _ 1.0 - frac1.	^ Color		r: self red * frac1 + (aColor red * frac2)		g: self green * frac1 + (aColor green * frac2)		b: self blue * frac1 + (aColor blue * frac2)		alpha: self alpha * frac1 + (aColor alpha * frac2)! !!Color methodsFor: 'transformations' stamp: 'RAA 6/2/2000 08:47'!atLeastAsLuminentAs: aFloat	| revisedColor |	revisedColor _ self.	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].	^revisedColor! !!Color methodsFor: 'transformations' stamp: 'nk 3/8/2004 09:43'!atMostAsLuminentAs: aFloat	| revisedColor |	revisedColor _ self.	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].	^revisedColor! !!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!blacker	^ self alphaMixed: 0.8333 with: Color black! !!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54'!dansDarker	"Return a darker shade of the same color.	An attempt to do better than the current darker method.	(now obsolete, since darker has been changed to do this. -dew)"	^ Color h: self hue s: self saturation		v: (self brightness - 0.16 max: 0.0)! !!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:40'!darker	"Answer a darker shade of this color."	^ self adjustBrightness: -0.08! !!Color methodsFor: 'transformations' stamp: 'dew 3/8/2002 00:13'!duller	^ self adjustSaturation: -0.03 brightness: -0.2! !!Color methodsFor: 'transformations' stamp: 'dew 1/23/2002 20:19'!lighter	"Answer a lighter shade of this color."	^ self adjustSaturation: -0.03 brightness: 0.08! !!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00'!mixed: proportion with: aColor 	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 	aColor alphaMixed: proportion with: anotherColor	"	| frac1 frac2 |	frac1 _ proportion asFloat min: 1.0 max: 0.0.	frac2 _ 1.0 - frac1.	^ Color		r: self red * frac1 + (aColor red * frac2)		g: self green * frac1 + (aColor green * frac2)		b: self blue * frac1 + (aColor blue * frac2)! !!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29'!muchDarker	^ self alphaMixed: 0.5 with: Color black! !!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07'!muchLighter	^ self alphaMixed: 0.233 with: Color white! !!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36'!negated	"Return an RGB inverted color"	^Color		r: 1.0 - self red		g: 1.0 - self green		b: 1.0 - self blue! !!Color methodsFor: 'transformations' stamp: 'di 9/27/2000 08:14'!orColorUnlike: theOther	"If this color is a lot like theOther, then return its complement, otherwide, return self"	(self diff: theOther) < 0.3		ifTrue: [^ theOther negated]		ifFalse: [^ self]! !!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:42'!paler	"Answer a paler shade of this color."	^ self adjustSaturation: -0.09 brightness: 0.09! !!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!slightlyDarker	^ self adjustBrightness: -0.03! !!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!slightlyLighter	^ self adjustSaturation: -0.01 brightness: 0.03! !!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25'!slightlyWhiter	^ self alphaMixed: 0.85 with: Color white! !!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:44'!twiceDarker	"Answer a significantly darker shade of this color."	^ self adjustBrightness: -0.15! !!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:45'!twiceLighter	"Answer a significantly lighter shade of this color."	^ self adjustSaturation: -0.06 brightness: 0.15! !!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07'!veryMuchLighter	^ self alphaMixed: 0.1165 with: Color white! !!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!whiter	^ self alphaMixed: 0.8333 with: Color white! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!darkShades: thisMany	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red darkShades: 12)"	^ self class black mix: self shades: thisMany! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!lightShades: thisMany	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red lightShades: 12)"	^ self class white mix: self shades: thisMany! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!mix: color2 shades: thisMany	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red mix: Color green shades: 12)"	| redInc greenInc blueInc rr gg bb c out |	thisMany = 1 ifTrue: [^ Array with: color2].	redInc _ color2 red - self red / (thisMany-1).	greenInc _ color2 green - self green / (thisMany-1).	blueInc _ color2 blue - self blue / (thisMany-1).	rr _ self red.  gg _ self green.  bb _ self blue.	out _ (1 to: thisMany) collect: [:num |		c _ Color r: rr g: gg b: bb.		rr _ rr + redInc.		gg _ gg + greenInc.		bb _ bb + blueInc.		c].	out at: out size put: color2.	"hide roundoff errors"	^ out! !!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45'!wheel: thisMany	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "	| sat bri hue step c |	sat _ self saturation.	bri _ self brightness.	hue _ self hue.	step _ 360.0 / (thisMany max: 1).	^ (1 to: thisMany) collect: [:num |		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"		hue _ hue + step.		c]."(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]"! !!Color methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:14'!byteEncode: aStream	aStream		print: '(';		print: self class name;		print: ' r: ';		write: (self red roundTo: 0.001);		print: ' g: ';		write: (self green roundTo: 0.001);		print: ' b: ';		write: (self blue roundTo: 0.001) ;		print: ')'.! !!Color methodsFor: 'printing' stamp: 'bf 5/25/2000 16:52'!printOn: aStream	| name |	(name _ self name) ifNotNil:		[^ aStream			nextPutAll: 'Color ';			nextPutAll: name].	self storeOn: aStream.! !!Color methodsFor: 'printing'!shortPrintString	"Return a short (but less precise) print string for use where space is tight."	| s |	s _ WriteStream on: ''.	s		nextPutAll: '(' , self class name;		nextPutAll: ' r: ';		nextPutAll: (self red roundTo: 0.01) printString;		nextPutAll: ' g: ';		nextPutAll: (self green roundTo: 0.01) printString;		nextPutAll: ' b: ';		nextPutAll: (self blue roundTo: 0.01) printString;		nextPutAll: ')'.	^ s contents! !!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!storeArrayOn: aStream	aStream nextPutAll: '#('.	self storeArrayValuesOn: aStream.	aStream nextPutAll: ') '! !!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!storeArrayValuesOn: aStream	(self red roundTo: 0.001) storeOn: aStream.	aStream space.	(self green roundTo: 0.001) storeOn: aStream.	aStream space.	(self blue roundTo: 0.001) storeOn: aStream.! !!Color methodsFor: 'printing' stamp: 'di 9/27/2000 13:34'!storeOn: aStream	aStream		nextPutAll: '(' , self class name;		nextPutAll: ' r: '; print: (self red roundTo: 0.001);		nextPutAll: ' g: '; print: (self green roundTo: 0.001);		nextPutAll: ' b: '; print: (self blue roundTo: 0.001);		nextPutAll: ')'.! !!Color methodsFor: 'other' stamp: 'sw 2/16/98 03:42'!colorForInsets	^ self! !!Color methodsFor: 'other' stamp: 'tk 6/14/96'!display	"Show a swatch of this color tracking the cursor until the next mouseClick. "	"Color red display"	| f |	f _ Form extent: 40@20 depth: Display depth.	f fillColor: self.	Cursor blank showWhile:		[f follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]]! !!Color methodsFor: 'other' stamp: 'jm 12/4/97 10:24'!name	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."	ColorNames do:		[:name | (Color perform: name) = self ifTrue: [^ name]].	^ nil! !!Color methodsFor: 'other' stamp: 'ar 8/16/2001 12:47'!raisedColor	^ self! !!Color methodsFor: 'other' stamp: 'jm 12/4/97 10:27'!rgbTriplet	"Color fromUser rgbTriplet"	^ Array		with: (self red roundTo: 0.01)		with: (self green roundTo: 0.01)		with: (self blue roundTo: 0.01)! !!Color methodsFor: 'conversions' stamp: 'ar 11/2/1998 12:19'!asColor	"Convert the receiver into a color"	^self! !!Color methodsFor: 'conversions' stamp: 'TBn 6/15/2000 20:37'!asColorref	"Convert the receiver into a colorref"	^(self red * 255) asInteger + ((self green * 255) asInteger << 8) + ((self green * 255) asInteger << 16)! !!Color methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!asNontranslucentColor	^ self! !!Color methodsFor: 'conversions' stamp: 'di 3/25/2000 10:13'!balancedPatternForDepth: depth	"A generalization of bitPatternForDepth: as it exists.  Generates a 2x2 stipple of color.	The topLeft and bottomRight pixel are closest approx to this color"	| pv1 pv2 mask1 mask2 pv3 c |	(depth == cachedDepth and:[cachedBitPattern size = 2]) ifTrue: [^ cachedBitPattern].	(depth between: 4 and: 16) ifFalse: [^ self bitPatternForDepth: depth].	cachedDepth _ depth.	pv1 _ self pixelValueForDepth: depth."	Subtract error due to pv1 to get pv2.	pv2 _ (self - (err1 _ (Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	Subtract error due to 2 pv1's and pv2 to get pv3.	pv3 _ (self - err1 - err1 - ((Color colorFromPixelValue: pv2 depth: depth) - self))						pixelValueForDepth: depth."	"Above two statements computed faster by the following..."	pv2 _ (c _ self - ((Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	pv3 _ (c + (c - (Color colorFromPixelValue: pv2 depth: depth)))						pixelValueForDepth: depth.	"Return to a 2-word bitmap that encodes a 2x2 stipple of the given pixelValues."	mask1 _ (#(- - -				16r01010101 - - -			"replicates every other 4 bits"			16r00010001 - - - - - - -	"replicates every other 8 bits"			16r00000001) at: depth).	"replicates every other 16 bits"	mask2 _ (#(- - -				16r10101010 - - -			"replicates the other 4 bits"			16r01000100 - - - - - - -	"replicates the other 8 bits"			16r00010000) at: depth).	"replicates the other 16 bits"	^ cachedBitPattern _ Bitmap with: (mask1*pv1) + (mask2*pv2) with: (mask1*pv3) + (mask2*pv1)! !!Color methodsFor: 'conversions' stamp: 'hmm 4/25/2000 09:40'!bitPatternForDepth: depth	"Return a Bitmap, possibly containing a stipple pattern, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps. The resulting Bitmap may be multiple words to represent a stipple pattern of several lines.  "	"See also:	pixelValueAtDepth:	-- value for single pixel				pixelWordAtDepth:	-- a 32-bit word filled with the pixel value"	"Details: The pattern for the most recently requested depth is cached."	"Note for depths > 2, there are stippled and non-stippled versions (generated with #balancedPatternForDepth: and #bitPatternForDepth:, respectively). The stippled versions don't work with the window bit caching of StandardSystemView, so we make sure that for these depths, only unstippled patterns are returned"	(depth == cachedDepth and: [depth <= 2 or: [cachedBitPattern size = 1]]) ifTrue: [^ cachedBitPattern].	cachedDepth _ depth.	depth > 2 ifTrue: [^ cachedBitPattern _ Bitmap with: (self pixelWordForDepth: depth)].	depth = 1 ifTrue: [^ cachedBitPattern _ self halfTonePattern1].	depth = 2 ifTrue: [^ cachedBitPattern _ self halfTonePattern2].! !!Color methodsFor: 'conversions'!closestPixelValue1	"Return the nearest approximation to this color for a monochrome Form."	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 0].  "white"	self luminance > 0.5		ifTrue: [^ 0]  "white"		ifFalse: [^ 1].  "black"! !!Color methodsFor: 'conversions'!closestPixelValue2	"Return the nearest approximation to this color for a 2-bit deep Form."	| lum |	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 2].  "opaque white"	lum _ self luminance.	lum < 0.2 ifTrue: [^ 1].  "black"	lum > 0.6 ifTrue: [^ 2].  "opaque white"	^ 3  "50% gray"! !!Color methodsFor: 'conversions'!closestPixelValue4	"Return the nearest approximation to this color for a 4-bit deep Form."	| bIndex |	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 2].  "opaque white"	rgb = PureRed privateRGB ifTrue: [^ 4].	rgb = PureGreen privateRGB ifTrue: [^ 5].	rgb = PureBlue privateRGB ifTrue: [^ 6].	rgb = PureCyan privateRGB ifTrue: [^ 7].	rgb = PureYellow privateRGB ifTrue: [^ 8].	rgb = PureMagenta privateRGB ifTrue: [^ 9].	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"	^ #(		1	"black"		10	"1/8 gray"		11	"2/8 gray"		12	"3/8 gray"		3	"4/8 gray"		13	"5/8 gray"		14	"6/8 gray"		15	"7/8 gray"		2	"opaque white"	) at: bIndex + 1.! !!Color methodsFor: 'conversions'!closestPixelValue8	"Return the nearest approximation to this color for an 8-bit deep Form."	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 255].  "white"	self saturation < 0.2 ifTrue: [		^ GrayToIndexMap at: (self privateGreen >> 2) + 1.  "nearest gray"	] ifFalse: [		"compute nearest entry in the color cube"		^ 40 +		  ((((self privateRed * 5) + HalfComponentMask) // ComponentMask) * 36) +		  ((((self privateBlue * 5) + HalfComponentMask) // ComponentMask) * 6) +		  (((self privateGreen * 5) + HalfComponentMask) // ComponentMask)].! !!Color methodsFor: 'conversions' stamp: 'di 9/2/97 20:21'!dominantColor	^ self! !!Color methodsFor: 'conversions' stamp: 'di 6/23/97 23:27'!halfTonePattern1	"Return a halftone-pattern to approximate luminance levels on 1-bit deep Forms."	| lum |	lum _ self luminance.	lum < 0.1 ifTrue: [^ Bitmap with: 16rFFFFFFFF]. "black"	lum < 0.4 ifTrue: [^ Bitmap with: 16rBBBBBBBB with: 16rEEEEEEEE]. "dark gray"	lum < 0.6 ifTrue: [^ Bitmap with: 16r55555555 with: 16rAAAAAAAA]. "medium gray"	lum < 0.9 ifTrue: [^ Bitmap with: 16r44444444 with: 16r11111111]. "light gray"	^ Bitmap with: 0  "1-bit white"! !!Color methodsFor: 'conversions'!halfTonePattern2	"Return a halftone-pattern to approximate luminance levels on 2-bit deep Forms."	| lum |	lum _ self luminance.	lum < 0.125 ifTrue: [^ Bitmap with: 16r55555555].  "black"	lum < 0.25 ifTrue: [^ Bitmap with: 16r55555555 with: 16rDDDDDDDD].  "1/8 gray"	lum < 0.375 ifTrue: [^ Bitmap with: 16rDDDDDDDD with: 16r77777777].  "2/8 gray"	lum < 0.5 ifTrue: [^ Bitmap with: 16rFFFFFFFF with: 16r77777777].  "3/8 gray"	lum < 0.625 ifTrue: [^ Bitmap with: 16rFFFFFFFF].  "4/8 gray"	lum < 0.75 ifTrue: [^ Bitmap with: 16rFFFFFFFF with: 16rBBBBBBBB].  "5/8 gray"	lum < 0.875 ifTrue: [^ Bitmap with: 16rEEEEEEEE with: 16rBBBBBBBB].  "6/8 gray"	lum < 1.0 ifTrue: [^ Bitmap with: 16rAAAAAAAA with: 16rBBBBBBBB].  "7/8 gray"	^ Bitmap with: 16rAAAAAAAA  "opaque white""handy expression for computing patterns for 2x2 tiles; set p to a string of 4 letters (e.g., 'wggw' for a gray-and- white checkerboard) and print the result of evaluating:| p d w1 w2 |p _ 'wggw'.d _ Dictionary new.d at: $b put: '01'.d at: $w put: '10'.d at: $g put: '11'.w1 _ (d at: (p at: 1)), (d at: (p at: 2)).w1 _ '2r', w1, w1, w1, w1, w1, w1, w1, w1, ' hex'.w2 _ (d at: (p at: 3)), (d at: (p at: 4)).w2 _ '2r', w2, w2, w2, w2, w2, w2, w2, w2, ' hex'.Array with: (Compiler evaluate: w1) with: (Compiler evaluate: w2) "! !!Color methodsFor: 'conversions' stamp: 'tk 4/24/97'!indexInMap: aColorMap	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 16) + 1].	self error: 'unknown pixel depth'.! !!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25'!makeForegroundColor        "Make a foreground color contrasting with me"        ^self luminance >= 0.5                ifTrue: [Color black]                ifFalse: [Color white]! !!Color methodsFor: 'conversions' stamp: 'ar 5/15/2001 16:12'!pixelValue32	"Note: pixelWord not pixelValue so we include translucency"	^self pixelWordForDepth: 32! !!Color methodsFor: 'conversions' stamp: 'jm 1/26/2001 15:11'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val _ LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val = 0 ifTrue: [val at: 1 put: 1].  "closest non-transparent black"		val at: 4 put: 16rFF.  "opaque alpha"		^ val].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!pixelWordFor: depth filledWith: pixelValue	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| halfword |	depth = 32 ifTrue: [^ pixelValue].	depth = 16		ifTrue: [halfword _ pixelValue]		ifFalse: [halfword _ pixelValue * 					(#(16rFFFF				"replicates at every bit"						16r5555 -			"replicates every 2 bits"						16r1111 - - -			"replicates every 4 bits"						16r0101) at: depth)	"replicates every 8 bits"].	^ halfword bitOr: (halfword bitShift: 16)! !!Color methodsFor: 'conversions'!pixelWordForDepth: depth	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| pixelValue |	pixelValue _ self pixelValueForDepth: depth.	^ self pixelWordFor: depth filledWith: pixelValue! !!Color methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:28'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	^self pixelWordForDepth: 32! !!Color methodsFor: 'private'!attemptToMutateError	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."	self error: 'Color objects are immutable once created'! !!Color methodsFor: 'private'!flushCache	"Flush my cached bit pattern."	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'private'!privateAlpha	"Private!! Return the raw alpha value for opaque. Used only for equality testing."	^ 255! !!Color methodsFor: 'private'!privateBlue	"Private!! Return the internal representation of my blue component."	^ rgb bitAnd: ComponentMask! !!Color methodsFor: 'private'!privateGreen	"Private!! Return the internal representation of my green component.	Replaced >> by bitShift: 0 -. SqR!! 2/25/1999 23:08"	^ (rgb bitShift: 0 - GreenShift) bitAnd: ComponentMask! !!Color methodsFor: 'private'!privateRGB	"Private!! Return the internal representation of my RGB components."	^ rgb! !!Color methodsFor: 'private'!privateRed	"Private!! Return the internal representation of my red component."	^ (rgb bitShift: 0 - RedShift) bitAnd: ComponentMask! !!Color methodsFor: 'private'!setHue: hue saturation: saturation brightness: brightness	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."	| s v hf i f p q t | 	s _ (saturation asFloat max: 0.0) min: 1.0.	v _ (brightness asFloat max: 0.0) min: 1.0.	"zero saturation yields gray with the given brightness"	s = 0.0 ifTrue: [ ^ self setRed: v green: v blue: v ].	hf _ hue asFloat.	(hf < 0.0 or: [hf >= 360.0])		ifTrue: [hf _ hf - ((hf quo: 360.0) asFloat * 360.0)].	hf _ hf / 60.0.	i _ hf asInteger.  "integer part of hue"	f _ hf fractionPart.         "fractional part of hue"	p _ (1.0 - s) * v.	q _ (1.0 - (s * f)) * v.	t _ (1.0 - (s * (1.0 - f))) * v.	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].	self error: 'implementation error'.! !!Color methodsFor: 'private' stamp: 'di 11/2/97 12:19'!setPrivateRed: r green: g blue: b	"Initialize this color's r, g, and b components to the given values in the range [0..ComponentMax].  Encoded in a single variable as 3 integers in [0..1023]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ ((r min: ComponentMask max: 0) bitShift: RedShift) +		((g min: ComponentMask max: 0) bitShift: GreenShift) +		 (b min: ComponentMask max: 0).	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'private' stamp: 'ls 9/24/1999 20:04'!setRGB: rgb0	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgb0! !!Color methodsFor: 'private'!setRed: r green: g blue: b	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0].  Encoded in a single variable as 3 integers in [0..1023]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _		(((r * ComponentMax) rounded bitAnd: ComponentMask) bitShift: RedShift) +		(((g * ComponentMax) rounded bitAnd: ComponentMask) bitShift: GreenShift) +		 ((b * ComponentMax) rounded bitAnd: ComponentMask).	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'private'!setRed: r green: g blue: b range: range	"Initialize this color's r, g, and b components to the given values in the range [0..r]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _		((((r * ComponentMask) // range) bitAnd: ComponentMask) bitShift: RedShift) +		((((g * ComponentMask) // range) bitAnd: ComponentMask) bitShift: GreenShift) +		 (((b * ComponentMask) // range) bitAnd: ComponentMask).	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'copying' stamp: 'tk 8/19/1998 16:12'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Color methodsFor: 'Morphic menu' stamp: 'dgd 10/17/2003 12:10'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'change color...' translated target: self selector: #changeColorIn:event: argument: aMorph! !!Color methodsFor: 'Morphic menu' stamp: 'ar 10/5/2000 18:50'!changeColorIn: aMorph event: evt	"Note: This is just a workaround to make sure we don't use the old color inst var"	aMorph changeColorTarget: aMorph selector: #fillStyle: originalColor: self hand: evt hand! !!Color methodsFor: '*morphic-Postscript Canvases'!encodePostscriptOn: aStream	aStream setrgbcolor:self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Color class	instanceVariableNames: ''!!Color class methodsFor: 'instance creation' stamp: 'sw 2/26/2002 10:46'!colorFrom: parm	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"	| aColor firstParm |	(parm isKindOf: Color) ifTrue: [^ parm].	(parm isKindOf: Symbol) ifTrue: [^ self perform: parm].	((parm isKindOf: SequenceableCollection) and: [parm size > 0])		ifTrue:			[firstParm _ parm first.			(firstParm isKindOf: Number) ifTrue:				[^ self fromRgbTriplet: parm].			aColor _ self colorFrom: firstParm.			parm doWithIndex:				[:sym :ind | ind > 1 ifTrue:					[aColor _ aColor perform: sym]].			^ aColor].	^ parm"Color colorFrom: #(blue darker)Color colorFrom: Color blue darkerColor colorFrom: #blueColor colorFrom: #(0.0 0.0 1.0)"! !!Color class methodsFor: 'instance creation' stamp: 'tk 8/15/2001 11:03'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r _ (p bitShift: -10) bitAnd: 16r1F.		g _ (p bitShift: -5) bitAnd: 16r1F.		b _ p bitAnd: 16r1F.		(r = 0 and: [g = 0]) ifTrue: [			b = 0 ifTrue: [^Color transparent].			b = 1 ifTrue: [^Color black]].		^ Color r: r g: g b: b range: 31].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		r _ (p bitShift: -16) bitAnd: 16rFF.		g _ (p bitShift: -8) bitAnd: 16rFF.		b _ p bitAnd: 16rFF.		alpha _ p bitShift: -24.		alpha = 0 ifTrue: [^Color transparent].		(r = 0 and: [g = 0 and: [b = 0]])  ifTrue: [^Color transparent].		alpha < 255			ifTrue: [^ (Color r: r g: g b: b range: 255) alpha: (alpha asFloat / 255.0)]			ifFalse: [^ (Color r: r g: g b: b range: 255)]].	d = 12 ifTrue: [		"four bits per component"		r _ (p bitShift: -8) bitAnd: 16rF.		g _ (p bitShift: -4) bitAnd: 16rF.		b _ p bitAnd: 16rF.		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r _ (p bitShift: -6) bitAnd: 16r7.		g _ (p bitShift: -3) bitAnd: 16r7.		b _ p bitAnd: 16r7.		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!Color class methodsFor: 'instance creation' stamp: 'mir 7/21/1999 11:54'!fromArray: colorDef	colorDef size == 3			ifTrue: [^self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)].	colorDef size == 0			ifTrue: [^Color transparent].	colorDef size == 4			ifTrue: [^(TranslucentColor r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)) alpha: (colorDef at: 4)].	self error: 'Undefined color definition'! !!Color class methodsFor: 'instance creation' stamp: 'sw 8/8/97 22:03'!fromRgbTriplet: list	^ self r: list first g: list second b: list last! !!Color class methodsFor: 'instance creation' stamp: 'dvf 6/16/2000 17:48'!fromString: aString	"for HTML color spec: #FFCCAA or white/black"	"Color fromString: '#FFCCAA'.	 Color fromString: 'white'.	 Color fromString: 'orange'"	| aColorHex red green blue |	aString isEmptyOrNil ifTrue: [^ Color white].	aString first = $#		ifTrue: [aColorHex _ aString copyFrom: 2 to: aString size]		ifFalse: [aColorHex _ aString].	[aColorHex size = 6		ifTrue:			[aColorHex _ aColorHex asUppercase.			red _ ('16r', (aColorHex copyFrom: 1 to: 2)) asNumber/255.			green _ ('16r', (aColorHex copyFrom: 3 to: 4)) asNumber/255.			blue _ ('16r', (aColorHex copyFrom: 5 to: 6)) asNumber/255.			^ self r: red g: green b: blue]]	ifError: [:err :rcvr | "not a hex color triplet" ].		"try to match aColorHex with known named colors"	aColorHex _ aColorHex asLowercase.	^self perform: (ColorNames detect: [:i | i asString asLowercase = aColorHex]		ifNone: [#white])! !!Color class methodsFor: 'instance creation' stamp: 'jm 12/4/97 13:05'!gray: brightness	"Return a gray shade with the given brightness in the range [0.0..1.0]."	^ self basicNew setRed: brightness green: brightness blue: brightness! !!Color class methodsFor: 'instance creation'!h: hue s: saturation v: brightness	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."	^ self basicNew setHue: hue saturation: saturation brightness: brightness! !!Color class methodsFor: 'instance creation' stamp: 'dew 3/19/2002 23:49'!h: h s: s v: v alpha: alpha	^ (self h: h s: s v: v) alpha: alpha! !!Color class methodsFor: 'instance creation'!new	^ self r: 0.0 g: 0.0 b: 0.0! !!Color class methodsFor: 'instance creation' stamp: 'jm 12/4/97 13:04'!r: r g: g b: b	"Return a color with the given r, g, and b components in the range [0.0..1.0]."	^ self basicNew setRed: r green: g blue: b! !!Color class methodsFor: 'instance creation'!r: r g: g b: b alpha: alpha	^ (self r: r g: g b: b) alpha: alpha! !!Color class methodsFor: 'instance creation'!r: r g: g b: b range: range	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."	^ self basicNew setRed: r green: g blue: b range: range! !!Color class methodsFor: 'instance creation'!random	"Return a random color that isn't too dark or under-saturated."	^ self basicNew		setHue: (360.0 * RandomStream next)		saturation: (0.3 + (RandomStream next * 0.7))		brightness: (0.4 + (RandomStream next * 0.6))! !!Color class methodsFor: 'class initialization'!initialize	"Color initialize"	"Details: Externally, the red, green, and blue components of color	are floats in the range [0.0..1.0]. Internally, they are represented	as integers in the range [0..ComponentMask] packing into a	small integer to save space and to allow fast hashing and	equality testing.	For a general description of color representations for computer	graphics, including the relationship between the RGB and HSV	color models used here, see Chapter 17 of Foley and van Dam,	Fundamentals of Interactive Computer Graphics, Addison-Wesley,	1982."	ComponentMask _ 1023.	HalfComponentMask _ 512.  "used to round up in integer calculations"	ComponentMax _ 1023.0.  "a Float used to normalize components"	RedShift _ 20.	GreenShift _ 10.	BlueShift _ 0.	PureRed		 _ self r: 1 g: 0 b: 0.	PureGreen	 _ self r: 0 g: 1 b: 0.	PureBlue	 _ self r: 0 g: 0 b: 1.	PureYellow	 _ self r: 1 g: 1 b: 0.	PureCyan	 _ self r: 0 g: 1 b: 1.	PureMagenta _ self r: 1 g: 0 b: 1.	RandomStream _ Random new.	self initializeIndexedColors.	self initializeGrayToIndexMap.	self initializeNames.	self initializeHighLights.! !!Color class methodsFor: 'class initialization'!initializeGrayToIndexMap	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."	"Color initializeGrayToIndexMap"	| grayLevels grayIndices c distToClosest dist indexOfClosest |	"record the level and index of each gray in the 8-bit color table"	grayLevels _ OrderedCollection new.	grayIndices _ OrderedCollection new.	"Note: skip the first entry, which is reserved for transparent"	2 to: IndexedColors size do: [:i |		c _ IndexedColors at: i.		c saturation = 0.0 ifTrue: [  "c is a gray"			grayLevels add: (c privateBlue) >> 2.  "top 8 bits; R, G, and B are the same"			grayIndices add: i - 1]].  "pixel values are zero-based"	grayLevels _ grayLevels asArray.	grayIndices _ grayIndices asArray.	"for each gray level in [0..255], select the closest match"	GrayToIndexMap _ ByteArray new: 256.	0 to: 255 do: [:level |		distToClosest _ 10000.  "greater than distance to any real gray"		1 to: grayLevels size do: [:i |			dist _ (level - (grayLevels at: i)) abs.			dist < distToClosest ifTrue: [				distToClosest _ dist.				indexOfClosest _ grayIndices at: i]].		GrayToIndexMap at: (level + 1) put: indexOfClosest].! !!Color class methodsFor: 'class initialization' stamp: 'tk 6/22/96'!initializeHighLights	"Create a set of Bitmaps for quickly reversing areas of the screen without converting colors. "	"Color initializeHighLights"	| t |	t _ Array new: 32.	t at: 1 put: (Bitmap with: 16rFFFFFFFF).	t at: 2 put: (Bitmap with: 16rFFFFFFFF).	t at: 4 put: (Bitmap with: 16r55555555).	t at: 8 put: (Bitmap with: 16r7070707).	t at: 16 put: (Bitmap with: 16rFFFFFFFF).	t at: 32 put: (Bitmap with: 16rFFFFFFFF).	HighLightBitmaps _ t.! !!Color class methodsFor: 'class initialization'!initializeIndexedColors	"Build an array of colors corresponding to the fixed colormap used	 for display depths of 1, 2, 4, or 8 bits."	"Color initializeIndexedColors"	| a index grayVal |	a _ Array new: 256.	"1-bit colors (monochrome)"	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"	"additional colors for 2-bit color"	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"	"additional colors for 4-bit color"	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"	"additional colors for 8-bit color"	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"	index _ 17.	1 to: 31 do: [:v |		(v \\ 4) = 0 ifFalse: [			grayVal _ v / 32.0.			a at: index put: (Color r: grayVal g: grayVal b: grayVal).			index _ index + 1]].	"The remainder of color table defines a color cube with six steps	 for each primary color. Note that the corners of this cube repeat	 previous colors, but this simplifies the mapping between RGB colors	 and color map indices. This color cube spans indices 40 through 255	 (indices 41-256 in this 1-based array)."	0 to: 5 do: [:r |		0 to: 5 do: [:g |			0 to: 5 do: [:b |				index _ 41 + ((36 * r) + (6 * b) + g).				index > 256 ifTrue: [					self error: 'index out of range in color table compuation'].				a at: index put: (Color r: r g: g b: b range: 5)]]].	IndexedColors _ a.! !!Color class methodsFor: 'class initialization' stamp: 'dwh 7/7/1999 23:57'!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames _ OrderedCollection new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).	self named: #paleBuff put: (Color r: 254 g: 250 b: 235 range: 255).	self named: #paleBlue put: (Color r: 222 g: 249 b: 254 range: 255).	self named: #paleYellow put: (Color r: 255 g: 255 b: 217 range: 255).	self named: #paleGreen put: (Color r: 223 g: 255 b: 213 range: 255).	self named: #paleRed put: (Color r: 255 g: 230 b: 230 range: 255).	self named: #veryPaleRed put: (Color r: 255 g: 242 b: 242 range: 255).	self named: #paleTan put: (Color r: 235 g: 224 b: 199 range: 255).	self named: #paleMagenta put: (Color r: 255 g: 230 b: 255 range: 255).	self named: #paleOrange put: (Color r: 253 g: 237 b: 215 range: 255).	self named: #palePeach put: (Color r: 255 g: 237 b: 213 range: 255).! !!Color class methodsFor: 'class initialization' stamp: 'ar 2/16/2000 21:56'!initializeTranslucentPatterns	"Color initializeTranslucentPatterns"	| mask bits pattern patternList |	TranslucentPatterns _ Array new: 8.	#(1 2 4 8) do:[:d|		patternList _ Array new: 5.		mask _ (1 bitShift: d) - 1.		bits _ 2 * d.		[bits >= 32] whileFalse: [			mask _ mask bitOr: (mask bitShift: bits).  "double the length of mask"			bits _ bits + bits].		"0% pattern"		pattern _ Bitmap with: 0 with: 0.		patternList at: 1 put: pattern.		"25% pattern"		pattern _ Bitmap with: mask with: 0.		patternList at: 2 put: pattern.		"50% pattern"		pattern _ Bitmap with: mask with: mask bitInvert32.		patternList at: 3 put: pattern.		"75% pattern"		pattern _ Bitmap with: mask with: 16rFFFFFFFF.		patternList at: 4 put: pattern.		"100% pattern"		pattern _ Bitmap with: 16rFFFFFFFF with: 16rFFFFFFFF.		patternList at: 5 put: pattern.		TranslucentPatterns at: d put: patternList.	].! !!Color class methodsFor: 'class initialization' stamp: 'tk 6/13/96'!named: newName put: aColor	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color colorNames) returns a list of all color names.  "	| str cap sym accessor csym |	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].	str _ newName asString.	sym _ str asSymbol.	cap _ str capitalized.	csym _ cap asSymbol.	(self class canUnderstand: sym) ifFalse: [		"define access message"		accessor _ str, (String with: Character cr with: Character tab), 			'^', cap.		self class compile: accessor			classified: 'named colors'].	(self classPool includesKey: csym) ifFalse: [		self addClassVarName: cap].	(ColorNames includes: sym) ifFalse: [		ColorNames add: sym].	^ self classPool at: csym put: aColor! !!Color class methodsFor: 'examples'!colorRampForDepth: depth extent: aPoint	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."	"(Color colorRampForDepth: Display depth extent: 256@80) display"	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"	| f dx dy r |	f _ Form extent: aPoint depth: depth.	dx _ aPoint x // 256.	dy _ aPoint y // 4.	0 to: 255 do: [:i |		r _ (dx * i)@0 extent: dx@dy.		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).		r _ r translateBy: 0@dy.		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).		r _ r translateBy: 0@dy.		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).		r _ r translateBy: 0@dy.		f fill: r fillColor: (Color r: i g: i b: i range: 255)].	^ f! !!Color class methodsFor: 'examples' stamp: 'tk 6/19/96'!hotColdShades: thisMany	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "	"Color showColors: (Color hotColdShades: 25)"	| n s1 s2 s3 s4 s5 |	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].	n _ thisMany // 5.	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).	s2 _ self yellow mix: self red shades: n+1.	s2 _ s2 copyFrom: 2 to: n+1.	s3 _ self red mix: self green darker shades: n+1.	s3 _ s3 copyFrom: 2 to: n+1.	s4 _ self green darker mix: self blue shades: n+1.	s4 _ s4 copyFrom: 2 to: n+1.	s5 _ self blue mix: self black shades: n+1.	s5 _ s5 copyFrom: 2 to: n+1.	^ s1, s2, s3, s4, s5! !!Color class methodsFor: 'examples'!showColorCube	"Show a 12x12x12 color cube."	"Color showColorCube"	0 to: 11 do: [:r |		0 to: 11 do: [:g |			0 to: 11 do: [:b |					Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)					fillColor: (Color r: r g: g b: b range: 11)]]].! !!Color class methodsFor: 'examples'!showColors: colorList	"Display the given collection of colors across the top of the Display."	| w r |	w _ Display width // colorList size.	r _ 0@0 extent: w@((w min: 30) max: 10).	colorList do: [:c |		Display fill: r fillColor: c.		r _ r translateBy: w@0].! !!Color class methodsFor: 'examples'!showHSVPalettes	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."	"Color showHSVPalettes"	| left top c |	left _ top _ 0.	0 to: 179 by: 15 do: [:h |		0 to: 10 do: [:s |			left _ (h * 4) + (s * 4).			0 to: 10 do: [:v |				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.				top _ (v * 4).				Display fill: (left@top extent: 4@4) fillColor: c.				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.				top _ (v * 4) + 50.				Display fill: (left@top extent: 4@4) fillColor: c]]].! !!Color class methodsFor: 'examples'!showHuesInteractively	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."	"Color showHuesInteractively"	| p s v |	[Sensor anyButtonPressed] whileFalse: [		p _ Sensor cursorPoint.		s _ p x asFloat / 300.0.		v _ p y asFloat / 300.0.		self showColors: (self wheel: 12 saturation: s brightness: v)].	^ (s min: 1.0) @ (v min: 1.0)! !!Color class methodsFor: 'examples'!wheel: thisMany	"Return a collection of thisMany colors evenly spaced around the color wheel."	"Color showColors: (Color wheel: 12)"	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7! !!Color class methodsFor: 'examples'!wheel: thisMany saturation: s brightness: v	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"	^ (Color h: 0.0 s: s v: v) wheel: thisMany! !!Color class methodsFor: 'named colors'!black	^Black! !!Color class methodsFor: 'named colors'!blue	^Blue! !!Color class methodsFor: 'named colors'!brown	^Brown! !!Color class methodsFor: 'named colors'!cyan	^Cyan! !!Color class methodsFor: 'named colors'!darkGray	^DarkGray! !!Color class methodsFor: 'named colors'!gray	^Gray! !!Color class methodsFor: 'named colors'!green	^Green! !!Color class methodsFor: 'named colors'!lightBlue	^LightBlue! !!Color class methodsFor: 'named colors'!lightBrown	^LightBrown! !!Color class methodsFor: 'named colors'!lightCyan	^LightCyan! !!Color class methodsFor: 'named colors'!lightGray	^LightGray! !!Color class methodsFor: 'named colors'!lightGreen	^LightGreen! !!Color class methodsFor: 'named colors'!lightMagenta	^LightMagenta! !!Color class methodsFor: 'named colors'!lightOrange	^LightOrange! !!Color class methodsFor: 'named colors'!lightRed	^LightRed! !!Color class methodsFor: 'named colors'!lightYellow	^LightYellow! !!Color class methodsFor: 'named colors'!magenta	^Magenta! !!Color class methodsFor: 'named colors'!orange	^Orange! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleBlue	^PaleBlue! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleBuff	^PaleBuff! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleGreen	^PaleGreen! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleMagenta	^PaleMagenta! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleOrange	^PaleOrange! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!palePeach	^PalePeach! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleRed	^PaleRed! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleTan	^PaleTan! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleYellow	^PaleYellow! !!Color class methodsFor: 'named colors'!red	^Red! !!Color class methodsFor: 'named colors' stamp: 'wod 5/24/1998 01:56'!tan	^  Color r: 0.8 g: 0.8 b: 0.5! !!Color class methodsFor: 'named colors'!transparent	^Transparent! !!Color class methodsFor: 'named colors'!veryDarkGray	^VeryDarkGray! !!Color class methodsFor: 'named colors'!veryLightGray	^VeryLightGray! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!veryPaleRed	^VeryPaleRed! !!Color class methodsFor: 'named colors'!veryVeryDarkGray	^VeryVeryDarkGray! !!Color class methodsFor: 'named colors'!veryVeryLightGray	^VeryVeryLightGray! !!Color class methodsFor: 'named colors'!white	^White! !!Color class methodsFor: 'named colors'!yellow	^Yellow! !!Color class methodsFor: 'colormaps' stamp: 'jm 5/2/1999 07:24'!cachedColormapFrom: sourceDepth to: destDepth	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."	| srcIndex map |	CachedColormaps class == Array ifFalse: [CachedColormaps _ (1 to: 9) collect: [:i | Array new: 32]].	srcIndex _ sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex _ 9].	(map _ (CachedColormaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].	map _ self computeColormapFrom: sourceDepth to: destDepth.	(CachedColormaps at: srcIndex) at: destDepth put: map.	^ map! !!Color class methodsFor: 'colormaps'!colorMapIfNeededFrom: sourceDepth to: destDepth	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [		"mapping is done in BitBlt by zero-filling or truncating each color component"		^ nil].	^ Color cachedColormapFrom: sourceDepth to: destDepth! !!Color class methodsFor: 'colormaps' stamp: 'jm 3/25/1999 19:48'!computeColormapFrom: sourceDepth to: destDepth	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."	| map bitsPerColor |	sourceDepth < 16 ifTrue: [		"source is 1-, 2-, 4-, or 8-bit indexed color"		map _ (IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))					collect: [:c | c pixelValueForDepth: destDepth].		map _ map as: Bitmap.	] ifFalse: [		"source is 16-bit or 32-bit RGB"		destDepth > 8			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"			ifFalse: [bitsPerColor _ 4].		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].	"Note: zero is transparent except when source depth is one-bit deep"	sourceDepth > 1 ifTrue: [map at: 1 put: 0].	^ map! !!Color class methodsFor: 'colormaps' stamp: 'jm 12/4/97 15:25'!computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."	| mask map c |	(#(3 4 5) includes: bitsPerColor)		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].	mask _ (1 bitShift: bitsPerColor) - 1.	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		c _ Color			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)			b: ((i bitShift: 0) bitAnd: mask)			range: mask.		map at: i + 1 put: (c pixelValueForDepth: destDepth)].	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"	^ map! !!Color class methodsFor: 'other'!colorNames	"Return a collection of color names."	^ ColorNames! !!Color class methodsFor: 'other'!indexedColors	^ IndexedColors! !!Color class methodsFor: 'other' stamp: 'di 3/29/1999 13:33'!maskingMap: depth	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."	| sizeNeeded |	depth <= 8		ifTrue: [sizeNeeded _ 1 bitShift: depth]		ifFalse: [sizeNeeded _ 4096].	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.		MaskingMap at: 1 put: 0.  "transparent"].	^ MaskingMap! !!Color class methodsFor: 'other'!pixelScreenForDepth: depth	"Return a 50% stipple containing alternating pixels of all-zeros and all-ones to be used as a mask at the given depth."	| mask bits |	mask _ (1 bitShift: depth) - 1.	bits _ 2 * depth.	[bits >= 32] whileFalse: [		mask _ mask bitOr: (mask bitShift: bits).  "double the length of mask"		bits _ bits + bits].	^ Bitmap with: mask with: mask bitInvert32! !!Color class methodsFor: 'other'!quickHighLight: depth	"Quickly return a Bitblt-ready raw colorValue for highlighting areas.  6/22/96 tk"	^ HighLightBitmaps at: depth! !!Color class methodsFor: 'other'!shutDown	"Color shutDown"	ColorChart _ nil.		"Palette of colors for the user to pick from"	CachedColormaps _ nil.	"Maps to translate between color depths"	MaskingMap _ nil.		"Maps all colors except transparent to black for creating a mask"! !!Color class methodsFor: 'other' stamp: 'ar 2/16/2000 21:56'!translucentMaskFor: alphaValue depth: d	"Return a pattern representing a mask usable for stipple transparency"	^(TranslucentPatterns at: d) at: ((alphaValue min: 1.0 max: 0.0) * 4) rounded + 1! !!Color class methodsFor: 'color from user' stamp: 'jm 12/5/97 18:35'!colorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorPaletteForDepth: 16 extent: 190@60) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |	palette _ Form extent: chartExtent depth: depth.	transCaption _ "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt _ transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	x _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		y _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		x _ x + 1].	y _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y _ y + 1].	^ palette! !!Color class methodsFor: 'color from user' stamp: 'jm 1/19/1999 11:33'!colorTest: depth extent: chartExtent colorMapper: colorMapper	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 7) asInteger / 7			g: (c green * 7) asInteger / 7			b: (c blue * 3) asInteger / 3]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 5) asInteger / 5			g: (c green * 5) asInteger / 5			b: (c blue * 5) asInteger / 5]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 15) asInteger / 15			g: (c green * 15) asInteger / 15			b: (c blue * 15) asInteger / 15]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 31) asInteger / 31			g: (c green * 31) asInteger / 31			b: (c blue * 31) asInteger / 31]) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |	palette _ Form extent: chartExtent depth: depth.	transCaption _ "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt _ transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	x _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		y _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			c _ colorMapper value: c.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			c _ colorMapper value: c.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		x _ x + 1].	y _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		c _ colorMapper value: c.		palette fill: (x@y extent: 10@1) fillColor: c.		y _ y + 1].	^ palette! !!Color class methodsFor: 'color from user' stamp: 'di 4/13/1999 14:30'!fromUser	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."	"Color fromUser"	| d startPt save tr oldColor c here s |	d _ Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].	Sensor cursorPoint y < Display center y 		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]		ifFalse: [startPt _ 0@0].	save _ Form fromDisplay: (startPt extent: ColorChart extent).	ColorChart displayAt: startPt.	tr _ ColorChart extent - (50@19) corner: ColorChart extent.	tr _ tr translateBy: startPt.	oldColor _ nil.	[Sensor anyButtonPressed] whileFalse: [		c _ Display colorAt: (here _ Sensor cursorPoint).		(tr containsPoint: here)			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]			ifTrue: [				c _ Color transparent.				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].		c = oldColor ifFalse: [			Display fillWhite: (20@61 + startPt extent: 135@19).			c isTransparent				ifTrue: [s _ 'transparent']				ifFalse: [s _ c shortPrintString.						s _ s copyFrom: 7 to: s size - 1].			s displayAt: 20@61 + startPt.			oldColor _ c]].	save displayAt: startPt.	Sensor waitNoButton.	^ c! !!Color class methodsFor: 'color from user' stamp: 'di 4/13/1999 14:28'!oldColorPaletteForDepth: depth extent: paletteExtent	"Returns a form of the given size showing a color palette for the given depth."	"(Color oldColorPaletteForDepth: Display depth extent: 720@100) display"	| c p f nSteps rect w h q |	f _ Form extent: paletteExtent depth: depth.	f fill: f boundingBox fillColor: Color white.	nSteps _ depth > 8 ifTrue: [12] ifFalse: [6].	w _ paletteExtent x // (nSteps * nSteps).	h _ paletteExtent y - 20 // nSteps.	0 to: nSteps-1 do: [:r |		0 to: nSteps-1 do: [:g |			0 to: nSteps-1 do: [:b |				c _ Color r: r g: g b: b range: nSteps - 1.				rect _ ((r * nSteps * w) + (b * w)) @ (g * h) extent: w@(h + 1).				f fill: rect fillColor: c]]].	q _ Quadrangle origin: paletteExtent - (50@19) corner: paletteExtent.	q displayOn: f.	'Trans.' displayOn: f at: q origin + (9@1).	w _ ((paletteExtent x - q width - 130) // 64) max: 1.	p _ paletteExtent x - q width - (64 * w) - 1 @ (paletteExtent y - 19).	0 to: 63 do:		[:v | c _ Color r: v g: v b: v range: 63.		f fill: ((v * w)@0 + p extent: (w + 1)@19) fillColor: c].	^ f! !ArrayedCollection variableWordSubclass: #ColorArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!ColorArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 20:03'!at: index	^(super at: index) asColorOfDepth: 32! !!ColorArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 20:04'!at: index put: aColor	^super at: index put: (aColor pixelWordForDepth: 32).! !!ColorArray methodsFor: 'converting' stamp: 'ar 3/3/2001 20:06'!asColorArray	^self! !!ColorArray methodsFor: 'converting' stamp: 'RAA 3/8/2001 06:24'!bytesPerElement	^4! !Form subclass: #ColorForm	instanceVariableNames: 'colors cachedDepth cachedColormap'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!ColorForm commentStamp: '<historical>' prior: 0!ColorForm is a normal Form plus a color map of up to 2^depth Colors. Typically, one reserves one entry in the color map for transparent. This allows 1, 3, 15, or 255 non-transparent colors in ColorForms of depths 1, 2, 4, and 8 bits per pixel. ColorForms don't support depths greater than 8 bits because that would require excessively large color maps with little real benefit, since 16-bit and 32-bit depths already support thousands and millions of colors.ColorForms have several uses:  1) Precise colors. You can have up to 256 true colors, instead being limited to the 8-bit color palette.  2) Easy transparency. Just store (Color transparent) at the desired position in the color map.  3) Cheap color remapping by changing the color map.A color map is an Array of up to 2^depth Color objects. A Bitmap colorMap is automatically computed and cached for rapid display. Note that if you change the color map, you must resubmit it via the colors: method to flush this cache.ColorForms can be a bit tricky. Note that:  a) When you BitBlt from one ColorForm to another, you must remember to copy the color map of the source ColorForm to the destination ColorForm.  b) A ColorForm's color map is an array of depth-independent Color objects. BitBlt requires a BitMap of actual pixel values, adjusted to the destination depth. These are different things!! ColorForms automatically maintain a cache of the BitBlt-style color map corresponding to the colors array for the last depth on which the ColorForm was displayed, so there should be little need for clients to work with BitBlt-style color maps.  c) The default map for 8 bit depth has black in the first entry, not transparent.  Say (cform colors at: 1 put: Color transparent).!!ColorForm methodsFor: 'accessing' stamp: 'jm 11/14/97 17:39'!colors	"Return my color palette."	self ensureColorArrayExists.	^ colors! !!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!colors: colorList	"Set my color palette to the given collection."	| colorArray colorCount newColors |	colorList ifNil: [		colors _ cachedDepth _ cachedColormap _ nil.		^ self].	colorArray _ colorList asArray.	colorCount _ colorArray size.	newColors _ Array new: (1 bitShift: self depth).	1 to: newColors size do: [:i |		i <= colorCount			ifTrue: [newColors at: i put: (colorArray at: i)]			ifFalse: [newColors at: i put: Color transparent]].	colors _ newColors.	cachedDepth _ nil.	cachedColormap _ nil.! !!ColorForm methodsFor: 'accessing' stamp: 'mir 7/21/1999 11:51'!colorsFromArray: colorArray	| colorList |	colorList _ colorArray collect: [:colorDef |		Color fromArray: colorDef].	self colors: colorList! !!ColorForm methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:32'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: rule fillColor: aForm	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm		map: (self colormapIfNeededFor: aDisplayMedium).! !!ColorForm methodsFor: 'displaying' stamp: 'di 7/17/97 10:04'!displayOnPort: port at: location	port copyForm: self to: location rule: Form paint! !!ColorForm methodsFor: 'displaying' stamp: 'ar 12/14/2001 18:14'!maskingMap	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."	| maskingMap |	maskingMap _ Bitmap new: (1 bitShift: depth) withAll: 16rFFFFFFFF.	1 to: colors size do:[:i|		(colors at: i) isTransparent ifTrue:[maskingMap at: i put: 0].	].	colors size+1 to: maskingMap size do:[:i| maskingMap at: i put: 0].	^maskingMap! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 11/14/97 17:25'!colorAt: aPoint	"Return the color of the pixel at aPoint."	^ self colors at: (self pixelValueAt: aPoint) + 1! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 11/14/97 17:25'!colorAt: aPoint put: aColor	"Store the given color into the pixel at aPoint. The given color must match one of the colors in the receiver's colormap."	| i |	i _ self colors indexOf: aColor		ifAbsent: [^ self error: 'trying to use a color that is not in my colormap'].	self pixelValueAt: aPoint put: i - 1.! !!ColorForm methodsFor: 'pixel accessing' stamp: 'tk 10/21/97 12:27'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	^ (self colorAt: aPoint) isTransparent! !!ColorForm methodsFor: 'pixel accessing' stamp: 'ar 5/28/2000 12:06'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. Typical clients use colorAt: to get a Color."	"Details: To get the raw pixel value, be sure the peeker's colorMap is nil."	^ (BitBlt current bitPeekerFromForm: self) colorMap: nil; pixelAt: aPoint! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20'!asGrayScale	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"	^ self copy colors:		(colors collect:			[:c | c isTransparent ifTrue: [c]						ifFalse: [Color gray: c luminance]])! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/17/2001 15:44'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: self depth to: destDepth].	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth _ destDepth.	^ cachedColormap _ newMap.! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 4/18/98 20:34'!colorsUsed	"Return a list of the colors actually used by this ColorForm."	| myColor list |	myColor _ self colors.	list _ OrderedCollection new.	self tallyPixelValues doWithIndex: [:count :i |		count > 0 ifTrue: [list add: (myColor at: i)]].	^ list asArray! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 11/16/97 11:18'!ensureTransparentColor	"Ensure that the receiver (a) includes Color transparent in its color map and (b) that the entry for Color transparent is the first entry in its color map."	| i |self error: 'not yet implemented'.	(colors includes: Color transparent)		ifTrue: [			(colors indexOf: Color transparent) = 1 ifTrue: [^ self].			"shift the entry for color transparent"]		ifFalse: [			i _ self unusedColormapEntry.			i = 0 ifTrue: [self error: 'no color map entry is available'].			colors at: i put: Color transparent.			"shift the entry for color transparent"].! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:48'!indexOfColor: aColor	"Return the index of aColor in my color array"	self ensureColorArrayExists.	^ colors indexOf: aColor ifAbsent: [0]! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 10/19/1998 10:52'!mapColor: oldColor to: newColor	"Replace all occurances of the given color with the given new color in my color map."	self ensureColorArrayExists.	1 to: colors size do: [:i | 		(colors at: i) = oldColor ifTrue: [colors at: i put: newColor]].	self clearColormapCache.! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 11/16/97 09:08'!replaceColor: oldColor with: newColor	"Replace all occurances of the given color with the given new color in my color map."	self ensureColorArrayExists.	1 to: colors size do: [:i | 		(colors at: i) = oldColor ifTrue: [colors at: i put: newColor]].	self clearColormapCache.! !!ColorForm methodsFor: 'color manipulation' stamp: 'tk 3/2/98 15:42'!replaceColorAt: aPoint with: newColor	"Replace a color map entry with newColor.  The entry replaced is the one used by aPoint.  If there are are two entries in the colorMap for the oldColor, just replace ONE!!!!  There are often two whites or two blacks, and this is what you want, when replacing one."	| oldIndex |	self ensureColorArrayExists.	oldIndex _ self pixelValueAt: aPoint.	colors at: oldIndex+1 put: newColor.	self clearColormapCache.! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:49'!replaceColorAtIndex: index with: newColor	"Replace a color map entry with newColor."	self ensureColorArrayExists.	colors at: index put: newColor.	cachedColormap == nil ifFalse:		[cachedColormap at: index put: (newColor pixelValueForDepth: cachedDepth)]! !!ColorForm methodsFor: 'color manipulation' stamp: 'tk 3/2/98 11:26'!transparentAllPixelsLike: aPoint	"Make all occurances of the given pixel value transparent.  Very useful when two entries in the colorMap have the same value.  This only changes ONE."	self replaceColorAt: aPoint with: Color transparent.! !!ColorForm methodsFor: 'color manipulation' stamp: 'tk 3/2/98 11:27'!transparentColor: aColor	"Make all occurances of the given color transparent.  Note: for colors like black and white, which have two entries in the colorMap, this changes BOTH of them.  Not always what you want."	self replaceColor: aColor with: Color transparent.! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/28/2000 12:06'!twoToneFromDisplay: aRectangle backgroundColor: bgColor	"Copy one-bit deep ColorForm from the Display using a color map that maps all colors except the background color to black. Used for caching the contents of inactive MVC windows."	| map |	(width = aRectangle width and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	"make a color map mapping the background color	 to zero and all other colors to one"	map _ Bitmap new: (1 bitShift: (Display depth min: 9)).	1 to: map size do: [:i | map at: i put: 16rFFFFFFFF].	map at: (bgColor indexInMap: map) put: 0.	(BitBlt current toForm: self)		destOrigin: 0@0;		sourceForm: Display;		sourceRect: aRectangle;		combinationRule: Form over;		colorMap: map;		copyBits.! !!ColorForm methodsFor: 'copying' stamp: 'RAA 8/14/2000 10:45'!asCursorForm	^ (self asFormOfDepth: 32) offset: offset; as: StaticForm! !!ColorForm methodsFor: 'copying' stamp: 'di 11/12/2001 15:37'!blankCopyOf: aRectangle scaledBy: scale        | newForm |        newForm _ super blankCopyOf: aRectangle scaledBy: scale.        colors ifNotNil: [newForm colors: colors copy].        ^ newForm! !!ColorForm methodsFor: 'copying' stamp: 'ar 5/28/2000 12:06'!copy: aRect 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."	| newForm |	newForm _ self class extent: aRect extent depth: depth.	((BitBlt current		destForm: newForm		sourceForm: self		fillColor: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: aRect origin		extent: aRect extent		clipRect: newForm boundingBox)		colorMap: nil) copyBits.	colors ifNotNil: [newForm colors: colors copy].	^ newForm! !!ColorForm methodsFor: 'copying' stamp: 'jm 2/27/98 09:38'!deepCopy	^ self shallowCopy		bits: bits copy;		offset: offset copy;		colors: colors! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 09:07'!clearColormapCache	cachedDepth _ nil.	cachedColormap _ nil.! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 09:12'!depth: bitsPerPixel	bitsPerPixel > 8 ifTrue: [self error: 'ColorForms only support depths up to 8 bits'].	super depth: bitsPerPixel.! !!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44'!ensureColorArrayExists	"Return my color palette."	colors ifNil: [		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].		self colors: (Color indexedColors copyFrom: 1 to: (1 bitShift: self depth))].! !!ColorForm methodsFor: 'private' stamp: 'jm 4/5/1999 10:11'!setColors: colorArray cachedColormap: aBitmap depth: anInteger	"Semi-private. Set the color array, cached colormap, and cached colormap depth to avoid having to recompute the colormap when switching color palettes in animations."	colors _ colorArray.	cachedDepth _ anInteger.	cachedColormap _ aBitmap.! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 08:37'!setExtent: extent depth: bitsPerPixel	"Create a virtual bit map with the given extent and bitsPerPixel."	bitsPerPixel > 8 ifTrue: [self error: 'ColorForms only support depths up to 8 bits'].	super setExtent: extent depth: bitsPerPixel.! !!ColorForm methodsFor: 'private' stamp: 'jm 2/24/98 18:53'!unusedColormapEntry	"Return the index of an unused color map entry, or zero if there isn't one."	| tallies |	tallies _ self tallyPixelValues.	1 to: tallies size do: [:i |		(tallies at: i) = 0 ifTrue: [^ i]].	^ 0! !!ColorForm methodsFor: 'scaling, rotation' stamp: 'ar 3/15/1999 14:28'!flipBy: direction centerAt: aPoint	| oldColors newForm |	oldColors _ colors.	self colors: nil.	newForm _ super flipBy: direction centerAt: aPoint.	self colors: oldColors.	newForm colors: oldColors.	^newForm ! !!ColorForm methodsFor: 'scaling, rotation' stamp: 'RAA 8/5/2000 18:12'!scaledToSize: newExtent	"super method did not seem to work so well on ColorForms"	^(self asFormOfDepth: 16) scaledToSize: newExtent! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 20:07'!hibernate	"Make myself take up less space. See comment in Form>hibernate."	super hibernate.	self clearColormapCache.	colors ifNotNil:[colors _ colors asColorArray].! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:46'!readAttributesFrom: aBinaryStream	super readAttributesFrom: aBinaryStream.	colors _ ColorArray new: (2 raisedTo: depth).	1 to: colors size do: [:idx | 		colors basicAt: idx put: (aBinaryStream nextLittleEndianNumber: 4).	]. 	! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'bf 5/25/2000 16:31'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream		cr; tab;		nextPutAll: 'colorsFromArray: #('.	self colors do: [:color |		color storeArrayOn: aStream].	aStream nextPutAll: ' ))'.! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 20:07'!unhibernate	colors ifNotNil:[colors _ colors asArray].	^super unhibernate.! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:42'!writeAttributesOn: file	| colorArray |	super writeAttributesOn: file.	colorArray _ self colors asColorArray.	1 to: (2 raisedTo: depth) do: [:idx |		file nextLittleEndianNumber: 4 put: (colorArray basicAt: idx).	] ! !!ColorForm methodsFor: 'postscript generation'!asFormWithSingleTransparentColors	| transparentIndexes |	transparentIndexes _ self transparentColorIndexes.	transparentIndexes size <= 1 ifTrue:[^self]		ifFalse:[^self mapTransparencies:transparentIndexes].! !!ColorForm methodsFor: 'postscript generation'!decodeArray	^self depth = 1 ifTrue:['[1 0]'] ifFalse:['[0 255]'].! !!ColorForm methodsFor: 'postscript generation'!getTransparencyUnificationLUT	| lut transparentIndex |	lut _ Array new:colors size.	transparentIndex _ self indexOfColor:Color transparent.	1 to: colors size do:		[ :i | lut at:i put:(((colors at:i) = Color transparent) ifTrue:[transparentIndex] ifFalse:[i])]. ! !!ColorForm methodsFor: 'postscript generation'!mapTransparencies:transparentIndexes	^self deepCopy mapColors:transparentIndexes to:(transparentIndexes at:1).! !!ColorForm methodsFor: 'postscript generation'!setColorspaceOn:aStream	self depth = 1 ifTrue:[		aStream print:'/DeviceRGB setcolorspace 0 setgray'; cr.	]	ifFalse:[	aStream print:'[ /Indexed /DeviceRGB ';	write:self colors size-1;	print:' <'.	(self colormapIfNeededForDepth: 32 ) storeBits:20 to:0 on:aStream.	aStream print:'> ] setcolorspace'; cr.].! !!ColorForm methodsFor: 'postscript generation'!transparentColorIndexes	^(1 to: colors size) select: [ :index | (colors at:index) isTransparent ].! !!ColorForm methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:44'!colormapIfNeededFor: destForm	| newMap color pv |	(self hasNonStandardPalette or:[destForm hasNonStandardPalette]) ifFalse:[		^self colormapIfNeededForDepth: destForm depth.	].	colors == nil ifTrue: [		"use the standard colormap"		^ super colormapIfNeededFor: destForm].	(destForm depth = cachedDepth and:[cachedColormap isColormap]) 		ifTrue: [^ cachedColormap].	newMap _ WordArray new: (1 bitShift: self depth).	1 to: colors size do: [:i |		color _ colors at: i.		pv _ destForm pixelValueFor: color.		(pv = 0 and:[color isTransparent not]) ifTrue:[pv _ 1].		newMap at: i put: pv].	cachedDepth _ destForm depth.	^cachedColormap _ ColorMap shifts: nil masks: nil colors: newMap.! !!ColorForm methodsFor: 'testing' stamp: 'ar 5/27/2001 16:34'!isColorForm	^true! !!ColorForm methodsFor: 'testing' stamp: 'ar 2/10/2004 17:18'!isTranslucent	"Answer whether this form may be translucent"	^true! !!ColorForm methodsFor: '*morphic-Postscript Canvases' stamp: 'sma 6/14/2000 14:20'!encodePostscriptOn: aStream 	self unhibernate.	aStream print: '% form contains ';	 write: (colors select: [:c | c = Color transparent]) size;	 print: ' transparent colors';	 cr.	^ self asFormWithSingleTransparentColors 		printPostscript: aStream operator: (self depth = 1			ifTrue: ['imagemask']			ifFalse: [(self indexOfColor: Color transparent) printString , ' transparentimage'])! !!ColorForm methodsFor: '*morphic-Postscript Canvases'!printPostscript:aStream	aStream nextPutAll:'% form contains '; 			print:((colors select:[:c| c=Color transparent]) size); 			nextPutAll:' transparent colors'; cr.	^self asFormWithSingleTransparentColors printPostscript:aStream operator:(self depth=1 ifTrue:['imagemask'] 	ifFalse:[ (self indexOfColor:Color transparent) printString ,' transparentimage']) .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ColorForm class	instanceVariableNames: ''!!ColorForm class methodsFor: 'as yet unclassified' stamp: 'nk 4/17/2004 19:44'!mappingWhiteToTransparentFrom: aFormOrCursor	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."	| f map |	aFormOrCursor depth <= 8 ifFalse: [		^ self error: 'argument depth must be 8-bits per pixel or less'].	(aFormOrCursor isColorForm) ifTrue: [		f _ aFormOrCursor deepCopy.		map _ aFormOrCursor colors.	] ifFalse: [		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.		f copyBits: aFormOrCursor boundingBox			from: aFormOrCursor			at: 0@0			clippingBox: aFormOrCursor boundingBox			rule: Form over			fillColor: nil.		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].	map _ map collect: [:c |		c = Color white ifTrue: [Color transparent] ifFalse: [c]].	f colors: map.	^ f! !!ColorForm class methodsFor: 'as yet unclassified'!twoToneFromDisplay: aRectangle using: oldForm backgroundColor: bgColor	"Return a 1-bit deep ColorForm copied from the given rectangle of the display. All colors except the background color will be mapped to black."	| f |	((oldForm ~~ nil) and: [oldForm extent = aRectangle extent]) ifTrue: [		f _ oldForm fromDisplay: aRectangle.	] ifFalse: [		f _ ColorForm extent: aRectangle extent depth: 1.		f twoToneFromDisplay: aRectangle backgroundColor: bgColor.		f colors: (Array			with: bgColor			with: Color black)].	^ f! !Object subclass: #ColorMap	instanceVariableNames: 'shifts masks colors'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:54'!alphaMask	^masks at: 4! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!alphaShift	^shifts at: 4! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:39'!at: index	^colors at: index! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:39'!at: index put: value	^colors at: index put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueMask	^masks at: 3! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueShift	^shifts at: 3! !!ColorMap methodsFor: 'accessing' stamp: 'ar 2/10/2000 17:12'!colors	^colors! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenMask	^masks at: 2! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenShift	^shifts at: 2! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/28/2000 22:08'!inverseMap	"Return the inverse map of the receiver"	| newMasks newShifts |	colors ifNotNil:[^self error:'Not yet implemented'].	newMasks _ WriteStream on: (Array new: 4).	newShifts _ WriteStream on: (Array new: 4).	masks with: shifts do:[:mask :shift|		newMasks nextPut: (mask bitShift: shift).		newShifts nextPut: shift negated].	^ColorMap		shifts: newShifts contents		masks: newMasks contents! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 19:16'!masks	^masks! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:36'!redMask	^masks at: 1! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redShift	^shifts at: 1! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 20:48'!rgbaBitMasks	"Return the rgba bit masks for the receiver"	^masks asArray with: shifts collect:[:m :s| m bitShift: s]! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 19:16'!shifts	^shifts! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/15/2001 16:12'!mapPixel: pixelValue	"Perform a forward pixel mapping operation"	| pv |	(shifts == nil and:[masks == nil]) ifFalse:[		pv _ (((pixelValue bitAnd: self redMask) bitShift: self redShift) bitOr:			((pixelValue bitAnd: self greenMask) bitShift: self greenShift)) bitOr:			(((pixelValue bitAnd: self blueMask) bitShift: self blueShift) bitOr:			((pixelValue bitAnd: self alphaMask) bitShift: self alphaShift)).	] ifTrue:[pv _ pixelValue].	colors ifNotNil:[pv _ colors at: pv].	"Need to check for translucency else Form>>paint goes gaga"	pv = 0 ifTrue:[pixelValue = 0 ifFalse:[pv _ 1]].	^pv! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 6/8/2000 20:36'!mappingTo: aColorMap	"Compute a new color map through the receiver and aColorMap.	Both maps are assumed to be mappings into canonical ARGB space"	| fixedMap |	self = aColorMap ifTrue:[^nil]. "No mapping needed"	aColorMap isIndexed ifTrue:[^nil]. "We can't compute mappings to an indexed map yet"	fixedMap _ self class mappingFrom: self rgbaBitMasks to: aColorMap rgbaBitMasks.	self isIndexed ifFalse:[^fixedMap].	"If the receiver is indexed then we need to map the colors as well"	self flag: #untested.	^ColorMap		shifts: fixedMap shifts		masks: fixedMap masks		colors: (colors collect:[:pv| aColorMap pixelMap: pv]).! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/15/2001 16:12'!pixelMap: pixelValue	"Perform a reverse pixel mapping operation"	| pv |	colors == nil		ifTrue:[pv _ pixelValue]		ifFalse:[pv _ colors at: pixelValue].	(shifts == nil and:[masks == nil]) 		ifFalse:[pv _ (((pv bitAnd: self redMask) bitShift: self redShift) bitOr: 				((pv bitAnd: self greenMask) bitShift: self greenShift)) bitOr:					(((pv bitAnd: self blueMask) bitShift: self blueShift) bitOr: 						((pv bitAnd: self alphaMask) bitShift: self alphaShift))].	"Need to check for translucency else Form>>paint goes gaga"	pv = 0 ifTrue:[pixelValue = 0 ifFalse:[pv _ 1]].	^pv! !!ColorMap methodsFor: 'private' stamp: 'ar 2/22/2000 16:47'!setShifts: shiftArray masks: maskArray colors: colorArray	shiftArray ifNotNil:[shifts _ shiftArray asIntegerArray].	maskArray ifNotNil:[masks _ maskArray asWordArray].	colorArray ifNotNil:[colors _ colorArray asWordArray].! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/25/2000 19:41'!isColormap	^true! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/27/2000 19:06'!isFixed	"Return true if the receiver does not use a lookup mechanism for pixel mapping"	^self isIndexed not! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/27/2000 19:06'!isIndexed	"Return true if the receiver uses a lookup mechanism for pixel mapping"	^colors notNil! !!ColorMap methodsFor: 'comparing' stamp: 'tk 7/5/2001 21:59'!= aColorMap	"Return true if the receiver is equal to aColorMap"	self species == aColorMap species ifFalse:[^false].	self isIndexed == aColorMap isIndexed ifFalse:[^false].	^self colors = aColorMap colors and:[		self shifts = aColorMap shifts and:[			self masks = aColorMap masks]]! !!ColorMap methodsFor: 'comparing' stamp: 'ar 5/27/2000 19:29'!hash	"Hash is re-implemented because #= is re-implemented"	^colors hash bitXor: (shifts hash bitXor: masks hash)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ColorMap class	instanceVariableNames: ''!!ColorMap class methodsFor: 'instance creation' stamp: 'ar 2/22/2000 14:08'!colors: colorArray	^self new setShifts: nil masks: nil colors: colorArray! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:09'!mapBitsFrom: srcBitMask to: dstBitMask	"Return an array consisting of the shift and the mask for	mapping component values out of srcBitMask and into dstBitMask.	While this computation is somewhat complicated it eases the batch	conversion of all the pixels in BitBlt."	| srcBits dstBits srcLow srcHigh dstLow dstHigh bits mask shift |	(srcBitMask = 0 or:[dstBitMask = 0]) ifTrue:[^#(0 0)]. "Zero mask and shift"	"Compute low and high bit position for source and dest bit mask"	srcLow _ srcBitMask lowBit - 1.	srcHigh _ srcBitMask highBit.	dstLow _ dstBitMask lowBit - 1.	dstHigh _ dstBitMask highBit.	"Compute the number of bits in source and dest bit mask"	srcBits _ srcHigh - srcLow.		dstBits _ dstHigh - dstLow.	"Compute the maximum number of bits we can transfer inbetween"	bits _ srcBits min: dstBits.	"Compute the (unshifted) transfer mask"	mask _ (1 bitShift: bits) - 1.	"Shift the transfer mask to the mask the highest n bits of srcBitMask"	mask _ mask bitShift: (srcHigh - bits).	"Compute the delta shift so that the most significant bit of the	source bit mask falls on the most significant bit of the dest bit mask.	Note that delta is used for #bitShift: so		shift > 0 : shift right		shift < 0 : shift left	e.g., if dstHigh > srcHigh we need to shift left and if dstHigh < srcHigh	we need to shift right. This leads to:"	shift _ dstHigh - srcHigh.	"And that's all we need"	^Array with: shift with: mask! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 19:41'!mappingFrom: srcBitMasks to: dstBitMasks	"Return a color map mapping from the array of source bit masks	to the array of dest bit masks."	| shifts masks shiftAndMask |	shifts _ IntegerArray new: 4.	masks _ WordArray new: 4.	1 to: 4 do:[:i|		shiftAndMask _ self mapBitsFrom: (srcBitMasks at: i) to: (dstBitMasks at: i).		shifts at: i put: (shiftAndMask at: 1).		masks at: i put: (shiftAndMask at: 2).	].	^self shifts: shifts masks: masks! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:08'!mappingFromARGB: dstBitMasks	"Return a ColorMap mapping from canonical ARGB space into dstBitMasks"	^self mappingFrom: #(16rFF0000 16rFF00 16rFF 16rFF000000) to: dstBitMasks! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 1/16/2000 16:02'!shifts: shiftArray masks: maskArray	^self shifts: shiftArray masks: maskArray colors: nil.! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 1/16/2000 16:02'!shifts: shiftArray masks: maskArray colors: colorArray	^self new setShifts: shiftArray masks: maskArray colors: colorArray! !StandardSystemView subclass: #ColorSystemView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!ColorSystemView methodsFor: 'as yet unclassified'!cacheBitsAsTwoTone	^ false! !!ColorSystemView methodsFor: 'as yet unclassified' stamp: 'di 2/26/98 08:58'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible."	bitsValid		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [super displayDeEmphasized]! !AbstractEvent subclass: #CommentedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!CommentedEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 11:37'!isCommented	^true! !!CommentedEvent methodsFor: 'printing' stamp: 'rw 7/1/2003 11:37'!printEventKindOn: aStream	aStream nextPutAll: 'Commented'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CommentedEvent class	instanceVariableNames: ''!!CommentedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:08'!changeKind	^#Commented! !!CommentedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 11:20'!supportedKinds	^Array with: self classKind! !ByteArray variableByteSubclass: #CompiledMethod	instanceVariableNames: ''	classVariableNames: 'BlockNodeCache LargeFrame SmallFrame SpecialConstants TempNameCache'	poolDictionaries: ''	category: 'Kernel-Methods'!!CompiledMethod commentStamp: 'ls 7/5/2003 13:48' prior: 0!My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields.	The current format of a CompiledMethod is as follows:	header (4 bytes)	literals (4 bytes each)	bytecodes  (variable)	trailer (variable)The header is a 30-bit integer with the following format:(index 0)	9 bits:	main part of primitive number   (#primitive)(index 9)	8 bits:	number of literals (#numLiterals)(index 17)	1 bit:	whether a large frame size is needed (#frameSize)(index 18)	6 bits:	number of temporary variables (#numTemps)(index 24)	4 bits:	number of arguments to the method (#numArgs)(index 28)	1 bit:	high-bit of primitive number (#primitive)(index 29)	1 bit:	flag bit, ignored by the VM  (#flag)The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.!!CompiledMethod methodsFor: 'initialize-release'!copyWithTrailerBytes: bytes"Testing:	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)		tempNamesPut: 'copy end '"	| copy end start |	start _ self initialPC.	end _ self endPC.	copy _ CompiledMethod newMethod: end - start + 1 + bytes size				header: self header.	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].	start to: end do: [:i | copy at: i put: (self at: i)].	1 to: bytes size do: [:i | copy at: end + i put: (bytes at: i)].	^ copy! !!CompiledMethod methodsFor: 'initialize-release' stamp: 'di 10/22/1999 13:14'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"	| largeFrameBit header |	largeFrameBit _ 16r20000.	(self numTemps + newFrameSize) > LargeFrame ifTrue:		[^ self error: 'Cannot compile -- stack including temps is too deep'].	header _ self objectAt: 1.	(header bitAnd: largeFrameBit) ~= 0		ifTrue: [header _ header - largeFrameBit].	self objectAt: 1 put: header			+ ((self numTemps + newFrameSize) > SmallFrame					ifTrue: [largeFrameBit]					ifFalse: [0])! !!CompiledMethod methodsFor: 'accessing' stamp: 'rw 5/12/2003 11:12'!defaultSelector 	"Invent and answer an appropriate message selector (a 	Symbol) for me, that is, one that will parse with the correct number of 	arguments."	| aStream |	aStream _ WriteStream on: (String new: 16).	aStream nextPutAll: 'DoIt'.	1 to: self numArgs do: [:i | aStream nextPutAll: 'with:'].	^aStream contents asSymbol! !!CompiledMethod methodsFor: 'accessing'!endPC	"Answer the index of the last bytecode."	| flagByte |	flagByte _ self last.	flagByte = 0 ifTrue:		["If last byte = 0, may be either 0, 0, 0, 0 or just 0"		1 to: 4 do: [:i | (self at: self size - i) = 0 ifFalse: [^ self size - i]]].	flagByte < 252 ifTrue:		["Magic sources (tempnames encoded in last few bytes)"		^ self size - self last - 1].	"Normal 4-byte source pointer"	^ self size - 4! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 116>! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 10/23/1999 22:00'!frameSize	"Answer the size of temporary frame needed to run the receiver."	"NOTE:  Versions 2.7 and later use two sizes of contexts."	(self header noMask: 16r20000)		ifTrue: [^ SmallFrame]		ifFalse: [^ LargeFrame]! !!CompiledMethod methodsFor: 'accessing'!initialPC	"Answer the program counter for the receiver's first bytecode."	^ (self numLiterals + 1) * 4 + 1! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 6/2/1998 16:26'!numArgs	"Answer the number of arguments the receiver takes."	^ (self header bitShift: -24) bitAnd: 16r0F! !!CompiledMethod methodsFor: 'accessing'!numLiterals	"Answer the number of literals used by the receiver."		^ (self header bitShift: -9) bitAnd: 16rFF! !!CompiledMethod methodsFor: 'accessing'!numTemps	"Answer the number of temporary variables used by the receiver."		^ (self header bitShift: -18) bitAnd: 16r3F! !!CompiledMethod methodsFor: 'accessing' stamp: 'ls 6/22/2000 14:35'!primitive	"Answer the primitive index associated with the receiver.	Zero indicates that this is not a primitive method.	We currently allow 10 bits of primitive index, but they are in two places	for  backward compatibility.  The time to unpack is negligible,	since the reconstituted full index is stored in the method cache."	| primBits |	primBits _ self header bitAnd: 16r100001FF.		^ (primBits bitAnd: 16r1FF) + (primBits bitShift: -19)! !!CompiledMethod methodsFor: 'accessing'!returnField	"Answer the index of the instance variable returned by a quick return 	method."	| prim |	prim _ self primitive.	prim < 264		ifTrue: [self error: 'only meaningful for quick-return']		ifFalse: [^ prim - 264]! !!CompiledMethod methodsFor: 'accessing' stamp: 'sw 8/15/97 16:17'!selector	"This is slow, so don't call it frivolously"	^ self who last! !!CompiledMethod methodsFor: 'accessing' stamp: 'ajh 11/17/2001 14:30'!trailer	| end trailer |	end _ self endPC.	trailer _ ByteArray new: self size - end.	end + 1 to: self size do: [:i | 		trailer at: i - end put: (self at: i)].	^ trailer! !!CompiledMethod methodsFor: 'comparing' stamp: 'ar 8/16/2001 13:24'!= method	| myLits otherLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(myLits _ self literals) = (otherLits _ method literals) ifFalse:		[myLits size = otherLits size ifFalse: [^ false].		"Dont bother checking FFI and named primitives"		(#(117 120) includes: self primitive) ifTrue: [^ true].		myLits with: otherLits do:			[:lit1 :lit2 | lit1 = lit2 ifFalse:			[(lit1 isVariableBinding)			ifTrue:				["Associations match if value is equal, since associations				used for super may have key = nil or name of class."				lit1 value == lit2 value ifFalse: [^ false]]			ifFalse:				[(lit1 isMemberOf: Float)				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^ false]]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]].	^ true! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 5/3/2001 15:06'!hasReportableSlip	"Answer whether the receiver contains anything that should be brought to the attention of the author when filing out.   Customize the lists here to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'checkForSlips' is set to true."	| assoc | 	#(doOnlyOnce: halt halt: hottest printDirectlyToDisplay toRemove personal urgent) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!CompiledMethod methodsFor: 'testing' stamp: 'md 11/21/2003 12:15'!isCompiledMethod	^ true! !!CompiledMethod methodsFor: 'testing' stamp: 'di 12/26/1998 21:31'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:11'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!CompiledMethod methodsFor: 'testing'!isReturnSelf	"Answer whether the receiver is a quick return of self."	^ self primitive = 256! !!CompiledMethod methodsFor: 'testing'!isReturnSpecial	"Answer whether the receiver is a quick return of self or constant."	^ self primitive between: 256 and: 263! !!CompiledMethod methodsFor: 'printing' stamp: 'sw 7/29/2002 02:24'!dateMethodLastSubmitted	"Answer a Date object indicating when a method was last submitted.  If there is no date stamp, return nil"	"(CompiledMethod compiledMethodAt: #dateMethodLastSubmitted) dateMethodLastSubmitted"	| aStamp tokens |	aStamp _ self timeStamp.	tokens _ aStamp findBetweenSubStrs: ' '.  "space is expected delimiter, but cr is sometimes seen, though of mysterious provenance"	^ tokens size > 1		ifTrue:			[[tokens second asDate] ifError: [nil]]		ifFalse:			[nil]! !!CompiledMethod methodsFor: 'printing' stamp: 'sma 2/12/2000 14:01'!decompileString	| clAndSel cl sel |	clAndSel _ self who.	clAndSel = #(unknown unknown)		ifTrue:			[cl _ Object.			sel _ #xxxUnknown.			self numArgs >= 1				ifTrue:					[sel _ sel , ':'.					2 to: self numArgs do: [:i | sel _ sel , 'with:'].					sel _ sel asSymbol]]		ifFalse:			[cl _ clAndSel first.			sel _ clAndSel last].	^ (cl decompilerClass new			decompile: sel in: cl method: self) decompileString! !!CompiledMethod methodsFor: 'printing' stamp: 'ajh 2/9/2003 14:17'!longPrintOn: aStream	"List of all the byte codes in a method with a short description of each" 	self longPrintOn: aStream indent: 0! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 6/28/2003 00:08'!longPrintOn: aStream indent: tabs	"List of all the byte codes in a method with a short description of each" 	self isQuick ifTrue: 		[self isReturnSpecial ifTrue:			[^ aStream tab: tabs; nextPutAll: 'Quick return ' , 				(#('self' 'true' 'false' 'nil' '-1' '0' '1' '2') at: self primitive - 255)].		^ aStream nextPutAll: 'Quick return field ' , self returnField printString , ' (0-based)'].	self primitive = 0 ifFalse: [		aStream tab: tabs.		self printPrimitiveOn: aStream.	].	(InstructionPrinter on: self) indent: tabs; printInstructionsOn: aStream.! !!CompiledMethod methodsFor: 'printing' stamp: 'sma 6/1/2000 09:45'!printOn: aStream 	"Overrides method inherited from the byte arrayed collection."	self printNameOn: aStream.	aStream space; nextPutAll: self identityHashPrintString! !!CompiledMethod methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:09'!printOnStream: aStream 	"Overrides method inherited from the byte arrayed collection."	aStream print: 'a CompiledMethod'! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/28/1999 19:37'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ self primitive.	primIndex = 0 ifTrue:[^self].	primIndex = 120 "External call spec"		ifTrue:[^aStream print: (self literalAt: 1); cr].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ self literalAt: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>; cr! !!CompiledMethod methodsFor: 'printing'!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' newMethod: '.	aStream store: self size - self initialPC + 1.	aStream nextPutAll: ' header: '.	aStream store: self header.	aStream nextPut: $).	noneYet _ self storeElementsFrom: self initialPC to: self endPC on: aStream.	1 to: self numLiterals do:		[:index |		noneYet			ifTrue: [noneYet _ false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' literalAt: '.		aStream store: index.		aStream nextPutAll: ' put: '.		aStream store: (self literalAt: index)].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!CompiledMethod methodsFor: 'printing' stamp: 'sw 7/29/2002 02:21'!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	| position file preamble stamp tokens tokenCount |	self fileIndex == 0 ifTrue: [^ String new].  "no source pointer for this method"	position _ self filePosition.	file _ SourceFiles at: self fileIndex.	file ifNil: [^ String new].  "sources file not available"	"file does not exist happens in secure mode"	file _ [file readOnlyCopy] on: FileDoesNotExistException do:[:ex| nil].	file ifNil: [^ String new].	file position: (0 max: position - 150).  "Skip back to before the preamble"		[file position < (position - 1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		stamp _ String new.		tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [Scanner new scanTokens: preamble]			ifFalse: [Array new  "ie cant be back ref"].		(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount - 3) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"							stamp _ tokens at: tokenCount - 2]].		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount  - 1) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokenCount]].	file close.	^ stamp! !!CompiledMethod methodsFor: 'printing' stamp: 'dvf 8/23/2003 11:50'!who	"Answer an Array of the class in which the receiver is defined and the 	selector to which it corresponds."	| sel |	self systemNavigation allBehaviorsDo: 			[:class | 			(sel := class methodDict keyAtIdentityValue: self ifAbsent: [nil]) 				ifNotNil: [^Array with: class with: sel]].	^Array with: #unknown with: #unknown! !!CompiledMethod methodsFor: 'literals' stamp: 'di 10/17/97 22:38'!hasLiteral: literal 	"Answer whether the receiver references the argument, literal."	<primitive: 132>  "a fast primitive operation equivalent to..."	2 to: self numLiterals + 1 do:		[:index |		literal == (self objectAt: index) ifTrue: [^ true]].	^ false! !!CompiledMethod methodsFor: 'literals' stamp: 'di 8/15/97 09:51'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in this method, even if imbedded in array structure."	| lit |	2 to: self numLiterals + 1 do:		[:index | lit _ self objectAt: index.		(litBlock value: lit) ifTrue: [^ true].		(lit class == Array and: [lit hasLiteralSuchThat: litBlock]) ifTrue: [^ true]].	^false! !!CompiledMethod methodsFor: 'literals' stamp: 'sma 6/3/2000 21:39'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	| lit |	2 to: self numLiterals + 1 do: 		[:index | 		(lit _ self objectAt: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false! !!CompiledMethod methodsFor: 'literals'!header	"Answer the word containing the information about the form of the 	receiver and the form of the context needed to run the receiver."	^self objectAt: 1! !!CompiledMethod methodsFor: 'literals' stamp: 'ajh 2/9/2003 13:15'!headerDescription	"Answer a description containing the information about the form of the 	receiver and the form of the context needed to run the receiver."	| s |	s _ '' writeStream.	self header printOn: s.	s cr; nextPutAll: '"primitive: '.	self primitive printOn: s.	s cr; nextPutAll: ' numArgs: '.	self numArgs printOn: s.	s cr; nextPutAll: ' numTemps: '.	self numTemps printOn: s.	s cr; nextPutAll: ' numLiterals: '.	self numLiterals printOn: s.	s cr; nextPutAll: ' frameSize: '.	self frameSize printOn: s.	s cr; nextPutAll: ' isClosureCompiled: '.	self isClosureCompiled printOn: s.	s nextPut: $"; cr.	^ s contents! !!CompiledMethod methodsFor: 'literals'!literalAt: index 	"Answer the literal indexed by the argument."	^self objectAt: index + 1! !!CompiledMethod methodsFor: 'literals'!literalAt: index put: value 	"Replace the literal indexed by the first argument with the second 	argument. Answer the second argument."	^self objectAt: index + 1 put: value! !!CompiledMethod methodsFor: 'literals'!literals	"Answer an Array of the literals referenced by the receiver."	| literals numberLiterals |	literals _ Array new: (numberLiterals _ self numLiterals).	1 to: numberLiterals do:		[:index |		literals at: index put: (self objectAt: index + 1)].	^literals! !!CompiledMethod methodsFor: 'literals'!objectAt: index 	"Primitive. Answer the method header (if index=1) or a literal (if index 	>1) from the receiver. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 68>	self primitiveFailed! !!CompiledMethod methodsFor: 'literals'!objectAt: index put: value 	"Primitive. Store the value argument into a literal in the receiver. An 	index of 2 corresponds to the first literal. Fails if the index is less than 2 	or greater than the number of literals. Answer the value as the result. 	Normally only the compiler sends this message, because only the 	compiler stores values in CompiledMethods. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 69>	self primitiveFailed! !!CompiledMethod methodsFor: 'scanning'!messages	"Answer a Set of all the message selectors sent by this method."	| scanner aSet |	aSet _ Set new.	scanner _ InstructionStream on: self.	scanner			scanFor: 			[:x | 			scanner addSelectorTo: aSet.			false	"keep scanning"].	^aSet! !!CompiledMethod methodsFor: 'scanning'!readsField: varIndex 	"Answer whether the receiver loads the instance variable indexed by the 	argument."	self isReturnField ifTrue: [^self returnField + 1 = varIndex].	varIndex <= 16 ifTrue: [^ self scanFor: varIndex - 1].	varIndex <= 64 ifTrue: [^ self scanLongLoad: varIndex - 1].	^ self scanVeryLongLoad: 64 offset: varIndex - 1! !!CompiledMethod methodsFor: 'scanning'!scanFor: byte 	"Answer whether the receiver contains the argument as a bytecode."	^ (InstructionStream on: self) scanFor: [:instr | instr = byte]"Smalltalk browseAllSelect: [:m | m scanFor: 134]"! !!CompiledMethod methodsFor: 'scanning'!scanLongLoad: extension 	"Answer whether the receiver contains a long load whose extension is the 	argument."	| scanner |	scanner _ InstructionStream on: self.	^scanner scanFor: [:instr | instr = 128 and: [scanner followingByte = extension]]! !!CompiledMethod methodsFor: 'scanning'!scanLongStore: extension 	"Answer whether the receiver contains a long store whose extension is 	the argument."	| scanner |	scanner _ InstructionStream on: self.	^scanner scanFor: 		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]! !!CompiledMethod methodsFor: 'scanning'!scanVeryLongLoad: extension offset: offset	"Answer whether the receiver contains a long load whose extension is the 	argument."	| scanner |	scanner _ InstructionStream on: self.	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])											and: [scanner thirdByte = offset]]! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 6/25/97 19:08'!scanVeryLongStore: extension offset: offset	"Answer whether the receiver contains a long load with the given offset.	Note that the constant +32 is the known difference between a	store and a storePop for instVars, and it will always fail on literal variables,	but these only use store (followed by pop) anyway."	| scanner ext |	scanner _ InstructionStream on: self.	^ scanner scanFor:		[:instr | (instr = 132 and: [(ext _ scanner followingByte) = extension											or: ["might be a store/pop into rcvr"												ext = (extension+32)]])							and: [scanner thirdByte = offset]]! !!CompiledMethod methodsFor: 'scanning'!sendsToSuper	"Answer whether the receiver sends any message to super."	| scanner |	scanner _ InstructionStream on: self.	^ scanner scanFor: 		[:instr |  instr = 16r85 or: [instr = 16r84						and: [scanner followingByte between: 16r20 and: 16r3F]]]! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 12/26/1998 21:30'!writesField: field 	"Answer whether the receiver stores into the instance variable indexed 	by the argument."	self isQuick ifTrue: [^ false].	field <= 8 ifTrue:		[^ (self scanFor: 96 + field - 1) or: [self scanLongStore: field - 1]].	field <= 64 ifTrue:		[^ self scanLongStore: field - 1].	^ self scanVeryLongStore: 160 offset: field - 1! !!CompiledMethod methodsFor: 'source code management'!cacheTempNames: names	TempNameCache _ Association key: self value: names! !!CompiledMethod methodsFor: 'source code management' stamp: 'tk 12/7/2000 12:28'!checkOKToAdd: size at: filePosition	"Issue several warnings as the end of the changes file approaches its limit,	and finally halt with an error when the end is reached."	| fileSizeLimit margin |	fileSizeLimit _ 16r2000000.	3 to: 1 by: -1 do:		[:i | margin _ i*100000.		(filePosition + size + margin) > fileSizeLimit			ifTrue: [(filePosition + margin) > fileSizeLimit ifFalse:						[self inform: 'WARNING: your changes file is within' , margin printString , ' characters of its size limit.You should take action soon to reduce its size.You may proceed.']]			ifFalse: [^ self]].	(filePosition + size > fileSizeLimit) ifFalse: [^ self].	self error: 'You have reached the size limit of the changes file.You must take action now to reduce it.Close this error.  Do not attempt to proceed.'! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 1/7/2004 15:32'!copyWithTempNames: tempNames	| tempStr compressed |	tempStr _ String streamContents:		[:strm | tempNames do: [:n | strm nextPutAll: n; space]].	compressed := self qCompress: tempStr firstTry: true.	compressed ifNil:		["failure case (tempStr too big) will just decompile with tNN names"		^ self copyWithTrailerBytes: #(0 0 0 0)].	^ self copyWithTrailerBytes: compressed! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:44'!fileIndex	^SourceFiles fileIndexFromSourcePointer: self sourcePointer! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:45'!filePosition	^SourceFiles filePositionFromSourcePointer: self sourcePointer! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 12/26/1998 22:34'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte |	flagByte _ self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	(source _ self getSourceFromFile) == nil ifFalse: [^ source].	"Something really wrong -- decompile blind (no temps)"	^ (class decompilerClass new decompile: selector in: class method: self)			decompileString! !!CompiledMethod methodsFor: 'source code management' stamp: 'tk 12/12/97 13:03'!getSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method."	| position |	(position _ self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: position)			text! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 7/21/2003 09:45'!holdsTempNames	"Are tempNames stored in trailer bytes"	| flagByte |	flagByte _ self last.	(flagByte = 0 or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue: [^ false].  "No source pointer & no temp names"	flagByte < 252 ifTrue: [^ true].  "temp names compressed"	^ false	"Source pointer"! !!CompiledMethod methodsFor: 'source code management' stamp: '6/5/97 di'!putSource: sourceStr fromParseNode: methodNode class: class category: catName	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble:			[:file |			class printCategoryChunk: catName on: file				withStamp: changeStamp priorMethod: priorMethod.			file cr]! !!CompiledMethod methodsFor: 'source code management' stamp: 'NS 1/16/2004 15:39'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString  st80str |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	SmalltalkImage current assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	(methodNode isKindOf: DialectMethodNode)		ifTrue:		["This source was parsed from an alternate syntax.		We must convert to ST80 before logging it."		st80str _ (DialectStream dialect: #ST80 contents: [:strm | methodNode printOn: strm])						asString.		remoteString _ RemoteString newString: st80str						onFileNumber: fileIndex toFile: file]		ifFalse:		[remoteString _ RemoteString newString: sourceStr						onFileNumber: fileIndex toFile: file].	file nextChunkPut: ' '.	InMidstOfFileinNotification signal ifFalse: [file flush].	self checkOKToAdd: sourceStr size at: remoteString position.	self setSourcePosition: remoteString position inFile: fileIndex! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 1/7/2004 15:32'!qCompress: str firstTry: firstTry	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble.	Normal call is with firstTry == true."	| charTable odd ix oddNibble names shorterStr maybe |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		oddNibble _ nil.		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm position > 251 ifTrue:			["Only values 1...251 are available for the flag byte			that signals compressed temps. See the logic in endPC."			"Before giving up completely, we attempt to encode most of			the temps, but with the last few shortened to tNN-style names."			firstTry ifFalse: [^ nil "already tried --give up now"].			names _ str findTokens: ' '.			names size < 8 ifTrue: [^ nil  "weird case -- give up now"].			4 to: names size//2 by: 4 do:				[:i | shorterStr _ String streamContents:					[:s |					1 to: names size - i do: [:j | s nextPutAll: (names at: j); space].					1 to: i do: [:j | s nextPutAll: 't' , j printString; space]].				(maybe _ self qCompress: shorterStr firstTry: false) ifNotNil: [^ maybe]].			^ nil].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!CompiledMethod methodsFor: 'source code management'!qDecompress: byteArray	"Decompress strings compressed by qCompress:.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble"	|  charTable extended ext |	charTable _  "Character encoding table must match qCompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ String streamContents:		[:strm | extended _ false.  "Flag for 2-nibble characters"		byteArray do:			[:byte | 			(Array with: byte//16 with: byte\\16)				do:				[:nibble | extended					ifTrue: [strm nextPut: (charTable at: ext*16+nibble + 1). extended _ false]					ifFalse: [nibble < 12 ifTrue: [strm nextPut: (charTable at: nibble + 1)]									ifFalse: [ext _ nibble-12.  extended _ true]]]]]! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 21:00'!setSourcePointer: srcPointer	srcPointer = 0 ifTrue: [		self at: self size put: 0.		^self].	(srcPointer between: 16r1000000 and: 16r4FFFFFF) ifFalse: [self error: 'Source pointer out of range'].	self at: self size put: (srcPointer bitShift: -24) + 251.	1 to: 3 do: [:i |		self at: self size-i put: ((srcPointer bitShift: (i-3)*8) bitAnd: 16rFF)]! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 21:02'!setSourcePosition: position inFile: fileIndex 	self setSourcePointer: (SourceFiles sourcePointerFromFileIndex: fileIndex andPosition: position)! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 8/13/2002 18:19'!sourceClass	"Get my receiver class (method class) from the preamble of my source.  Return nil if not found."	^ [(Compiler evaluate: (self sourceFileStream backChunk "blank"; backChunk "preamble")) theClass] on: Error do: [nil]! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 8/13/2002 18:18'!sourceFileStream 	"Answer the sources file stream with position set at the beginning of my source string"	| pos |	(pos _ self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: pos) fileStream! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:44'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	The returned value is either 0 (if no source is stored) or a number between 16r1000000 and 16r4FFFFFF.	The actual interpretation of this number is up to the SourceFileArray stored in the global variable SourceFiles."	| pos |	self last < 252 ifTrue: [^ 0  "no source"].	pos _ self last - 251.	self size - 1 to: self size - 3 by: -1 do: [:i | pos _ pos * 256 + (self at: i)].	^pos! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 7/21/2003 00:29'!tempNames	| byteCount bytes |	self holdsTempNames ifFalse: [		^ (1 to: self numTemps) collect: [:i | 't', i printString]	].	byteCount _ self at: self size.	byteCount = 0 ifTrue: [^ Array new].	bytes _ (ByteArray new: byteCount)		replaceFrom: 1 to: byteCount with: self 		startingAt: self size - byteCount.	^ (self qDecompress: bytes) findTokens: ' '! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 10/6/2000 14:22'!readDataFrom: aDataStream size: varsOnDisk	"Fill in my fields.  My header and number of literals are already installed.  Must read both objects for the literals and bytes for the bytecodes."	self error: 'Must use readMethod'.! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 8/19/1998 16:20'!veryDeepCopyWith: deepCopier	"Return self.  I am always shared.  Do not record me.  Only use this for blocks.  Normally methodDictionaries should not be copied this way."! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 5/28/2003 01:10'!blockNodeIn: homeMethodNode	"Return the block node for self"	homeMethodNode ifNil: [		^ self decompilerClass new decompileBlock: self].	homeMethodNode ir compiledMethod.  "generate method"	homeMethodNode nodesDo: [:node |		(node isBlock and:		 [node scope isInlined not and:		  [node ir compiledMethod = self]])			ifTrue: [				BlockNodeCache _ self -> node.				^ node]	].	self errorNodeNotFound! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 19:45'!decompile	"Return the decompiled parse tree that represents self"	^ self decompileClass: nil selector: nil! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 19:44'!decompileClass: aClass selector: selector	"Return the decompiled parse tree that represents self"	^ self decompilerClass new decompile: selector in: aClass method: self! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ar 6/28/2003 00:05'!decompilerClass	^Decompiler! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 13:11'!isClosureCompiled	"Return true if this method was compiled with the new closure compiler, Parser2 (compiled while Preference compileBlocksAsClosures was true).  Return false if it was compiled with the old compiler."	^ self header < 0! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 00:22'!methodNode	"Return the parse tree that represents self"	^ self methodNodeDecompileClass: nil selector: nil! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 12/13/2003 18:30'!methodNodeDecompileClass: aClass selector: selector	"Return the parse tree that represents self"	| source |	^ (source _ self getSourceFromFile)		ifNil: [self decompileClass: aClass selector: selector]		ifNotNil: [self parserClass new parse: source class: (aClass ifNil: [self sourceClass])]! !!CompiledMethod methodsFor: 'decompiling' stamp: 'nk 2/20/2004 15:59'!methodNodeFormattedAndDecorated: decorate	"Return the parse tree that represents self"	^ self methodNodeFormattedDecompileClass: nil selector: nil decorate: decorate! !!CompiledMethod methodsFor: 'decompiling' stamp: 'nk 2/20/2004 15:58'!methodNodeFormattedDecompileClass: aClass selector: selector  decorate: decorated	"Return the parse tree that represents self, using pretty-printed source text if possible."	| source sClass node |	source := self getSourceFromFile.	sClass _ aClass ifNil: [self sourceClass].	source ifNil: [ ^self decompileClass: sClass selector: selector].	source _ sClass compilerClass new						format: source						in: sClass						notifying: nil						decorated: decorated.	node _ sClass parserClass new				parse: source				class: sClass.	node sourceText: source.	^node! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ar 6/28/2003 00:05'!parserClass	^Parser! !!CompiledMethod methodsFor: 'breakpoints' stamp: 'emm 5/30/2002 09:22'!hasBreakpoint	^BreakpointManager methodHasBreakpoint: self! !!CompiledMethod methodsFor: 'user interface' stamp: 'ajh 2/3/2003 19:18'!inspectorClass

	^ CompiledMethodInspector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompiledMethod class	instanceVariableNames: ''!!CompiledMethod class methodsFor: 'class initialization' stamp: 'ajh 2/3/2003 21:16'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame _ 16.	"Context range for temps+stack"	LargeFrame _ 56.	self classPool at: #BlockNodeCache ifAbsentPut: [nil->nil].! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'tk 9/9/2000 20:36'!basicNew: size	self error: 'CompiledMethods may only be created with newMethod:header:' ! !!CompiledMethod class methodsFor: 'instance creation'!new	"This will not make a meaningful method, but it could be used	to invoke some otherwise useful method in this class."	^ self newMethod: 0 header: 0! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'tk 1/21/2000 15:25'!new: size	self error: 'CompiledMethods may only be created with newMethod:header:'! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:37'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method |	nTemps > 64 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		largeBit _ (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits _ primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high 2 bits of primitive no. are in high bits of header"				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r600) bitShift: 19)].	method _ self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits.	1 to: trailer size do:  "Copy the source code trailer to the end"		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!CompiledMethod class methodsFor: 'instance creation'!newMethod: numberOfBytes header: headerWord 	"Primitive. Answer an instance of me. The number of literals (and other 	information) is specified the headerWord. The first argument specifies 	the number of fields for bytecodes in the method. Fail if either 	argument is not a SmallInteger, or if numberOfBytes is negative. Once 	the header of a method is set by this primitive, it cannot be changed in 	any way. Essential. See Object documentation whatIsAPrimitive."	<primitive: 79>	(numberOfBytes isInteger and:	 [headerWord isInteger and:	 [numberOfBytes >= 0]]) ifTrue: [		"args okay; space must be low"		Smalltalk signalLowSpace.		"retry if user proceeds"		^ self newMethod: numberOfBytes header: headerWord	].	^self primitiveFailed! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:43'!toReturnConstant: index trailerBytes: trailer	"Answer an instance of me that is a quick return of the constant	indexed in (true false nil -1 0 1 2)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 256 + index! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:44'!toReturnField: field trailerBytes: trailer	"Answer an instance of me that is a quick return of the instance variable 	indexed by the argument, field."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 264 + field! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:51'!toReturnSelf	"Answer an instance of me that is a quick return of the instance (^self)."	^ self toReturnSelfTrailerBytes: #(0 0 0 0)! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:44'!toReturnSelfTrailerBytes: trailer	"Answer an instance of me that is a quick return of the instance (^self)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 256! !Inspector subclass: #CompiledMethodInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!CompiledMethodInspector methodsFor: 'accessing' stamp: 'ajh 1/18/2003 13:47'!fieldList

	| keys |
	keys _ OrderedCollection new.
	keys add: 'self'.
	keys add: 'all bytecodes'.
	keys add: 'header'.
	1 to: object numLiterals do: [ :i |
		keys add: 'literal', i printString ].
	object initialPC to: object size do: [ :i |
		keys add: i printString ].
	^ keys asArray
	! !!CompiledMethodInspector methodsFor: 'selecting' stamp: 'ajh 3/20/2003 00:17'!contentsIsString
	"Hacked so contents empty when deselected"

	^ #(0 2 3) includes: selectionIndex! !!CompiledMethodInspector methodsFor: 'selecting' stamp: 'ajh 1/18/2003 13:56'!selection

	| bytecodeIndex |
	selectionIndex = 0 ifTrue: [^ ''].
	selectionIndex = 1 ifTrue: [^ object ].
	selectionIndex = 2 ifTrue: [^ object symbolic].	selectionIndex = 3 ifTrue: [^ object headerDescription].
	selectionIndex <= (object numLiterals + 3) 
		ifTrue: [ ^ object objectAt: selectionIndex - 2 ].
	bytecodeIndex _ selectionIndex - object numLiterals - 3.	^ object at: object initialPC + bytecodeIndex - 1! !!CompiledMethodInspector methodsFor: 'selecting' stamp: 'ajh 3/20/2001 11:56'!selectionUnmodifiable	"Answer if the current selected variable is unmodifiable via acceptance in the code pane.  For most inspectors, no selection and a selection of self (selectionIndex = 1) are unmodifiable"

	^ true! !Object subclass: #CompiledMethodWithNode	instanceVariableNames: 'node method'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!CompiledMethodWithNode methodsFor: 'private' stamp: 'NS 1/28/2004 09:03'!method: aCompiledMethod	method _ aCompiledMethod! !!CompiledMethodWithNode methodsFor: 'private' stamp: 'NS 1/28/2004 09:04'!node: aMethodNode	node _ aMethodNode! !!CompiledMethodWithNode methodsFor: 'accessing' stamp: 'NS 1/28/2004 09:03'!method	^ method! !!CompiledMethodWithNode methodsFor: 'accessing' stamp: 'NS 1/28/2004 09:04'!node	^ node! !!CompiledMethodWithNode methodsFor: 'accessing' stamp: 'NS 1/28/2004 09:04'!selector	^ self node selector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompiledMethodWithNode class	instanceVariableNames: ''!!CompiledMethodWithNode class methodsFor: 'instance creation' stamp: 'NS 1/28/2004 09:05'!generateMethodFromNode: aMethodNode trailer: bytes	^ self method: (aMethodNode generate: bytes) node: aMethodNode.! !!CompiledMethodWithNode class methodsFor: 'instance creation' stamp: 'NS 1/28/2004 09:05'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !Object subclass: #Compiler	instanceVariableNames: 'sourceStream requestor class context parserClass cacheDoItNode'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!Compiler commentStamp: '<historical>' prior: 0!The compiler accepts Smalltalk source code and compiles it with respect to a given class. The user of the compiler supplies a context so that temporary variables are accessible during compilation. If there is an error, a requestor (usually a kind of StringHolderController) is sent the message notify:at:in: so that the error message can be displayed. If there is no error, then the result of compilation is a MethodNode, which is the root of a parse tree whose nodes are kinds of ParseNodes. The parse tree can be sent messages to (1) generate code for a CompiledMethod (this is done for compiling methods or evaluating expressions); (2) pretty-print the code (for formatting); or (3) produce a map from object code back to source code (used by debugger program-counter selection). See also Parser, Encoder, ParseNode.!!Compiler methodsFor: 'error handling'!interactive 	"Answer whether there is a requestor of the compiler who should be 	informed that an error occurred."	^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!Compiler methodsFor: 'error handling'!notify: aString 	"Refer to the comment in Object|notify:."	^self notify: aString at: sourceStream position + 1! !!Compiler methodsFor: 'error handling' stamp: 'LC 1/6/2002 13:53'!notify: aString at: location	"Refer to the comment in Object|notify:."	requestor == nil		ifTrue: [^SyntaxErrorNotification					inClass: class					withCode: 						(sourceStream contents							copyReplaceFrom: location							to: location - 1							with: aString)					doitFlag: false]		ifFalse: [^requestor					notify: aString					at: location					in: sourceStream]! !!Compiler methodsFor: 'public access'!compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'vb 8/13/2001 23:11'!compileNoPattern: textOrStream in: aClass context: aContext notifying: aRequestor ifFail: failBlock	"Similar to #compile:in:notifying:ifFail:, but the compiled code is	expected to be a do-it expression, with no message pattern."	self from: textOrStream		class: aClass		context: aContext		notifying: aRequestor.	^self		translate: sourceStream		noPattern: true		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'sd 1/19/2004 20:58'!evaluate: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result _ self				evaluate: aString				in: aContext				to: aReceiver				notifying: nil				ifFail: [^ #failedDoit].	^ result! !!Compiler methodsFor: 'public access' stamp: 'NS 1/19/2004 09:05'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	^ self evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: false.! !!Compiler methodsFor: 'public access' stamp: 'NS 1/28/2004 11:19'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value selector |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].		selector _ context isNil		ifTrue: [#DoIt]		ifFalse: [#DoItIn:].	class addSelectorSilently: selector withMethod: method.	value _ context isNil		ifTrue: [receiver DoIt]		ifFalse: [receiver DoItIn: context].	InMidstOfFileinNotification signal 		ifFalse: [class basicRemoveSelector: selector].	logFlag ifTrue: [SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext].	^ value.! !!Compiler methodsFor: 'public access' stamp: 'sw 5/20/2001 10:01'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	aSymbol == #colorPrint		ifTrue: [^ aNode asColorizedSmalltalk80Text].	aSymbol == #altSyntax  "Alan's current explorations for alternate syntax - 2000/2001"		ifTrue:			[^ aNode asAltSyntaxText].	^ aNode decompileString! !!Compiler methodsFor: 'public access' stamp: 'sw 11/7/1999 00:11'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileString]! !!Compiler methodsFor: 'public access' stamp: 'di 4/24/2000 07:46'!parse: textOrStream in: aClass notifying: req	"Compile the argument, textOrStream, with respect to the class, aClass, 	and answer the MethodNode that is the root of the resulting parse tree. 	Notify the argument, req, if an error occurs. The failBlock is defaulted to 	an empty block."	^ self parse: textOrStream in: aClass notifying: req dialect: false! !!Compiler methodsFor: 'public access' stamp: 'ajh 9/14/2002 18:47'!parse: textOrStream in: aClass notifying: req dialect: useDialect        "Compile the argument, textOrStream, with respect to the class, aClass,         and answer the MethodNode that is the root of the resulting parse tree.         Notify the argument, req, if an error occurs. The failBlock is defaulted to         an empty block."        self from: textOrStream class: aClass context: nil notifying: req.        ^ ((useDialect and: [RequestAlternateSyntaxSetting signal])                ifTrue: [self dialectParserClass]                ifFalse: [self parserClass]) new                        parse: sourceStream                        class: class                        noPattern: false                        context: context                        notifying: requestor                        ifFail: []! !!Compiler methodsFor: 'private' stamp: 'ar 6/28/2003 00:05'!dialectParserClass	^DialectParser! !!Compiler methodsFor: 'private' stamp: 'ajh 1/21/2003 12:44'!format: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ 		self parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !!Compiler methodsFor: 'private'!from: textOrStream class: aClass context: aContext notifying: req	(textOrStream isKindOf: PositionableStream)		ifTrue: [sourceStream _ textOrStream]		ifFalse: [sourceStream _ ReadStream on: textOrStream asString].	class _ aClass.	context _ aContext.	requestor _ req! !!Compiler methodsFor: 'private' stamp: 'ajh 1/21/2003 12:44'!parserClass	^ parserClass! !!Compiler methodsFor: 'private' stamp: 'ajh 9/19/2002 02:20'!parserClass: aParserClass	parserClass _ aParserClass.	cacheDoItNode _ true.! !!Compiler methodsFor: 'private' stamp: 'ajh 1/21/2003 12:45'!translate: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ 		self parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Compiler class	instanceVariableNames: ''!!Compiler class methodsFor: 'accessing' stamp: 'ajh 1/21/2003 12:39'!new	^ super new parserClass: self parserClass! !!Compiler class methodsFor: 'accessing'!parserClass	"Return a parser class to use for parsing method headers."	^Parser! !!Compiler class methodsFor: 'evaluating' stamp: 'NS 1/19/2004 10:07'!evaluate: textOrString 	"See Compiler|evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor. 	Compilation is carried out with respect to nil, i.e., no object, and the 	invocation is not logged."	^self evaluate: textOrString for: nil logged: false! !!Compiler class methodsFor: 'evaluating'!evaluate: textOrString for: anObject logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor."	^self evaluate: textOrString for: anObject notifying: nil logged: logFlag! !!Compiler class methodsFor: 'evaluating' stamp: 'NS 1/19/2004 09:50'!evaluate: textOrString for: anObject notifying: aController logged: logFlag	"Compile and execute the argument, textOrString with respect to the class 	of anObject. If a compilation error occurs, notify aController. If both 	compilation and execution are successful then, if logFlag is true, log 	(write) the text onto a system changes file so that it can be replayed if 	necessary."	^ self new				evaluate: textOrString				in: nil				to: anObject				notifying: aController				ifFail: [^nil]				logged: logFlag.! !!Compiler class methodsFor: 'evaluating'!evaluate: textOrString logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor. 	Compilation is carried out with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil logged: logFlag! !!Compiler class methodsFor: 'evaluating'!evaluate: textOrString notifying: aController logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. Compilation is carried out 	with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil notifying: aController logged: logFlag! !CharacterScanner subclass: #CompositionScanner	instanceVariableNames: 'spaceX spaceIndex lineHeight baseline lineHeightAtSpace baselineAtSpace'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!CompositionScanner commentStamp: '<historical>' prior: 0!CompositionScanners are used to measure text and determine where line breaks and space padding should occur.!!CompositionScanner methodsFor: 'scanning' stamp: 'hmm 7/20/2000 18:24'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:36'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	lineHeight == nil		ifTrue: [descent _ font descent.				baseline _ font ascent.				lineHeight _ baseline + descent]		ifFalse: [descent _ lineHeight - baseline max: font descent.				baseline _ baseline max: font ascent.				lineHeight _ lineHeight max: baseline + descent]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'RAA 5/4/2001 13:52'!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	spaceX _ destX.	line paddingWidth: rightMargin - spaceX.	^true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	spaceX _ destX.	line paddingWidth: rightMargin - spaceX.	^true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	spaceCount >= 1 ifTrue:		["The common case. First back off to the space at which we wrap."		line stop: spaceIndex.		lineHeight _ lineHeightAtSpace.		baseline _ baselineAtSpace.		spaceCount _ spaceCount - 1.		spaceIndex _ spaceIndex - 1.		"Check to see if any spaces preceding the one at which we wrap.			Double space after punctuation, most likely."		[(spaceCount > 1 and: [(text at: spaceIndex) = Space])]			whileTrue:				[spaceCount _ spaceCount - 1.				"Account for backing over a run which might					change width of space."				font _ text fontAt: spaceIndex withStyle: textStyle.				spaceIndex _ spaceIndex - 1.				spaceX _ spaceX - (font widthOf: Space)].		line paddingWidth: rightMargin - spaceX.		line internalSpaces: spaceCount]	ifFalse:		["Neither internal nor trailing spaces -- almost never happens."		lastIndex _ lastIndex - 1.		[destX <= rightMargin]			whileFalse:				[destX _ destX - (font widthOf: (text at: lastIndex)).				lastIndex _ lastIndex - 1].		spaceX _ destX.		line paddingWidth: rightMargin - destX.		line stop: (lastIndex max: line first)].	^true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			spaceX _ destX.			line paddingWidth: rightMargin - destX.			^true]	ifFalse:	[runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).			runStopIndex _ lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 12/17/2001 02:13'!placeEmbeddedObject: anchoredMorph	| descent |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: ["It doesn't fit"		"But if it's the first character then leave it here"		lastIndex < line first ifFalse:[			line stop: lastIndex-1.			^ false]].	descent _ lineHeight - baseline.	lineHeight _ lineHeight max: anchoredMorph height.	baseline _ lineHeight - descent.	line stop: lastIndex.	^ true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'BG 10/29/2003 10:20'!setFont	super setFont.	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions _ stopConditions copy].	stopConditions at: Space asciiValue + 1 put: #space.	wantsColumnBreaks == true ifTrue: [		stopConditions at: "TextComposer characterForColumnBreak asciiValue" 1 + 1 put: #columnBreak.	].! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:37'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:55'!space	"Record left x and character index of the space character just encounted. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	spaceX _ destX.	destX _ spaceX + spaceWidth.	spaceIndex _ lastIndex.	lineHeightAtSpace _ lineHeight.	baselineAtSpace _ baseline.	lastIndex _ lastIndex + 1.	spaceCount _ spaceCount + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:59'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!CompositionScanner methodsFor: 'accessing' stamp: 'ar 1/8/2000 14:35'!rightX	"Meaningful only when a line has just been composed -- refers to the 	line most recently composed. This is a subtrefuge to allow for easy 	resizing of a composition rectangle to the width of the maximum line. 	Useful only when there is only one line in the form or when each line 	is terminated by a carriage return. Handy for sizing menus and lists."	^spaceX! !!CompositionScanner methodsFor: 'intialize-release' stamp: 'ar 5/17/2000 19:14'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	self		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !ReadWriteStream subclass: #CompressedSourceStream	instanceVariableNames: 'segmentFile segmentSize nSegments segmentTable segmentIndex dirty endOfFile'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!CompressedSourceStream commentStamp: 'di 11/3/2003 17:58' prior: 0!I implement a file format that compresses segment by segment to allow incremental writing and browsing.  Note that the file can only be written at the end.Structure:segmentFile		The actual compressed file.segmentSize		This is the quantum of compression.  The virtual file is sliced up				into segments of this size.nSegments		The maximum number of segments to which this file can be grown.endOfFile		The user's endOfFile pointer.segmentTable	When a file is open, this table holds the physical file positions				of the compressed segments.segmentIndex	Index of the most recently accessed segment.Inherited from ReadWriteStream...collection		The segment buffer, uncompressedposition			This is the position *local* to the current segment bufferreadLimit		ReadLimit for the current bufferwriteLimit		WriteLimit for the current bufferGreat care must be exercised to distinguish between the position relative to the segment buffer and the full file position (and, or course, the segment file position ;-).The implementation defaults to a buffer size of 20k, and a max file size of 34MB (conveniently chosen to be greater than the current 33MB limit of source code pointers).  The format of the file is as follows:	segmentSize		4 bytes	nSegments		4 bytes	endOfFile		4 bytes	segmentTable	4 bytes * (nSegments+1)	beginning of first compressed segmentIt is possible to override the default allocation by sending the message #segmentSize:nSegments: immediately after opening a new file for writing, as follows:	bigFile _ (CompressedSourceStream on: (FileStream newFileNamed: 'biggy.stc'))			segmentSize: 50000 maxSize: 200000000The difference between segment table entries reveals the size of each compressed segment.  When a file is being written, it may lack the final segment, but any flush, position:, or close will force a dirty segment to be written.!!CompressedSourceStream methodsFor: 'open/close' stamp: 'di 11/1/2003 22:36'!binary	self error: 'Compressed source files are ascii to the user (though binary underneath)'! !!CompressedSourceStream methodsFor: 'open/close' stamp: 'di 11/1/2003 22:36'!close	self flush.	segmentFile close! !!CompressedSourceStream methodsFor: 'open/close' stamp: 'di 11/3/2003 17:54'!openOn: aFile	"Open the receiver."	segmentFile _ aFile.	segmentFile binary.	segmentFile size > 0	ifTrue:		[self readHeaderInfo.  "If file exists, then read the parameters"]	ifFalse:		[self segmentSize: 20000 maxSize: 34000000.  "Otherwise write default values"]! !!CompressedSourceStream methodsFor: 'open/close' stamp: 'di 11/3/2003 10:13'!openReadOnly	segmentFile openReadOnly! !!CompressedSourceStream methodsFor: 'open/close' stamp: 'di 11/5/2003 22:41'!readHeaderInfo	| valid a b |	segmentFile position: 0.	segmentSize _ segmentFile nextNumber: 4.	nSegments _ segmentFile nextNumber: 4.	endOfFile _ segmentFile nextNumber: 4.	segmentFile size < (nSegments+1 + 3 * 4) ifTrue: "Check for reasonable segment info"		[self error: 'This file is not in valid compressed source format'].	segmentTable _ (1 to: nSegments+1) collect: [:x | segmentFile nextNumber: 4].	segmentTable first ~= self firstSegmentLoc ifTrue:		[self error: 'This file is not in valid compressed source format'].	valid _ true.	1 to: nSegments do:  "Check that segment offsets are ascending"		[:i | a _ segmentTable at: i.  b _ segmentTable at: i+1.		(a = 0 and: [b ~= 0]) ifTrue: [valid _ false].		(a ~= 0 and: [b ~= 0]) ifTrue: [b <= a ifTrue: [valid _ false]]].	valid ifFalse:		[self error: 'This file is not in valid compressed source format'].	dirty _ false.	self position: 0.! !!CompressedSourceStream methodsFor: 'open/close' stamp: 'di 11/3/2003 10:09'!readOnlyCopy	^ self class on: segmentFile readOnlyCopy! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/3/2003 00:41'!atEnd	position >= readLimit ifFalse: [^ false].  "more in segment"	^ self position >= endOfFile  "more in file"! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/1/2003 22:48'!contentsOfEntireFile	| contents |	self position: 0.	contents _ self next: self size.	self close.	^ contents! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/1/2003 19:50'!flush	dirty ifTrue:		["Write buffer, compressed, to file, and also write the segment offset and eof"		self writeSegment].! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/20/2003 12:03'!next	<primitive: 65>	position >= readLimit		ifTrue: [^ (self next: 1) at: 1]		ifFalse: [^ collection at: (position _ position + 1)]! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/2/2003 11:45'!next: n	| str |	n <= (readLimit - position) ifTrue:		["All characters are available in buffer"		str _ collection copyFrom: position + 1 to: position + n.		position _ position + n.		^ str].	"Read limit could be segment boundary or real end of file"	(readLimit + self segmentOffset) = endOfFile ifTrue:		["Real end of file -- just return what's available"		^ self next: readLimit - position].	"Read rest of segment.  Then (after positioning) read what remains"	str _ self next: readLimit - position.	self position: self position.	^ str , (self next: n - str size)! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/2/2003 11:27'!nextPut: char	"Slow, but we don't often write, and then not a lot"	self nextPutAll: char asString.	^ char! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/2/2003 12:06'!nextPutAll: str	| n nInSeg |	n _ str size.	n <= (writeLimit - position) ifTrue:		["All characters fit in buffer"		collection replaceFrom: position + 1 to: position + n with: str.		dirty _ true.		position _ position + n.		readLimit _ readLimit max: position.		endOfFile _ endOfFile max: self position.		^ str].	"Write what fits in segment.  Then (after positioning) write what remains"	nInSeg _ writeLimit - position.	nInSeg = 0		ifTrue: [self position: self position.				self nextPutAll: str]		ifFalse: [self nextPutAll: (str first: nInSeg).				self position: self position.				self nextPutAll: (str allButFirst: nInSeg)]	! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/2/2003 09:27'!position	^ position + self segmentOffset! !!CompressedSourceStream methodsFor: 'access' stamp: 'di 11/1/2003 11:41'!size	^ endOfFile ifNil: [0]! !!CompressedSourceStream methodsFor: 'private' stamp: 'di 11/2/2003 09:35'!firstSegmentLoc	"First segment follows 3 header words and segment table"	^ (3 + nSegments+1) * 4! !!CompressedSourceStream methodsFor: 'private' stamp: 'di 11/2/2003 09:24'!segmentOffset	^ segmentIndex - 1 * segmentSize! !!CompressedSourceStream methodsFor: 'private' stamp: 'di 11/5/2003 22:41'!segmentSize: segSize maxSize: maxSize	"Note that this method can be called after the initial open, provided that no	writing has yet taken place.  This is how to override the default segmentation."	self size = 0 ifFalse: [self error: 'Cannot set parameters after the first write'].	segmentFile position: 0.	segmentFile nextNumber: 4 put: (segmentSize _ segSize).	segmentFile nextNumber: 4 put: (nSegments _ maxSize // segSize + 2).	segmentFile nextNumber: 4 put: (endOfFile _ 0).	segmentTable _ Array new: nSegments+1 withAll: 0.	segmentTable at: 1 put: self firstSegmentLoc.  "Loc of first segment, always."	segmentTable do: [:i | segmentFile nextNumber: 4 put: i].	segmentIndex _ 1.	collection _ String new: segmentSize.	writeLimit _ segmentSize.	readLimit _ 0.	position _ 0.	endOfFile _ 0.	self writeSegment.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompressedSourceStream class	instanceVariableNames: ''!!CompressedSourceStream class methodsFor: 'as yet unclassified' stamp: 'di 11/1/2003 22:58'!on: aFile	^ self basicNew openOn: aFile! !InstructionStream subclass: #ContextPart	instanceVariableNames: 'stackp'	classVariableNames: 'PrimitiveFailToken QuickStep'	poolDictionaries: ''	category: 'Kernel-Methods'!!ContextPart commentStamp: '<historical>' prior: 0!To the instruction parsing ability of InstructionStream I add the actual semantics for execution. The execution state is stored in the indexable fields of my subclasses. This includes temporary variables and a stack of values used in evaluating expressions. The actual semantics of execution can be found in my category "system simulation" and "instruction decode". These methods exactly parallel the operation of the Smalltalk machine itself.	The simulator is a group of my methods that do what the Smalltalk interpreter does: execute Smalltalk bytecodes. By adding code to the simulator, you may take statistics on the running of Smalltalk methods. For example,	Transcript show: (ContextPart runSimulated: [3 factorial]) printString.!!ContextPart methodsFor: 'accessing'!client	"Answer the client, that is, the object that sent the message that created this context."	^sender receiver! !!ContextPart methodsFor: 'accessing'!home	"Answer the context in which the receiver was defined."	self subclassResponsibility! !!ContextPart methodsFor: 'accessing'!method	"Answer the method of this context."	self subclassResponsibility! !!ContextPart methodsFor: 'accessing' stamp: 'ajh 2/9/2003 00:21'!methodNode	| selector methodClass |	selector _ self receiver class		selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^ self method methodNodeDecompileClass: methodClass selector: selector! !!ContextPart methodsFor: 'accessing' stamp: 'nk 2/20/2004 16:50'!methodNodeFormattedAndDecorated: decorate	"Answer a method node made from pretty-printed (and colorized, if decorate is true) source text."	| selector methodClass |	selector _ self receiver class		selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^ self method methodNodeFormattedDecompileClass: methodClass selector: selector decorate: decorate! !!ContextPart methodsFor: 'accessing'!receiver	"Answer the receiver of the message that created this context."	self subclassResponsibility! !!ContextPart methodsFor: 'accessing'!tempAt: index	"Answer the value of the temporary variable whose index is the 	argument, index."	self subclassResponsibility! !!ContextPart methodsFor: 'accessing'!tempAt: index put: value 	"Store the argument, value, as the temporary variable whose index is the 	argument, index."	self subclassResponsibility! !!ContextPart methodsFor: 'instruction decoding'!doDup	"Simulate the action of a 'duplicate top of stack' bytecode."	self push: self top! !!ContextPart methodsFor: 'instruction decoding'!doPop	"Simulate the action of a 'remove top of stack' bytecode."	self pop! !!ContextPart methodsFor: 'instruction decoding'!jump: distance 	"Simulate the action of a 'unconditional jump' bytecode whose offset is 	the argument, distance."	pc _ pc + distance! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 7/6/2003 20:38'!jump: distance if: condition 	"Simulate the action of a 'conditional jump' bytecode whose offset is the 	argument, distance, and whose condition is the argument, condition."	| bool |	bool _ self pop.	(bool == true or: [bool == false]) ifFalse: [		^self			send: #mustBeBooleanIn:			to: bool			with: {self}			super: false].	(bool eqv: condition) ifTrue: [self jump: distance]! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:35'!methodReturnConstant: value 	"Simulate the action of a 'return constant' bytecode whose value is the 	argument, value. This corresponds to a source expression like '^0'."	^ self return: value from: self home! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:34'!methodReturnReceiver	"Simulate the action of a 'return receiver' bytecode. This corresponds to 	the source expression '^self'."	^ self return: self receiver from: self home! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:34'!methodReturnTop	"Simulate the action of a 'return top of stack' bytecode. This corresponds 	to source expressions like '^something'."	^ self return: self pop from: self home! !!ContextPart methodsFor: 'instruction decoding'!popIntoLiteralVariable: value 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into a literal variable of my method."	value value: self pop! !!ContextPart methodsFor: 'instruction decoding'!popIntoReceiverVariable: offset 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into an instance variable of my receiver."	self receiver instVarAt: offset + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding'!popIntoTemporaryVariable: offset 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into one of my temporary variables."	self home at: offset + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding'!pushActiveContext	"Simulate the action of bytecode that pushes the the active context on the 	top of its own stack."	self push: self! !!ContextPart methodsFor: 'instruction decoding'!pushConstant: value 	"Simulate the action of bytecode that pushes the constant, value, on the 	top of the stack."	self push: value! !!ContextPart methodsFor: 'instruction decoding'!pushLiteralVariable: value 	"Simulate the action of bytecode that pushes the contents of the literal 	variable whose index is the argument, index, on the top of the stack."	self push: value value! !!ContextPart methodsFor: 'instruction decoding'!pushReceiver	"Simulate the action of bytecode that pushes the active context's receiver 	on the top of the stack."	self push: self receiver! !!ContextPart methodsFor: 'instruction decoding'!pushReceiverVariable: offset 	"Simulate the action of bytecode that pushes the contents of the receiver's 	instance variable whose index is the argument, index, on the top of the 	stack."	self push: (self receiver instVarAt: offset + 1)! !!ContextPart methodsFor: 'instruction decoding'!pushTemporaryVariable: offset 	"Simulate the action of bytecode that pushes the contents of the 	temporary variable whose index is the argument, index, on the top of 	the stack."	self push: (self home at: offset + 1)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 3/5/2004 03:44'!return: value from: aSender 	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"	| newTop ctxt |	aSender isDead ifTrue: [		^ self send: #cannotReturn: to: self with: {value} super: false].	newTop _ aSender sender.	ctxt _ self findNextUnwindContextUpTo: newTop.	ctxt ifNotNil: [		^ self send: #aboutToReturn:through: to: self with: {value. ctxt} super: false].	self releaseTo: newTop.	newTop ifNotNil: [newTop push: value].	^ newTop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'hmm 7/17/2001 20:52'!send: selector super: superFlag numArgs: numArgs	"Simulate the action of bytecodes that send a message with selector, 	selector. The argument, superFlag, tells whether the receiver of the 	message was specified with 'super' in the source method. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."	| receiver arguments answer |	arguments _ Array new: numArgs.	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].	receiver _ self pop.	selector == #doPrimitive:method:receiver:args:		ifTrue: [answer _ receiver 					doPrimitive: (arguments at: 1)					method: (arguments at: 2)					receiver: (arguments at: 3)					args: (arguments at: 4).				self push: answer.				^self].	QuickStep == self ifTrue: [		QuickStep _ nil.		^self quickSend: selector to: receiver with: arguments super: superFlag].	^self send: selector to: receiver with: arguments super: superFlag! !!ContextPart methodsFor: 'instruction decoding'!storeIntoLiteralVariable: value 	"Simulate the action of bytecode that stores the top of the stack into a 	literal variable of my method."	value value: self top! !!ContextPart methodsFor: 'instruction decoding'!storeIntoReceiverVariable: offset 	"Simulate the action of bytecode that stores the top of the stack into an 	instance variable of my receiver."	self receiver instVarAt: offset + 1 put: self top! !!ContextPart methodsFor: 'instruction decoding'!storeIntoTemporaryVariable: offset 	"Simulate the action of bytecode that stores the top of the stack into one 	of my temporary variables."	self home at: offset + 1 put: self top! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 9/25/2001 00:12'!contextStack 	"Answer an Array of the contexts on the receiver's sender chain."	^self stackOfSize: 100000! !!ContextPart methodsFor: 'debugger access' stamp: 'ls 12/5/1999 13:43'!mclass 	"Answer the class in which the receiver's method was found."	| mclass |	self receiver class selectorAtMethod: self method setClass: [:mc |mclass _ mc ].	^mclass! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 9/7/2002 21:15'!methodSelector	"Answer the selector of the method that created the receiver."	^self receiver class 		selectorAtMethod: self method 		setClass: [:ignored]! !!ContextPart methodsFor: 'debugger access'!pc	"Answer the index of the next bytecode to be executed."	^pc! !!ContextPart methodsFor: 'debugger access'!release	"Remove information from the receiver and all of the contexts on its 	sender chain in order to break circularities."	self releaseTo: nil! !!ContextPart methodsFor: 'debugger access'!releaseTo: caller 	"Remove information from the receiver and the contexts on its sender 	chain up to caller in order to break circularities."	| c s |	c _ self.	[c == nil or: [c == caller]]		whileFalse: 			[s _ c sender.			c singleRelease.			c _ s]! !!ContextPart methodsFor: 'debugger access'!selector	"Answer the selector of the method that created the receiver."	^self receiver class 		selectorAtMethod: self method 		setClass: [:ignored]! !!ContextPart methodsFor: 'debugger access'!sender	"Answer the context that sent the message that created the receiver."	^sender! !!ContextPart methodsFor: 'debugger access' stamp: 'di 8/31/1999 09:42'!shortStack	"Answer a String showing the top ten contexts on my sender chain."	^ String streamContents:		[:strm |		(self stackOfSize: 10)			do: [:item | strm print: item; cr]]! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 1/24/2003 00:03'!singleRelease	"Remove information from the receiver in order to break circularities."	stackp == nil ifFalse: [1 to: stackp do: [:i | self at: i put: nil]].	sender _ nil.	pc _ nil.! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 7/9/1999 19:01'!sourceCode	| selector methodClass |	selector _ self receiver class selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^self method getSourceFor: selector in: methodClass	"Note: The above is a bit safer than		^ methodClass sourceCodeAt: selector	which may fail if the receiver's method has been changed in	the debugger (e.g., the method is no longer in the methodDict	and thus the above selector is something like #Doit:with:with:with:)	but the source code is still available."! !!ContextPart methodsFor: 'debugger access' stamp: 'tfei 3/20/2000 00:51'!stackOfSize: limit 	"Answer an OrderedCollection of the top 'limit' contexts		on the receiver's sender chain."	| a stack cachedStackTop newLimit |	stack _ OrderedCollection new.	stack addLast: (a _ self).	[(a _ a sender) ~~ nil and: [stack size < limit]]		whileTrue:			[a hideFromDebugger ifFalse: [stack addLast: a].			a cachesStack ifTrue: [cachedStackTop := a cachedStackTop]].	^cachedStackTop == nil 		ifTrue: [stack]		ifFalse:			[newLimit := limit - stack size.			newLimit > 0				ifTrue: [stack addAllLast: (cachedStackTop stackOfSize: newLimit); yourself]				ifFalse: [stack]]! !!ContextPart methodsFor: 'debugger access'!swapSender: coroutine 	"Replace the receiver's sender with coroutine and answer the receiver's 	previous sender. For use in coroutining."	| oldSender |	oldSender _ sender.	sender _ coroutine.	^oldSender! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 2/9/2003 12:25'!tempNames	"Answer an OrderedCollection of the names of the receiver's temporary 	variables, which are strings."	^ self methodNode tempNames! !!ContextPart methodsFor: 'debugger access'!tempsAndValues	"Return a string of the temporary variabls and their current values"	| aStream |	aStream _ WriteStream on: (String new: 100).	self tempNames		doWithIndex: [:title :index |			aStream nextPutAll: title; nextPut: $:; space; tab.			(self tempAt: index) printOn: aStream.			aStream cr].	^aStream contents! !!ContextPart methodsFor: 'controlling'!activateMethod: newMethod withArgs: args receiver: rcvr class: class 	"Answer a ContextPart initialized with the arguments."	^MethodContext 		sender: self		receiver: rcvr		method: newMethod		arguments: args! !!ContextPart methodsFor: 'controlling' stamp: 'di 10/23/1999 17:03'!blockCopy: numArgs 	"Primitive. Distinguish a block of code from its enclosing method by 	creating a new BlockContext for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	blockCopy:. Do not use blockCopy: in code that you write!! Only the 	compiler can decide to send the message blockCopy:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 80>	^ (BlockContext newForMethod: self home method)		home: self home		startpc: pc + 2		nargs: numArgs! !!ContextPart methodsFor: 'controlling'!hasSender: context 	"Answer whether the receiver is strictly above context on the stack."	| s |	self == context ifTrue: [^false].	s _ sender.	[s == nil]		whileFalse: 			[s == context ifTrue: [^true].			s _ s sender].	^false! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 3/25/2004 00:07'!jump	"Abandon thisContext and resume self instead (using the same current process).  You may want to save thisContext's sender before calling this so you can jump back to it.	Self MUST BE a top context (ie. a suspended context or a abandoned context that was jumped out of).  A top context already has its return value on its stack (see Interpreter>>primitiveSuspend and other suspending primitives).	thisContext's sender is converted to a top context (by pushing a nil return value on its stack) so it can be jump back to."	| top |	"Make abandoned context a top context (has return value (nil)) so it can be jumped back to"	thisContext sender push: nil.	"Pop self return value then return it to self (since we jump to self by returning to it)"	stackp = 0 ifTrue: [self stepToSendOrReturn].	stackp = 0 ifTrue: [self push: nil].  "must be quick return self/constant"	top _ self pop.	thisContext privSender: self.	^ top! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:40'!pop	"Answer the top of the receiver's stack and remove the top of the stack."	| val |	val _ self at: stackp.	self stackp: stackp - 1.	^ val! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:39'!push: val 	"Push val on the receiver's stack."	self stackp: stackp + 1.	self at: stackp put: val! !!ContextPart methodsFor: 'controlling' stamp: 'hmm 7/17/2001 20:57'!quickSend: selector to: receiver with: arguments super: superFlag	"Send the given selector with arguments in an environment which closely resembles the non-simulating environment, with an interjected unwind-protected block to catch nonlocal returns.	Attention: don't get lost!!"	| oldSender contextToReturnTo result lookupClass |	contextToReturnTo _ self.	lookupClass _ superFlag					ifTrue: [(self method literalAt: self method numLiterals) value superclass]					ifFalse: [receiver class].	[oldSender _ thisContext sender swapSender: self.	result _ receiver perform: selector withArguments: arguments inSuperclass: lookupClass.	thisContext sender swapSender: oldSender] ifCurtailed: [		contextToReturnTo _ thisContext sender receiver.	"The block context returning nonlocally"		contextToReturnTo jump: -1.	"skip to front of return bytecode causing this unwind"		contextToReturnTo nextByte = 16r7C ifTrue: [			"If it was a returnTop, push the value to be returned.			Otherwise the value is implicit in the bytecode"			contextToReturnTo push: (thisContext sender tempAt: 1)].		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"		contextToReturnTo].	contextToReturnTo push: result.	^contextToReturnTo! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:32'!restart	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: nil to: self].	self privRefresh.	ctxt _ thisContext.	[	ctxt _ ctxt findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock _ ctxt tempAt: 1.		unwindBlock ifNotNil: [			ctxt tempAt: 1 put: nil.			thisContext terminateTo: ctxt.			unwindBlock value].	].	thisContext terminateTo: self.	self jump.! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 6/27/2003 22:17'!resume	"Roll back thisContext to self and resume.  Execute unwind blocks when rolling back.  ASSUMES self is a sender of thisContext"	self resume: nil! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:32'!resume: value	"Unwind thisContext to self and resume with value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: value to: self].	ctxt _ thisContext.	[	ctxt _ ctxt findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock _ ctxt tempAt: 1.		unwindBlock ifNotNil: [			ctxt tempAt: 1 put: nil.			thisContext terminateTo: ctxt.			unwindBlock value].	].	thisContext terminateTo: self.	^ value! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/21/2003 19:27'!return	"Unwind until my sender is on top"	self return: self receiver! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:27'!return: value	"Unwind thisContext to self and return value to self's sender.  Execute any unwind blocks while unwinding.  ASSUMES self is a sender of thisContext"	sender ifNil: [self cannotReturn: value to: sender].	sender resume: value! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:20'!runUntilErrorOrReturnFrom: aSender 	"ASSUMES aSender is a sender of self.  Execute self's stack until aSender returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSender returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSender that jumps back to thisContext when evaluated.  We also insert an exception handler under aSender that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."	| error ctxt here topContext |	here _ thisContext.	"Insert ensure and exception handler contexts under aSender"	error _ nil.	ctxt _ aSender insertSender: (ContextPart		contextOn: UnhandledError do: [:ex |			error ifNil: [				error _ ex exception.				topContext _ thisContext.				ex resumeUnchecked: here jump]			ifNotNil: [ex pass]		]).	ctxt _ ctxt insertSender: (ContextPart		contextEnsure: [error ifNil: [				topContext _ thisContext.				here jump]		]).	self jump.  "Control jumps to self"	"Control resumes here once above ensure block or exception handler is executed"	^ error ifNil: [		"No error was raised, remove ensure context by stepping until popped"		[ctxt isDead] whileFalse: [topContext _ topContext stepToCallee].		{topContext. nil}	] ifNotNil: [		"Error was raised, remove inserted above contexts then return signaler context"		aSender terminateTo: ctxt sender.  "remove above ensure and handler contexts"		{topContext. error}	].! !!ContextPart methodsFor: 'controlling' stamp: 'di 11/26/1999 19:34'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	| class meth val |	class _ superFlag			ifTrue: [(self method literalAt: self method numLiterals) value superclass]			ifFalse: [rcvr class].	meth _ class lookupSelector: selector.	meth == nil		ifTrue: [^ self send: #doesNotUnderstand:					to: rcvr					with: (Array with: (Message selector: selector arguments: args))					super: superFlag]		ifFalse: [val _ self tryPrimitiveFor: meth						receiver: rcvr						args: args.				val == PrimitiveFailToken ifFalse: [^ val].				(selector == #doesNotUnderstand: and: [class == ProtoObject]) ifTrue:					[^ self error: 'Simulated message ' , (args at: 1) selector									, ' not understood'].				^ self activateMethod: meth					withArgs: args					receiver: rcvr					class: class]! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 00:56'!terminate	"Make myself unresumable."	sender _ nil.	pc _ nil.! !!ContextPart methodsFor: 'controlling' stamp: 'ar 3/6/2001 14:26'!terminateTo: previousContext	"Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender."	| currentContext sendingContext |	<primitive: 196>	(self hasSender: previousContext) ifTrue: [		currentContext _ sender.		[currentContext == previousContext] whileFalse: [			sendingContext _ currentContext sender.			currentContext terminate.			currentContext _ sendingContext]].	sender _ previousContext! !!ContextPart methodsFor: 'controlling'!top	"Answer the top of the receiver's stack."	^self at: stackp! !!ContextPart methodsFor: 'printing' stamp: 'ajh 3/17/2003 09:25'!printOn: aStream 	| selector class mclass |	self method == nil ifTrue: [^ super printOn: aStream].	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:c | mclass _ c].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector.	selector = #doesNotUnderstand: ifTrue: [		aStream space.		(self tempAt: 1) selector printOn: aStream.	].! !!ContextPart methodsFor: 'system simulation'!step	"Simulate the execution of the receiver's next bytecode. Answer the 	context that would be the active context after this bytecode."	^self interpretNextInstructionFor: self! !!ContextPart methodsFor: 'system simulation' stamp: 'ajh 1/24/2003 22:54'!stepToCallee	"Step to callee or sender"	| ctxt |	ctxt _ self.	[(ctxt _ ctxt step) == self] whileTrue.	^ ctxt! !!ContextPart methodsFor: 'system simulation' stamp: 'hmm 7/30/2001 20:48'!stepToSendOrReturn	"Simulate the execution of bytecodes until either sending a message or 	returning a value to the receiver (that is, until switching contexts)."	| ctxt |	[self willReallySend | self willReturn | self willStore]		whileFalse: [			ctxt _ self step.			ctxt == self ifFalse: [self halt. 				"Caused by mustBeBoolean handling"				^ctxt]]! !!ContextPart methodsFor: 'private' stamp: 'ajh 5/20/2004 16:27'!activateReturn: aContext value: value	"Activate 'aContext return: value' in place of self, so execution will return to aContext's sender"	^ self		activateMethod: ContextPart theReturnMethod		withArgs: {value}		receiver: aContext		class: aContext class! !!ContextPart methodsFor: 'private' stamp: 'ajh 6/29/2003 15:32'!cannotReturn: result to: homeContext	"The receiver tried to return result to homeContext that no longer exists."	^ BlockCannotReturn new		result: result;		deadHome: homeContext;		signal! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/24/2003 00:50'!cut: aContext	"Cut aContext and its senders from my sender chain"	| ctxt callee |	ctxt _ self.	[ctxt == aContext] whileFalse: [		callee _ ctxt.		ctxt _ ctxt sender.		ctxt ifNil: [aContext ifNotNil: [self error: 'aContext not a sender']].	].	callee privSender: nil.! !!ContextPart methodsFor: 'private' stamp: 'hg 10/2/2001 20:44'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: nil].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	primitiveIndex = 117 		ifTrue:[value _ self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]		ifFalse:[value _ receiver tryPrimitive: primitiveIndex withArgs: arguments].	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!ContextPart methodsFor: 'private' stamp: 'ajh 7/21/2003 09:59'!insertSender: aContext	"Insert aContext and its sender chain between me and my sender.  Return new callee of my original sender."	| ctxt |	ctxt _ aContext bottomContext.	ctxt privSender: self sender.	self privSender: aContext.	^ ctxt! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/23/2003 22:35'!privSender: aContext 	sender _ aContext! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 10:12'!push: numObjects fromIndexable: anIndexableCollection	"Push the elements of anIndexableCollection onto the receiver's stack.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	1 to: numObjects do:		[:i | self push: (anIndexableCollection at: i)]! !!ContextPart methodsFor: 'private' stamp: 'di 10/23/1999 17:31'!stackp: newStackp	"Storing into the stack pointer is a potentially dangerous thing.	This primitive stores nil into any cells that become accessible as a result,	and it performs the entire operation atomically."	"Once this primitive is implemented, failure code should cause an error"	<primitive: 76>	self error: 'stackp store failure'."	stackp == nil ifTrue: [stackp _ 0].	newStackp > stackp  'effectively checks that it is a number'		ifTrue: [oldStackp _ stackp.				stackp _ newStackp.				'Nil any newly accessible cells'				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp _ newStackp]"! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:41'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector _ #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod _ aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec _ theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	^aReceiver perform: selector withArguments: arguments! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:45'!tryPrimitiveFor: method receiver: receiver args: arguments 	"If this method has a primitive index, then run the primitive and return its result.	Otherwise (and also if the primitive fails) return PrimitiveFailToken,	as an indication that the method should be activated and run as bytecodes."	| primIndex |	(primIndex _ method primitive) = 0 ifTrue: [^ PrimitiveFailToken].	^ self doPrimitive: primIndex method: method receiver: receiver args: arguments! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/28/2000 19:27'!findNextHandlerContextStarting	"Return the next handler marked context, returning nil if there is none.  Search starts with self and proceeds up to nil."	| ctx |	<primitive: 197>	ctx _ self.		[ctx isHandlerContext ifTrue:[^ctx].		(ctx _ ctx sender) == nil ] whileFalse.	^nil! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/23/2000 16:37'!findNextUnwindContextUpTo: aContext	"Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext."	| ctx |	<primitive: 195>	ctx _ self.		[(ctx _ ctx sender) == nil or: [ctx == aContext]] whileFalse:		[ ctx isUnwindContext ifTrue: [^ctx]].	^nil! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 6/27/2003 20:47'!handleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."	| val |	(((self tempAt: 1) handles: exception) and: [self tempAt: 3]) ifFalse: [		^ self nextHandlerContext handleSignal: exception].	exception privHandlerContext: self contextTag.	self tempAt: 3 put: false.  "disable self while executing handle block"	val _ [(self tempAt: 2) valueWithPossibleArgs: {exception}]		ensure: [self tempAt: 3 put: true].	self return: val.  "return from self if not otherwise directed in handle block"! !!ContextPart methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 21:29'!isHandlerContext	^false! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/28/2000 15:45'!isUnwindContext	^false! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 2/1/2003 00:20'!nextHandlerContext	^ self sender findNextHandlerContextStarting! !!ContextPart methodsFor: 'private-debugger' stamp: 'tfei 3/19/2000 23:24'!cachesStack	^false! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 12:35'!blockHome	^ self! !!ContextPart methodsFor: 'query' stamp: 'ajh 7/21/2003 09:59'!bottomContext	"Return the last context (the first context invoked) in my sender chain"	^ self findContextSuchThat: [:c | c sender isNil]! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 00:12'!findContextSuchThat: testBlock	"Search self and my sender chain for first one that satisfies testBlock.  Return nil if none satisfy"	| ctxt |	ctxt _ self.	[ctxt isNil] whileFalse: [		(testBlock value: ctxt) ifTrue: [^ ctxt].		ctxt _ ctxt sender.	].	^ nil! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 19:42'!hasContext: aContext 	"Answer whether aContext is me or one of my senders"	^ (self findContextSuchThat: [:c | c == aContext]) notNil! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 00:04'!isDead	"Has self finished"	^ pc isNil! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:42'!errorReportOn: foo! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ContextPart class	instanceVariableNames: ''!!ContextPart class methodsFor: 'simulation' stamp: 'di 2/10/1999 22:15'!initialize	"A unique object to be returned when a primitive fails during simulation"	PrimitiveFailToken _ Object new  ! !!ContextPart class methodsFor: 'simulation' stamp: 'di 2/10/1999 22:15'!primitiveFailToken	^ PrimitiveFailToken! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!basicNew: size	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 00:30'!initializedInstance	^ nil! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!new	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!new: size	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:55'!newForMethod: aMethod	"This is the only method for creating new contexts, other than primitive cloning.	Any other attempts, such as inherited methods like shallowCopy, should be	avoided or must at least be rewritten to determine the proper size from the	method being activated.  This is because asking a context its size (even basicSize!!)	will not return the real object size but only the number of fields currently	accessible, as determined by stackp."	^ super basicNew: aMethod frameSize! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 1/24/2003 14:31'!contextEnsure: block	"Create an #ensure: context that is ready to return from executing its receiver"	| ctxt chain |	ctxt _ thisContext.	[chain _ thisContext sender cut: ctxt. ctxt jump] ensure: block.	"jump above will resume here without unwinding chain"	^ chain! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 1/24/2003 14:31'!contextOn: exceptionClass do: block	"Create an #on:do: context that is ready to return from executing its receiver"	| ctxt chain |	ctxt _ thisContext.	[chain _ thisContext sender cut: ctxt. ctxt jump] on: exceptionClass do: block.	"jump above will resume here without unwinding chain"	^ chain! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 5/20/2004 16:25'!theReturnMethod	| meth |	meth _ self lookupSelector: #return:.	meth primitive = 0 ifFalse: [^ self error: 'expected #return: to not be a primitive'].	^ meth! !Inspector subclass: #ContextVariablesInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!ContextVariablesInspector commentStamp: '<historical>' prior: 0!I represent a query path into the internal representation of a ContextPart. Typically this is a context at a point in the query path of a Debugger. As a StringHolder, the string I represent is the value of the currently selected variable of the observed temporary variable of the context.!!ContextVariablesInspector methodsFor: 'accessing'!fieldList 	"Refer to the comment in Inspector|fieldList."	object == nil ifTrue: [^Array with: 'thisContext'].	^(Array with: 'thisContext' with: 'all temp vars') , object tempNames! !!ContextVariablesInspector methodsFor: 'accessing' stamp: 'ajh 1/31/2003 15:45'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection."	self initialize.	object _ anObject.	selectionIndex _ 0.	contents _ ''! !!ContextVariablesInspector methodsFor: 'selecting'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	selectionIndex = 1		ifTrue: [^object]		ifFalse: [^object tempAt: selectionIndex - 2 put: anObject]! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'ar 5/29/1998 18:32'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: selectionIndex - 2]! !!ContextVariablesInspector methodsFor: 'code'!doItContext	^object! !!ContextVariablesInspector methodsFor: 'code'!doItReceiver	^object receiver! !Object subclass: #ControlManager	instanceVariableNames: 'scheduledControllers activeController activeControllerProcess screenController newTopClicked'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!ControlManager commentStamp: '<historical>' prior: 0!I represent the top level control over scheduling which controller of a view on the screen the user is actively using. ScheduledControllers is the global reference to an instance of me, the one attached to the Project currently being used.!!ControlManager methodsFor: 'initialize-release'!initialize	"Initialize the receiver to refer to only the background controller."	| screenView |	screenController _ ScreenController new.	screenView _ FormView new.	screenView model: (InfiniteForm with: Color gray) controller: screenController.	screenView window: Display boundingBox.	scheduledControllers _ OrderedCollection with: screenController! !!ControlManager methodsFor: 'initialize-release'!release 	"Refer to the comment in Object|release."	scheduledControllers == nil		ifFalse: 			[scheduledControllers 				do: [:controller | (controller isKindOf: Controller)								ifTrue: [controller view release]								ifFalse: [controller release]].			scheduledControllers _ nil]! !!ControlManager methodsFor: 'accessing'!activeController	"Answer the currently active controller."	^activeController! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController _ aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess _ 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'accessing'!activeControllerNoTerminate: aController andProcess: aProcess	"Set aController to be the currently active controller and aProcess to be 	the the process that handles controller scheduling activities in the 	system. This message differs from activeController:andProcess: in that it 	does not send controlTerminate to the currently active controller."	self inActiveControllerProcess		ifTrue: 			[aController~~nil				ifTrue: [(scheduledControllers includes: aController)							ifTrue: [self promote: aController]							ifFalse: [self error: 'Old controller not scheduled']].			activeController _ aController.			activeController == nil				ifFalse: [activeController controlInitialize].			activeControllerProcess _ aProcess.			activeControllerProcess resume]		ifFalse: 			[self error: 'New active controller process must be set from old one'] ! !!ControlManager methodsFor: 'accessing'!activeControllerProcess	"Answer the process that is currently handling controller scheduling 	activities in the system."	^activeControllerProcess! !!ControlManager methodsFor: 'accessing'!controllerSatisfying: aBlock	"Return the first scheduled controller which satisfies the 1-argument boolean-valued block, or nil if none.  7/25/96 sw"	scheduledControllers do:		[:aController | (aBlock value: aController) == true ifTrue: [^ aController]].	^ nil! !!ControlManager methodsFor: 'accessing'!controllerWhoseModelSatisfies: aBlock	"Return the first scheduled controller whose model satisfies the 1-argument boolean-valued block, or nil if none.  5/6/96 sw"	scheduledControllers do:		[:aController | (aBlock value: aController model) == true ifTrue: [^ aController]].	^ nil! !!ControlManager methodsFor: 'accessing' stamp: 'sw 5/4/2001 23:20'!controllersSatisfying: aBlock	"Return a list of scheduled controllers satisfying aBlock"	^ (scheduledControllers ifNil: [^ #()]) select:		[:aController | (aBlock value: aController) == true]! !!ControlManager methodsFor: 'accessing'!includes: aController	^ scheduledControllers includes: aController! !!ControlManager methodsFor: 'accessing'!noteNewTop	newTopClicked _ true! !!ControlManager methodsFor: 'accessing'!scheduledControllers	"Answer a copy of the ordered collection of scheduled controllers."	^scheduledControllers copy! !!ControlManager methodsFor: 'accessing' stamp: 'di 10/4/97 09:05'!scheduledWindowControllers	"Same as scheduled controllers, but without ScreenController.	Avoids null views just after closing, eg, a debugger."	^ scheduledControllers select:		[:c | c ~~ screenController and: [c view ~~ nil]]! !!ControlManager methodsFor: 'accessing'!screenController	^ screenController! !!ControlManager methodsFor: 'accessing'!windowOriginsInUse	"Answer a collection of the origins of windows currently on the screen in the current project.  5/21/96 sw"	^ self scheduledWindowControllers collect: [:aController | aController view displayBox origin].! !!ControlManager methodsFor: 'scheduling'!activateController: aController	"Make aController, which must already be a scheduled controller, the active window.  5/8/96 sw"	self activeController: aController.	(activeController view labelDisplayBox		intersect: Display boundingBox) area < 200			ifTrue: [activeController move].	Processor terminateActive! !!ControlManager methodsFor: 'scheduling'!activateTranscript	"There is known to be a Transcript open in the current project; activate it.  2/5/96 sw"	| itsController |	itsController _ scheduledControllers detect:			[:controller | controller model == Transcript]		ifNone:			[^ self].	self activeController: itsController.	(activeController view labelDisplayBox			intersect: Display boundingBox) area < 200				ifTrue: [activeController move].	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'di 5/19/1998 09:03'!findWindow	"Present a menu of window titles, and activate the one that gets chosen."	^ self findWindowSatisfying: [:c | true]! !!ControlManager methodsFor: 'scheduling' stamp: 'wod 6/17/1998 15:46'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically _ Sensor shiftPressed.	controllers _ OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling'!inActiveControllerProcess	"Answer whether the active scheduling process is the actual active 	process in the system."	^activeControllerProcess == Processor activeProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 11/19/1998 18:31'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling'!promote: aController	"Make aController be the first scheduled controller in the ordered 	collection."		scheduledControllers remove: aController.	scheduledControllers addFirst: aController! !!ControlManager methodsFor: 'scheduling' stamp: 'RAA 7/7/2000 09:22'!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController _ nil.	activeControllerProcess _ Processor activeProcess.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling'!scheduleActiveNoTerminate: aController 	"Make aController be the active controller. Presumably the process that 	requested the new active controller wants to keep control to do more 	activites before the new controller can take control. Therefore, do not 	terminate the currently active process."	self schedulePassive: aController.	self scheduled: aController		from: Processor activeProcess! !!ControlManager methodsFor: 'scheduling'!scheduleOnBottom: aController 	"Make aController be scheduled as a scheduled controller, but not the 	active one. Put it at the end of the ordered collection of controllers."	scheduledControllers addLast: aController! !!ControlManager methodsFor: 'scheduling'!schedulePassive: aController 	"Make aController be scheduled as a scheduled controller, but not the 	active one. Put it at the beginning of the ordered collection of 	controllers."	scheduledControllers addFirst: aController! !!ControlManager methodsFor: 'scheduling'!searchForActiveController	"Find a scheduled controller that wants control and give control to it. If 	none wants control, then see if the System Menu has been requested."	| aController |	activeController _ nil.	activeControllerProcess _ Processor activeProcess.	self activeController: self nextActiveController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'ajh 12/31/2001 15:15'!spawnNewProcess	self activeController: self screenController! !!ControlManager methodsFor: 'scheduling'!unschedule: aController	"Remove the view, aController, from the collection of scheduled 	controllers."	scheduledControllers remove: aController ifAbsent: []! !!ControlManager methodsFor: 'scheduling'!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers _ OrderedCollection new.	labels _ String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !!ControlManager methodsFor: 'displaying'!backgroundForm: aForm	screenController view model: aForm.	ScheduledControllers restore"	QDPen new mandala: 30 diameter: 640.	ScheduledControllers backgroundForm:		(Form fromDisplay: Display boundingBox).	ScheduledControllers backgroundForm:		(InfiniteForm with: Form gray)."! !!ControlManager methodsFor: 'displaying' stamp: 'di 2/26/98 08:58'!restore 	"Clear the screen to gray and then redisplay all the scheduled views.  Try to be a bit intelligent about the view that wants control and not display it twice if possible."	scheduledControllers first view uncacheBits.  "assure refresh"	self unschedule: screenController; scheduleOnBottom: screenController.	screenController view window: Display boundingBox; displayDeEmphasized.	self scheduledWindowControllers reverseDo:		[:aController | aController view displayDeEmphasized].! !!ControlManager methodsFor: 'displaying' stamp: 'hmm 1/5/2000 07:00'!restore: aRectangle	"Restore all windows visible in aRectangle"	^ self restore: aRectangle without: nil! !!ControlManager methodsFor: 'displaying' stamp: 'ssa 8/26/2008 08:55'!restore: aRectangle below: index without: aView	"Restore all windows visible in aRectangle, but without aView"	| view | 	view := (scheduledControllers at: index) view.	view == aView ifTrue: 		[index >= scheduledControllers size ifTrue: [^ self].		^ self restore: aRectangle below: index+1 without: aView].	view isNil ifTrue:[^self].	view displayOn: ((BitBlt current toForm: Display) clipRect: aRectangle).	index >= scheduledControllers size ifTrue: [^ self].	(aRectangle areasOutside: view windowBox) do:		[:rect | self restore: rect below: index + 1 without: aView]! !!ControlManager methodsFor: 'displaying' stamp: 'hmm 12/30/1999 19:35'!restore: aRectangle without: aView	"Restore all windows visible in aRectangle"	Display deferUpdates: true.	self restore: aRectangle below: 1 without: aView.	Display deferUpdates: false; forceToScreen: aRectangle! !!ControlManager methodsFor: 'displaying'!updateGray	"From Georg Gollmann - 11/96.  tell the Screen Controller's model to use the currently-preferred desktop color."	"ScheduledControllers updateGray"	(screenController view model isMemberOf: InfiniteForm)		ifTrue: [screenController view model: (InfiniteForm with:Preferences desktopColor)]! !!ControlManager methodsFor: 'private'!nextActiveController	"Answer the controller that would like control.  	If there was a click outside the active window, it's the top window	that now has the mouse, otherwise it's just the top window."	(newTopClicked notNil and: [newTopClicked])		ifTrue: [newTopClicked _ false.				^ scheduledControllers 					detect: [:aController | aController isControlWanted]					ifNone: [scheduledControllers first]]		ifFalse: [^ scheduledControllers first]! !!ControlManager methodsFor: 'private'!scheduled: aController from: aProcess	activeControllerProcess==aProcess		ifTrue: 			[activeController ~~ nil					ifTrue: [activeController controlTerminate].			aController centerCursorInView.			self activeController: aController]! !!ControlManager methodsFor: 'private' stamp: 'sw 12/6/1999 23:40'!unCacheWindows	scheduledControllers ifNotNil: [scheduledControllers do:		[:aController | aController view uncacheBits]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ControlManager class	instanceVariableNames: ''!!ControlManager class methodsFor: 'exchange'!newScheduler: controlManager	"When switching projects, the control scheduler has to be exchanged. The 	active one is the one associated with the current project."	Smalltalk at: #ScheduledControllers put: controlManager.	ScheduledControllers restore.	controlManager searchForActiveController! !!ControlManager class methodsFor: 'snapshots' stamp: 'di 2/4/1999 15:16'!shutDown  "Saves space in snapshots"	Smalltalk isMorphic ifFalse: [ScheduledControllers unCacheWindows]! !!ControlManager class methodsFor: 'snapshots' stamp: 'di 2/4/1999 09:00'!startUp	Smalltalk isMorphic ifFalse: [ScheduledControllers restore]! !Object subclass: #Controller	instanceVariableNames: 'model view sensor lastActivityTime'	classVariableNames: 'MinActivityLapse'	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!Controller commentStamp: '<historical>' prior: 0!A Controller coordinates a View, its model, and user actions. It provides scheduling (control) behavior to determine when the user wants to communicate with the model or view.!!Controller methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	sensor _ InputSensor default! !!Controller methodsFor: 'initialize-release'!release	"Breaks the cycle between the receiver and its view. It is usually not 	necessary to send release provided the receiver's view has been properly 	released independently."	model _ nil.	view ~~ nil		ifTrue: 			[view controller: nil.			view _ nil]! !!Controller methodsFor: 'model access'!model	"Answer the receiver's model which is the same as the model of the 	receiver's view."	^model! !!Controller methodsFor: 'model access'!model: aModel 	"Controller|model: and Controller|view: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: so that the receiver's model and view links can be set 	up by the view."	model _ aModel! !!Controller methodsFor: 'view access'!inspectView	view notNil ifTrue: [^ view inspect]! !!Controller methodsFor: 'view access'!view	"Answer the receiver's view."	^view! !!Controller methodsFor: 'view access'!view: aView 	"Controller|view: and Controller|model: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: and the receiver's model and view links are set up 	automatically by the view."	view _ aView! !!Controller methodsFor: 'sensor access'!sensor	"Answer the receiver's sensor. Subclasses may use other objects that are 	not instances of Sensor or its subclasses if more general kinds of 	input/output functions are required."	^sensor! !!Controller methodsFor: 'sensor access'!sensor: aSensor	"Set the receiver's sensor to aSensor."	sensor _ aSensor! !!Controller methodsFor: 'basic control sequence'!controlInitialize	"Sent by Controller|startUp as part of the standard control sequence, it 	provides a place in the standard control sequence for initializing the 	receiver (taking into account the current state of its model and view). It 	should be redefined in subclasses to perform some specific action."	^self! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence'!controlTerminate	"Provide a place in the standard control sequence for terminating the 	receiver (taking into account the current state of its model and view). It 	should be redefined in subclasses to perform some specific action."	^self! !!Controller methodsFor: 'basic control sequence' stamp: 'RAA 1/30/2001 19:06'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait <= MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							(Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!Controller methodsFor: 'basic control sequence'!startUp	"Give control to the receiver. The default control sequence is to initialize 	(see Controller|controlInitialize), to loop (see Controller|controlLoop), and 	then to terminate (see Controller|controlTerminate). After this sequence, 	control is returned to the sender of Control|startUp. The receiver's control 	sequence is used to coordinate the interaction of its view and model. In 	general, this consists of polling the sensor for user input, testing the 	input with respect to the current display of the view, and updating the 	model to reflect intended changes."	self controlInitialize.	self controlLoop.	self controlTerminate! !!Controller methodsFor: 'basic control sequence'!terminateAndInitializeAround: aBlock	"1/12/96 sw"	self controlTerminate.	aBlock value.	self controlInitialize! !!Controller methodsFor: 'control defaults'!controlActivity	"Pass control to the next control level (that is, to the Controller of a 	subView of the receiver's view) if possible. It is sent by 	Controller|controlLoop each time through the main control loop. It should 	be redefined in a subclass if some other action is needed."	self controlToNextLevel! !!Controller methodsFor: 'control defaults'!controlToNextLevel	"Pass control to the next control level (that is, to the Controller of a 	subView of the receiver's view) if possible. The receiver finds the 	subView (if any) of its view whose inset display box (see 	View|insetDisplayBox) contains the sensor's cursor point. The Controller 	of this subView is then given control if it answers true in response to 	the message Controller|isControlWanted."	| aView |	aView _ view subViewWantingControl.	aView ~~ nil ifTrue: [aView controller startUp]! !!Controller methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:23'!isControlActive	"Answer whether receiver wishes to continue evaluating its controlLoop 	method. It is sent by Controller|controlLoop in order to determine when 	the receiver's control loop should terminate, and should be redefined in 	a subclass if some special condition for terminating the main control loop 	is needed."	^ self viewHasCursor		and: [sensor blueButtonPressed not		and: [sensor yellowButtonPressed not]]! !!Controller methodsFor: 'control defaults'!isControlWanted	"Answer whether the cursor is inside the inset display box (see 	View|insetDisplayBox) of the receiver's view. It is sent by 	Controller|controlNextLevel in order to determine whether or not control 	should be passed to this receiver from the Controller of the superView of 	this receiver's view."	^self viewHasCursor! !!Controller methodsFor: 'cursor'!centerCursorInView	"Position sensor's mousePoint (which is assumed to be connected to the 	cursor) to the center of its view's inset display box (see 	Sensor|mousePoint: and View|insetDisplayBox)."	^sensor cursorPoint: view insetDisplayBox center! !!Controller methodsFor: 'cursor' stamp: 'sw 7/13/1999 18:42'!viewHasCursor	"Answer whether the cursor point of the receiver's sensor lies within the 	inset display box of the receiver's view (see View|insetDisplayBox). 	Controller|viewHasCursor is normally used in internal methods."	^ view ifNotNil: [view containsPoint: sensor cursorPoint] ifNil: [false]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Controller class	instanceVariableNames: ''!!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!Controller class methodsFor: 'initialization' stamp: 'ssa 8/15/2008 09:40'!initialize	"Controller initialize"	self MinActivityLapse: 50.! !StandardFileStream subclass: #CrLfFileStream	instanceVariableNames: 'lineEndConvention'	classVariableNames: 'Cr CrLf Lf LineEndDefault LineEndStrings LookAheadCount'	poolDictionaries: ''	category: 'System-Files'!!CrLfFileStream commentStamp: 'ls 11/10/2002 13:32' prior: 0!I am the same as a regular file stream, except that when I am in text mode, I will automatically convert line endings between the underlying platform's convention, and Squeak's convention of carriage-return only.  The goal is that Squeak text files can be treated as OS text files, and vice versa.In binary mode, I behave identically to a StandardFileStream.To enable CrLfFileStream as the default file stream class for an entire image, modify FileStream class concreteStream .There are two caveats on programming with CrLfFileStream.First, the choice of text mode versus binary mode affects which characters are visible in Squeak, and no longer just affects whether those characters are returned as Character's or as Integer's.  Thus the choice of mode needs to be made very carefully, and must be based on intent instead of convenience of representation.  The methods asString, asByteArray, asCharacter, and asInteger can be used to convert between character and integer representations.  (Arguably, file streams should accept either strings or characters in nextPut: and nextPutAll:, but that is not the case right now.)Second, arithmetic on positions no longer works, because one character that Squeak sees (carriage return) could map to two characters in the underlying file (carriage return plus line feed, on MS Windows and MS DOS).  Comparison between positions still works.  (This caveat could perhaps be fixed by maintaining a map between Squeak positions and positions in the underlying file, but it is complicated.  Consider, for example, updates to the middle of the file.  Also, consider that text files are rarely updated in the middle of the file, and that general random access to a text file is rarely very useful.  If general random access with specific file counts is desired, then the file is starting to sound like a binary file instead of a text file.)!]style[(448 31 1371 6 32)f1,f1LFileStream class concreteStream;,f1,f1i,f1!!CrLfFileStream methodsFor: 'open/close' stamp: 'ar 1/20/98 16:15'!open: aFileName forWrite: writeMode 	"Open the receiver.  If writeMode is true, allow write, else access will be 	read-only. "	| result |	result _ super open: aFileName forWrite: writeMode.	result ifNotNil: [self detectLineEndConvention].	^ result! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!ascii	super ascii.	self detectLineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!binary	super binary.	lineEndConvention _ nil! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 7/10/1998 23:35'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead pos |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	lineEndConvention _ LineEndDefault.	"Default if nothing else found"	numRead _ 0.	pos _ super position.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char _ super next.			char = Lf				ifTrue: 					[super position: pos.					^ lineEndConvention _ #lf].			char = Cr				ifTrue: 					[super peek = Lf						ifTrue: [lineEndConvention _ #crlf]						ifFalse: [lineEndConvention _ #cr].					super position: pos.					^ lineEndConvention].			numRead _ numRead + 1].	super position: pos.	^ lineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 11/5/1998 23:37'!next    | char secondChar |    char _ super next.    self isBinary ifTrue: [^char].    char == Cr ifTrue:        [secondChar _ super next.        secondChar ifNotNil: [secondChar == Lf ifFalse: [self skip: -1]].        ^Cr].    char == Lf ifTrue: [^Cr].    ^char! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 12/29/1998 17:15'!next: n		| string peekChar |		string _ super next: n.		string size = 0 ifTrue: [ ^string ].		self isBinary ifTrue: [ ^string ].		"if we just read a CR, and the next character is an LF, then skip the LF"		( string last = Character cr ) ifTrue: [			peekChar _ super next.		"super peek doesn't work because it relies on #next"			peekChar ~= Character lf ifTrue: [				super position: (super position - 1) ]. ]. 		string _ string withSqueakLineEndings.		string size = n ifTrue: [ ^string ].		"string shrunk due to embedded crlfs; make up the difference"		^string, (self next: n - string size)! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPut: char 	(lineEndConvention notNil and: [char = Cr])		ifTrue: [super nextPutAll: (LineEndStrings at: lineEndConvention)]		ifFalse: [super nextPut: char].	^ char! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPutAll: aString 	super nextPutAll: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'access' stamp: 'wod 6/18/1998 13:52'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos _ self position.	next _ self next.	self position: pos.	^ next! !!CrLfFileStream methodsFor: 'access' stamp: 'wod 11/5/1998 14:15'!upTo: aCharacter	| newStream char |	newStream _ WriteStream on: (String new: 100).	[(char _ self next) isNil or: [char == aCharacter]]		whileFalse: [newStream nextPut: char].	^ newStream contents! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CrLfFileStream class	instanceVariableNames: ''!!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCR	"CrLfFileStream defaultToCR"	LineEndDefault := #cr.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCRLF	"CrLfFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToLF	"CrLfFileStream defaultToLF"	LineEndDefault := #lf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:13'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $: ifTrue:[^self defaultToCR].	FileDirectory pathNameDelimiter = $/ ifTrue:[^self defaultToLF].	FileDirectory pathNameDelimiter = $\ ifTrue:[^self defaultToCRLF].	"in case we don't know"	^self defaultToCR! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'di 2/4/1999 09:16'!initialize	"CrLfFileStream initialize"	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.	Smalltalk addToStartUpList: self.	self startUp.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'djp 1/28/1999 22:08'!startUp	self guessDefaultLineEndConvention! !Form subclass: #Cursor	instanceVariableNames: ''	classVariableNames: 'BlankCursor BottomLeftCursor BottomRightCursor CornerCursor CrossHairCursor CurrentCursor DownCursor MarkerCursor MenuCursor MoveCursor NormalCursor OriginCursor ReadCursor ResizeLeftCursor ResizeTopCursor ResizeTopLeftCursor ResizeTopRightCursor RightArrowCursor SquareCursor TopLeftCursor TopRightCursor UpCursor WaitCursor WebLinkCursor WriteCursor XeqCursor'	poolDictionaries: ''	category: 'Graphics-Display Objects'!!Cursor commentStamp: '<historical>' prior: 0!I am a Form that is a possible appearance for a mouse cursor.  My size is always 16x16, ever since the original implementation on the Alto.There are many examples available in the "current cursor" category of class methods.  For example, "Cursor normal" and "Cursor wait".  For example:	Cursor wait show!!Cursor methodsFor: 'updating' stamp: 'ls 6/17/2002 12:00'!changed: aParameter	"overriden to reinstall the cursor if it is the active cursor, in case the appearance has changed.  (Is this used anywhere?  Do cursors really change in place these days?)"	self == CurrentCursor ifTrue: [self beCursor].	super changed: aParameter! !!Cursor methodsFor: 'displaying' stamp: 'ls 6/17/2002 11:56'!show	"Make the hardware's mouse cursor look like the receiver"	Sensor currentCursor: self! !!Cursor methodsFor: 'displaying' stamp: 'bf 10/13/1999 13:05'!showWhile: aBlock 	"While evaluating the argument, aBlock, make the receiver be the cursor 	shape."	| oldcursor |	oldcursor _ Sensor currentCursor.	self show.	^aBlock ensure: [oldcursor show]! !!Cursor methodsFor: 'printing'!printOn: aStream	self storeOn: aStream base: 2! !!Cursor methodsFor: 'testing' stamp: 'bf 2/2/1999 19:34'!hasMask	^false! !!Cursor methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:14'!asCursorForm	| form |	form _ StaticForm extent: self extent depth: 8.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!Cursor methodsFor: 'converting' stamp: 'bf 2/2/1999 19:32'!withMask	^CursorWithMask derivedFrom: self! !!Cursor methodsFor: 'primitives'!beCursor	"Primitive. Tell the interpreter to use the receiver as the current cursor 	image. Fail if the receiver does not match the size expected by the 	hardware. Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !!Cursor methodsFor: 'primitives' stamp: 'jm 9/22/1998 23:33'!beCursorWithMask: maskForm	"Primitive. Tell the interpreter to use the receiver as the current cursor image with the given mask Form. Both the receiver and the mask should have extent 16@16 and a depth of one. The mask and cursor bits are combined as follow:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel""Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cursor class	instanceVariableNames: ''!!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 18:57'!initBottomLeft	BottomLeftCursor _ 		(Cursor extent: 16@16			fromArray: #(		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1111111111111111		2r1111111111111111)			offset: 0@-16).! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 18:57'!initBottomRight	BottomRightCursor _ 		(Cursor extent: 16@16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16@-16).! !!Cursor class methodsFor: 'class initialization'!initCorner	CornerCursor _ 		(Cursor 			extent: 16@16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16@-16).! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 21:02'!initCrossHair	CrossHairCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r0000000000000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0111111111111100		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000000000000		2r0)			offset: -7@-7).		! !!Cursor class methodsFor: 'class initialization'!initDown	DownCursor  _		     (Cursor	extent: 16@16	fromArray: #(		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r1111110000000000		2r111100000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).! !!Cursor class methodsFor: 'class initialization'!initMarker	MarkerCursor _ 		Cursor			extent: 16@16			fromArray: #(		2r0111000000000000		2r1111100000000000		2r1111100000000000		2r0111000000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)			offset: 0@0.! !!Cursor class methodsFor: 'class initialization' stamp: 'di 7/30/2001 10:32'!initMenu 	MenuCursor  _		        (Cursor	extent: 16@16	fromArray: #(		2r1111111111100000		2r1000000000100000		2r1010011000100000		2r1000000000100000		2r1101001101100000		2r1111111111100000		2r1000000000100000		2r1011001010100000		2r1000000000100000		2r1010110010100000		2r1000000000100000		2r1010010100100000		2r1000000000100000		2r1111111111100000		0)	offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 21:10'!initMove	MoveCursor _ 		Cursor 			extent: 16@16			fromArray: #(		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100          0)			offset: 0@0.! !!Cursor class methodsFor: 'class initialization'!initNormal	NormalCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r1000000000000000		2r1100000000000000		2r1110000000000000		2r1111000000000000		2r1111100000000000		2r1111110000000000		2r1111111000000000		2r1111100000000000		2r1111100000000000		2r1001100000000000		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0@0).		! !!Cursor class methodsFor: 'class initialization' stamp: 'di 10/8/1998 17:04'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor _ (CursorWithMask extent: 16@16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1@-1)		setMaskForm: (Form extent: 16@16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization'!initOrigin	OriginCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 22:55'!initRead	ReadCursor _  		(Cursor			extent: 16@16			fromArray: #(		2r0000000000000000		2r0000000000000000		2r0001000000001000		2r0010100000010100		2r0100000000100000		2r1111101111100000		2r1000010000100000		2r1000010000100000		2r1011010110100000		2r0111101111000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'dew 2/14/2004 01:24'!initResizeLeft	ResizeLeftCursor _ 		(Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0000001001000000		2r0000001001000000		2r0000001001000000		2r0000101001010000		2r0001101001011000		2r0011101001011100		2r0111111001111110		2r0011101001011100		2r0001101001011000		2r0000101001010000		2r0000001001000000		2r0000001001000000		2r0000001001000000		2r0000001001000000		2r0000000000000000 )	offset: -7@-7 ) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 4/3/2004 11:46'!initResizeTop     "Cursor initResizeTop"	ResizeTopCursor _ 		(Cursor extent: 16@16 fromArray: #(		2r000000100000000		2r000001110000000		2r000011111000000		2r000111111100000		2r000000100000000		2r111111111111100		2r000000000000000		2r000000000000000		2r111111111111100		2r000000100000000		2r000111111100000		2r000011111000000		2r000001110000000		2r000000100000000		2r000000000000000)	offset: -7@-7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 18:59'!initResizeTopLeft	ResizeTopLeftCursor _ 		(Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0111110000010000		2r0111100000100000		2r0111000001000100		2r0110100010001000		2r0100010100010000		2r0000001000100000		2r0000010001000000		2r0000100010000000		2r0001000100100010		2r0010001000010110		2r0000010000001110		2r0000100000011110		2r0000000000111110		2r0000000000000000		2r0000000000000000)	offset: -7@-7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:00'!initResizeTopRight	ResizeTopRightCursor _ 		(Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0000100000111110		2r0000010000011110		2r0010001000001110		2r0001000100010110		2r0000100010100010		2r0000010001000000		2r0000001000100000		2r0000000100010000		2r0100010010001000		2r0110100001000100		2r0111000000100000		2r0111100000010000		2r0111110000000000		2r0000000000000000		2r0000000000000000)	offset: -7@-7) withMask.! !!Cursor class methodsFor: 'class initialization'!initRightArrow 	RightArrowCursor  _		      (Cursor	extent: 16@16	fromArray: #(		2r100000000000		2r111000000000		2r1111111110000000		2r111000000000		2r100000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).		"Cursor initRightArrow"! !!Cursor class methodsFor: 'class initialization'!initSquare	SquareCursor _ 		(Cursor			extent: 16@16			fromArray: #(		2r0		2r0		2r0		2r0		2r0		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: -8@-8).	! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:01'!initTopLeft	TopLeftCursor _ 		(Cursor extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:02'!initTopRight	TopRightCursor _ 		(Cursor extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011)			offset: -16@0).! !!Cursor class methodsFor: 'class initialization'!initUp	UpCursor _ 		    (Cursor	extent: 16@16	fromArray: #(		2r11000000000000		2r111100000000000		2r1111110000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 21:27'!initWait	WaitCursor _ 		  (Cursor			extent: 16@16			fromArray: #(		2r1111111111111100		2r1000000000000100		2r0100000000001000		2r0010000000010000		2r0001110011100000		2r0000111111000000		2r0000011110000000		2r0000011110000000		2r0000100101000000		2r0001000100100000		2r0010000110010000		2r0100001111001000		2r1000111111110100		2r1111111111111100		0)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 22:52'!initWrite	WriteCursor _ (Cursor	extent: 16@16	fromArray: #(		2r0000000000011000		2r0000000000111100		2r0000000001001000		2r0000000010010000		2r0000000100100000		2r0000001001000100		2r0000010010000100		2r0000100100001100		2r0001001000010000		2r0010010000010000		2r0111100000001000		2r0101000011111000		2r1110000110000000		2r0111111100000000		2r0		2r0)	offset: 0@0).! !!Cursor class methodsFor: 'class initialization'!initXeq	XeqCursor _ 		(Cursor			extent: 16@16			fromArray: #(		2r1000000000010000		2r1100000000010000		2r1110000000111000		2r1111000111111111		2r1111100011000110		2r1111110001000100		2r1111111001111100		2r1111000001101100		2r1101100011000110		2r1001100010000010		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:04'!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor _ Cursor new.		self initXeq.		self initSquare.		self initNormalWithMask.		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		self initBottomLeft.		self initBottomRight.		self initResizeLeft.		self initResizeTop.		self initResizeTopLeft.		self initResizeTopRight.		self initTopLeft.		self initTopRight.		self makeCursorsWithMask.		"Cursor initialize"! !!Cursor class methodsFor: 'class initialization' stamp: 'bf 2/2/1999 19:33'!makeCursorsWithMask	"Cursor initialize;makeCursorsWithMask"	self classPool associationsDo: [:var |		var value hasMask			ifFalse: [var value: var value withMask]] ! !!Cursor class methodsFor: 'class initialization'!startUp	self currentCursor: self currentCursor! !!Cursor class methodsFor: 'instance creation'!extent: extentPoint fromArray: anArray offset: offsetPoint 	"Answer a new instance of me with width and height specified by	extentPoint, offset by offsetPoint, and bits from anArray.	NOTE: This has been kluged to take an array of 16-bit constants,	and shift them over so they are left-justified in a 32-bit bitmap"	extentPoint = (16 @ 16)		ifTrue: 			[^ super				extent: extentPoint				fromArray: (anArray collect: [:bits | bits bitShift: 16])				offset: offsetPoint]		ifFalse: [self error: 'cursors must be 16@16']! !!Cursor class methodsFor: 'instance creation' stamp: 'di 10/6/1998 13:53'!new	^ self extent: 16 @ 16		fromArray: (Array new: 16 withAll: 0)		offset: 0 @ 0	"Cursor new bitEdit show"! !!Cursor class methodsFor: 'current cursor'!currentCursor	"Answer the instance of Cursor that is the one currently displayed."	^CurrentCursor! !!Cursor class methodsFor: 'current cursor' stamp: 'di 10/6/1998 13:57'!currentCursor: aCursor 	"Make the instance of cursor, aCursor, be the current cursor. Display it. 	Create an error if the argument is not a Cursor."	(aCursor isKindOf: self)		ifTrue: [CurrentCursor _ aCursor.				aCursor beCursor]		ifFalse: [self error: 'The new cursor must be an instance of class Cursor']! !!Cursor class methodsFor: 'constants'!blank	"Answer the instance of me that is all white."	^BlankCursor! !!Cursor class methodsFor: 'constants' stamp: 'JMM 10/21/2003 19:13'!bottomLeft	"Cursor bottomLeft showWhile: [Sensor waitButton]"	^BottomLeftCursor! !!Cursor class methodsFor: 'constants' stamp: 'JMM 10/21/2003 19:13'!bottomRight	"Cursor bottomRight showWhile: [Sensor waitButton]"	^BottomRightCursor! !!Cursor class methodsFor: 'constants'!corner	"Answer the instance of me that is the shape of the bottom right corner 	of a rectangle."	^CornerCursor! !!Cursor class methodsFor: 'constants'!crossHair	"Answer the instance of me that is the shape of a cross."	^CrossHairCursor! !!Cursor class methodsFor: 'constants'!down	"Answer the instance of me that is the shape of an arrow facing 	downward."	^DownCursor! !!Cursor class methodsFor: 'constants'!execute	"Answer the instance of me that is the shape of an arrow slanted left 	with a star next to it."	^XeqCursor! !!Cursor class methodsFor: 'constants'!menu 	"Answer the instance of me that is the shape of a menu."	^MenuCursor! !!Cursor class methodsFor: 'constants'!move	"Answer the instance of me that is the shape of a cross inside a square."	^MoveCursor! !!Cursor class methodsFor: 'constants'!normal	"Answer the instance of me that is the shape of an arrow slanted left."	^NormalCursor! !!Cursor class methodsFor: 'constants'!origin	"Answer the instance of me that is the shape of the top left corner of a 	rectangle."	^OriginCursor! !!Cursor class methodsFor: 'constants'!read	"Answer the instance of me that is the shape of eyeglasses."	^ReadCursor! !!Cursor class methodsFor: 'constants'!rightArrow 	"Answer the instance of me that is the shape of an arrow pointing to the right."	^RightArrowCursor! !!Cursor class methodsFor: 'constants' stamp: 'JMM 10/21/2003 19:01'!topLeft	"Cursor topLeft showWhile: [Sensor waitButton]"	^ TopLeftCursor! !!Cursor class methodsFor: 'constants' stamp: 'JMM 10/21/2003 19:02'!topRight	"Cursor topRight showWhile: [Sensor waitButton]"	^ TopRightCursor! !!Cursor class methodsFor: 'constants'!up	"Answer the instance of me that is the shape of an arrow facing upward."	^UpCursor! !!Cursor class methodsFor: 'constants' stamp: 'sw 8/15/97 13:28'!wait	"Answer the instance of me that is the shape of an Hourglass (was in the 	shape of three small balls)."	^WaitCursor! !!Cursor class methodsFor: 'constants'!write	"Answer the instance of me that is the shape of a pen writing."	^WriteCursor! !Cursor subclass: #CursorWithMask	instanceVariableNames: 'maskForm'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!CursorWithMask commentStamp: '<historical>' prior: 0!A Cursor which additionally has a 16x16 transparency bitmap called a "mask".  See the comment of beCursorWithMask: for details on how the mask is treated.!]style[(97 17 40)f3,f3LCursor beCursorWithMask:;,f3!!CursorWithMask methodsFor: 'mask' stamp: 'bf 2/2/1999 19:34'!hasMask	^true! !!CursorWithMask methodsFor: 'mask' stamp: 'di 10/8/1998 16:46'!setMaskForm: aForm	maskForm _ aForm! !!CursorWithMask methodsFor: 'mask' stamp: 'bf 2/2/1999 19:30'!storeOn: aStream base: anInteger	aStream nextPut: $(.	super storeOn: aStream base: anInteger.	aStream nextPutAll: ' setMaskForm: '.	maskForm storeOn: aStream base: anInteger.	aStream nextPut: $)! !!CursorWithMask methodsFor: 'mask' stamp: 'bf 2/2/1999 19:31'!withMask	^self! !!CursorWithMask methodsFor: 'primitives' stamp: 'di 10/6/1998 15:16'!beCursor	maskForm unhibernate.	^ self beCursorWithMask: maskForm! !!CursorWithMask methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:14'!asCursorForm	| form |	form _ StaticForm extent: self extent depth: 8.	form fillShape: maskForm fillColor: Color white.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CursorWithMask class	instanceVariableNames: ''!!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 2/18/1999 08:56'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask ext |	ext _ aForm extent.	cursor _ self extent: ext.	cursor copy: (1@1 extent: ext) from: 0@0 in: aForm rule: Form over.	mask _ Form extent: ext.	(1@1) eightNeighbors do:		[:p | mask copy: (p extent: ext) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: ((aForm offset - (1@1)) max: ext negated).	^ cursor! !Path subclass: #CurveFitter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!CurveFitter commentStamp: '<historical>' prior: 0!I represent a conic section determined by three points p1, p2 and p3. I interpolate p1 and p3 and am tangent to line p1, p2 at p1 and line p3, p2 at p3.!!CurveFitter methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| pa pb k s p1 p2 p3 line |	line _ Line new.	line form: self form.	collectionOfPoints size < 3 ifTrue: [self error: 'Curve must have three points'].	p1 _ self firstPoint.	p2 _ self secondPoint.	p3 _ self thirdPoint.	s _ Path new.	s add: p1.	pa _ p2 - p1.	pb _ p3 - p2.	k _ 5 max: pa x abs + pa y abs + pb x abs + pb y abs // 20.	"k is a guess as to how many line segments to use to approximate 	the curve."	1 to: k do: 		[:i | 		s add: pa * i // k + p1 * (k - i) + (pb * (i - 1) // k + p2 * (i - 1)) // (k - 1)].	s add: p3.	1 to: s size - 1 do: 		[:i | 		line beginPoint: (s at: i).		line endPoint: (s at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!CurveFitter methodsFor: 'displaying' stamp: '6/9/97 10:16 di'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| transformedPath newCurveFitter |	transformedPath _ aTransformation applyTo: self.	newCurveFitter _ CurveFitter new.	newCurveFitter firstPoint: transformedPath firstPoint.	newCurveFitter secondPoint: transformedPath secondPoint.	newCurveFitter thirdPoint: transformedPath thirdPoint.	newCurveFitter form: self form.	newCurveFitter		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CurveFitter class	instanceVariableNames: ''!!CurveFitter class methodsFor: 'instance creation'!new	| newSelf | 	newSelf _ super new: 3.	newSelf add: 0@0.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!CurveFitter class methodsFor: 'examples' stamp: '6/9/97 10:16 di'!example	"Designate three locations on the screen by clicking any button. The	curve determined by the points will be displayed with a long black form."	| aCurveFitter aForm |  	aForm _ Form extent: 1@30.			"make a long thin Form for display "	aForm fillBlack.							"turn it black"	aCurveFitter _ CurveFitter new.	aCurveFitter form: aForm.						"set the form for display"				"collect three Points and show them on the dispaly"	aCurveFitter firstPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter firstPoint.	aCurveFitter secondPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter secondPoint.	aCurveFitter thirdPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter thirdPoint.	aCurveFitter displayOn: Display					"display the CurveFitter"	"CurveFitter example"! !SelectionMenu subclass: #CustomMenu	instanceVariableNames: 'labels dividers lastDivider title targets arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!CustomMenu commentStamp: '<historical>' prior: 0!I am used to build menus on-the-fly. I maintain lists of menu items, actions (usually symbols to be sent as messages), and menu section dividing lines to which my clients may append new entries and lines by sending me the messages:	add: aString action: anAction	addLineAfter the menu is constructed, it may be invoked with one of the following messages:	startUp: initialSelection	startUpI am a subclass of ActionMenu, so I inherit a number of instance variables. The ones I am particularly concerned with are:	items _ an OrderedCollection of strings to appear in the menu	selectors _ an OrderedCollection of Symbols to be used as message selectors	lineArray _ an OrderedCollection of line positions	lastLine _ used to keep track of the last line to avoid making duplicate entries in lineArray!!CustomMenu methodsFor: 'initialize-release' stamp: 'sumim 2/10/2002 01:26'!initialize	labels _ OrderedCollection new.	selections _ OrderedCollection new.	dividers _ OrderedCollection new.	lastDivider _ 0.	targets _ OrderedCollection new.	arguments _ OrderedCollection new	! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title _ aTitle! !!CustomMenu methodsFor: 'construction' stamp: 'dhhi 9/14/2000 22:39'!add: aString action: actionItem	"Add the given string as the next menu item. If it is selected, the given action (usually but not necessarily a symbol) will be returned to the client."	| s |	aString ifNil: [^ self addLine].	s _ String new: aString size + 2.	s at: 1 put: Character space.	s replaceFrom: 2 to: s size - 1 with: aString.	s at: s size put: Character space.	labels addLast: s.	selections addLast: actionItem.! !!CustomMenu methodsFor: 'construction'!addLine	"Append a line to the menu after the last entry. Suppress duplicate lines."	(lastDivider ~= selections size) ifTrue: [		lastDivider _ selections size.		dividers addLast: lastDivider].! !!CustomMenu methodsFor: 'construction' stamp: 'sw 2/27/2001 07:52'!addList: listOfTuplesAndDashes	"Add a menu item to the receiver for each tuple in the given list of the form (<what to show> <selector>). Add a line for each dash (-) in the list.  The tuples may have an optional third element, providing balloon help for the item, but such an element is ignored in mvc."	listOfTuplesAndDashes do: [:aTuple |		aTuple == #-			ifTrue: [self addLine]			ifFalse: [self add: aTuple first action: aTuple second]]	"CustomMenu new addList: #(		('apples' buyApples)		('oranges' buyOranges)		-		('milk' buyMilk)); startUp"! !!CustomMenu methodsFor: 'construction' stamp: 'sw 8/12/2002 17:14'!addStayUpItem	"For compatibility with MenuMorph.  Here it is a no-op"! !!CustomMenu methodsFor: 'construction' stamp: 'sw 7/20/1999 18:47'!balloonTextForLastItem: aString	"Vacuous backstop provided for compatibility with MorphicMenu"! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList _ (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray _ #()]		ifNotNil: [linesArray _ anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font _ aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'di 8/20/1998 09:24'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 2/17/2002 04:48'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return nil if no item is selected.  If the chosen selector has arguments, obtain them from my arguments"	^ self invokeOn: targetObject orSendTo: nil! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 11/16/2002 23:45'!invokeOn: targetObject orSendTo: anObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"	| aSelector anIndex recipient |	^ (aSelector _ self startUp) ifNotNil:		[anIndex _ self selection.		recipient _ ((targets _ self targets) isEmptyOrNil or: [anIndex > targets size])			ifTrue:				[targetObject]			ifFalse:				[targets at: anIndex].		aSelector numArgs == 0			ifTrue:				[recipient perform: aSelector orSendTo: anObject]			ifFalse:				[recipient perform: aSelector withArguments: (self arguments at: anIndex)]]! !!CustomMenu methodsFor: 'invocation'!startUp	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: nil! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 8/18/1998 12:01'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: title! !!CustomMenu methodsFor: 'invocation'!startUp: initialSelection withCaption: caption	"Build and invoke this menu with the given initial selection and caption. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	self build.	(initialSelection notNil) ifTrue: [self preSelect: initialSelection].	^ super startUpWithCaption: caption! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 7/31/97 19:31'!startUpWithCaption: caption	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen; use the provided caption"	^ self startUp: nil withCaption: caption! !!CustomMenu methodsFor: 'compatibility' stamp: 'ads 2/20/2003 08:59'!add: aString subMenu: aMenu target: target selector: aSymbol argumentList: argList	"Create a sub-menu with the given label. This isn't really a sub-menu the way Morphic does it; it'll just pop up another menu."	self		add: aString		target: aMenu		selector: #invokeOn:		argumentList: argList asArray.! !!CustomMenu methodsFor: 'compatibility' stamp: 'sumim 2/10/2002 01:23'!add: aString target: target selector: aSymbol argument: arg	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given argument."	self add: aString		target: target		selector: aSymbol		argumentList: (Array with: arg)! !!CustomMenu methodsFor: 'compatibility' stamp: 'sumim 2/10/2002 01:18'!add: aString target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument."	self add: aString action: aSymbol.	targets addLast: target.	arguments addLast: argList asArray! !!CustomMenu methodsFor: 'compatibility' stamp: 'nk 2/15/2004 16:19'!addService: aService for: serviceUser	"Append a menu item with the given service. If the item is selected, it will perform the given service."	aService addServiceFor: serviceUser toMenu: self.! !!CustomMenu methodsFor: 'compatibility' stamp: 'nk 2/15/2004 16:02'!addServices2: services for: served extraLines: linesArray	services withIndexDo: [:service :i |		service addServiceFor: served toMenu: self.		(linesArray includes: i)  ifTrue: [self addLine] ]! !!CustomMenu methodsFor: 'compatibility' stamp: 'sumim 2/10/2002 01:20'!addServices: services for: served extraLines: linesArray	services withIndexDo: [:service :i |		self addService: service for: served.		(linesArray includes: i) | service useLineAfter 			ifTrue: [self addLine]]! !!CustomMenu methodsFor: 'private' stamp: 'sw 12/10/1999 11:21'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [:label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: MenuStyle defaultFont		lines: dividers! !!CustomMenu methodsFor: 'private' stamp: 'di 4/14/1999 21:28'!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i _ selections indexOf: action ifAbsent: [^ self].	marker ifNil: [self computeForm].	marker _ marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection _ i.! !!CustomMenu methodsFor: 'accessing' stamp: 'ssa 6/20/2008 14:29'!arguments	arguments isNil ifTrue:[arguments := OrderedCollection new].	^arguments! !!CustomMenu methodsFor: 'accessing' stamp: 'ssa 6/20/2008 14:29'!selections	selections isNil ifTrue:[selections := OrderedCollection new].	^selections! !!CustomMenu methodsFor: 'accessing' stamp: 'ssa 6/20/2008 14:29'!targets	targets isNil ifTrue:[targets := OrderedCollection new].	^targets! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomMenu class	instanceVariableNames: ''!!CustomMenu class methodsFor: 'example' stamp: 'sw 11/8/1999 17:27'!example	"CustomMenu example"	| menu |	menu _ CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples"NB:  The following is equivalent to the above, but uses the compact #fromArray: consruct:	(CustomMenu fromArray:		#(	('apples'		apples)			('oranges'		oranges)			-			-			('peaches'		peaches)			-			('pears'			pears)			-))				startUp: #apples"! !Timespan subclass: #Date	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!Date commentStamp: '<historical>' prior: 0!Instances of Date are Timespans with duration of 1 day.Their default creation assumes a start of midnight in the local time zone.!!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:07'!mmddyyyy
	"Answer the receiver rendered in standard U.S.A format mm/dd/yyyy.	Note that the name here is slightly misleading -- the month and day numbers don't show leading zeros, 	so that for example February 1 1996 is 2/1/96"


	^ self printFormat: #(2 1 3 $/ 1 1)! !!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:06'!printFormat: formatArray 
	"Answer a String describing the receiver using the argument formatArray."

	| aStream |
	aStream _ WriteStream on: (String new: 16).
	self printOn: aStream format: formatArray.
	^ aStream contents! !!Date methodsFor: 'printing' stamp: 'BP 3/23/2001 12:27'!printOn: aStream

	self printOn: aStream format: #(1 2 3 $  3 1 )! !!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:05'!printOn: aStream format: formatArray 	"Print a description of the receiver on aStream using the format 	denoted the argument, formatArray: 	
		#(item item item sep monthfmt yearfmt twoDigits) 	
		items: 1=day 2=month 3=year will appear in the order given, 	
		separated by sep which is eaither an ascii code or character. 	
		monthFmt: 1=09 2=Sep 3=September 	
		yearFmt: 1=1996 2=96 	
		digits: (missing or)1=9 2=09. 	
	See the examples in printOn: and mmddyy"	| gregorian twoDigits element monthFormat |	gregorian _ self dayMonthYearDo: [ :d :m :y | {d. m. y} ].	twoDigits _ formatArray size > 6 and: [(formatArray at: 7) > 1].	1 to: 3 do: 		[ :i | 			element := formatArray at: i.			element = 1				ifTrue: [twoDigits						ifTrue: [aStream								nextPutAll: (gregorian first asString										padded: #left										to: 2										with: $0)]						ifFalse: [gregorian first printOn: aStream]].			element = 2				ifTrue: [monthFormat := formatArray at: 5.					monthFormat = 1						ifTrue: [twoDigits								ifTrue: [aStream										nextPutAll: (gregorian middle asString												padded: #left												to: 2												with: $0)]								ifFalse: [gregorian middle printOn: aStream]].					monthFormat = 2						ifTrue: [aStream								nextPutAll: ((Month nameOfMonth: gregorian middle)										copyFrom: 1										to: 3)].					monthFormat = 3						ifTrue: [aStream								nextPutAll: (Month nameOfMonth: gregorian middle)]].			element = 3				ifTrue: [(formatArray at: 6)							= 1						ifTrue: [gregorian last printOn: aStream]						ifFalse: [aStream								nextPutAll: ((gregorian last \\ 100) asString										padded: #left										to: 2										with: $0)]].			i < 3				ifTrue: [(formatArray at: 4)							~= 0						ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]! !!Date methodsFor: 'printing' stamp: 'BP 3/23/2001 12:27'!storeOn: aStream

	aStream print: self printString; nextPutAll: ' asDate'! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 22:09'!addDays: dayCount 	^ (self asDateAndTime + (dayCount days)) asDate! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:08'!asSeconds
	"Answer the seconds since the Squeak epoch: 1 January 1901"

	^ start asSeconds! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:08'!leap	"Answer whether the receiver's year is a leap year."	^ start isLeapYear ifTrue: [1] ifFalse: [0].! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 1/16/2004 14:30'!previous: dayName 	"Answer the previous date whose weekday name is dayName."	| days |	days _ 7 + self weekdayIndex - (self class dayOfWeek: dayName) \\ 7.	days = 0 ifTrue: [ days _ 7 ].	^ self subtractDays: days! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:09'!subtractDate: aDate 	"Answer the number of days between self and aDate"	^ (self start - aDate asDateAndTime) days! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 22:05'!subtractDays: dayCount 	^ (self asDateAndTime - (dayCount days)) asDate! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 8/24/2003 12:04'!weekday	"Answer the name of the day of the week on which the receiver falls."	^ self dayOfWeekName! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 8/24/2003 12:04'!weekdayIndex	"Sunday=1, ... , Saturday=7"	^ self dayOfWeek! !!Date methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:10'!asDate

	^ self! !!Date methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:10'!dayMonthYearDo: aBlock 	"Supply integers for day, month and year to aBlock and return the result"	^ start dayMonthYearDo: aBlock! !!Date methodsFor: 'squeak protocol' stamp: 'avi 2/21/2004 18:12'!month	^ self asMonth! !!Date methodsFor: 'squeak protocol' stamp: 'avi 2/29/2004 13:10'!monthIndex	^ super month! !!Date methodsFor: 'deprecated' stamp: 'brp 8/5/2003 18:36'!day: dayInteger year: yearInteger	^ self		deprecated: 'Obsolete'! !!Date methodsFor: 'deprecated' stamp: 'brp 8/5/2003 18:37'!firstDayOfMonthIndex: monthIndex 	^ self		deprecated: 'Obsolete'! !!Date methodsFor: 'deprecated' stamp: 'brp 8/5/2003 18:41'!julianDayNumber: anInteger	"Set the number of days elapsed since midnight GMT on January 1st, 4713 B.C."	self deprecated: 'Obsolete'.! !!Date methodsFor: 'deprecated' stamp: 'brp 8/5/2003 18:34'!mmddyy	"Please use mmddyyyy instead, so dates in 2000 will be unambiguous"	^ self 		deprecated: 'Use #mmddyyyy';		printFormat: #(2 1 3 $/ 1 2)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Date class	instanceVariableNames: ''!!Date class methodsFor: 'smalltalk-80' stamp: 'brp 8/24/2003 00:00'!dateAndTimeNow
	"Answer an Array whose with Date today and Time now."

	^ Time dateAndTimeNow! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:35'!dayOfWeek: dayName 	^ Week indexOfDay: dayName! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:59'!daysInMonth: monthName forYear: yearInteger 	^ Month daysInMonth: monthName forYear: yearInteger.! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:53'!daysInYear: yearInteger 	^ Year daysInYear: yearInteger.! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 1/16/2004 14:35'!firstWeekdayOfMonth: month year: year	"Answer the weekday index of the first day in <month> in the <year>."	^ (self newDay: 1 month: month year: year) weekdayIndex! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:01'!fromDays: dayCount 	"Days since 1 January 1901"	^ self julianDayNumber: dayCount + SqueakEpoch! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:02'!fromSeconds: seconds
	"Answer an instance of me which is 'seconds' seconds after January 1, 1901."

	^ self fromDays: ((Duration seconds: seconds) days)! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:39'!indexOfMonth: aMonthName 	^ Month indexOfMonth: aMonthName.! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:56'!leapYear: yearInteger 	^ Year leapYear: yearInteger! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:37'!nameOfDay: dayIndex 	^ Week nameOfDay: dayIndex ! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:40'!nameOfMonth: anIndex 	^ Month nameOfMonth: anIndex.! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:02'!newDay: day month: month year: year 

	^ self year: year month: month day: day! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:01'!newDay: dayCount year: yearInteger	^ self year: yearInteger day: dayCount! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:01'!today

	^ self current! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:03'!fromString: aString
	"Answer an instance of created from a string with format dd.mm.yyyy."

	^ self readFrom: aString readStream.
! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 18:25'!julianDayNumber: aJulianDayNumber	^ self starting: (DateAndTime julianDayNumber: aJulianDayNumber)! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/1/2003 09:21'!readFrom: aStream 	"Read a Date from the stream in any of the forms:  	
		<day> <monthName> <year>		(5 April 1982; 5-APR-82)  	
		<monthName> <day> <year>		(April 5, 1982)  	
		<monthNumber> <day> <year>		(4/5/82) 			<day><monthName><year>			(5APR82)"	| day month year |	aStream peek isDigit		ifTrue: [day := Integer readFrom: aStream].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue: ["number/name... or name..."			month := WriteStream						on: (String new: 10).			[aStream peek isLetter]				whileTrue: [month nextPut: aStream next].			month := month contents.			day isNil				ifTrue: ["name/number..."					[aStream peek isAlphaNumeric]						whileFalse: [aStream skip: 1].					day := Integer readFrom: aStream]]		ifFalse: ["number/number..."			month := Month nameOfMonth: day.			day := Integer readFrom: aStream].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	year := Integer readFrom: aStream.	year < 10 ifTrue: [year := 2000 + year] 		ifFalse: [ year < 1900 ifTrue: [ year := 1900 + year]].	^ self		year: year		month: month		day: day! !!Date class methodsFor: 'squeak protocol' stamp: 'BP 3/23/2001 12:36'!starting: aDateAndTime

	^super starting: (aDateAndTime midnight) duration: (Duration days: 1)
! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 22:03'!year: year day: dayOfYear	^ self starting: (DateAndTime year: year day: dayOfYear)! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 22:02'!year: year month: month day: day

	^ self starting: (DateAndTime year: year month: month day: day)
! !Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'LocalTimeZone'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.


My implementation uses three SmallIntegers
 and a Duration:
jdn		- julian day number.
seconds	- number of seconds since midnight.
nanos	- the number of nanoseconds since the second.

offset	- duration from UTC.

The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.
!!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 7/9/2005 08:45'!+ operand
	"operand conforms to protocol Duration"
	| ticks | 	ticks _ self ticks + (operand asDuration ticks) .
	^ self class basicNew
		ticks: ticks
		offset: self offset; 
		yourself.
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 1/9/2004 05:39'!- operand
	"operand conforms to protocol DateAndTime or protocol Duration"

	^ (operand respondsTo: #asDateAndTime)
		ifTrue: 
			[ | lticks rticks |
			lticks _ self asLocal ticks.	
		rticks _ operand asDateAndTime asLocal ticks.
			Duration
 				seconds: (SecondsInDay *(lticks first - rticks first)) + 
							(lticks second - rticks second)
 				nanoSeconds: (lticks third - rticks third) ]	
	ifFalse:
		
 	[ self + (operand negated) ].
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 09:09'!< comparand	"comparand conforms to protocol DateAndTime,	or can be converted into something that conforms."	| lticks rticks comparandAsDateAndTime |	comparandAsDateAndTime := comparand asDateAndTime.	offset = comparandAsDateAndTime offset		ifTrue: [lticks := self ticks.			rticks := comparandAsDateAndTime ticks]		ifFalse: [lticks := self asUTC ticks.			rticks := comparandAsDateAndTime asUTC ticks].	^ lticks first < rticks first		or: [lticks first > rticks first				ifTrue: [false]				ifFalse: [lticks second < rticks second						or: [lticks second > rticks second								ifTrue: [false]								ifFalse: [lticks third < rticks third]]]]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 08:49'!= comparand	"comparand conforms to protocol DateAndTime,	or can be converted into something that conforms."	| comparandAsDateAndTime |	self == comparand		ifTrue: [^ true].	[comparandAsDateAndTime := comparand asDateAndTime]		on: MessageNotUnderstood		do: [^ false].	^ self offset = comparandAsDateAndTime offset		ifTrue: [self ticks = comparandAsDateAndTime ticks]		ifFalse: [self asUTC ticks = comparandAsDateAndTime asUTC ticks]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 13:11'!asLocal
	

	^ (self offset = self class localOffset)

		ifTrue: [self]
		ifFalse: [self utcOffset: self class localOffset]
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 13:12'!asUTC


	^ self utcOffset: 0! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:03'!dayOfMonth
	"Answer which day of the month is represented by the receiver."

	^ self
		dayMonthYearDo: [ :d :m :y | d ]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/24/2003 12:25'!dayOfWeek

	"Sunday=1, ... , Saturday=7"

	^ (jdn + 1 rem: 7) + 1! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:28'!dayOfWeekName

	^ Week nameOfDay: self dayOfWeek
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!dayOfYear


	^ jdn - (Year year: self year) start julianDayNumber + 1
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 15:49'!hash

	^ self asUTC ticks hash
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!hour

	^ self hour24
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!hour24


	^ (Duration seconds: seconds) hours
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!isLeapYear


	^ Year isLeapYear: self year.
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!minute


	^ (Duration seconds: seconds) minutes
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:05'!month

	^ self 
		dayMonthYearDo: [ :d :m :y | m ].! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!monthName


	^ Month nameOfMonth: self month
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!offset

	^ offset
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:09'!offset: anOffset

	"Answer a <DateAndTime> equivalent to the receiver but with its local time 
	being offset from UTC by offset."

	^ self class basicNew 
		ticks: self ticks offset: anOffset asDuration;
		yourself
		! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:31'!second


	^ (Duration seconds: seconds) seconds
! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:05'!year
	^ self
		dayMonthYearDo: [ :d :m :y | y ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 23:56'!asDate
	^ Date starting: self
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:46'!asDateAndTime

	^ self
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:47'!asDuration

	"Answer the duration since midnight"

	^ Duration seconds: seconds nanoSeconds: nanos
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:47'!asMonth

	^ Month starting: self
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:45'!asNanoSeconds
	"Answer the number of nanoseconds since midnight"

	^ self asDuration asNanoSeconds
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/24/2003 00:00'!asTime
	^ Time seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/24/2003 00:02'!asTimeStamp	^ self as: TimeStamp! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:47'!asYear

	^ Year starting: self
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:47'!dayMonthYearDo: aBlock
	"Evaluation the block with three arguments: day month, year."

	| l n i j dd mm yyyy |
	l := jdn + 68569.
	n := 4 * l // 146097.
	l := l - (146097 * n + 3 // 4).
	i := 4000 * (l + 1) // 1461001.
	l := l - (1461 * i // 4) + 31.
	j := 80 * l // 2447.
	dd := l - (2447 * j // 80).
	l := j // 11.
	mm := j + 2 - (12 * l).
	yyyy := 100 * (n - 49) + i + l.

	^ aBlock
		value: dd
		value: mm
		value: yyyy.! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:49'!duration

	^ Duration zero
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:49'!julianDayNumber


	^ jdn
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:48'!midnight
	"Answer a DateAndTime starting at midnight local time"

	^ self
		dayMonthYearDo: [ :d :m :y | self class year: y month: m day: d ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:50'!nanoSecond


	^ nanos
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:03'!printHMSOn: aStream	"Print just hh:mm:ss"	aStream		nextPutAll: (self hour asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self minute asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self second asString padded: #left to: 2 with: $0).! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:38'!printOn: aStream	"Print as per ISO 8601 sections 5.3.3 and 5.4.1.	Prints either:		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)"	^self printOn: aStream withLeadingSpace: false! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:37'!printOn: aStream withLeadingSpace: printLeadingSpaceToo	"Print as per ISO 8601 sections 5.3.3 and 5.4.1.	If printLeadingSpaceToo is false, prints either:		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)	If printLeadingSpaceToo is true, prints either:		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)	"	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.	aStream nextPut: $T.	self printHMSOn: aStream.	self nanoSecond ~= 0 ifTrue:		[ | z ps |		ps := self nanoSecond printString padded: #left to: 9 with: $0.		z := ps findLast: [ :c | c asciiValue > $0 asciiValue ].		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].	aStream		nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);		nextPutAll: (offset hours abs asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (offset minutes abs asString padded: #left to: 2 with: $0).	offset seconds = 0 ifFalse:		[ aStream			nextPut: $:;			nextPutAll: (offset seconds abs truncated asString) ].! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:29'!printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo	"Print just the year, month, and day on aStream.	If printLeadingSpaceToo is true, then print as:		' YYYY-MM-DD' (if the year is positive) or '-YYYY-MM-DD' (if the year is negative)	otherwise print as:		'YYYY-MM-DD' or '-YYYY-MM-DD' "	| year month day |	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].	year negative		ifTrue: [ aStream nextPut: $- ]		ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ]].	aStream		nextPutAll: (year abs asString padded: #left to: 4 with: $0);		nextPut: $-;		nextPutAll: (month asString padded: #left to: 2 with: $0);		nextPut: $-;		nextPutAll: (day asString padded: #left to: 2 with: $0)! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:50'!to: anEnd
	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"

	^ Timespan starting: self ending: (anEnd asDateAndTime).
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:57'!to: anEnd by: aDuration
	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"

	^ (Schedule starting: self ending: (anEnd asDateAndTime))
		schedule: (Array with: aDuration asDuration);
		yourself.
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 16:01'!to: anEnd by: aDuration do: aBlock
	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"

	^ (self to: anEnd by: aDuration) scheduleDo: aBlock
! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:37'!utcOffset: anOffset

	"Answer a <DateAndTime> equivalent to the receiver but offset from UTC by anOffset"

	| equiv |
	equiv _ self + (anOffset asDuration - self offset).
	^ equiv ticks: (equiv ticks) offset: anOffset asDuration; yourself
! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 21:03'!asSeconds
	"Return the number of seconds since the Squeak epoch"

	^ (self - (self class epoch)) asSeconds
! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 17:53'!day

	^ self dayOfYear! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 07:48'!daysInMonth
	"Answer the number of days in the month represented by the receiver."


	^ self asMonth daysInMonth
! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 07:48'!daysInYear

	"Answer the number of days in the year represented by the receiver."

	^ self asYear daysInYear
! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 15:44'!daysLeftInYear
	"Answer the number of days in the year after the date of the receiver."

	^ self daysInYear - self dayOfYear
! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 15:44'!firstDayOfMonth

	^ self asMonth start day! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 18:30'!hours

	^ self hour! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 1/7/2004 15:45'!minutes

	^ self minute! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 07:50'!monthIndex


	^ self month
! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 18:31'!seconds

	^ self second! !!DateAndTime methodsFor: 'private' stamp: 'brp 8/23/2003 15:45'!ticks
	"Private - answer an array with our instance variables. Assumed to be UTC "

	^ Array with: jdn with: seconds with: nanos
.! !!DateAndTime methodsFor: 'private' stamp: 'nk 3/30/2004 09:38'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	| normalize |	normalize := [ :i :base | | tick div quo rem |		tick := ticks at: i.		div := tick digitDiv: base neg: tick negative.		quo := div first normalize.		rem := div second normalize.		rem < 0 ifTrue: [ quo := quo - 1. rem := base + rem ].		ticks at: (i-1) put: ((ticks at: i-1) + quo).		ticks at: i put: rem ].	normalize value: 3 value: NanosInSecond.	normalize value: 2 value: SecondsInDay.	jdn	_ ticks first.	seconds	_ ticks second.	nanos := ticks third.	offset := utcOffset.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DateAndTime class	instanceVariableNames: ''!!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:32'!clockPrecision
	"One nanosecond precision"

	^ Duration nanoSeconds: 1
! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'avi 2/21/2004 19:03'!now	^ self basicNew 		ticks: (Duration 				days: SqueakEpoch 				hours: 0 				minutes: 0 				seconds: self totalSeconds 				nanoSeconds: 0) ticks		offset: self localOffset;		yourself! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 7/27/2003 15:25'!year: year day: dayOfYear hour: hour minute: minute second: second

	^ self
		year: year
		day: dayOfYear
		hour: hour
		minute: minute
		second: second
		offset: self localOffset.
! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 7/27/2003 15:28'!year: year day: dayOfYear hour: hour minute: minute second: second offset: offset 
	"Return a DataAndTime"

	| y d |
	y _ self
		year: year
		month: 1
		day: 1
		hour: hour
		minute: minute
		second: second
		nanoSecond: 0
		offset: offset.

	d _ Duration days: (dayOfYear - 1).

	^ y + d! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:00'!year: year month: month day: day hour: hour minute: minute second: second
	"Return a DateAndTime"

	^ self
		year: year
		month: month
		day: day
		hour: hour
		minute: minute
		second: second
		offset: self localOffset
! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:36'!year: year month: month day: day hour: hour minute: minute second: second offset: offset

	^ self
		year: year
		month: month
		day: day
		hour: hour
		minute: minute
		second: second
		nanoSecond: 0
		offset: offset
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:36'!current


	^ self now
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 16:12'!date: aDate time: aTime

	^ self 
		year: aDate year 
		day: aDate dayOfYear 
		hour: aTime hour 
		minute: aTime minute 
		second: aTime second
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp` 8/24/2003 19:11'!epoch
	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"

	^ self julianDayNumber: SqueakEpoch
	! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:36'!fromString: aString


	^ self readFrom: (ReadStream on: aString)
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 21:08'!julianDayNumber: aJulianDayNumber

	^ self basicNew
		ticks: aJulianDayNumber days ticks offset: self localOffset;
		yourself
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 9/4/2003 06:40'!localOffset
	"Answer the duration we are offset from UTC"

	^ self localTimeZone offset
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 9/4/2003 06:39'!localTimeZone
	"Answer the local time zone"

	^ LocalTimeZone ifNil: [ LocalTimeZone _ TimeZone default ]

! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:09'!midnight

	^ self now midnight
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:57'!new
	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"

	^ self epoch
	! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:58'!readFrom: aStream
	| bc year month day hour minute second nanos offset buffer ch |


	aStream peek = $- ifTrue: [ aStream next. bc _ -1] ifFalse: [bc _ 1].
	year _ (aStream upTo: $-) asInteger * bc.
	month _ (aStream upTo: $-) asInteger.
	day _ (aStream upTo: $T) asInteger.
	hour _ (aStream upTo: $:) asInteger.
 	buffer _ '00:'. ch _ nil.
	minute _ WriteStream on: buffer.
	[ aStream atEnd | (ch = $:) | (ch = $+) | (ch = $-) ]
		whileFalse: [ ch _ minute nextPut: aStream next. ].
	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $: ].
	minute _ ((ReadStream on: buffer) upTo: ch) asInteger.
	buffer _ '00.'.
	second _ WriteStream on: buffer.
	[ aStream atEnd | (ch = $.) | (ch = $+) | (ch = $-) ]
		whileFalse: [ ch _ second nextPut: aStream next. ].
	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $. ].
	second _ ((ReadStream on: buffer) upTo: ch) asInteger.
	buffer _ '00000000+'.
	nanos _ WriteStream on: buffer.
	[ aStream atEnd | (ch = $+) | (ch = $-) ]
		whileFalse: [ ch _ nanos nextPut: aStream next. ].
	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $+ ].
	nanos _ ((ReadStream on: buffer) upTo: ch) asInteger.
	aStream atEnd
		ifTrue: [ offset _ self localOffset ]
	
	ifFalse:
		 	[offset _ Duration fromString: (ch asString, '0:', aStream upToEnd).
	
		(offset = self localOffset) ifTrue: [ offset _ self localOffset ]].
	^ self
		year: year
		month: month
		day: day
		hour: hour
		minute: minute

		second: second
		nanoSecond:  nanos

		offset: offset.


	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime
		' 2002-05-16T17:20:45.00000001+01:01' asDateAndTime
  		' 2002-05-16T17:20:45.00000001' asDateAndTime
 		' 2002-05-16T17:20' asDateAndTime
		' 2002-05-16T17:20:45' asDateAndTime
		' 2002-05-16T17:20:45+01:57' asDateAndTime
 		' 2002-05-16T17:20:45-02:34' asDateAndTime
 		' 2002-05-16T17:20:45+00:00' asDateAndTime
		' 1997-04-26T01:02:03+01:02:3' asDateAndTime 
 	"
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:09'!today

	^ self midnight
! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:53'!year: year day: dayOfYear
	"Return a DateAndTime"

	^ self
		year: year
		day: dayOfYear
		hour: 0
		minute: 0
		second: 0! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:54'!year: year month: month day: day
	"Return a DateAndTime, midnight local time" 	^ self
 		year: year
 		month: month
 		day: day
 		hour: 0
		minute: 0! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:54'!year: year month: month day: day hour: hour minute: minute

	"Return a DateAndTime" 	^ self
 		year: year
 		month: month
 		day: day
 		hour: hour
		minute: minute
		second: 0! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 1/7/2004 15:39'!year: year month: month day: day hour: hour minute: minute second: second nanoSecond: nanoCount offset: offset
	"Return a DateAndTime"

	| monthIndex p q r s julianDayNumber since |

	monthIndex _ month isInteger ifTrue: [month] ifFalse: [Month indexOfMonth: month].
	p _ (monthIndex - 14) quo: 12.
	q _ year + 4800 + p.
	r _ monthIndex - 2 - (12 * p).
	s _ (year + 4900 + p) quo: 100.

	julianDayNumber _
 		( (1461 * q) quo: 4 ) +
			( (367 * r) quo: 12 ) -
 				( (3 * s) quo: 4 ) +
 					( day - 32075 ).

	since _ Duration days: julianDayNumber hours: hour 				minutes: minute seconds: second nanoSeconds: nanoCount.

	^ self basicNew
 		ticks: since ticks offset: offset;
		yourself.! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'brp` 8/24/2003 19:09'!fromSeconds: seconds
	"Answer a DateAndTime since the Squeak epoch: 1 January 1901"

	| since |
	since _ Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: seconds.
	^ self basicNew
		ticks: since ticks offset: self localOffset;
		yourself.
! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'brp 8/24/2003 00:00'!millisecondClockValue	^ Time millisecondClockValue! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'brp 8/24/2003 00:01'!totalSeconds	^ Time totalSeconds! !CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC sourceMap tempNames savedCursor isolationHead failedProject errorWasInUIProcess labelString theMethodNode'	classVariableNames: 'ContextStackKeystrokes ErrorRecursion'	poolDictionaries: ''	category: 'Tools-Debugger'!!Debugger commentStamp: '<historical>' prior: 0!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!Debugger methodsFor: 'initialize' stamp: 'RAA 1/30/2001 13:05'!buildMVCDebuggerViewLabel: aString minSize: aPoint	"Build an MVC debugger view around the receiver, and return the StandardSystemView thus created."	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView deltaY underPane annotationPane buttonsView oldContextStackIndex |	oldContextStackIndex _ contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	contextStackIndex _ oldContextStackIndex.	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	stackListView _ PluggableListView on: self			list: #contextStackList			selected: #contextStackIndex			changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted:			keystroke: #contextStackKey:from:.		stackListView menuTitleSelector: #messageListSelectorTitle.		stackListView window: (0 @ 0 extent: 150 @ 50).		topView addSubView: stackListView.	deltaY _ 0.	 self wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 150@self optionalAnnotationHeight).			topView addSubView: annotationPane below: stackListView.			deltaY _ deltaY + self optionalAnnotationHeight.			underPane _ annotationPane]		ifFalse:			[underPane _ stackListView].	self wantsOptionalButtons		ifTrue:			[buttonsView _ self buildMVCOptionalButtonsButtonsView.			buttonsView borderWidth: 1.			topView addSubView: buttonsView below: underPane.			underPane _ buttonsView.			deltaY _ deltaY + self optionalButtonHeight].	stackCodeView _ PluggableTextView on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		stackCodeView window: (0 @ 0 extent: 150 @ (75 - deltaY)).		topView addSubView: stackCodeView below: underPane.	rcvrVarView _ PluggableListView on: self receiverInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		rcvrVarView window: (0 @ 0 extent: 25 @ (50 - deltaY)).		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ PluggableTextView on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		rcvrValView window: (0 @ 0 extent: 50 @ (50 - deltaY)).		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ PluggableListView on: self contextVariablesInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		ctxtVarView window: (0 @ 0 extent: 25 @ (50 - deltaY)).		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ PluggableTextView on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		ctxtValView window: (0 @ 0 extent: 50 @ (50 - deltaY)).		topView addSubView: ctxtValView toRightOf: ctxtVarView.	topView label: aString.	topView minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'sw 1/16/2002 20:03'!buildMVCNotifierButtonView	| aView bHeight priorButton buttonView |	aView _ View new model: self.	bHeight _ self notifierButtonHeight.	aView window: (0@0 extent: 350@bHeight).	priorButton _ nil.	self preDebugButtonQuads do:		[:aSpec |			buttonView _ PluggableButtonView				on: self				getState: nil				action: aSpec second.			buttonView				label: aSpec first;				insideColor: (Color perform: aSpec third) muchLighter lighter;				borderWidthLeft: 1 right: 1 top: 0 bottom: 0;				window: (0@0 extent: 117@bHeight).			priorButton				ifNil:					[aView addSubView: buttonView]				ifNotNil:					[aView addSubView: buttonView toRightOf: priorButton].			priorButton _ buttonView].	^ aView! !!Debugger methodsFor: 'initialize' stamp: 'rhi 12/20/2000 16:50'!buildMVCNotifierViewLabel: aString message: messageString minSize: aPoint	| topView notifyView buttonView x y bHeight |	self expandStack.	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	buttonView _ self buildMVCNotifierButtonView.	topView addSubView: buttonView.	notifyView _ PluggableListView on: self		list: #contextStackList		selected: #contextStackIndex		changeSelected: #debugAt:		menu: nil		keystroke: nil.	x _ 350 max: (aPoint x).	y _ ((4 * 15) + 16) max: (aPoint y - 16 - self optionalButtonHeight).	bHeight _ self optionalButtonHeight.	y _ y - bHeight.	notifyView window: (0@0 extent: x@y).	topView		addSubView: notifyView below: buttonView;		label: aString;		minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'hmm 7/30/2001 17:25'!buildMVCOptionalButtonsButtonsView	| aView bHeight offset aButtonView wid pairs windowWidth previousView |	aView _ View new model: self.	bHeight _ self optionalButtonHeight.	windowWidth _ 150.	aView window: (0@0 extent: windowWidth@bHeight).	offset _ 0.	pairs _ self optionalButtonPairs.	previousView _ nil.	pairs do: [:pair |		aButtonView _ PluggableButtonView on: self getState: nil action: pair second.		pair second = pairs last second			ifTrue:				[wid _ windowWidth - offset]			ifFalse:				[aButtonView borderWidthLeft: 0 right: 1 top: 0 bottom: 0.				wid _ windowWidth // (pairs size)].		aButtonView			label: pair first asParagraph;			insideColor: Color red muchLighter lighter;			window: (offset@0 extent: wid@bHeight).		offset _ offset + wid.		pair second = pairs first second			ifTrue: [aView addSubView: aButtonView]			ifFalse: [aView addSubView: aButtonView toRightOf: previousView].		previousView _ aButtonView].	^ aView! !!Debugger methodsFor: 'initialize' stamp: 'ab 2/25/2004 18:59'!customButtonSpecs	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."	| list |	list _ #(('Proceed'	proceed				'close the debugger and proceed.')		('Restart'		restart				'reset this context to its start.')		('Into'			send				'step Into message sends')		('Over'			doStep				'step Over message sends')		('Through'		stepIntoBlock		'step into a block')		('Full Stack'		fullStack			'show full stack')		('Where'		where				'select current pc range')).	Preferences restartAlsoProceeds ifTrue:		[list _ list collect: [:each |			each second == #restart				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]				ifFalse: [each]]].	^ list! !!Debugger methodsFor: 'initialize' stamp: 'kfr 10/4/2000 22:13'!debugAt: anInteger	self toggleContextStackIndex: anInteger. 	 ^ self debug.! !!Debugger methodsFor: 'initialize' stamp: 'tk 5/9/2003 11:20'!initialExtent	"Make the full debugger longer!!"	dependents size < 9 ifTrue: [^ super initialExtent].	"Pre debug window"	RealEstateAgent standardWindowExtent y < 400 "a tiny screen" 		ifTrue: [^ super initialExtent].		^ 600@700! !!Debugger methodsFor: 'initialize' stamp: 'sw 12/28/1999 13:07'!notifierButtonHeight	^ 18! !!Debugger methodsFor: 'initialize' stamp: 'BG 10/28/2003 20:40'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| topView |		topView _ self buildMVCDebuggerViewLabel: aString minSize: 300@200.	topView controller openNoTerminate.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'BG 10/28/2003 20:39'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, (msgString ifNil: [''])]		ifFalse: [msg _ msgString].	isolationHead ifNotNil:		["We have already revoked the isolation layer -- now jump to the parent project."		msg _ self isolationRecoveryAdvice, msgString.		failedProject _ Project current.		isolationHead parent enterForEmergencyRecovery].	Display fullScreen.	topView _ self 		buildMVCNotifierViewLabel: label 		message: thisContext sender sender shortStack 		minSize: 350@((14 * 5) + 16 + self optionalButtonHeight).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 09:50'!optionalAnnotationHeight	^ 10! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 08:31'!optionalButtonHeight	^ 10! !!Debugger methodsFor: 'initialize' stamp: 'ssa 9/3/2008 15:34'!optionalButtonPairs	"Actually, return triples.  In mvc (until someone deals with this) only the custom debugger-specific buttons are shown, but in morphic, the standard code-tool buttons are provided in addition to the custom buttons"	^ Smalltalk isMorphic		ifFalse:			[self customButtonSpecs]		ifTrue:			[]! !!Debugger methodsFor: 'initialize' stamp: 'mir 11/10/2003 15:13'!preDebugButtonQuads

	^Preferences eToyFriendly
		ifTrue: [
	 #(('Store log'		storeLog 	blue 	'write a log of the encountered problem' )
		('Abandon'		abandon 	black 	'abandon this execution by closing this window')
		('Debug'		debug 		red 		'bring up a debugger'))]
		ifFalse: [
	 #(('Proceed'		proceed 	blue 	'continue execution' )
		('Abandon'		abandon 	black 	'abandon this execution by closing this window')
		('Debug'		debug 		red 		'bring up a debugger'))]
! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:31'!release	self windowIsClosing.	super release.! !!Debugger methodsFor: 'initialize' stamp: 'sw 1/24/2001 21:22'!wantsOptionalButtons	"The debugger benefits so majorly from the optional buttons that we put them up regardless of the global setting.  Some traditionalists will want to change this method manually!!"	^ true! !!Debugger methodsFor: 'initialize' stamp: 'ajh 3/5/2004 21:31'!windowIsClosing	"My window is being closed; clean up. Restart the low space watcher."	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!Debugger methodsFor: 'accessing' stamp: 'di 10/9/1998 17:15'!contents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	contents == nil ifTrue: [^ String new].	^ contents copy! !!Debugger methodsFor: 'accessing' stamp: 'ajh 3/5/2004 01:20'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be  	updated. In this case, the retrieved information is the method of the  	selected context."	| selector classOfMethod category h ctxt |	contextStackIndex = 0		ifTrue: [^ false].	self selectedContext isExecutingBlock		ifTrue: [h := self selectedContext finalBlockHome.			h				ifNil: [self inform: 'Method not found for block, can''t edit'.					^ false].			(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: h]				ifFalse: [^ false]].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'.			^ false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector		ifNil: [^ false].	"compile cancelled"	contents := aText.	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifFalse: [		self inform: 'Method saved, but current context unchangedbecause of unwind error. Click OK to see error'.	] ifTrue: [		interruptedProcess			restartTopWith: (classOfMethod compiledMethodAt: selector);		 	stepToSendOrReturn.		contextVariablesInspector object: nil.		theMethodNode := Preferences browseWithPrettyPrint			ifTrue: [ctxt methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting]			ifFalse: [ctxt methodNode].		sourceMap := theMethodNode sourceMap.		tempNames := theMethodNode tempNames.	].	self resetContext: ctxt.	^ true! !!Debugger methodsFor: 'accessing'!contextVariablesInspector	"Answer the instance of Inspector that is providing a view of the 	variables of the selected context."	^contextVariablesInspector! !!Debugger methodsFor: 'accessing'!interruptedContext	"Answer the suspended context of the interrupted process."	^contextStackTop! !!Debugger methodsFor: 'accessing' stamp: 'hmm 7/16/2001 21:54'!labelString	^labelString! !!Debugger methodsFor: 'accessing' stamp: 'hmm 7/16/2001 21:54'!labelString: aString	labelString _ aString.	self changed: #relabel! !!Debugger methodsFor: 'accessing'!proceedValue: anObject 	"Set the value to be returned to the selected context when the interrupted 	process proceeds."	proceedValue _ anObject! !!Debugger methodsFor: 'accessing'!receiver	"Answer the receiver of the selected context, if any. Answer nil 	otherwise."	contextStackIndex = 0		ifTrue: [^nil]		ifFalse: [^self selectedContext receiver]! !!Debugger methodsFor: 'accessing'!receiverInspector	"Answer the instance of Inspector that is providing a view of the 	variables of the selected context's receiver."	^receiverInspector! !!Debugger methodsFor: 'notifier menu' stamp: 'BG 10/28/2003 20:40'!debug	"Open a full DebuggerView."	| topView |	topView _ self topView.	topView model: nil.  "so close won't release me."		topView controller controlTerminate.	topView deEmphasize; erase.	"a few hacks to get the scroll selection artifacts out when we got here by clicking in the list"	topView subViewWantingControl ifNotNil: [		topView subViewWantingControl controller controlTerminate	].	topView controller status: #closed.	self openFullNoSuspendLabel: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive.! !!Debugger methodsFor: 'context stack (message list)'!contextStackIndex	"Answer the index of the selected context."	^contextStackIndex! !!Debugger methodsFor: 'context stack (message list)'!contextStackList	"Answer the array of contexts."	^contextStackList! !!Debugger methodsFor: 'context stack (message list)' stamp: 'tk 4/17/1998 18:05'!expandStack	"A Notifier is being turned into a full debugger.  Show a substantial amount of stack in the context pane."	self newStack: (contextStackTop stackOfSize: 20).	contextStackIndex _ 0.	receiverInspector _ Inspector inspect: nil.	contextVariablesInspector _ ContextVariablesInspector inspect: nil.	proceedValue _ nil! !!Debugger methodsFor: 'context stack (message list)' stamp: 'ajh 9/25/2001 00:14'!fullyExpandStack	"Expand the stack to include all of it, rather than the first four or five	contexts."	self okToChange ifFalse: [^ self].	self newStack: contextStackTop contextStack.	self changed: #contextStackList! !!Debugger methodsFor: 'context stack (message list)'!messageListIndex	"Answer the index of the currently selected context."	^contextStackIndex! !!Debugger methodsFor: 'context stack (message list)' stamp: 'nk 2/20/2004 15:55'!selectedMessage	"Answer the source code of the currently selected context."	contents := theMethodNode sourceText.	^ contents := contents asText makeSelectorBold! !!Debugger methodsFor: 'context stack (message list)' stamp: 'ajh 9/7/2002 21:15'!selectedMessageName	"Answer the message selector of the currently selected context."	^self selectedContext methodSelector! !!Debugger methodsFor: 'context stack (message list)'!toggleContextStackIndex: anInteger 	"If anInteger is the same as the index of the selected context, deselect it. 	Otherwise, the context whose index is anInteger becomes the selected 	context."	self contextStackIndex: 		(contextStackIndex = anInteger			ifTrue: [0]			ifFalse: [anInteger])		oldContextWas:		(contextStackIndex = 0			ifTrue: [nil]			ifFalse: [contextStack at: contextStackIndex])! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 12/28/1999 13:04'!abandon	"abandon the debugger from its pre-debug notifier"	self abandon: self topView! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 12/28/1999 13:05'!abandon: aTopView 	"abandon the notifier represented by aTopView"	aTopView controller close! !!Debugger methodsFor: 'context stack menu' stamp: 'sd 3/4/2004 20:39'!askForCategoryIn: aClass default: aString	| categories index category |	categories := OrderedCollection with: 'new ...'. 	categories addAll: (aClass allMethodCategoriesIntegratedThrough: Object).		index := PopUpMenu withCaption: 'Please provide a good category for the new method!!' translated						chooseFrom: categories.	index = 0 ifTrue: [^ aString].	category := index = 1 ifTrue: [FillInTheBlank request: 'Enter category name:']						ifFalse: [categories at: index].	^ category isEmpty ifTrue: [^ aString] ifFalse: [category]! !!Debugger methodsFor: 'context stack menu' stamp: 'wod 5/15/1998 00:24'!browseMessages	"Present a menu of all messages sent by the currently selected message.	Open a message set browser of all implementors of the message chosen.	Do nothing if no message is chosen."	contextStackIndex = 0 ifTrue: [^ self].	super browseMessages.! !!Debugger methodsFor: 'context stack menu' stamp: 'wod 5/15/1998 00:23'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all implementors	of the message chosen."	contextStackIndex = 0 ifTrue: [^ self].	super browseSendersOfMessages! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 9/14/2001 00:26'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	VersionsBrowser		browseVersionsOf: (class compiledMethodAt: selector)		class: self selectedClass theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!Debugger methodsFor: 'context stack menu' stamp: 'tk 4/6/98 23:00'!buildMessageBrowser	"Create and schedule a message browser on the current method."	contextStackIndex = 0 ifTrue: [^ self].	^ Browser		openMessageBrowserForClass: self selectedClassOrMetaClass		selector: self selectedMessageName		editString: nil! !!Debugger methodsFor: 'context stack menu' stamp: 'tk 4/18/1998 09:24'!contextStackKey: aChar from: view	"Respond to a keystroke in the context list" 	| selector |	selector _ ContextStackKeystrokes at: aChar ifAbsent: [nil].	selector ifNil: [self messageListKey: aChar from: view]		ifNotNil: [self perform: selector]! !!Debugger methodsFor: 'context stack menu' stamp: 'ssa 9/3/2008 11:23'!contextStackMenu: aMenu shifted: shifted	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	^ shifted ifFalse: 		[self selectedContext selector = #doesNotUnderstand: ifTrue:			[aMenu 				add: 'implement in...' 				subMenu: (self populateImplementInMenu: (Smalltalk isMorphic ifTrue: [] ifFalse: [CustomMenu new]))				target: nil 				selector: nil 				argumentList: #(nil)].		aMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)step through (T)send (e)where (w)peel to first like thissenders of... (n)implementors of... (m)inheritance (i)versions (v)inst var refs...inst var defs...class var refs...class variablesclass refs (N)browse full (b)file out more...'		lines: #(8 12 14 17 20)		selections: #(fullStack restart proceed doStep stepIntoBlock send where peelToFirstbrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFull fileOutMessage shiftedYellowButtonActivity)]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse method (O)implementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert & remove from changesmore...' 	lines: #(5 7 10)	selections: #(classHierarchy browseClass 		openSingleMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 7/6/2003 21:06'!doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext newContext |	self okToChange ifFalse: [^ self].	self checkContextSelection.	currentContext _ self selectedContext.	newContext _ interruptedProcess completeStep: currentContext.	newContext == currentContext ifTrue: [		newContext _ interruptedProcess stepToSendOrReturn].	self contextStackIndex > 1		ifTrue: [self resetContext: newContext]		ifFalse: [newContext == currentContext				ifTrue: [self changed: #contentsSelection.						self updateInspectors]				ifFalse: [self resetContext: newContext]].! !!Debugger methodsFor: 'context stack menu' stamp: 'tk 4/15/1998 16:55'!down	"move down the context stack to the previous (enclosing) context"	self toggleContextStackIndex: contextStackIndex+1! !!Debugger methodsFor: 'context stack menu' stamp: 'tk 4/17/1998 18:06'!fullStack	"Change from displaying the minimal stack to a full one."	self contextStackList size > 20 "Already expanded"		ifTrue:			[self changed: #flash]		ifFalse:			[self contextStackIndex = 0 ifFalse: [				self toggleContextStackIndex: self contextStackIndex].			self fullyExpandStack]! !!Debugger methodsFor: 'context stack menu' stamp: 'sd 3/4/2004 20:39'!implement: aMessage inClass: aClass		| category |	category := self askForCategoryIn: aClass default: 'as yet unclassified'.	aClass compile: aMessage createStubMethod classified: category.	self selectedContext privRefreshWith: (aClass lookupSelector: aMessage selector).	self resetContext: self selectedContext.	self contextStackIndex: 1 oldContextWas: nil! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 3/16/2001 17:20'!messageListMenu: aMenu shifted: shifted	"The context-stack menu takes the place of the message-list menu in the debugger, so pass it on"	^ self contextStackMenu: aMenu shifted: shifted! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 3/4/2004 23:10'!peelToFirst	"Peel the stack back to the second occurance of the currently selected message.  Very useful for an infinite recursion.  Gets back to the second call so you can see one complete recursion cycle, and how it was called at the beginning.  Also frees a lot of space!!"	| upperGuy meth second ctxt |	contextStackIndex = 0 ifTrue: [^ Beeper beep].	"self okToChange ifFalse: [^ self]."	upperGuy _ contextStack at: contextStackIndex.	meth _ upperGuy method.	contextStackIndex+1 to: contextStack size do: [:ind |		(contextStack at: ind) method == meth ifTrue: [			second _ upperGuy.			upperGuy _ contextStack at: ind]].	second ifNil: [second _ upperGuy].	ctxt _ interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifTrue: [self resetContext: second]		ifFalse: [self resetContext: ctxt].  "unwind error"! !!Debugger methodsFor: 'context stack menu' stamp: 'ads 2/20/2003 08:46'!populateImplementInMenu: aMenu	| msg |	msg _ self selectedContext at: 1.	self selectedContext receiver class withAllSuperclasses do:		[:each |		aMenu add: each name target: self selector: #implement:inClass: argumentList: (Array with: msg with: each)].	^ aMenu! !!Debugger methodsFor: 'context stack menu' stamp: 'di 5/5/1998 00:07'!proceed	"Proceed execution of the receiver's model, starting after the expression at 	which an interruption occurred."	Smalltalk okayToProceedEvenIfSpaceIsLow ifTrue: [		self proceed: self topView].! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:29'!proceed: aTopView 	"Proceed from the interrupted state of the currently selected context. The 	argument is the topView of the receiver. That view is closed."	self okToChange ifFalse: [^ self].	self checkContextSelection.	self resumeProcess: aTopView! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 3/4/2004 23:14'!restart	"Proceed from the initial state of the currently selected context. The 	argument is a controller on a view of the receiver. That view is closed."	"Closing now depends on a preference #restartAlsoProceeds - hmm 9/7/2001 16:46"	| ctxt noUnwindError |	self okToChange ifFalse: [^ self].	self checkContextSelection.	ctxt _ interruptedProcess popTo: self selectedContext.	noUnwindError _ false.	ctxt == self selectedContext ifTrue: [		noUnwindError _ true.		interruptedProcess restartTop; stepToSendOrReturn].	self resetContext: ctxt.	(Preferences restartAlsoProceeds and: [noUnwindError]) ifTrue: [self proceed].! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:29'!send	"Send the selected message in the accessed method, and take control in 	the method invoked to allow further step or send."	self okToChange ifFalse: [^ self].	self checkContextSelection.	interruptedProcess step: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:46'!stepIntoBlock	"Send messages until you return to the present method context.	 Used to step into a block in the method."	interruptedProcess stepToHome: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!Debugger methodsFor: 'context stack menu' stamp: 'tk 4/15/1998 16:55'!up	"move up the context stack to the next (enclosed) context"	contextStackIndex > 1 ifTrue: [self toggleContextStackIndex: contextStackIndex-1]! !!Debugger methodsFor: 'context stack menu' stamp: 'nk 2/6/2001 19:34'!where	"Select the expression whose evaluation was interrupted."	selectingPC _ true.	self contextStackIndex: contextStackIndex oldContextWas: self selectedContext! !!Debugger methodsFor: 'code pane' stamp: 'tk 4/15/1998 18:31'!contentsSelection	^ self pcRange! !!Debugger methodsFor: 'code pane'!doItContext	"Answer the context in which a text selection can be evaluated."	contextStackIndex = 0		ifTrue: [^super doItContext]		ifFalse: [^self selectedContext]! !!Debugger methodsFor: 'code pane'!doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^self receiver! !!Debugger methodsFor: 'code pane' stamp: 'tk 5/2/1998 10:04'!pc	^ self pcRange! !!Debugger methodsFor: 'code pane' stamp: 'nk 2/20/2004 15:35'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap ifNil:		[sourceMap _ theMethodNode sourceMap.		tempNames _ theMethodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	(sourceMap size = 0 or: [ self selectedContext isDead ]) ifTrue: [^1 to: 0].	Smalltalk at: #RBProgramNode ifPresent:[:nodeClass|		(theMethodNode isKindOf: nodeClass) ifTrue: [			pc _ contextStackIndex = 1				ifTrue: [self selectedContext pc]				ifFalse: [self selectedContext previousPc].			i _ sourceMap findLast:[:pcRange | pcRange key <= pc].			i = 0 ifTrue:[^ 1 to: 0].			^ (sourceMap at: i) value		].	].	pc_ self selectedContext pc -		(("externalInterrupt" true and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!Debugger methodsFor: 'code pane menu' stamp: 'tk 4/17/1998 17:25'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	| result |	(#(debug proceed) includes: selector)		"When I am a notifier window"		ifTrue: [^ self perform: selector]		ifFalse: [result _ super perform: selector orSendTo: otherTarget.				selector == #doIt ifTrue: [					result ~~ #failedDoit ifTrue: [self proceedValue: result]].				^ result]! !!Debugger methodsFor: 'message category list'!selectedMessageCategoryName	"Answer the name of the message category of the message of the 	currently selected context."	^self selectedClass organization categoryOfElement: self selectedMessageName! !!Debugger methodsFor: 'class list'!selectedClass	"Answer the class in which the currently selected context's method was 	found."	^self selectedContext mclass! !!Debugger methodsFor: 'class list'!selectedClassOrMetaClass	"Answer the class in which the currently selected context's method was 	found."	^self selectedContext mclass! !!Debugger methodsFor: 'dependents access' stamp: 'di 1/14/1999 09:28'!step 	"Update the inspectors."	receiverInspector ifNotNil: [receiverInspector step].	contextVariablesInspector ifNotNil: [contextVariablesInspector step].! !!Debugger methodsFor: 'dependents access' stamp: 'hmm 7/15/2001 19:48'!updateInspectors 	"Update the inspectors on the receiver's variables."	receiverInspector == nil ifFalse: [receiverInspector update].	contextVariablesInspector == nil ifFalse: [contextVariablesInspector update]! !!Debugger methodsFor: 'dependents access' stamp: 'di 1/14/1999 09:25'!wantsSteps 	^ true! !!Debugger methodsFor: 'private' stamp: 'yo 8/12/2003 16:34'!checkContextSelection	contextStackIndex = 0 ifTrue: [self contextStackIndex: 1 oldContextWas: nil].! !!Debugger methodsFor: 'private' stamp: 'nk 2/20/2004 16:51'!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| newMethod |	contextStackIndex := anInteger.	anInteger = 0		ifTrue: [currentCompiledMethod := theMethodNode := tempNames := sourceMap := contents := nil.			self changed: #contextStackIndex.			self decorateButtons.			self contentsChanged.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^ self].	(newMethod := oldContext == nil					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)])		ifTrue: [tempNames := sourceMap := nil.			theMethodNode := Preferences browseWithPrettyPrint				ifTrue: [ 	self selectedContext methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting ]				ifFalse: [	self selectedContext methodNode ].			contents := self selectedMessage.			self contentsChanged.			self pcRange			"will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	self decorateButtons.	tempNames == nil		ifTrue: [tempNames := self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod		ifFalse: [self changed: #contentsSelection]! !!Debugger methodsFor: 'private'!externalInterrupt: aBoolean	externalInterrupt _ aBoolean ! !!Debugger methodsFor: 'private' stamp: 'tk 8/17/2000 15:36'!isolationRecoveryAdvice	"Return a notifier message string to be presented in case of recovery from recursive error by revoking the changes in an isolation layer.  This surely ranks as one of Squeak's longer help messages."	^ 'Warning!! You have encountered a recursive error situation.Don''t panic, but do read the following advice.  If you were just fooling around, the simplest thing to do is to quit and NOT save, and restart Squeak.  If you care about recovery, then read on...In the process of diagnosing one error, further errors occurred, making it impossible to give you a debugger to work with.  Squeak has jumped to an outer project where many of the objects and code changes that might have caused this problem are not involved in normal operation.  If you are looking at this window, chances are that this first level of recovery was successful.  If there are changes you care a lot about, try to save them now.  Then, hopefully, from the state in this debugger, you can determine what the problem was and fix it.  Do not save this image until you are confident of its recovery.You are no longer in the world that is damaged.  The two most likely causes of recursive errors are malformed objects (for instance a corrupt value encountered in any display of the desktop) and recurring code errors (such as a change that causes errors in any attempt to display the desktop).In the case of malformed objects, you can attempt to repair them by altering various bindings in the corrupted environment.  Open this debugger and examine the state of the objects closest to the error.In the case of code errors, note that you are no longer in a world where the erroneous code is in effect.  The only simple option available is for you to browse to the changeSet for the project in distress, and remove one or more of the changes (later it will be possible to edit the code remotely from here).If you feel you have repaired the problem, then you may proceed from this debugger.  This will put you back in the project that failed with the changes that failed for another try.  Note that the debugger from which you are proceeding is the second one that occurred;  you will likely find the first one waiting for you when you reenter the failed project!!  Also note that if your error occurred while displaying a morph, it may now be flagged as undisplayable (red with yellow cross);  if so, use the morph debug menu to choose ''start drawing again''.If you have not repaired the problem, you should close this debugger and delete the failed project after retrieving whatever may be of value in it.Good luck.	- The Squeak Fairy GodmotherPS:  If you feel you need the help of a quantum mechanic, do NOT close this window.  Instead, the best thing to do (after saving anything that seems safe to save) would be to use the ''save as...'' command in the world menu, and give it a new image name, such as OOPS.  There is a good chance that someone who knows their way around Squeak can help you out.'! !!Debugger methodsFor: 'private' stamp: 'jm 5/1/1998 16:20'!lowSpaceChoices	"Return a notifier message string to be presented when space is running low."	^ 'Warning!! Squeak is almost out of memory!!Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.Here are some suggestions: If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem. If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...   > Close any windows that are not needed.   > Get rid of some large objects (e.g., images).   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window. If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep. (Trying to show the full stack will definitely use up all remaining memory if the low-space problem is caused by an infinite recursion!!).'! !!Debugger methodsFor: 'private'!newStack: stack	| oldStack diff |	oldStack _ contextStack.	contextStack _ stack.	(oldStack == nil or: [oldStack last ~~ stack last])		ifTrue: [contextStackList _ contextStack collect: [:ctx | ctx printString].				^ self].	"May be able to re-use some of previous list"	diff _ stack size - oldStack size.	contextStackList _ diff <= 0		ifTrue: [contextStackList copyFrom: 1-diff to: oldStack size]		ifFalse: [diff > 1				ifTrue: [contextStack collect: [:ctx | ctx printString]]				ifFalse: [(Array with: stack first printString) , contextStackList]]! !!Debugger methodsFor: 'private' stamp: 'di 4/14/2000 16:24'!process: aProcess controller: aController context: aContext	^ self process: aProcess controller: aController context: aContext isolationHead: nil! !!Debugger methodsFor: 'private' stamp: 'ssa 9/3/2008 11:03'!process: aProcess controller: aController context: aContext isolationHead: projectOrNil	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [:c | c new close].	contents _ nil. 	interruptedProcess _ aProcess.	interruptedController _ aController.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	isolationHead _ projectOrNil.! !!Debugger methodsFor: 'private' stamp: 'ajh 9/25/2001 00:14'!resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method. There is room for much optimization here, first	to save recomputing the whole stack list (and text), and secondly to avoid	recomposing all that text (by editing the paragraph instead of recreating it)."	| oldContext |	oldContext _ self selectedContext.	contextStackTop _ aContext.	self newStack: contextStackTop contextStack.	self changed: #contextStackList.	self contextStackIndex: 1 oldContextWas: oldContext.	self changed: #content.! !!Debugger methodsFor: 'private' stamp: 'ssa 9/3/2008 11:04'!resumeProcess: aTopView 	Smalltalk isMorphic		ifFalse: [aTopView erase].	savedCursor		ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead		ifNotNil: [failedProject enterForEmergencyRecovery.			isolationHead invoke.			isolationHead _ nil].	interruptedProcess isTerminated ifFalse: [		Smalltalk isMorphic			ifTrue: []			ifFalse: [ScheduledControllers activeControllerNoTerminate: interruptedController andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil.	"Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: []		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.	"restart low space handler"	errorWasInUIProcess == false		ifFalse: [Processor terminateActive]! !!Debugger methodsFor: 'private'!selectedContext	contextStackIndex = 0		ifTrue: [^contextStackTop]		ifFalse: [^contextStack at: contextStackIndex]! !!Debugger methodsFor: 'as yet unclassified' stamp: 'nk 8/6/2003 13:52'!codePaneMenu: aMenu shifted: shifted	aMenu add: 'run to here' target: self selector: #runToSelection: argument: thisContext sender receiver selectionInterval.	aMenu addLine.	super codePaneMenu: aMenu shifted: shifted.	^aMenu.! !!Debugger methodsFor: 'as yet unclassified' stamp: 'nk 5/31/2003 07:38'!runToSelection: selectionInterval	| currentContext |	self pc first >= selectionInterval first ifTrue: [ ^self ].	currentContext _ self selectedContext.	[ currentContext == self selectedContext and: [ self pc first < selectionInterval first ] ] whileTrue: [ self doStep ].! !!Debugger methodsFor: 'breakpoints' stamp: 'emm 5/30/2002 10:08'!toggleBreakOnEntry	"Install or uninstall a halt-on-entry breakpoint"	| selectedMethod |	self selectedClassOrMetaClass isNil ifTrue:[^self].	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.	selectedMethod hasBreakpoint		ifTrue:			[BreakpointManager unInstall: selectedMethod]		ifFalse:			[BreakpointManager 				installInClass: self selectedClassOrMetaClass				selector: self selectedMessageName].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Debugger class	instanceVariableNames: ''!!Debugger class methodsFor: 'class initialization' stamp: 'hg 9/29/2001 20:24'!initialize	ErrorRecursion _ false.	ContextStackKeystrokes _ Dictionary new		at: $e put: #send;		at: $t put: #doStep;		at: $T put: #stepIntoBlock;		at: $p put: #proceed;		at: $r put: #restart;		at: $f put: #fullStack;		at: $w put: #where;		yourself.	"Debugger initialize"! !!Debugger class methodsFor: 'class initialization' stamp: 'BG 10/30/2003 20:37'!openContext: aContext label: aString contents: contentsStringOrNil	| isolationHead |	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		"(isolationHead _ CurrentProjectRefactoring currentIsolationHead)			ifNil: [self primitiveError: aString]			ifNotNil: [isolationHead revoke]"].	ErrorRecursion _ true.	self informExistingDebugger: aContext label: aString.	(Debugger context: aContext isolationHead: nil)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'instance creation' stamp: 'di 4/14/2000 16:29'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self context: aContext isolationHead: nil! !!Debugger class methodsFor: 'instance creation' stamp: 'di 4/14/2000 16:29'!context: aContext isolationHead: isolationHead	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext		isolationHead: isolationHead! !!Debugger class methodsFor: 'instance creation' stamp: 'hmm 8/3/2001 13:05'!informExistingDebugger: aContext label: aString	"Walking the context chain, we try to find out if we're in a debugger stepping situation.	If we find the relevant contexts, we must rearrange them so they look just like they would	if the methods were excuted outside of the debugger."	| ctx quickStepMethod oldSender baseContext |	ctx _ thisContext.	quickStepMethod _ ContextPart compiledMethodAt: #quickSend:to:with:super:.	[ctx sender == nil or: [ctx sender method == quickStepMethod]] whileFalse: [ctx _ ctx sender].	ctx sender == nil ifTrue: [^self].	baseContext _ ctx.	"baseContext is now the context created by the #quickSend... method."	oldSender _ ctx _ ctx sender home sender.	"oldSender is the context which originally sent the #quickSend... method"	[ctx == nil or: [ctx receiver isKindOf: self]] whileFalse: [ctx _ ctx sender].	ctx == nil ifTrue: [^self].	"ctx is the context of the Debugger method #doStep"	ctx receiver labelString: aString.	ctx receiver externalInterrupt: false; proceedValue: aContext receiver.	baseContext swapSender: baseContext sender sender sender.	"remove intervening contexts"	thisContext swapSender: oldSender.	"make myself return to debugger"	ErrorRecursion _ false.	^aContext! !!Debugger class methodsFor: 'opening' stamp: 'hg 10/2/2001 20:45'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.Preferences logDebuggerStackToFile ifTrue:	[(aString includesSubString: 'Space') & 		(aString includesSubString: 'low') ifTrue: [			Smalltalk logError: aString inContext: debugger interruptedContext to:'LowSpaceDebug.log']].	^ debugger		openNotifierContents: nil		label: aString! !!Debugger class methodsFor: 'opening' stamp: 'ssa 9/3/2008 11:06'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller |	Smalltalk isMorphic		ifTrue: []		ifFalse: [controller _ ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController]].	[		[	| debugger |			debugger _ self new process: process controller: controller context: context.			bool ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].			Smalltalk isMorphic				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	] fork.	process suspend.! !InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit lastJumpPc lastReturnPc limit hasValue blockStackBase'	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag'	poolDictionaries: ''	category: 'System-Compiler'!!Decompiler commentStamp: '<historical>' prior: 0!I decompile a method in three phases:	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)	Parser: prefix symbolic codes -> node tree (same as the compiler)	Printer: node tree -> text (done by the nodes)!!Decompiler methodsFor: 'initialize-release' stamp: 'ajh 7/21/2003 01:14'!initSymbols: aClass	| nTemps namedTemps |	constructor method: method class: aClass literals: method literals.	constTable _ constructor codeConstants.	instVars _ Array new: aClass instSize.	nTemps _ method numTemps.	namedTemps _ tempVars ifNil: [method tempNames].	tempVars _ (1 to: nTemps) collect:				[:i | i <= namedTemps size					ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]					ifFalse: [constructor codeTemp: i - 1]]! !!Decompiler methodsFor: 'initialize-release'!withTempNames: tempNameArray	tempVars _ tempNameArray! !!Decompiler methodsFor: 'control' stamp: 'tao 8/20/97 22:51'!blockForCaseTo: end	"Decompile a range of code as in statementsForCaseTo:, but return a block node."	| exprs block oldBase |	oldBase _ blockStackBase.	blockStackBase _ stack size.	exprs _ self statementsForCaseTo: end.	block _ constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase _ oldBase.	lastReturnPc _ -1.  "So as not to mislead outer calls"	^block! !!Decompiler methodsFor: 'control'!blockTo: end	"Decompile a range of code as in statementsTo:, but return a block node."	| exprs block oldBase |	oldBase _ blockStackBase.	blockStackBase _ stack size.	exprs _ self statementsTo: end.	block _ constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase _ oldBase.	lastReturnPc _ -1.  "So as not to mislead outer calls"	^block! !!Decompiler methodsFor: 'control'!checkForBlock: receiver	"We just saw a blockCopy: message. Check for a following block."	| savePc jump args argPos block |	receiver == constructor codeThisContext ifFalse: [^false].	savePc _ pc.	(jump _ self interpretJump) notNil		ifFalse:			[pc _ savePc.  ^nil].	"Definitely a block"	jump _ jump + pc.	argPos _ statements size.	[self willStorePop]		whileTrue:			[stack addLast: ArgumentFlag.  "Flag for doStore:"			self interpretNextInstructionFor: self].	args _ Array new: statements size - argPos.	1 to: args size do:  "Retrieve args"		[:i | args at: i put: statements removeLast.		(args at: i) scope: -1  "flag args as block temps"].	block _ self blockTo: jump.	stack addLast: (constructor codeArguments: args block: block).	^true! !!Decompiler methodsFor: 'control' stamp: 'tao 8/20/97 22:51'!statementsForCaseTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end.	Note that stack initially contains a CaseFlag which will be removed by	a subsequent Pop instruction, so adjust the StackPos accordingly."	| blockPos stackPos t |	blockPos _ statements size.	stackPos _ stack size - 1. "Adjust for CaseFlag"	[pc < end]		whileTrue:			[lastPc _ pc.  limit _ end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue _ stack size > stackPos)		ifTrue:			[statements addLast: stack removeLast].	lastJumpPc = lastPc ifFalse: [exit _ pc].	^self popTo: blockPos! !!Decompiler methodsFor: 'control'!statementsTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end."	| blockPos stackPos t |	blockPos _ statements size.	stackPos _ stack size.	[pc < end]		whileTrue:			[lastPc _ pc.  limit _ end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue _ stack size > stackPos)		ifTrue:			[statements addLast: stack removeLast].	lastJumpPc = lastPc ifFalse: [exit _ pc].	^self popTo: blockPos! !!Decompiler methodsFor: 'instruction decoding'!blockReturnTop	"No action needed"! !!Decompiler methodsFor: 'instruction decoding' stamp: 'md 11/14/2003 16:28'!case: dist	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"	| nextCase end thenJump stmtStream elements b node cases otherBlock |	nextCase _ pc + dist.	end _ limit.	"Now add CascadeFlag & keyValueBlock to statements"	statements addLast: stack removeLast.	stack addLast: CaseFlag. "set for next pop"	statements addLast: (self blockForCaseTo: nextCase).	stack last == CaseFlag		ifTrue: "Last case"			["ensure jump is within block (in case thenExpr returns wierdly I guess)"			stack removeLast. "get rid of CaseFlag"			thenJump _ exit <= end ifTrue: [exit] ifFalse: [nextCase].			stmtStream _ ReadStream on: (self popTo: stack removeLast).			elements _ OrderedCollection new.			b _ OrderedCollection new.			[stmtStream atEnd] whileFalse:				[(node _ stmtStream next) == CascadeFlag					ifTrue:						[elements addLast: (constructor							codeMessage: (constructor codeBlock: b returns: false)							selector: (constructor codeSelector: #-> code: #macro)							arguments: (Array with: stmtStream next)).						 b _ OrderedCollection new]					ifFalse: [b addLast: node]].			b size > 0 ifTrue: [self error: 'Bad cases'].			cases _ constructor codeBrace: elements.			otherBlock _ self blockTo: thenJump.			stack addLast:				(constructor					codeMessage: stack removeLast					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)					arguments: (Array with: cases with: otherBlock))]! !!Decompiler methodsFor: 'instruction decoding'!doDup	stack last == CascadeFlag		ifFalse:			["Save position and mark cascade"			stack addLast: statements size.			stack addLast: CascadeFlag].	stack addLast: CascadeFlag! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 2/5/2000 09:34'!doPop	stack isEmpty ifTrue:		["Ignore pop in first leg of ifNil for value"		^ self].	stack last == CaseFlag		ifTrue: [stack removeLast]		ifFalse: [statements addLast: stack removeLast].! !!Decompiler methodsFor: 'instruction decoding'!doStore: stackOrBlock	"Only called internally, not from InstructionStream. StackOrBlock is stack	for store, statements for storePop."	| var expr |	var _ stack removeLast.	expr _ stack removeLast.	stackOrBlock addLast: (expr == ArgumentFlag		ifTrue: [var]		ifFalse: [constructor codeAssignTo: var value: expr])! !!Decompiler methodsFor: 'instruction decoding'!jump: dist	exit _ pc + dist.	lastJumpPc _ lastPc! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 2/6/2000 08:46'!jump: dist if: condition	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump		elseJump condHasValue b isIfNil saveStack |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc _ lastPc.	elseStart _ pc + dist.	end _ limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign _ condition.	savePc _ pc.	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist].	pc _ savePc.	ifExpr _ stack removeLast.	(stack size > 0 and: [stack last == IfNilFlag])		ifTrue: [stack removeLast.  isIfNil _ true]		ifFalse: [isIfNil _ false].	saveStack _ stack.	stack _ OrderedCollection new.	thenBlock _ self blockTo: elseStart.	condHasValue _ hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			thenJump will jump to the beginning of the while expr.  In the case of			while's with a block in the condition, the while expr			should include more than just the last expression: find all the			statements needed by re-decompiling."			stack _ saveStack.			pc _ thenJump.			b _ self statementsTo: elsePc.			"discard unwanted statements from block"			b size - 1 timesRepeat: [statements removeLast].			statements addLast: (constructor					codeMessage: (constructor codeBlock: b returns: false)					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)					arguments: (Array with: thenBlock)).			pc _ elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock _ self blockTo: thenJump.			elseJump _ exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc				ifTrue: [pc _ lastPc].			isIfNil			ifTrue: [cond _ constructor						codeMessage: ifExpr ifNilReceiver						selector: (sign							ifTrue: [constructor codeSelector: #ifNotNil: code: #macro]							ifFalse: [constructor codeSelector: #ifNil: code: #macro])						arguments: (Array with: thenBlock)]			ifFalse: [cond _ constructor						codeMessage: ifExpr						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)						arguments:							(sign								ifTrue: [Array with: elseBlock with: thenBlock]								ifFalse: [Array with: thenBlock with: elseBlock])].			stack _ saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Decompiler methodsFor: 'instruction decoding'!methodReturnConstant: value	self pushConstant: value; methodReturnTop! !!Decompiler methodsFor: 'instruction decoding'!methodReturnReceiver	self pushReceiver; methodReturnTop! !!Decompiler methodsFor: 'instruction decoding' stamp: 'th 3/17/2000 20:48'!methodReturnTop	| last |	last _ stack removeLast "test test" asReturnNode.	stack size > blockStackBase  "get effect of elided pop before return"		ifTrue: [statements addLast: stack removeLast].	exit _ method size + 1.	lastJumpPc _ lastReturnPc _ lastPc.	statements addLast: last! !!Decompiler methodsFor: 'instruction decoding'!popIntoLiteralVariable: value	self pushLiteralVariable: value; doStore: statements! !!Decompiler methodsFor: 'instruction decoding'!popIntoReceiverVariable: offset	self pushReceiverVariable: offset; doStore: statements! !!Decompiler methodsFor: 'instruction decoding'!popIntoTemporaryVariable: offset	self pushTemporaryVariable: offset; doStore: statements! !!Decompiler methodsFor: 'instruction decoding'!pushActiveContext	stack addLast: constructor codeThisContext! !!Decompiler methodsFor: 'instruction decoding'!pushConstant: value	| node |	node _ value == true ifTrue: [constTable at: 2]		ifFalse: [value == false ifTrue: [constTable at: 3]		ifFalse: [value == nil ifTrue: [constTable at: 4]		ifFalse: [constructor codeAnyLiteral: value]]].	stack addLast: node! !!Decompiler methodsFor: 'instruction decoding'!pushLiteralVariable: assoc	stack addLast: (constructor codeAnyLitInd: assoc)! !!Decompiler methodsFor: 'instruction decoding'!pushReceiver	stack addLast: (constTable at: 1)! !!Decompiler methodsFor: 'instruction decoding'!pushReceiverVariable: offset	| var |	(var _ instVars at: offset + 1) == nil		ifTrue:			["Not set up yet"			instVars at: offset + 1 put: (var _ constructor codeInst: offset)].	stack addLast: var! !!Decompiler methodsFor: 'instruction decoding'!pushTemporaryVariable: offset	stack addLast: (tempVars at: offset + 1)! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 1/29/2000 08:38'!send: selector super: superFlag numArgs: numArgs	| args rcvr selNode msgNode messages |	args _ Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	rcvr _ stack removeLast.	superFlag ifTrue: [rcvr _ constructor codeSuper].	(selector == #blockCopy: and: [self checkForBlock: rcvr])		ifFalse:			[selNode _ constructor codeAnySelector: selector.			rcvr == CascadeFlag				ifTrue:					["May actually be a cascade or an ifNil: for value."					self willJumpIfFalse						ifTrue: "= generated by a case macro"							[selector == #= ifTrue:								[" = signals a case statement..."								statements addLast: args first.								stack addLast: rcvr. "restore CascadeFlag"								^ self].							selector == #== ifTrue:								[" == signals an ifNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							self error: 'bad case: ', selector]						ifFalse:							[(self willJumpIfTrue and: [selector == #==]) ifTrue:								[" == signals an ifNotNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							msgNode _ constructor codeCascadedMessage: selNode											arguments: args].					stack last == CascadeFlag						ifFalse:							["Last message of a cascade"							statements addLast: msgNode.							messages _ self popTo: stack removeLast.  "Depth saved by first dup"							msgNode _ constructor								codeCascade: stack removeLast								messages: messages]]				ifFalse:					[msgNode _ constructor								codeMessage: rcvr								selector: selNode								arguments: args].			stack addLast: msgNode]! !!Decompiler methodsFor: 'instruction decoding'!storeIntoLiteralVariable: assoc	self pushLiteralVariable: assoc; doStore: stack! !!Decompiler methodsFor: 'instruction decoding'!storeIntoReceiverVariable: offset	self pushReceiverVariable: offset; doStore: stack! !!Decompiler methodsFor: 'instruction decoding'!storeIntoTemporaryVariable: offset	self pushTemporaryVariable: offset; doStore: stack! !!Decompiler methodsFor: 'public access'!decompile: aSelector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	^self		decompile: aSelector		in: aClass		method: aMethod		using: DecompilerConstructor new! !!Decompiler methodsFor: 'public access' stamp: 'LC 1/6/2002 15:50'!decompileBlock: aBlock 	"Original version timestamp: sn 1/26/98 18:27	(Don't know who's sn?) "	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode tempNames home source |	(home _ aBlock home) ifNil: [^ nil].	method _ home method.	(homeClass _ home who first) == #unknown ifTrue: [^ nil].	constructor _ DecompilerConstructor new.	method fileIndex ~~ 0		ifTrue: ["got any source code?"			source _ [method getSourceFromFile]						on: Error						do: [:ex | ^ nil].			tempNames _ ([homeClass compilerClass new						parse: source						in: homeClass						notifying: nil]						on: (Smalltalk classNamed: 'SyntaxErrorNotification')						do: [:ex | ^ nil]) tempNames.			self withTempNames: tempNames].	self initSymbols: homeClass.	startpc _ aBlock startpc.	end _ (method at: startpc - 2)				\\ 16 - 4 * 256				+ (method at: startpc - 1) + startpc - 1.	stack _ OrderedCollection new: method frameSize.	statements _ OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode _ self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^ blockNode statements first! !!Decompiler methodsFor: 'public access'!tempAt: offset	"Needed by BraceConstructor<PopIntoTemporaryVariable"	^tempVars at: offset + 1! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 11:06'!convertToDoLoop	"If statements contains the pattern		var _ startExpr.		[var <= limit] whileTrue: [...statements... var _ var + incConst]	then replace this by		startExpr to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	initStmt variable scope: -1.  "Flag arg as block temp"	statements removeLast; removeLast; addLast: toDoStmt.	"Attempt further conversion of the pattern		limitVar _ limitExpr.		startExpr to: limitVar by: incConst do: [:var | ...statements...]	to		startExpr to: limitExpr by: incConst do: [:var | ...statements...]"	statements size < 2 ifTrue: [^ self].	limitStmt _ statements at: statements size-1.	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable isTemp		and: [limitStmt variable == toDoStmt arguments first		and: [self methodRefersOnlyOnceToTemp: limitStmt variable fieldOffset]]])		ifFalse: [^ self].	toDoStmt arguments at: 1 put: limitStmt value.	limitStmt variable scope: -2.  "Flag limit var so it won't print"	statements removeLast; removeLast; addLast: toDoStmt.! !!Decompiler methodsFor: 'private' stamp: 'ajh 11/15/2003 01:21'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor _ aConstructor.	method _ aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block _ self quickMethod]		ifFalse: 			[stack _ OrderedCollection new: method frameSize.			statements _ OrderedCollection new: 20.			super method: method pc: method initialPC.			block _ self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^constructor		codeMethod: aSelector		block: block		tempVars: tempVars		primitive: method primitive		class: aClass! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 08:49'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames _ Decompiler allInstVarNames.	code _ (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , (code copyFrom: 4 to: code size) , '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 10:55'!methodRefersOnlyOnceToTemp: offset	| nRefs byteCode extension scanner |	nRefs _ 0.	offset <= 15		ifTrue:			[byteCode _ 16 + offset.			(InstructionStream on: method) scanFor:				[:instr | instr = byteCode ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]]		ifFalse:			[extension _ 64 + offset.			scanner _ InstructionStream on: method.			scanner scanFor:				[:instr | (instr = 128 and: [scanner followingByte = extension])							ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]].	^ nRefs = 1! !!Decompiler methodsFor: 'private'!popTo: oldPos	| t |	t _ Array new: statements size - oldPos.	(t size to: 1 by: -1) do:		[:i | t at: i put: statements removeLast].	^t! !!Decompiler methodsFor: 'private' stamp: 'di 12/26/1998 21:29'!quickMethod	| |	method isReturnSpecial		ifTrue: [^ constructor codeBlock:				(Array with: (constTable at: method primitive - 255)) returns: true].	method isReturnField		ifTrue: [^ constructor codeBlock:				(Array with: (constructor codeInst: method returnField)) returns: true].	self error: 'improper short method'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Decompiler class	instanceVariableNames: ''!!Decompiler class methodsFor: 'class initialization' stamp: 'di 1/28/2000 22:21'!initialize	CascadeFlag _ 'cascade'.  "A unique object"	CaseFlag _ 'case'. "Ditto"	ArgumentFlag _ 'argument'.  "Ditto"	IfNilFlag _ 'ifNil'.  "Ditto"	"Decompiler initialize"! !ParseNode subclass: #DecompilerConstructor	instanceVariableNames: 'method instVars nArgs literalValues tempVars'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!DecompilerConstructor commentStamp: '<historical>' prior: 0!I construct the node tree for a Decompiler.!!DecompilerConstructor methodsFor: 'initialize-release'!method: aMethod class: aClass literals: literals	method _ aMethod.	instVars _ aClass allInstVarNames.	nArgs _ method numArgs.	literalValues _ literals! !!DecompilerConstructor methodsFor: 'constructor'!codeAnyLitInd: association	^VariableNode new		name: association key		key: association		index: 0		type: LdLitIndType! !!DecompilerConstructor methodsFor: 'constructor'!codeAnyLiteral: value	^LiteralNode new		key: value		index: 0		type: LdLitType! !!DecompilerConstructor methodsFor: 'constructor'!codeAnySelector: selector	^SelectorNode new		key: selector		index: 0		type: SendType! !!DecompilerConstructor methodsFor: 'constructor'!codeArguments: args block: block	^block arguments: args! !!DecompilerConstructor methodsFor: 'constructor'!codeAssignTo: variable value: expression	^AssignmentNode new variable: variable value: expression! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 3/3/2000 13:34'!codeBlock: statements returns: returns	^ BlockNode statements: statements returns: returns! !!DecompilerConstructor methodsFor: 'constructor'!codeBrace: elements	^BraceNode new elements: elements! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 11/19/1999 11:06'!codeCascade: receiver messages: messages	^ (BraceNode new matchBraceStreamReceiver: receiver messages: messages)		ifNil: [CascadeNode new receiver: receiver messages: messages]! !!DecompilerConstructor methodsFor: 'constructor'!codeCascadedMessage: selector arguments: arguments	^self		codeMessage: nil		selector: selector		arguments: arguments! !!DecompilerConstructor methodsFor: 'constructor'!codeConstants	"Answer with an array of the objects representing self, true, false, nil,	-1, 0, 1, 2."	^(Array with: NodeSelf with: NodeTrue with: NodeFalse with: NodeNil)		, ((-1 to: 2) collect: [:i | LiteralNode new key: i code: LdMinus1 + i + 1])! !!DecompilerConstructor methodsFor: 'constructor'!codeInst: index	^VariableNode new		name: (instVars at: index + 1)		index: index		type: LdInstType! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 2/5/2000 12:37'!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol _ selector key.	(node _ BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node _ self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: symbol precedence! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'ajh 11/15/2003 01:20'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| node methodTemps |	node _ self codeSelector: selector code: nil.	tempVars _ vars.	methodTemps _ tempVars select: [:t | t scope >= 0].	^MethodNode new		selector: node		arguments: (methodTemps copyFrom: 1 to: nArgs)		precedence: selector precedence		temporaries: (methodTemps copyFrom: nArgs + 1 to: methodTemps size)		block: block		encoder: (Encoder new initScopeAndLiteralTables					temps: tempVars					literals: literalValues					class: class)		primitive: primitive! !!DecompilerConstructor methodsFor: 'constructor'!codeSelector: sel code: code	^SelectorNode new key: sel code: code! !!DecompilerConstructor methodsFor: 'constructor'!codeSuper	^NodeSuper! !!DecompilerConstructor methodsFor: 'constructor'!codeTemp: index	^ TempVariableNode new		name: 't' , (index + 1) printString		index: index		type: LdTempType		scope: 0! !!DecompilerConstructor methodsFor: 'constructor'!codeTemp: index named: tempName	^ TempVariableNode new		name: tempName		index: index		type: LdTempType		scope: 0! !!DecompilerConstructor methodsFor: 'constructor'!codeThisContext	^NodeThisContext! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 1/28/2000 21:23'!decodeIfNilWithReceiver: receiver selector: selector arguments: arguments	selector == #ifTrue:ifFalse:		ifFalse: [^ nil].	(receiver isMessage: #==				receiver: nil				arguments: [:argNode | argNode == NodeNil])		ifFalse: [^ nil].	^ (MessageNode new			receiver: receiver			selector: (SelectorNode new key: #ifTrue:ifFalse: code: #macro)			arguments: arguments			precedence: 3)		noteSpecialSelector: #ifNil:ifNotNil:! !StandardSystemController subclass: #DeferredActionStandardSystemController	instanceVariableNames: 'queue'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Process Browser'!!DeferredActionStandardSystemController commentStamp: '<historical>' prior: 0!This is a StandardSystemController that can queue up objects to be evaluated before its control loop.!!DeferredActionStandardSystemController methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 22:28'!addDeferredUIMessage: valuableObject 	queue nextPut: valuableObject! !!DeferredActionStandardSystemController methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 22:27'!controlActivity	[queue isEmpty]		whileFalse: [queue next value].	^super controlActivity! !!DeferredActionStandardSystemController methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 22:28'!initialize	super initialize.	queue _ SharedQueue new.! !Object subclass: #Delay	instanceVariableNames: 'delayDuration resumptionTime delaySemaphore beingWaitedOn'	classVariableNames: 'AccessProtect ActiveDelay ActiveDelayStartTime SuspendedDelays TimingSemaphore'	poolDictionaries: ''	category: 'Kernel-Processes'!!Delay commentStamp: 'ls 10/14/2003 11:46' prior: 0!I am the main way that a process may pause for some amount of time.  The simplest usage is like this:	(Delay forSeconds: 5) wait.An instance of Delay responds to the message 'wait' by suspending the caller's process for a certain amount of time. The duration of the pause is specified when the Delay is created with the message forMilliseconds: or forSeconds:. A Delay can be used again when the current wait has finished. For example, a clock process might repeatedly wait on a one-second Delay.The maximum delay is (SmallInteger maxVal // 2) milliseconds, or about six days. A delay in progress when an image snapshot is saved is resumed when the snapshot is re-started. Delays work across millisecond clock roll-overs.For a more complex example, see  #testDelayOf:for:rect: .!]style[(763 22 2)f1,f1LDelay class testDelayOf:for:rect:;,f1!!Delay methodsFor: 'delaying' stamp: 'nk 3/14/2001 08:52'!isExpired	^delaySemaphore isSignaled.! !!Delay methodsFor: 'delaying' stamp: 'jm 9/12/97 09:10'!wait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	delaySemaphore wait.! !!Delay methodsFor: 'private' stamp: 'ar 7/18/2001 20:28'!activate	"Private!! Make the receiver the Delay to be awoken when the next timer interrupt occurs. This method should only be called from a block protected by the AccessProtect semaphore."	ActiveDelay _ self.	ActiveDelayStartTime _ Time millisecondClockValue.	ActiveDelayStartTime > resumptionTime ifTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty ifTrue:[			ActiveDelay _ nil.			ActiveDelayStartTime _ nil.		] ifFalse:[SuspendedDelays removeFirst activate].	] ifFalse:[		TimingSemaphore initSignals.		Delay primSignal: TimingSemaphore atMilliseconds: resumptionTime.	].! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 14:49'!adjustResumptionTimeOldBase: oldBaseTime newBase: newBaseTime	"Private!! Adjust the value of the system's millisecond clock at which this Delay will be awoken. Used to adjust resumption times after a snapshot or clock roll-over."	resumptionTime _ newBaseTime + (resumptionTime - oldBaseTime).! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 11:54'!resumptionTime	"Answer the value of the system's millisecondClock at which the receiver's suspended Process will resume."	^ resumptionTime! !!Delay methodsFor: 'private' stamp: 'jm 9/12/97 11:10'!schedule	"Private!! Schedule this Delay, but return immediately rather than waiting. The receiver's semaphore will be signalled when its delay duration has elapsed."	beingWaitedOn ifTrue: [self error: 'This Delay has already been scheduled.'].	AccessProtect critical: [		beingWaitedOn _ true.		resumptionTime _ Time millisecondClockValue + delayDuration.		ActiveDelay == nil			ifTrue: [self activate]			ifFalse: [				resumptionTime < ActiveDelay resumptionTime					ifTrue: [						SuspendedDelays add: ActiveDelay.						self activate]					ifFalse: [SuspendedDelays add: self]]].! !!Delay methodsFor: 'private' stamp: 'jm 9/12/97 08:56'!setDelay: millisecondCount forSemaphore: aSemaphore	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."	delayDuration _ millisecondCount.	delaySemaphore _ aSemaphore.	beingWaitedOn _ false.! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 11:54'!signalWaitingProcess	"The delay time has elapsed; signal the waiting process."	beingWaitedOn _ false.	delaySemaphore signal.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Delay class	instanceVariableNames: ''!!Delay class methodsFor: 'instance creation' stamp: 'jm 9/15/97 17:09'!forMilliseconds: anInteger	"Return a new Delay for the given number of milliseconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: anInteger		forSemaphore: Semaphore new! !!Delay class methodsFor: 'instance creation' stamp: 'di 6/16/1999 23:04'!forSeconds: aNumber	"Return a new Delay for the given number of seconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	aNumber < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: (aNumber * 1000) asInteger		forSemaphore: Semaphore new! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 14:59'!restoreResumptionTimes	"Private!! Restore the resumption times of all scheduled Delays after a snapshot or clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| newBaseTime |	newBaseTime _ Time millisecondClockValue.	SuspendedDelays do: [:d | d adjustResumptionTimeOldBase: 0 newBase: newBaseTime].	ActiveDelay == nil ifFalse: [		ActiveDelay adjustResumptionTimeOldBase: 0 newBase: newBaseTime.		ActiveDelay activate].! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:15'!saveResumptionTimes	"Private!! Record the resumption times of all Delays relative to a base time of zero. This is done prior to snapshotting or adjusting the resumption times after a clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| oldBaseTime |	oldBaseTime _ Time millisecondClockValue.	ActiveDelay == nil		ifFalse: [			oldBaseTime < ActiveDelayStartTime				ifTrue: [oldBaseTime _ ActiveDelayStartTime].  "clock rolled over"			ActiveDelay adjustResumptionTimeOldBase: oldBaseTime newBase: 0].	SuspendedDelays do:		[:d | d adjustResumptionTimeOldBase: oldBaseTime newBase: 0].! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:00'!shutDown	"Suspend the active delay, if any, before snapshotting. It will be reactived when the snapshot is resumed."	"Details: This prevents a timer interrupt from waking up the active delay in the midst snapshoting, since the active delay will be restarted when resuming the snapshot and we don't want to process the delay twice."	AccessProtect wait.	self primSignal: nil atMilliseconds: 0.	self saveResumptionTimes.! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:01'!startUp	"Restart active delay, if any, when resuming a snapshot."	self restoreResumptionTimes.	ActiveDelay == nil ifFalse: [ActiveDelay activate].	AccessProtect signal.! !!Delay class methodsFor: 'timer process' stamp: 'jm 9/11/97 15:15'!startTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	| p |	self primSignal: nil atMilliseconds: 0.	TimingSemaphore == nil		ifFalse: [TimingSemaphore terminateProcess].	TimingSemaphore _ Semaphore new.	AccessProtect _ Semaphore forMutualExclusion.	SuspendedDelays _ 		SortedCollection sortBlock: 			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	ActiveDelay _ nil.	p _ [self timerInterruptWatcher] newProcess.	p priority: Processor timingPriority.	p resume.! !!Delay class methodsFor: 'timer process' stamp: 'jm 9/11/97 15:13'!timerInterruptWatcher	"This loop runs in its own process. It waits for a timer interrupt and wakes up the active delay. Note that timer interrupts are only enabled when there are active delays."	[true] whileTrue: [		TimingSemaphore wait.		AccessProtect critical: [			ActiveDelay == nil ifFalse: [				ActiveDelay signalWaitingProcess.				Time millisecondClockValue < ActiveDelayStartTime					ifTrue: [  "clock wrapped"						self saveResumptionTimes.						self restoreResumptionTimes]].			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay _ nil.					ActiveDelayStartTime _ nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay class methodsFor: 'primitives' stamp: 'jm 9/11/97 10:54'!primSignal: aSemaphore atMilliseconds: aSmallInteger	"Signal the semaphore when the millisecond clock reaches the value of the second argument. Fail if the first argument is neither a Semaphore nor nil. Essential. See Object documentation whatIsAPrimitive."	<primitive: 136>	self primitiveFailed! !Array weakSubclass: #DependentsArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!DependentsArray commentStamp: '<historical>' prior: 0!An array of (weak) dependents of some object.!!DependentsArray methodsFor: 'copying' stamp: 'ar 2/24/2001 17:30'!copyWith: newElement 	"Re-implemented to not copy any niled out dependents"	^self class streamContents:[:s|		self do:[:item| s nextPut: item].		s nextPut: newElement].! !!DependentsArray methodsFor: 'copying' stamp: 'nk 3/11/2004 09:34'!size	^self inject: 0 into: [ :count :dep | dep ifNotNil: [ count _ count + 1 ]]! !!DependentsArray methodsFor: 'enumerating' stamp: 'nk 3/11/2004 09:34'!do: aBlock	"Refer to the comment in Collection|do:."	| dep |	1 to: self basicSize do:[:i|		(dep _ self at: i) ifNotNil:[aBlock value: dep]].! !!DependentsArray methodsFor: 'enumerating' stamp: 'ar 2/11/2001 01:50'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do:[:obj|		(aBlock value: obj)			ifTrue: [aStream nextPut: obj]].	^ aStream contents! !Warning subclass: #Deprecation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!Deprecation commentStamp: 'dew 5/21/2003 17:46' prior: 0!This Warning is signalled by methods which are deprecated.The use of Object>>#deprecatedExplanation: aString and Object>>#deprecated: aBlock explanation: aString is recommended.Idiom: Imagine I want to deprecate the message #foo.foo	^ 'foo'I can replace it with:foo	self deprecatedExplanation: 'The method #foo was not good. Use Bar>>newFoo instead.'	^ 'foo'Or, for certain cases such as when #foo implements a primitive, #foo can be renamed to #fooDeprecated.fooDeprecated	^ <primitive>foo	^ self deprecated: [self fooDeprecated] explanation: 'The method #foo was not good. Use Bar>>newFoo instead.'!MethodNode subclass: #DialectMethodNode	instanceVariableNames: 'dialect'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!DialectMethodNode commentStamp: '<historical>' prior: 0!The purpose of this class is to carry along with theinformation in a regular method node the further information that it was parsed from an laternate dialect of Squeak.  Which dialect that was is carried as a symbol in the dialect variable.!!DialectMethodNode methodsFor: 'as yet unclassified' stamp: 'di 4/13/2000 20:46'!setDialect: dialectSymbol	dialect _ dialectSymbol! !Parser subclass: #DialectParser	instanceVariableNames: 'dialect'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!DialectParser commentStamp: '<historical>' prior: 0!This Parser is part of a package designed to allow for experiments with alternatives to ST-80 syntax.  The particular alternative offered by this parser eliminates colons, left-arrows and up-arrows, and adds prefix keywords for common control constructs.ST-80									SQ-00-------									-------a + b between: c and: c + 4				a + b between (c) and (c + 4)a _ 3.0									Set a to 3.0^ self size + 3							Return self size + 3a > b									Test (a > b)	ifTrue: ['greater']						ifTrue ['greater']	ifFalse: ['less']							ifFalse ['less']1 to: 9 do:								Repeat (1) to (9) do	[:i | Transcript cr; show: i]				[Set i. | Transcript cr; show (i)]The use of prefix keywords is currently ad-hoc;  in other words they are built into the parser, and there is not a way to define a method pattern to include a prefix keyword.  Most of the work has been done to support this, though, as selectors can now have the form	#:prefix:kwd1:kwd2:and they will respond appropriately to #keywords and #numArgs.A test method in the class ensures that every method in the system can be pretty-printed in the alternative syntax, and that compiling the resulting text produces exactly the same bytecodes as the original method.!!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/23/2000 22:18'!assignment: varNode	" 'set' (var) 'to' (expression) => AssignmentNode."	| loc |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	varNode nowHasDef.	self advance.  " to "	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ AssignmentNode new				variable: varNode				value: parseNode				from: encoder.	^ true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/13/2000 00:34'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables |	variableNodes _ OrderedCollection new.	"Gather parameters."	(self matchToken: 'With') ifTrue:		[[self match: #period]			whileFalse: [variableNodes addLast: (encoder autoBind: self argumentName)]].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^ self expected: 'Period or right bracket'].	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/22/2000 17:11'!expression	^ self expressionWithInitialKeyword: ''! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 09:51'!expressionWithInitialKeyword: kwdIfAny	| checkpoint |	(hereType == #word and: [here = 'Set' and: [tokenType == #word]]) ifTrue:			["Parse assignment statement 'Set' var 'to' expression"			checkpoint _ self checkpoint.			self advance.			token = 'to'				ifTrue: [^ self assignment: self variable]				ifFalse: [self revertToCheckpoint: checkpoint]].	self matchKeyword		ifTrue: ["It's an initial keyword."				kwdIfAny isEmpty ifFalse: [self error: 'compiler logic error'].				^ self expressionWithInitialKeyword: ':' , self advance , ':'].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true initialKeyword: kwdIfAny)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/25/2000 22:36'!matchKeyword	"Return true if we are looking at a keyword (and its argument)."	hereType == #word ifFalse: [^ false].	tokenType == #leftParenthesis ifTrue: [^ true].	tokenType == #leftBracket ifTrue: [^ true].	tokenType == #leftBrace ifTrue: [^ true].	^ false! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/11/2000 15:27'!matchReturn	^ self matchToken: 'Answer'! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/22/2000 16:56'!messagePart: level repeat: repeat	^ self messagePart: level repeat: repeat initialKeyword: ''! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'hmm 7/16/2001 20:12'!messagePart: level repeat: repeat initialKeyword: kwdIfAny	| start receiver selector args precedence words keywordStart |	[receiver _ parseNode.	(self matchKeyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			selector nextPutAll: kwdIfAny.			args _ OrderedCollection new.			words _ OrderedCollection new.			[self matchKeyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance , ':'.					words addLast: (keywordStart to: hereEnd + requestorOffset).					self primaryExpression ifFalse: [^ self expected: 'Argument'].					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [(hereType == #word							and: [(#(leftParenthesis leftBracket leftBrace) includes: tokenType) not])						ifTrue: 							[start _ self startOfNextToken.							selector _ self advance.							args _ #().							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 5/30/2000 22:01'!newMethodNode	^ DialectMethodNode new setDialect: #SQ00! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 17:02'!parseArgsAndTemps: aString notifying: req 	"Parse the argument, aString, notifying req if an error occurs. Otherwise, 	answer a two-element Array containing Arrays of strings (the argument 	names and temporary variable names)."	aString == nil ifTrue: [^#()].	doitFlag _ false.		"Don't really know if a doit or not!!"	^self initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2) , self temporaries]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/11/2000 15:27'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector checkpoint |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	"NOTE: there is now an ambiguity between	keywordSelector (argName) -and- unarySelector (first expression).	Also, there is an amibuity (if there are no temp declarations) between	keywordSelector (argName) -and- PrefixKeyword (some expression).	We use duct tape for now."	(hereType == #word and: [tokenType == #leftParenthesis]) ifTrue:		[checkpoint _ self checkpoint.  "in case we have to back out"		selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #word				and: [tokenType == #leftParenthesis				and: [here first isLowercase						or: [(#('Test' 'Repeat' 'Answer') includes: here) not]]]]				whileTrue: 					[selector nextPutAll: self advance , ':'.  "selector part"					self advance.  "open paren"					(args size = 0 and: [tokenType ~~ #rightParenthesis]) ifTrue:						["This is really a unary selector on a method that						begins with a parenthesized expression.  Back out now"						self revertToCheckpoint: checkpoint.						^ {self advance asSymbol. {}. 1}].					args addLast: (encoder bindArg: self argumentName).			(self match: #rightParenthesis)						ifFalse: [^ self expected: 'right parenthesis']].			^ {selector contents asSymbol. args. 3}].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	^ self expected: 'Message pattern'! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'hmm 7/16/2001 20:09'!temporaries	" [ 'Use' (variable)* '.' ]"	| vars theActualText |	(self matchToken: #'Use') ifFalse: 		["no temps"		doitFlag ifTrue: [requestor				ifNil: [tempsMark _ 1]				ifNotNil: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ prevEnd+1.		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #period) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Period'! !TextStream subclass: #DialectStream	instanceVariableNames: 'dialect colorTable'	classVariableNames: 'ST80ColorTable Sq00ColorTable'	poolDictionaries: ''	category: 'System-Compiler'!!DialectStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 11:20'!colorTable	"Answer the table to use to determine colors"	^ colorTable ifNil:		[colorTable _ dialect == #SQ00			ifTrue:				[Sq00ColorTable]			ifFalse:				[ST80ColorTable]]! !!DialectStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 21:05'!withColor: colorSymbol emphasis: emphasisSymbol do: aBlock	"Evaluate the given block with the given color and style text attribute"	^ self withAttributes: {TextColor color: (Color perform: colorSymbol).							TextEmphasis perform: emphasisSymbol}		do: aBlock! !!DialectStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 11:30'!withStyleFor: elementType do: aBlock	"Evaluate aBlock with appropriate emphasis and color for the given elementType"	| colorAndStyle |	colorAndStyle _ self colorTable at: elementType.	^ self withColor: colorAndStyle first emphasis: colorAndStyle second do: aBlock! !!DialectStream methodsFor: 'access' stamp: 'di 4/5/2000 08:48'!dialect	^ dialect! !!DialectStream methodsFor: 'access' stamp: 'di 4/5/2000 08:48'!setDialect: dialectSymbol	dialect _ dialectSymbol! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DialectStream class	instanceVariableNames: ''!!DialectStream class methodsFor: 'class initialization' stamp: 'sw 5/20/2001 11:27'!initialize	"Initialize the color tables"	self initializeST80ColorTable.	self initializeSq00ColorTable."DialectStream initialize"! !!DialectStream class methodsFor: 'class initialization' stamp: 'sw 5/20/2001 21:09'!initializeST80ColorTable	"Initiialize the colors that characterize the ST80 dialect"	ST80ColorTable _ IdentityDictionary new.	#(	(temporaryVariable blue italic)		(methodArgument blue normal)		(methodSelector black bold)		(blockArgument red normal)		(comment brown normal)		(variable magenta normal)		(literal	tan normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				ST80ColorTable at: aTriplet first put: aTriplet allButFirst]"DialectStream initialize"! !!DialectStream class methodsFor: 'class initialization' stamp: 'sw 5/20/2001 11:25'!initializeSq00ColorTable	"Initiialize the colors that characterize the Sq00 dialect"	Sq00ColorTable _ IdentityDictionary new.	#(	(temporaryVariable black normal)		(methodArgument black normal)		(methodSelector black bold)		(blockArgument black normal)		(comment brown normal)		(variable black normal)		(literal	 blue normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				Sq00ColorTable at: aTriplet first put: aTriplet allButFirst]! !!DialectStream class methodsFor: 'instance creation' stamp: 'sw 5/20/2001 21:07'!dialect: dialectSymbol contents: blockWithArg 	"Evaluate blockWithArg on a DialectStream of the given description"	| stream |	stream _ self on: (Text new: 400).	stream setDialect: dialectSymbol.	blockWithArg value: stream.	^ stream contents! !Set subclass: #Dictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!Dictionary commentStamp: '<historical>' prior: 0!I represent a set of elements that can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to =. The external name is referred to as the key.  I inherit many operations from Set.!!Dictionary methodsFor: 'accessing'!associationAt: key 	^ self associationAt: key ifAbsent: [self errorKeyNotFound]! !!Dictionary methodsFor: 'accessing'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	| index assoc |	index _ self findElementOrNil: key.	assoc _ array at: index.	nil == assoc ifTrue: [ ^ aBlock value ].	^ assoc! !!Dictionary methodsFor: 'accessing' stamp: 'tk 4/9/1999 10:22'!associationDeclareAt: aKey	"Return an existing association, or create and return a new one.  Needed as a single message by ImageSegment.prepareToBeSaved."	| existing |	^ self associationAt: aKey ifAbsent: [		(Undeclared includesKey: aKey)			ifTrue: 				[existing _ Undeclared associationAt: aKey.				Undeclared removeKey: aKey.				self add: existing]			ifFalse: 				[self add: aKey -> false]]! !!Dictionary methodsFor: 'accessing' stamp: 'dvf 9/17/2003 16:03'!associations	"Answer a Collection containing the receiver's associations."	| out |	out _ WriteStream on: (Array new: self size).	self associationsDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'accessing'!at: key 	"Answer the value associated with the key."	^ self at: key ifAbsent: [self errorKeyNotFound]! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:59'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| assoc |	assoc _ array at: (self findElementOrNil: key).	assoc ifNil: [^ aBlock value].	^ assoc value! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:01'!at: key ifAbsentPut: aBlock 	"Return the value at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."	^ self at: key ifAbsent: [self at: key put: aBlock value]! !!Dictionary methodsFor: 'accessing' stamp: 'jm 5/15/1998 07:20'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v _ self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!Dictionary methodsFor: 'accessing' stamp: 'di 3/7/2001 15:29'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v _ self at: key ifAbsent: [^ nil].	v isInMemory ifFalse: [^ nil].	^ aBlock value: v! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:00'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index _ self findElementOrNil: key.	assoc _ array at: index.	assoc		ifNil: [self atNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!Dictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:16'!keyAtIdentityValue: value 	"Answer the key that is the external name for the argument, value. If 	there is none, answer nil.	Note: There can be multiple keys with the same value. Only one is returned."	^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound]! !!Dictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:16'!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	Note: There can be multiple keys with the same value. Only one is returned." 	self associationsDo: 		[:association | value == association value ifTrue: [^association key]].	^exceptionBlock value! !!Dictionary methodsFor: 'accessing'!keyAtValue: value 	"Answer the key that is the external name for the argument, value. If 	there is none, answer nil."	^self keyAtValue: value ifAbsent: [self errorValueNotFound]! !!Dictionary methodsFor: 'accessing' stamp: 'tk 2/18/97'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast." 	self associationsDo: 		[:association | value = association value ifTrue: [^association key]].	^exceptionBlock value! !!Dictionary methodsFor: 'accessing'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ Set new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!Dictionary methodsFor: 'accessing' stamp: 'sma 6/18/2000 12:56'!keysSortedSafely	"Answer a SortedCollection containing the receiver's keys."	| sortedKeys |	sortedKeys _ SortedCollection new: self size.	sortedKeys sortBlock:		[:x :y |  "Should really be use <obj, string, num> compareSafely..."		((x isString and: [y isString])			or: [x isNumber and: [y isNumber]])			ifTrue: [x < y]			ifFalse: [x class == y class				ifTrue: [x printString < y printString]				ifFalse: [x class name < y class name]]].	self keysDo: [:each | sortedKeys addLast: each].	^ sortedKeys reSort! !!Dictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 07:28'!values	"Answer a Collection containing the receiver's values."	| out |	out _ WriteStream on: (Array new: self size).	self valuesDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'testing' stamp: 'bf 8/20/1999 15:07'!hasContentsInExplorer	^self isEmpty not! !!Dictionary methodsFor: 'testing'!includes: anObject	self do: [:each | anObject = each ifTrue: [^true]].	^false! !!Dictionary methodsFor: 'testing' stamp: 'sw 2/14/2000 14:34'!includesIdentity: anObject	"Answer whether anObject is one of the values of the receiver.  Contrast #includes: in which there is only an equality check, here there is an identity check"	self do: [:each | anObject == each ifTrue: [^ true]].	^ false! !!Dictionary methodsFor: 'testing' stamp: 'RAA 8/23/2001 12:56'!includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."		self at: key ifAbsent: [^false].	^true! !!Dictionary methodsFor: 'testing' stamp: 'sw 3/23/2000 01:12'!keyForIdentity: anObject	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"	self associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc key]].	^ nil! !!Dictionary methodsFor: 'testing'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| count |	count _ 0.	self do: [:each | anObject = each ifTrue: [count _ count + 1]].	^count! !!Dictionary methodsFor: 'adding'!add: anAssociation	| index element |	index _ self findElementOrNil: anAssociation key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: anAssociation]		ifFalse: [element value: anAssociation value].	^ anAssociation! !!Dictionary methodsFor: 'adding' stamp: 'raok 12/17/2003 16:01'!addAll: aKeyedCollection	aKeyedCollection == self ifFalse: [		aKeyedCollection keysAndValuesDo: [:key :value |			self at: key put: value]].	^aKeyedCollection! !!Dictionary methodsFor: 'adding'!declare: key from: aDictionary 	"Add key to the receiver. If key already exists, do nothing. If aDictionary 	includes key, then remove it from aDictionary and use its association as 	the element of the receiver."	(self includesKey: key) ifTrue: [^ self].	(aDictionary includesKey: key)		ifTrue: 			[self add: (aDictionary associationAt: key).			aDictionary removeKey: key]		ifFalse: 			[self add: key -> nil]! !!Dictionary methodsFor: 'removing' stamp: 'di 4/4/2000 11:47'!keysAndValuesRemove: keyValueBlock	"Removes all entries for which keyValueBlock returns true."	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."	| removals |	removals _ OrderedCollection new.	self associationsDo:		[:assoc | (keyValueBlock value: assoc key value: assoc value)			ifTrue: [removals add: assoc key]]. 	removals do:		[:aKey | self removeKey: aKey]! !!Dictionary methodsFor: 'removing'!remove: anObject	self shouldNotImplement! !!Dictionary methodsFor: 'removing'!remove: anObject ifAbsent: exceptionBlock	self shouldNotImplement! !!Dictionary methodsFor: 'removing'!removeKey: key 	"Remove key from the receiver.	If key is not in the receiver, notify an error."	^ self removeKey: key ifAbsent: [self errorKeyNotFound]! !!Dictionary methodsFor: 'removing'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index assoc |	index _ self findElementOrNil: key.	assoc _ array at: index.	assoc == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^ assoc value! !!Dictionary methodsFor: 'removing'!removeUnreferencedKeys   "Undeclared removeUnreferencedKeys"	^ self unreferencedKeys do: [:key | self removeKey: key].! !!Dictionary methodsFor: 'removing' stamp: 'dvf 8/23/2003 11:51'!unreferencedKeys	"TextConstants unreferencedKeys"	| n |	^'Scanning for references . . .' 		displayProgressAt: Sensor cursorPoint		from: 0		to: self size		during: 			[:bar | 			n := 0.			self keys select: 					[:key | 					bar value: (n := n + 1).					(self systemNavigation allCallsOn: (self associationAt: key)) isEmpty]]! !!Dictionary methodsFor: 'enumerating'!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value 	associations)."	super do: aBlock! !!Dictionary methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection _ OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Dictionary methodsFor: 'enumerating'!do: aBlock	super do: [:assoc | aBlock value: assoc value]! !!Dictionary methodsFor: 'enumerating' stamp: 'ar 7/11/1999 08:04'!keysAndValuesDo: aBlock	^self associationsDo:[:assoc|		aBlock value: assoc key value: assoc value].! !!Dictionary methodsFor: 'enumerating'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | aBlock value: association key]! !!Dictionary methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a	new dictionary, only those associations for which aBlock evaluates to	true."	| newCollection |	newCollection _ self species new.	self associationsDo: 		[:each | 		(aBlock value: each value) ifTrue: [newCollection add: each]].	^newCollection! !!Dictionary methodsFor: 'enumerating' stamp: 'dtl 2/17/2003 09:48'!valuesDo: aBlock 	"Evaluate aBlock for each of the receiver's values."	self associationsDo: [:association | aBlock value: association value]! !!Dictionary methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:33'!flattenOnStream:aStream	^aStream writeDictionary:self.! !!Dictionary methodsFor: 'printing' stamp: 'sma 6/1/2000 09:52'!printElementsOn: aStream	aStream nextPut: $(.	self keysSortedSafely do:		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key); space].	aStream nextPut: $)! !!Dictionary methodsFor: 'printing'!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet _ true.	self associationsDo: 			[:each | 			noneYet				ifTrue: [noneYet _ false]				ifFalse: [aStream nextPut: $;].			aStream nextPutAll: ' add: '.			aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Dictionary methodsFor: 'private' stamp: 'raok 4/22/2002 12:09'!copy	"Must copy the associations, or later store will affect both theoriginal and the copy"	^ self shallowCopy withArray:		(array collect: [:assoc |			assoc ifNil: [nil]				ifNotNil: [Association key: assoc keyvalue: assoc value]])! !!Dictionary methodsFor: 'private'!errorKeyNotFound	self error: 'key not found'! !!Dictionary methodsFor: 'private'!errorValueNotFound	self error: 'value not found'! !!Dictionary methodsFor: 'private'!keyAt: index	"May be overridden by subclasses so that fixCollisions will work"	| assn |	assn _ array at: index.	assn == nil ifTrue: [^ nil]				ifFalse: [^ assn key]! !!Dictionary methodsFor: 'private'!noCheckAdd: anObject	"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.  9/7/96 tk"	array at: (self findElementOrNil: anObject key) put: anObject.	tally _ tally + 1! !!Dictionary methodsFor: 'private'!rehash	"Smalltalk rehash."	| newSelf |	newSelf _ self species new: self size.	self associationsDo: [:each | newSelf noCheckAdd: each].	array _ newSelf array! !!Dictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary methodsFor: 'private'!valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary 	"Support for coordinating class variable and global declarations	with variables that have been put in Undeclared so as to	redirect all references to the undeclared variable."	(aDictionary includesKey: aKey)		ifTrue: 			[self atNewIndex: index 				put: ((aDictionary associationAt: aKey) value: anObject).			aDictionary removeKey: aKey]		ifFalse: 			[self atNewIndex: index put: (Association key: aKey value: anObject)]! !!Dictionary methodsFor: 'user interface' stamp: 'tk 4/12/1998 08:54'!inspect	"Open a DictionaryInspector on the receiver.  Use basicInspect to get a normal (less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: true! !!Dictionary methodsFor: 'user interface' stamp: 'tk 4/12/1998 08:54'!inspectWithLabel: aLabel	"Open a DictionaryInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: true withLabel: aLabel! !!Dictionary methodsFor: '*Compiler' stamp: 'ar 5/17/2003 14:07'!bindingOf: varName	^self associationAt: varName ifAbsent:[nil]! !!Dictionary methodsFor: '*Compiler' stamp: 'ar 5/18/2003 20:33'!bindingsDo: aBlock	^self associationsDo: aBlock! !!Dictionary methodsFor: 'comparing' stamp: 'raok 6/10/2002 15:29'!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value".	(aDictionary isKindOf: Dictionary) ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Dictionary class	instanceVariableNames: ''!!Dictionary class methodsFor: 'instance creation'!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary _ self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}	{1->#a. 2->#b. 3->#c} as: NewDictionary	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}	{1->#a. 2->#b. 1->#c} as: NewDictionary"! !Inspector subclass: #DictionaryInspector	instanceVariableNames: 'keyArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!DictionaryInspector methodsFor: 'accessing'!fieldList	^ keyArray collect: [ :key | key printString ]! !!DictionaryInspector methodsFor: 'accessing'!inspect: aDictionary	"Initialize the receiver so that it is inspecting aDictionary. There is no 	current selection."	self initialize.	(aDictionary isKindOf: Dictionary) ifFalse:		[^ self error: 'DictionaryInspectors can only inspect dictionaries' ].	object _ aDictionary.	contents _ ''.	self calculateKeyArray! !!DictionaryInspector methodsFor: 'selecting' stamp: 'tk 4/11/1998 13:09'!addEntry: aKey	object at: aKey put: nil.	self calculateKeyArray.	selectionIndex _ keyArray indexOf: aKey.	self changed: #inspectObject.	self changed: #fieldList.	self update! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 3/8/2000 09:14'!calculateKeyArray	"Recalculate the KeyArray from the object being inspected"	keyArray _ object keysSortedSafely asArray.	selectionIndex _ 0.! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:25'!contentsIsString	"Hacked so contents empty when deselected"	^ (selectionIndex = 0)! !!DictionaryInspector methodsFor: 'selecting'!replaceSelectionValue: anObject	^ object at: (keyArray at: selectionIndex) put: anObject! !!DictionaryInspector methodsFor: 'selecting' stamp: 'ar 12/7/1999 18:12'!selection	selectionIndex = 0 ifTrue: [^ ''].	^ object at: (keyArray at: selectionIndex) ifAbsent:[nil]! !!DictionaryInspector methodsFor: 'selecting'!selectionUnmodifiable	"For dicionary inspectors, any selection is modifiable"	^ selectionIndex <= 0! !!DictionaryInspector methodsFor: 'menu' stamp: 'tk 4/12/1998 08:15'!addEntry	| newKey aKey |	newKey _ FillInTheBlank request:'Enter new key, then type RETURN.(Expression will be evaluated for value.)Examples:  #Fred    ''a string''   3+4'.	aKey _ Compiler evaluate: newKey.	object at: aKey put: nil.	self calculateKeyArray.	selectionIndex _ keyArray indexOf: aKey.	self changed: #inspectObject.	self changed: #fieldList.	self update! !!DictionaryInspector methodsFor: 'menu' stamp: 'ar 1/15/2001 18:37'!copyName	"Copy the name of the current variable, so the user can paste it into the window below and work with is.  If collection, do (xxx at: 1). "	| sel |	sel _ '(self at: ', 		(String streamContents: [:strm | (keyArray at: selectionIndex) storeOn: strm]) ,		')'.	Clipboard clipboardText: sel asText.	"no undo allowed"! !!DictionaryInspector methodsFor: 'menu' stamp: 'ssa 9/3/2008 11:06'!dictionaryMenu: aMenu	"Set up the key-list menu for a dictionary inspector"	aMenu title: 'Dictionary key'.	^ aMenu addList: #(		('inspect'						inspectSelection)		('copy name'					copyName)		('references'					selectionReferences)		('objects pointing to this value'	objectReferencesToSelection)		('senders of this key'			sendersOfSelectedKey)		-		('refresh view'					calculateKeyArray)		-		('add key'						addEntry)		('rename key'					renameEntry)		('remove'						removeSelection)		-		('basic inspect'					inspectBasic))! !!DictionaryInspector methodsFor: 'menu' stamp: 'tk 4/12/1998 08:19'!removeSelection	selectionIndex = 0 ifTrue: [^ self changed: #flash].	object removeKey: (keyArray at: selectionIndex).	selectionIndex _ 0.	contents _ ''.	self calculateKeyArray.	self changed: #inspectObject.	self changed: #fieldList.	self changed: #selection.	self changed: #selectionIndex.! !!DictionaryInspector methodsFor: 'menu' stamp: 'tk 10/18/2002 16:41'!renameEntry	| newKey aKey value |	value _ object at: (keyArray at: selectionIndex).	newKey _ FillInTheBlank request: 'Enter new key, then type RETURN.(Expression will be evaluated for value.)Examples:  #Fred    ''a string''   3+4'		 initialAnswer: (keyArray at: selectionIndex) printString.	aKey _ Compiler evaluate: newKey.	object removeKey: (keyArray at: selectionIndex).	object at: aKey put: value.	self calculateKeyArray.	selectionIndex _ keyArray indexOf: aKey.	self changed: #inspectObject.	self changed: #fieldList.	self update! !!DictionaryInspector methodsFor: 'menu' stamp: 'nk 6/26/2003 21:43'!selectionReferences	"Create a browser on all references to the association of the current selection."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	object class == MethodDictionary ifTrue: [^ self changed: #flash].	self systemNavigation browseAllCallsOn: (object associationAt: (keyArray at: selectionIndex)).! !!DictionaryInspector methodsFor: 'menu' stamp: 'wiz 5/16/2004 13:05'!sendersOfSelectedKey	"Create a browser on all senders of the selected key"	| aKey |	self selectionIndex = 0		ifTrue: [^ self changed: #flash].	((aKey := keyArray at: selectionIndex) isKindOf: Symbol)		ifFalse: [^ self changed: #flash].	object class == MethodDictionary		ifTrue: [^ self changed: #flash].	SystemNavigation default browseAllCallsOn: aKey! !ArrayedCollection subclass: #DirectoryEntry	instanceVariableNames: 'name creationTime modificationTime dirFlag fileSize'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!DirectoryEntry commentStamp: '<historical>' prior: 0!an entry in a directory; a reference to either a file or a directory.!!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!creationTime	"time the entry was created.  (what's its type?)"	^creationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!fileSize	"size of the entry, if it's a file"	^fileSize! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!isDirectory	"whether this entry represents a directory"	^dirFlag! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!modificationTime	"time the entry was last modified"	^modificationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!name	"name of the entry"	^name! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:29'!at: index	"compatibility interface"	"self halt: 'old-style access to DirectoryEntry'"	index = 1 ifTrue: [ ^self name ].	index = 2 ifTrue: [ ^self creationTime ].	index = 3 ifTrue: [ ^self modificationTime ].	index = 4 ifTrue:[ ^self isDirectory ].	index = 5 ifTrue:[ ^self fileSize ].	self error: 'invalid index specified'.! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:16'!size	^5! !!DirectoryEntry methodsFor: 'private-initialization' stamp: 'ls 7/15/1998 21:42'!privateName: name0  creationTime: creationTime0  modificationTime: modificationTime0  isDirectory: isDirectory0  fileSize: fileSize0	name _ name0.	creationTime _ creationTime0.	modificationTime _ modificationTime0.	dirFlag _ isDirectory0.	fileSize _ fileSize0.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DirectoryEntry class	instanceVariableNames: ''!!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:42'!fromArray: array	^self name: (array at: 1) creationTime: (array at: 2) modificationTime: (array at: 3) isDirectory: (array at: 4) fileSize: (array at: 5) ! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:41'!name: name0  creationTime: creationTime  modificationTime: modificationTime   isDirectory: isDirectory  fileSize: fileSize	^self new privateName: name0  creationTime: creationTime  modificationTime: modificationTime  isDirectory: isDirectory  fileSize: fileSize! !DisplayObject subclass: #DisplayMedium	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!DisplayMedium commentStamp: '<historical>' prior: 0!I am a display object which can both paint myself on a medium (displayOn: messages), and can act as a medium myself. My chief subclass is Form.!!DisplayMedium methodsFor: 'coloring'!fill: aRectangle fillColor: aForm 	"Replace a rectangular area of the receiver with the pattern described by 	aForm according to the rule over."	self fill: aRectangle rule: Form over fillColor: aForm! !!DisplayMedium methodsFor: 'coloring'!fill: aRectangle rule: anInteger fillColor: aForm 	"Replace a rectangular area of the receiver with the pattern described by 	aForm according to the rule anInteger."	self subclassResponsibility! !!DisplayMedium methodsFor: 'coloring'!fillBlack	"Set all bits in the receiver to black (ones)."	self fill: self boundingBox fillColor: Color black! !!DisplayMedium methodsFor: 'coloring'!fillBlack: aRectangle 	"Set all bits in the receiver's area defined by aRectangle to black (ones)."	self fill: aRectangle rule: Form over fillColor: Color black! !!DisplayMedium methodsFor: 'coloring'!fillColor: aColor	"Set all pixels in the receiver to the color.  Must be a correct color for this depth of medium.  TK 1 Jun 96"	self fill: self boundingBox fillColor: aColor! !!DisplayMedium methodsFor: 'coloring'!fillGray	"Set all bits in the receiver to gray."	self fill: self boundingBox fillColor: Color gray! !!DisplayMedium methodsFor: 'coloring'!fillGray: aRectangle	"Set all bits in the receiver's area defined by aRectangle to the gray mask."	self fill: aRectangle rule: Form over fillColor: Color gray! !!DisplayMedium methodsFor: 'coloring'!fillShape: aShapeForm fillColor: aColor	"Fill a region corresponding to 1 bits in aShapeForm with aColor"	^ self fillShape: aShapeForm fillColor: aColor at: 0@0! !!DisplayMedium methodsFor: 'coloring' stamp: 'ar 5/28/2000 12:06'!fillShape: aShapeForm fillColor: aColor at: location	"Fill a region corresponding to 1 bits in aShapeForm with aColor"	((BitBlt current destForm: self sourceForm: aShapeForm fillColor: aColor		combinationRule: Form paint		destOrigin: location + aShapeForm offset sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits! !!DisplayMedium methodsFor: 'coloring'!fillWhite	"Set all bits in the form to white."	self fill: self boundingBox fillColor: Color white.! !!DisplayMedium methodsFor: 'coloring'!fillWhite: aRectangle	"Set all bits in the receiver's area defined by aRectangle to white."	self fill: aRectangle rule: Form over fillColor: Color white.! !!DisplayMedium methodsFor: 'coloring'!fillWithColor: aColor	"Fill the receiver's bounding box with the given color."	self fill: self boundingBox fillColor: aColor.! !!DisplayMedium methodsFor: 'coloring' stamp: 'jm 6/18/1999 19:01'!reverse	"Change all the bits in the receiver that are white to black, and the ones 	that are black to white."	self fill: self boundingBox rule: Form reverse fillColor: (Color quickHighLight: self depth)! !!DisplayMedium methodsFor: 'coloring' stamp: 'jm 6/18/1999 19:00'!reverse: aRectangle	"Change all the bits in the receiver's area that intersects with aRectangle 	that are white to black, and the ones that are black to white."	self fill: aRectangle rule: Form reverse fillColor: (Color quickHighLight: self depth)! !!DisplayMedium methodsFor: 'coloring'!reverse: aRectangle fillColor: aMask		"Change all the bits in the receiver's area that intersects with aRectangle 	according to the mask. Black does not necessarily turn to white, rather it 	changes with respect to the rule and the bit in a corresponding mask 	location. Bound to give a surprise."	self fill: aRectangle rule: Form reverse fillColor: aMask! !!DisplayMedium methodsFor: 'bordering'!border: aRectangle width: borderWidth 	"Paint a border whose rectangular area is defined by aRectangle. The 	width of the border of each side is borderWidth. Uses black for 	drawing the border."	self border: aRectangle width: borderWidth fillColor: Color black.! !!DisplayMedium methodsFor: 'bordering'!border: aRectangle width: borderWidth fillColor: aHalfTone 	"Paint a border whose rectangular area is defined by aRectangle. The 	width of the border of each side is borderWidth. Uses aHalfTone for 	drawing the border."	self border: aRectangle		widthRectangle: 			(Rectangle				left: borderWidth				right: borderWidth				top: borderWidth				bottom: borderWidth)		rule: Form over		fillColor: aHalfTone! !!DisplayMedium methodsFor: 'bordering'!border: aRectangle width: borderWidth rule: combinationRule fillColor: aHalfTone 	"Paint a border whose rectangular area is defined by aRectangle. The 	width of the border of each side is borderWidth. Uses aHalfTone for 	drawing the border."	self border: aRectangle		widthRectangle: 			(Rectangle				left: borderWidth				right: borderWidth				top: borderWidth				bottom: borderWidth)		rule: combinationRule		fillColor: aHalfTone! !!DisplayMedium methodsFor: 'bordering'!border: aRectangle widthRectangle: insets rule: combinationRule fillColor: aHalfTone	"Paint a border whose rectangular area is defined by aRectangle. The 	width of each edge of the border is determined by the four coordinates 	of insets. Uses aHalfTone and combinationRule for drawing the border."	(aRectangle areasOutside: (aRectangle insetBy: insets)) do:		[:edgeStrip | self fill: edgeStrip rule: combinationRule fillColor: aHalfTone]! !!DisplayMedium methodsFor: 'displaying'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm 	"Make up a BitBlt table and copy the bits."	self subclassResponsibility! !!DisplayMedium methodsFor: 'displaying' stamp: 'hmm 9/16/2000 21:27'!deferUpdatesIn: aRectangle while: aBlock	"DisplayScreen overrides with something more involved..."	^aBlock value! !!DisplayMedium methodsFor: 'displaying'!drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Draw line by copying the argument, sourceForm, starting at location 	beginPoint and ending at endPoint, clipped by the rectangle, clipRect. 	The rule and mask for copying are the arguments anInteger and aForm."	self subclassResponsibility! !Object subclass: #DisplayObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!DisplayObject commentStamp: '<historical>' prior: 0!The abstract protocol for most display primitives that are used by Views for presenting information on the screen.!!DisplayObject methodsFor: 'accessing'!extent	"Answer the point that represents the width and height of the receiver's 	bounding box."	^self boundingBox extent! !!DisplayObject methodsFor: 'accessing'!height	"Answer the number that represents the height of the receiver's 	bounding box."	^self boundingBox height! !!DisplayObject methodsFor: 'accessing'!offset	"Answer the amount by which the receiver should be offset when it is 	displayed or its position is tested."	self subclassResponsibility! !!DisplayObject methodsFor: 'accessing'!offset: aPoint 	"Set the amount by which the receiver's position is offset."	^self! !!DisplayObject methodsFor: 'accessing'!relativeRectangle	"Answer a Rectangle whose top left corner is the receiver's offset position 	and whose width and height are the same as the receiver."	^Rectangle origin: self offset extent: self extent! !!DisplayObject methodsFor: 'accessing'!width	"Answer the number that represents the width of the receiver's bounding 	box."	^self boundingBox width! !!DisplayObject methodsFor: 'truncation and round off'!rounded	"Convert the offset of the receiver to integer coordinates."	self offset: self offset rounded! !!DisplayObject methodsFor: 'transforming'!align: alignmentPoint with: relativePoint 	"Translate the receiver's offset such that alignmentPoint aligns with 	relativePoint."	self offset: (self offset translateBy: relativePoint - alignmentPoint)! !!DisplayObject methodsFor: 'transforming'!scaleBy: aPoint 	"Scale the receiver's offset by aPoint."	self offset: (self offset scaleBy: aPoint)! !!DisplayObject methodsFor: 'transforming'!translateBy: aPoint 	"Translate the receiver's offset."	self offset: (self offset translateBy: aPoint)! !!DisplayObject methodsFor: 'display box access'!boundingBox	"Answer the rectangular area that represents the boundaries of the 	receiver's space of information."	^self computeBoundingBox! !!DisplayObject methodsFor: 'display box access'!center	^ self boundingBox center! !!DisplayObject methodsFor: 'display box access'!computeBoundingBox	"Answer the rectangular area that represents the boundaries of the 	receiver's area for displaying information. This is the primitive for 	computing the area if it is not already known."	self subclassResponsibility! !!DisplayObject methodsFor: 'display box access'!initialExtent	"Included here for when a FormView is being opened	as a window.  (4@4) covers border widths."	^ self extent + (4@4) ! !!DisplayObject methodsFor: 'displaying-generic'!displayAt: aDisplayPoint 	"Display the receiver located at aDisplayPoint with default settings for 	the displayMedium, rule and halftone."	self displayOn: Display		at: aDisplayPoint		clippingBox: Display boundingBox		rule: Form over		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium	"Simple default display in order to see the receiver in the upper left 	corner of screen."	self displayOn: aDisplayMedium at: 0 @ 0! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium at: aDisplayPoint 	"Display the receiver located at aDisplayPoint with default settings for 	rule and halftone."	self displayOn: aDisplayMedium		at: aDisplayPoint		clippingBox: aDisplayMedium boundingBox		rule: Form over		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle 	"Display the receiver located at aDisplayPoint with default settings for 	rule and halftone. Information to be displayed must be confined to the 	area that intersects with clipRectangle."	self displayOn: aDisplayMedium		at: aDisplayPoint		clippingBox: clipRectangle		rule: Form over		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the basic display primitive for graphic display objects. Display 	the receiver located at aDisplayPoint with rule, ruleInteger, and mask, 	aForm. Information to be displayed must be confined to the area that 	intersects with clipRectangle."	self subclassResponsibility! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium at: aDisplayPoint rule: ruleInteger	"Display the receiver located at aPoint with default setting for the 	halftone and clippingBox."	self displayOn: aDisplayMedium		at: aDisplayPoint		clippingBox: aDisplayMedium boundingBox		rule: ruleInteger		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle 	"Display primitive for the receiver where a DisplayTransformation is 	provided as an argument. Alignment is defaulted to the receiver's 	rectangle. Information to be displayed must be confined to the area that 	intersects with clipRectangle."	self displayOn: aDisplayMedium		transformation: displayTransformation		clippingBox: clipRectangle		align: self relativeRectangle center		with: self relativeRectangle center		rule: Form over		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint 	"Display primitive where a DisplayTransformation is provided as an 	argument, rule is over and mask is Form black. Information to be 	displayed must be confined to the area that intersects with clipRectangle."	self displayOn: aDisplayMedium		transformation: displayTransformation		clippingBox: clipRectangle		align: alignmentPoint		with: relativePoint		rule: Form over		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Display the receiver where a DisplayTransformation is provided as an 	argument, rule is ruleInteger and mask is aForm. Translate by 	relativePoint-alignmentPoint. Information to be displayed must be 	confined to the area that intersects with clipRectangle."	| absolutePoint |	absolutePoint _ displayTransformation applyTo: relativePoint.	self displayOn: aDisplayMedium		at: (absolutePoint - alignmentPoint) 		clippingBox: clipRectangle 		rule: ruleInteger 		fillColor: aForm ! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle fixedPoint: aPoint 	"Display the receiver where a DisplayTransformation is provided as an 	argument, rule is over and mask is Form black. No translation. 	Information to be displayed must be confined to the area that intersects 	with clipRectangle."	self displayOn: aDisplayMedium		transformation: displayTransformation		clippingBox: clipRectangle		align: aPoint		with: aPoint		rule: Form over		fillColor: nil! !!DisplayObject methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Display the receiver where a DisplayTransformation is provided as an 	argument, rule is ruleInteger and mask is aForm. No translation. 	Information to be displayed must be confined to the area that intersects 	with clipRectangle."	self displayOn: aDisplayMedium		transformation: displayTransformation		clippingBox: clipRectangle		align: self relativeRectangle origin		with: self relativeRectangle origin		rule: ruleInteger		fillColor: aForm! !!DisplayObject methodsFor: 'displaying-generic'!displayOnPort: aPort 	self displayOnPort: aPort at: 0@0! !!DisplayObject methodsFor: 'displaying-generic' stamp: 'jm 10/21/97 16:56'!displayOnPort: port at: location rule: rule	port copyForm: self to: location rule: rule.! !!DisplayObject methodsFor: 'displaying-generic'!followCursor	"Just show the Form following the mouse. 6/21/96 tk"	Cursor blank showWhile:		[self follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]]! !!DisplayObject methodsFor: 'displaying-Display'!display 	"Display the receiver on the Display at location 0,0."	self displayOn: Display! !!DisplayObject methodsFor: 'displaying-Display'!follow: locationBlock while: durationBlock   "Move an image around on the Display. Restore the background   continuously without causing flashing. The argument, locationBlock,   supplies each new location, and the argument, durationBlock, supplies   true to continue, and then false to stop.   8/20/96 sw: call follow:while:bitsBehind: to do the real work.  Note that thmethod   now returns the final bits behind as method value."    | bitsBehind loc |   bitsBehind _ Form fromDisplay: ((loc _ locationBlock value) extent: self extent).   ^ self follow: locationBlock while: durationBlock bitsBehind: bitsBehind startingLoc: loc! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'ar 5/28/2000 12:06'!follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |   location _ loc.   rect1 _ location extent: self extent.   save1 _ initialBitsBehind.   save1Blt _ BitBlt current toForm: save1.   buffer _ Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"   bufferBlt _ BitBlt current toForm: buffer.   Display deferUpdates: true.   self displayOn: Display at: location rule: Form paint.   Display deferUpdates: false; forceToScreen: (location extent: self extent).   [durationBlock value] whileTrue: [		newLoc _ locationBlock value.		newLoc ~= location ifTrue: [			rect2 _ newLoc extent: self extent.			bothRects _ rect1 merge: rect2.			(rect1 intersects: rect2)				ifTrue: [  "when overlap, buffer background for both rectangles"					bufferBlt copyFrom: bothRects in: Display to: 0@0.					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.					"now buffer is clean background; get new bits for save1"					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.					self displayOnPort: bufferBlt at: rect2 origin - bothRects origin rule: Form paint.					Display deferUpdates: true.					Display copy: bothRects from: 0@0 in: buffer rule: Form over.					Display deferUpdates: false; forceToScreen: bothRects]				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"					Display deferUpdates: true.					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.					save1Blt copyFrom: rect2 in: Display to: 0@0.					self displayOn: Display at: newLoc rule: Form paint.					Display deferUpdates: false; 						forceToScreen: (location extent: save1 extent); 						forceToScreen: (newLoc extent: self extent)].			location _ newLoc.			rect1 _ rect2]].	^ save1 displayOn: Display at: location! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'di 9/12/97 11:09'!isTransparent	^ false! !!DisplayObject methodsFor: 'displaying-Display'!slideFrom: startPoint to: stopPoint nSteps: nSteps 	"does not display at the first point, but does at the last"	| i p delta |	i_0.  p_ startPoint.	delta _ (stopPoint-startPoint) // nSteps.	^ self follow: [p_ p+delta]		while: [(i_i+1) < nSteps]! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'jm 10/22/97 07:43'!slideFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs	"Slide this object across the display over the given number of steps, pausing for the given number of milliseconds after each step."	"Note: Does not display at the first point, but does at the last."	| i p delta |	i _ 0.	p _ startPoint.	delta _ (stopPoint - startPoint) / nSteps asFloat.	^ self		follow: [(p _ p + delta) truncated]		while: [			(Delay forMilliseconds: milliSecs) wait.			(i _ i + 1) < nSteps]! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'di 10/19/97 12:05'!slideFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs andStay: stayAtEnd	"Does not display at the first point, but does at the last.	Moreover, if stayAtEnd is true, it leaves the dragged image at the stopPoint"	| i done |	i _ 0.	^ self follow: [startPoint + ((stopPoint-startPoint) * i // nSteps)]		while: [milliSecs ifNotNil: [(Delay forMilliseconds: milliSecs) wait].				((done _ (i _ i+1) > nSteps) and: [stayAtEnd])					ifTrue: [^ self "Return without clearing the image"].				done not]! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'sr 6/6/2000 05:37'!slideWithFirstFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs 	"Slide this object across the display over the given number of steps, 	pausing for the given number of milliseconds after each step."	"Note: Does display at the first point and at the last."	| i p delta |	i _ 0.	delta _ stopPoint - startPoint / nSteps asFloat.	p _ startPoint - delta.	^ self follow: [(p _ p + delta) truncated]		while: 			[(Delay forMilliseconds: milliSecs) wait.			(i _ i + 1) <= nSteps]! !!DisplayObject methodsFor: 'fileIn/Out'!writeOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeOn: file.	file close" | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!DisplayObject methodsFor: 'fileIn/Out' stamp: 'tk 2/19/1999 07:20'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeUncompressedOn: file.	file close" | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeUncompressedOnFileNamed: 'test.form'.	(Form fromBinaryStream: (FileStream oldFileNamed: 'test.form')) display]."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DisplayObject class	instanceVariableNames: ''!!DisplayObject class methodsFor: 'fileIn/Out' stamp: 'mdr 8/31/2000 19:11'!collectionFromFileNamed: fileName 	"Answer a collection of Forms read from the external file 	named fileName. The file format is: fileCode, {depth, extent, offset, bits}."	| formList f fileCode |	formList _ OrderedCollection new.	f _ (FileStream readOnlyFileNamed: fileName) binary.	fileCode _ f next.	fileCode = 1		ifTrue: [			[f atEnd] whileFalse: [formList add: (self new readFromOldFormat: f)]]		ifFalse: [			fileCode = 2 ifFalse: [self error: 'unknown Form file format'. ^ formList].			[f atEnd] whileFalse: [formList add: (self new readFrom: f)]].	f close.	^ formList! !!DisplayObject class methodsFor: 'fileIn/Out'!writeCollection: coll onFileNamed: fileName 	"Saves a collection of Forms on the file fileName in the format:		fileCode, {depth, extent, offset, bits}."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	coll do: [:f | f writeOn: file].	file close" | f c | c _ OrderedCollection new.[(f _ Form fromUser) boundingBox area>25] whileTrue: [c add: f].Form writeCollection: c onFileNamed: 'test.forms'.c _ Form collectionFromFileNamed: 'test.forms'.1 to: c size do: [:i | (c at: i) displayAt: 0@(i*100)]."! !CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'bitBlt lineY runX foregroundColor backgroundColor fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!DisplayScanner commentStamp: '<historical>' prior: 0!My instances are used to scan text and display it on the screen or in a hidden form.!!DisplayScanner methodsFor: 'scanning' stamp: 'ar 12/17/2001 13:28'!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY _ lineY.		runX _ destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!DisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 19:26'!setDestForm: df	bitBlt setDestForm: df.! !!DisplayScanner methodsFor: 'private' stamp: 'di 9/3/2000 16:13'!setFont 	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[destY _ lineY + line baseline - font ascent]! !!DisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:42'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex_ lastIndex + 1.	^false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:24'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	^ true ! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:24'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:20'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount _ spaceCount + 1.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!plainTab	| oldX |	oldX _ destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	alignment = Justified ifTrue:[		"Make a local copy of stop conditions so we don't modify the default"		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!tab	self plainTab.	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'BG 12/15/2003 13:02'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset _ 0@0.	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX _ (runX _ leftMargin).			line _ aParagraph lines at: lineIndex.			lineHeight _ line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex _ line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun _ text runLengthFor: line first].			destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength _ leftInRun.			runStopIndex _ lastIndex + (runLength - 1) min: line last.			leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).			spaceCount _ 0.			done _ false.			string _ text string.			self handleIndentation.			[done] whileFalse:[				startIndex _ lastIndex.				lastPos _ destX@destY.				stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].			fillBlt == nil ifFalse:				[kern ~= 0                           ifTrue: [destX := destX - kern].				fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY _ lineY + lineHeight]]! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'BEO 8/7/2002 16:13'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule:		((Display depth = 1)			ifTrue:				[aParagraph rule]			ifFalse:				[Form paint]).	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (bitBlt destForm pixelValueFor: aParagraph foregroundColor)).	bitBlt clipRect: clippingRectangle! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DisplayScanner class	instanceVariableNames: ''!!DisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:39'!defaultFont	^ TextStyle defaultFont! !Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox extraRegions'	classVariableNames: 'DeferringUpdates DisplayChangeSignature ScreenSave'	poolDictionaries: ''	category: 'Graphics-Display Objects'!!DisplayScreen commentStamp: '<historical>' prior: 0!There is only one instance of me, Display. It is a global and is used to handle general user requests to deal with the whole display screen. 	Although I offer no protocol, my name provides a way to distinguish this special instance from all other Forms. This is useful, for example, in dealing with saving and restoring the system.	To change the depth of your Display...		Display newDepth: 16.		Display newDepth: 8.		Display newDepth: 1.Valid display depths are 1, 2, 4, 8, 16 and 32.  It is suggested that you run with your monitors setting the same, for better speed and color fidelity.  Note that this can add up to 4Mb for the Display form.  Finally, note that newDepth: ends by executing a 'ControlManager restore' which currently terminates the active process, so nothing that follows in the doit will get executed.Depths 1, 2, 4 and 8 bits go through a color map to put color on the screen, but 16 and 32-bit color use the pixel values directly for RGB color (5 and 8 bits per, respectivlely).  The color choice an be observed by executing Color fromUser in whatever depth you are using.!!DisplayScreen methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:07'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf 	(BitBlt current		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) copyBits! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:07'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map	((BitBlt current		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits! !!DisplayScreen methodsFor: 'displaying' stamp: 'jm 5/22/1998 01:23'!flash: aRectangle 	"Flash the area of the screen defined by the given rectangle."	self reverse: aRectangle.	self forceDisplayUpdate.	(Delay forMilliseconds: 100) wait.	self reverse: aRectangle.	self forceDisplayUpdate.! !!DisplayScreen methodsFor: 'other'!boundingBox	clippingBox == nil		ifTrue: [clippingBox _ super boundingBox].	^ clippingBox! !!DisplayScreen methodsFor: 'other'!clippingTo: aRect do: aBlock	"Display clippingTo: Rectangle fromUser do:	[ScheduledControllers restore: Display fullBoundingBox]"	| saveClip |	saveClip _ clippingBox.	clippingBox _ aRect.	aBlock value.	clippingBox _ saveClip! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:16'!deferUpdates: aBoolean	| wasDeferred |	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer whether updates were deferred before if the primitive succeeds, nil if it fails."	wasDeferred _ DeferringUpdates == true.	DeferringUpdates _ aBoolean.	^(self primitiveDeferUpdates: aBoolean) ifNotNil: [wasDeferred]! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 2/2/2001 10:14'!deferUpdatesIn: aRectangle while: aBlock	| result |	(self deferUpdates: true) ifTrue: [^aBlock value].	result _ aBlock value.	self deferUpdates: false.	self forceToScreen: aRectangle.	^result! !!DisplayScreen methodsFor: 'other' stamp: 'jm 5/21/1998 23:48'!forceDisplayUpdate	"On platforms that buffer screen updates, force the screen to be updated immediately. On other platforms, or if the primitive is not implemented, do nothing."	<primitive: 231>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'other' stamp: 'jm 5/19/1998 17:50'!forceToScreen: aRectangle	"Force the given rectangular section of the Display to be copied to the screen. The primitive call does nothing if the primitive is not implemented. Typically used when the deferUpdates flag in the virtual machine is on; see deferUpdates:."	self primShowRectLeft: aRectangle left		right: aRectangle right		top: aRectangle top		bottom: aRectangle bottom.! !!DisplayScreen methodsFor: 'other'!fullBoundingBox	^ super boundingBox! !!DisplayScreen methodsFor: 'other'!fullScreen   "Display fullScreen"	ScreenSave notNil ifTrue: [Display _ ScreenSave].	clippingBox _ super boundingBox! !!DisplayScreen methodsFor: 'other' stamp: 'sd 6/7/2003 19:46'!fullScreenMode: aBoolean	"On platforms that support it, set full-screen mode to the value of the argument. (Note: you'll need to restore the Display after calling this primitive."	"Display fullScreenMode: true. Display newDepth: Display depth"	<primitive: 233>	self primitiveFailed! !!DisplayScreen methodsFor: 'other'!height	^ self boundingBox height! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/5/1999 23:44'!newDepth: pixelSize"	Display newDepth: 8.	Display newDepth: 1."	(self supportsDisplayDepth: pixelSize)		ifFalse:[^self inform:'Display depth ', pixelSize printString, ' is not supported on this system'].	self newDepthNoRestore: pixelSize.	self restore.! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:14'!primitiveDeferUpdates: aBoolean	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer the receiver if the primitive succeeds, nil if it fails."	<primitive: 126>	^ nil  "answer nil if primitive fails"! !!DisplayScreen methodsFor: 'other'!replacedBy: aForm do: aBlock	"Permits normal display to draw on aForm instead of the display."	ScreenSave _ self.	Display _ aForm.	aBlock value.	Display _ self.	ScreenSave _ nil.! !!DisplayScreen methodsFor: 'other' stamp: 'BG 10/28/2003 20:53'!restore	Smalltalk isMorphic		ifTrue: []		ifFalse: [ScheduledControllers unCacheWindows; restore].! !!DisplayScreen methodsFor: 'other' stamp: 'BG 10/28/2003 20:53'!restoreAfter: aBlock	"Evaluate the block, wait for a mouse click, and then restore the screen."	aBlock value.	Sensor waitButton.	Smalltalk isMorphic		ifTrue: []		ifFalse: [(ScheduledControllers restore; activeController) view emphasize]! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/17/2001 21:02'!supportedDisplayDepths	"Return all pixel depths supported on the current host platform."	^#(1 2 4 8 16 32 -1 -2 -4 -8 -16 -32) select: [:d | self supportsDisplayDepth: d]! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/5/1999 23:45'!supportsDisplayDepth: pixelDepth	"Return true if this pixel depth is supported on the current host platform.	Primitive. Optional."	<primitive: 91>	^#(1 2 4 8 16 32) includes: pixelDepth! !!DisplayScreen methodsFor: 'other'!usableArea	"Answer the usable area of the receiver.  5/22/96 sw."	^ self boundingBox deepCopy! !!DisplayScreen methodsFor: 'other'!width	^ self boundingBox width! !!DisplayScreen methodsFor: 'private'!beDisplay	"Primitive. Tell the interpreter to use the receiver as the current display 	image. Fail if the form is too wide to fit on the physical display. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 102>	self primitiveFailed! !!DisplayScreen methodsFor: 'private' stamp: 'di 3/3/1999 10:00'!copyFrom: aForm	"Take on all state of aForm, with complete sharing"	super copyFrom: aForm.	clippingBox _ super boundingBox! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/25/2000 23:43'!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^self findAnyDisplayDepthIfNone:[		"Ugh .... now this is a biggie - a system that does not support		any of the Squeak display depths at all."		Smalltalk			logError:'Fatal error: This system has no support for any display depth at all.'			inContext: thisContext			to: 'SqueakDebug.log'.		Smalltalk quitPrimitive. "There is no way to continue from here"	].! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/17/2001 21:03'!findAnyDisplayDepthIfNone: aBlock	"Return any display depth that is supported on this system.	If there is none, evaluate aBlock."	#(1 2 4 8 16 32 -1 -2 -4 -8 -16 -32) do:[:bpp|		(self supportsDisplayDepth: bpp) ifTrue:[^bpp].	].	^aBlock value! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/17/2001 15:44'!newDepthNoRestore: pixelSize	"Change depths.  Check if there is enough space!!  , di"	| area need |	pixelSize = depth ifTrue: [^ self  "no change"].	pixelSize abs < self depth ifFalse:		["Make sure there is enough space"		area _ Display boundingBox area. "pixels"		Smalltalk isMorphic ifFalse:			[ScheduledControllers scheduledWindowControllers do:				[:aController | "This should be refined..."				aController view cacheBitsAsTwoTone ifFalse:					[area _ area + aController view windowBox area]]].		need _ (area * (pixelSize abs - self depth) // 8)  "new bytes needed"				+ Smalltalk lowSpaceThreshold.		(Smalltalk garbageCollectMost <= need			and: [Smalltalk garbageCollect <= need])			ifTrue: [self error: 'Insufficient free space']].	self setExtent: self extent depth: pixelSize.	Smalltalk isMorphic ifFalse: [ScheduledControllers updateGray].	DisplayScreen startUp! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. Do nothing if it fails. "	<primitive: 127>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. If this fails, retry integer coordinates."	<primitive: 127>	"if this fails, coerce coordinates to integers and try again"	self primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded.! !!DisplayScreen methodsFor: 'private' stamp: 'RAA 11/27/1999 15:48'!setExtent: aPoint depth: bitsPerPixel  "DisplayScreen startUp"	"This method is critical.  If the setExtent fails, there will be no	proper display on which to show the error condition..."	"ar 5/1/1999: ... and that is exactly why we check for the available display depths first."	"RAA 27 Nov 99 - if depth and extent are the same and acceptable, why go through this.	also - record when we change so worlds can tell if it is time to repaint"	(depth == bitsPerPixel and: [aPoint = self extent and: 					[self supportsDisplayDepth: bitsPerPixel]]) ifFalse: [		bits _ nil.  "Free up old bitmap in case space is low"		DisplayChangeSignature _ (DisplayChangeSignature ifNil: [0]) + 1.		(self supportsDisplayDepth: bitsPerPixel)			ifTrue:[super setExtent: aPoint depth: bitsPerPixel]			ifFalse:["Search for a suitable depth"					super setExtent: aPoint depth: self findAnyDisplayDepth].	].	clippingBox _ super boundingBox! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:07'!release	"I am no longer Display. Release any resources if necessary"! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 11:25'!shutDown 	"Minimize Display memory saved in image"	self setExtent: 240@120 depth: depth! !!DisplayScreen methodsFor: 'testing' stamp: 'ar 5/25/2000 23:34'!isDisplayScreen	^true! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:01'!defaultBitBltClass	"Return the BitBlt version to use when I am active"	^BitBlt! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'BG 10/29/2003 08:33'!defaultCanvasClass	"Return the WarpBlt version to use when I am active"	^BitBlt! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:01'!defaultWarpBltClass	"Return the WarpBlt version to use when I am active"	^WarpBlt! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DisplayScreen class	instanceVariableNames: ''!!DisplayScreen class methodsFor: 'display box access'!boundingBox	"Answer the bounding box for the form representing the current display 	screen."	^Display boundingBox! !!DisplayScreen class methodsFor: 'display box access' stamp: 'BG 10/28/2003 20:54'!checkForNewScreenSize	"Check whether the screen size has changed and if so take appropriate actions"	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].	DisplayScreen startUp.	Smalltalk isMorphic		ifTrue:			[]		ifFalse:			[ScheduledControllers restore; searchForActiveController]! !!DisplayScreen class methodsFor: 'snapshots'!actualScreenSize	<primitive: 106>	^ 640@480! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 5/28/2000 11:26'!shutDown 	"Minimize Display memory saved in image"	Display shutDown.! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 5/17/2001 15:50'!startUp  "DisplayScreen startUp"	Display setExtent: self actualScreenSize depth: Display nativeDepth.	Display beDisplay! !DisplayObject subclass: #DisplayText	instanceVariableNames: 'text textStyle offset form foreColor backColor'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Display Objects'!!DisplayText commentStamp: '<historical>' prior: 0!I represent Text whose emphasis changes are mapped to a set of fonts. My instances have an offset used in determining screen placement for displaying. They get used two different ways in the system. In the user interface, they mainly hold onto some text which is viewed by some form of ParagraphEditor. However, as a DisplayObject, they may need to display efficiently, so my instances have a cache for the bits.!!DisplayText methodsFor: 'accessing'!alignedTo: alignPointSelector	"Return a copy with offset according to alignPointSelector which is one of...	#(topLeft, topCenter, topRight, leftCenter, center, etc)"	| boundingBox |	boundingBox _ 0@0 corner: self form extent.	^ self shallowCopy offset: (0@0) - (boundingBox perform: alignPointSelector)! !!DisplayText methodsFor: 'accessing'!fontsUsed	"Return a list of all fonts used currently in this text.  8/19/96 tk"	^ text runs values asSet collect: [:each | textStyle fontAt: each]! !!DisplayText methodsFor: 'accessing'!form 	"Answer the form into which the receiver's display bits are cached."	form == nil ifTrue: [self composeForm].	^form! !!DisplayText methodsFor: 'accessing'!lineGrid	"Answer the relative space between lines of the receiver's text."	^textStyle lineGrid! !!DisplayText methodsFor: 'accessing'!numberOfLines 	"Answer the number of lines of text in the receiver."	^self height // text lineGrid! !!DisplayText methodsFor: 'accessing'!offset 	"Refer to the comment in DisplayObject|offset."	^offset! !!DisplayText methodsFor: 'accessing'!offset: aPoint 	"Refer to the comment in DisplayObject|offset:."	offset _ aPoint! !!DisplayText methodsFor: 'accessing'!string	"Answer the string of the characters displayed by the receiver."	^text string! !!DisplayText methodsFor: 'accessing'!text 	"Answer the text displayed by the receiver."	^text! !!DisplayText methodsFor: 'accessing'!text: aText 	"Set the receiver to display the argument, aText."		text _ aText.	form _ nil.	self changed.	! !!DisplayText methodsFor: 'accessing'!textStyle 	"Answer the style by which the receiver displays its text."	^textStyle! !!DisplayText methodsFor: 'accessing'!textStyle: aTextStyle 	"Set the style by which the receiver should display its text."	textStyle _ aTextStyle.	form _ nil.	self changed.	! !!DisplayText methodsFor: 'displaying' stamp: 'yo 6/23/2003 20:05'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"For TT font, rule 34 is used if possible."	"Refer to the comment in 	DisplayObject|displayOn:at:clippingBox:rule:mask:."	| form1 rule |	form1 _ self form.	rule _ (ruleInteger = Form over and: [backColor isTransparent])				ifTrue: [form1 depth = 32 ifTrue: [rule _ 34] ifFalse: [Form paint]]				ifFalse: [ruleInteger].	form1 depth = 32 ifTrue: [rule _ 34].	form1		displayOn: aDisplayMedium		at: aDisplayPoint + offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm! !!DisplayText methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Refer to the comment in 	DisplayObject|displayOn:transformation:clippingBox:align:with:rule:mask:."	| absolutePoint |	absolutePoint _ displayTransformation applyTo: relativePoint.	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.	self displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!DisplayText methodsFor: 'displaying'!displayOnPort: aPort at: location	self form displayOnPort: aPort at: location + offset! !!DisplayText methodsFor: 'display box access'!boundingBox 	"Refer to the comment in DisplayObject|boundingBox."	^self form boundingBox! !!DisplayText methodsFor: 'display box access'!computeBoundingBox 	"Compute minimum enclosing rectangle around characters."	| character font width carriageReturn lineWidth lineHeight |	carriageReturn _ Character cr.	width _ lineWidth _ 0.	font _ textStyle defaultFont.	lineHeight _ textStyle lineGrid.	1 to: text size do: 		[:i | 		character _ text at: i.		character = carriageReturn		  ifTrue: 			[lineWidth _ lineWidth max: width.			lineHeight _ lineHeight + textStyle lineGrid.			width _ 0]		  ifFalse: [width _ width + (font widthOf: character)]].	lineWidth _ lineWidth max: width.	^offset extent: lineWidth @ lineHeight! !!DisplayText methodsFor: 'converting' stamp: 'tk 10/21/97 12:28'!asParagraph	"Answer a Paragraph whose text and style are identical to that of the 	receiver."	| para |	para _ Paragraph withText: text style: textStyle.	para foregroundColor: foreColor backgroundColor: backColor.	backColor isTransparent ifTrue: [para rule: Form paint].	^ para! !!DisplayText methodsFor: 'private' stamp: 'BG 10/28/2003 20:54'!composeForm		Smalltalk isMorphic		ifTrue:			[]		ifFalse: [form _ self asParagraph asForm]! !!DisplayText methodsFor: 'private'!setText: aText textStyle: aTextStyle offset: aPoint	text _ aText.	textStyle _ aTextStyle.	offset _ aPoint.	form _ nil! !!DisplayText methodsFor: 'color'!backgroundColor	backColor == nil ifTrue: [^ Color transparent].	^ backColor! !!DisplayText methodsFor: 'color'!foregroundColor	foreColor == nil ifTrue: [^ Color black].	^ foreColor! !!DisplayText methodsFor: 'color'!foregroundColor: cf backgroundColor: cb	foreColor _ cf.	backColor _ cb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DisplayText class	instanceVariableNames: ''!!DisplayText class methodsFor: 'instance creation'!text: aText 	"Answer an instance of me such that the text displayed is aText 	according to the system's default text style."	^self new		setText: aText		textStyle: DefaultTextStyle copy		offset: 0 @ 0! !!DisplayText class methodsFor: 'instance creation'!text: aText textStyle: aTextStyle 	"Answer an instance of me such that the text displayed is aText 	according to the style specified by aTextStyle."	^self new		setText: aText		textStyle: aTextStyle		offset: 0 @ 0! !!DisplayText class methodsFor: 'instance creation'!text: aText textStyle: aTextStyle offset: aPoint 	"Answer an instance of me such that the text displayed is aText 	according to the style specified by aTextStyle. The display of the 	information should be offset by the amount given as the argument, 	aPoint."	^self new		setText: aText		textStyle: aTextStyle		offset: aPoint! !!DisplayText class methodsFor: 'examples' stamp: 'tk 11/28/2001 16:03'!example	"Continually prints two lines of text wherever you point with the cursor.  Terminate by pressing any button on the	mouse."	| tx |	tx _ 'this is a line of characters andthis is the second line.' asDisplayText.	tx foregroundColor: Color black backgroundColor: Color transparent.	tx _ tx alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[tx displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !View subclass: #DisplayTextView	instanceVariableNames: 'rule mask editParagraph centered'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Views'!!DisplayTextView commentStamp: '<historical>' prior: 0!I represent a view of an instance of DisplayText.!!DisplayTextView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	centered _ false! !!DisplayTextView methodsFor: 'accessing'!centered	centered _ true.	self centerText! !!DisplayTextView methodsFor: 'accessing'!fillColor	"Answer an instance of class Form that is to be used as the mask when 	displaying the receiver's model (a DisplayText)."	^ mask! !!DisplayTextView methodsFor: 'accessing'!fillColor: aForm 	"Set aForm to be the mask used when displaying the receiver's model."	mask _ aForm! !!DisplayTextView methodsFor: 'accessing'!isCentered	^centered! !!DisplayTextView methodsFor: 'accessing'!mask	"Answer an instance of class Form that is to be used as the mask when 	displaying the receiver's model (a DisplayText)."	^ mask! !!DisplayTextView methodsFor: 'accessing'!rule	"Answer a number from 0 to 15 that indicates which of the sixteen 	display rules is to be used when copying the receiver's model (a 	DisplayText) onto the display screen."	rule == nil		ifTrue: [^self defaultRule]		ifFalse: [^rule]! !!DisplayTextView methodsFor: 'accessing'!rule: anInteger 	"Set anInteger to be the rule used when displaying the receiver's model."	rule _ anInteger! !!DisplayTextView methodsFor: 'controller access'!defaultController 	"Refer to the comment in View|defaultController."	^self defaultControllerClass newParagraph: editParagraph! !!DisplayTextView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^ParagraphEditor! !!DisplayTextView methodsFor: 'window access'!defaultWindow 	"Refer to the comment in View|defaultWindow."	^self inverseDisplayTransform: (editParagraph boundingBox expandBy: 6 @ 6)! !!DisplayTextView methodsFor: 'window access'!window: aWindow 	"Refer to the comment in View|window:."	super window: aWindow.	self centerText! !!DisplayTextView methodsFor: 'model access'!model: aDisplayText 	"Refer to the comment in View|model:."	super model: aDisplayText.	editParagraph _ model asParagraph.	self centerText! !!DisplayTextView methodsFor: 'displaying'!display 	"Refer to the comment in View|display."	self isUnlocked ifTrue: [self positionText].	super display! !!DisplayTextView methodsFor: 'displaying'!displayView 	"Refer to the comment in View|displayView."	self clearInside.	(self controller isKindOf: ParagraphEditor )		ifTrue: [controller changeParagraph: editParagraph].	editParagraph foregroundColor: self foregroundColor				backgroundColor: self backgroundColor.	self isCentered		ifTrue: 			[editParagraph displayOn: Display				transformation: self displayTransformation				clippingBox: self insetDisplayBox				fixedPoint: editParagraph boundingBox center]		ifFalse: 			[editParagraph displayOn: Display]! !!DisplayTextView methodsFor: 'displaying'!uncacheBits	"Normally only sent to a StandardSystemView, but for casees where a DisplayTextView is used alone, without a superview, in which we make this a no-op, put in so that the Character Recognizer doesn't fail.  8/9/96 sw"! !!DisplayTextView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	(self controller isKindOf: ParagraphEditor)	 	ifTrue: [controller deselect]! !!DisplayTextView methodsFor: 'private'!centerText	self isCentered		ifTrue: 			[editParagraph				align: editParagraph boundingBox center				with: self getWindow center]! !!DisplayTextView methodsFor: 'private'!defaultRule	^Form over! !!DisplayTextView methodsFor: 'private'!positionText	| box |	box _ (self displayBox insetBy: 6@6) origin extent: editParagraph boundingBox extent.	editParagraph wrappingBox: box clippingBox: box.	self centerText! !!DisplayTextView methodsFor: 'lock access'!lock 	"Refer to the comment in View|lock.  Must do what would be done by displaying..."	self isUnlocked ifTrue: [self positionText].	super lock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DisplayTextView class	instanceVariableNames: ''!!DisplayTextView class methodsFor: 'examples'!example2		"Create a standarad system view with two parts, one editable, the other not."	| topView aDisplayTextView |	topView _ StandardSystemView new.	topView label: 'Text Editor'.	aDisplayTextView _ self new model: 'test string label' asDisplayText.	aDisplayTextView controller: NoController new.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	topView addSubView: aDisplayTextView.	aDisplayTextView _ self new model: 'test string' asDisplayText.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidth: 2.	topView		addSubView: aDisplayTextView		align: aDisplayTextView viewport topLeft		with: topView lastSubView viewport topRight.	topView controller open	"DisplayTextView example2"! !!DisplayTextView class methodsFor: 'examples'!example3		"Create a passive view of some text on the screen."	| view |	view_ self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 2.	view display.	view release	"DisplayTextView example3"! !!DisplayTextView class methodsFor: 'examples'!example4		"Create four passive views of some text on the screen with fat borders."	| view |	view_ self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 5.	view display.	3 timesRepeat: [view translateBy: 100@100. view display].	view release	"DisplayTextView example4"! !AbstractEvent subclass: #DoItEvent	instanceVariableNames: 'context'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!DoItEvent methodsFor: 'testing' stamp: 'rw 7/14/2003 10:15'!isDoIt	^true! !!DoItEvent methodsFor: 'printing' stamp: 'rw 7/14/2003 10:15'!printEventKindOn: aStream	aStream nextPutAll: 'DoIt'! !!DoItEvent methodsFor: 'private-accessing' stamp: 'rw 7/14/2003 11:29'!context: aContext	context := aContext! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DoItEvent class	instanceVariableNames: ''!!DoItEvent class methodsFor: 'accessing' stamp: 'rw 7/14/2003 10:19'!changeKind	^#DoIt! !!DoItEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:23'!supportedKinds	^ Array with: self expressionKind! !!DoItEvent class methodsFor: 'instance creation' stamp: 'NS 1/19/2004 09:47'!expression: stringOrStream context: aContext	| instance |	instance := self item: stringOrStream kind: AbstractEvent expressionKind.	instance context: aContext.	^instance! !FileDirectory subclass: #DosFileDirectory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!DosFileDirectory commentStamp: '<historical>' prior: 0!I represent a DOS or Windows FileDirectory.!!DosFileDirectory methodsFor: 'as yet unclassified' stamp: 'di 6/18/1998 08:57'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName badChars hasBadChars |	fName _ super checkName: aFileName fixErrors: fixing.	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	hasBadChars _ fName includesAnyOf: badChars.	(hasBadChars and:[fixing not]) ifTrue:[^self error:'Invalid file name'].	hasBadChars ifFalse:[^ fName].	^ fName collect:		[:char | (badChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !!DosFileDirectory methodsFor: 'as yet unclassified' stamp: 'bf 3/21/2000 17:06'!setPathName: pathString	"Ensure pathString is absolute - relative directories aren't supported on all platforms."	(pathString isEmpty		or: [pathString first = $\			or: [pathString size >= 2 and: [pathString second = $: and: [pathString first isLetter]]]])				ifTrue: [^ super setPathName: pathString].	self error: 'Fully qualified path expected'! !!DosFileDirectory methodsFor: 'path access' stamp: 'je 11/8/2000 20:02'!driveName   "return a possible drive letter and colon at the start of a Path name, empty string otherwise"   | firstTwoChars |   ( pathName size >= 2 ) ifTrue: [      firstTwoChars _ (pathName copyFrom: 1 to: 2).      (self class isDrive: firstTwoChars) ifTrue: [^firstTwoChars]   ].   ^''! !!DosFileDirectory methodsFor: 'path access' stamp: 'nk 7/18/2004 17:26'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	fileName ifNil:[^fileName].	"Check for fully qualified names"	((fileName size >= 2 and: [fileName first isLetter and: [fileName second = $:]])		or: [(fileName beginsWith: '\\') and: [(fileName occurrencesOf: $\) >= 2]])			ifTrue:[^fileName].	^super fullNameFor: fileName! !!DosFileDirectory methodsFor: 'path access' stamp: 'je 11/8/2000 19:57'!fullPathFor: path	"Return the fully-qualified path name for the given file."	path isEmpty ifTrue:[^pathName].	(path at: 1) = $\ ifTrue:[		(path size >= 2 and:[(path at: 2) = $\]) ifTrue:[^path]. "e.g., \\pipe\"		^self driveName , path "e.g., \windows\"].	(path size >= 2 and:[(path at: 2) = $: and:[path first isLetter]])		ifTrue:[^path]. "e.g., c:"	^pathName, self slash, path! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DosFileDirectory class	instanceVariableNames: ''!!DosFileDirectory class methodsFor: 'platform specific' stamp: 'ar 5/1/1999 01:48'!isCaseSensitive	"Return true if file names are treated case sensitive"	^false! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'ar 3/6/2004 03:46'!isDrive: fullName	"Answer whether the given full name describes a 'drive', e.g., one of the root directories of a Win32 file system. We allow two forms here - the classic one where a drive is specified by a letter followed by a colon, e.g., 'C:', 'D:' etc. and the network share form starting with double-backslashes e.g., '\\server'."	^ (fullName size = 2 and: [fullName first isLetter and: [fullName last = $:]])		or: [(fullName beginsWith: '\\') and: [(fullName occurrencesOf: $\) = 2]]! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'jm 5/8/1998 20:45'!maxFileNameLength	^ 255! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'jm 12/4/97 22:57'!pathNameDelimiter	^ $\! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'ar 3/6/2004 04:14'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. 	IMPORTANT NOTE: For 'drives', e.g., roots of the file system on Windows we treat the full name of that 'drive' as the local name rather than the path. This is because conceptually, all of these 'drives' hang off the virtual root of the entire Squeak file system, specified by FileDirectory root. In order to be consistent with, e.g., 		DosFileDirectory localNameFor: 'C:\Windows' -> 'Windows'		DosFileDirectory dirPathFor: 'C:\Windows' -> 'C:'	we expect the following to be true:		DosFileDirectory localNameFor: 'C:' -> 'C:'		DosFileDirectory dirPathFor: 'C:'. -> ''		DosFileDirectory localNameFor: '\\server' -> '\\server'.		DosFileDirectory dirPathFor: '\\server' -> ''.	so that in turn the following relations hold:		| fd |		fd := DosFileDirectory on: 'C:\Windows'.		fd containingDirectory includes: fd localName.		fd := DosFileDirectory on: 'C:'.		fd containingDirectory includes: fd localName.		fd := DosFileDirectory on: '\\server'.		fd containingDirectory includes: fd localName.	"	(self isDrive: fullName)		ifTrue: [^ pathAndNameBlock value:''  value: fullName].	^ super splitName: fullName to: pathAndNameBlock! !Model subclass: #DualChangeSorter	instanceVariableNames: 'leftCngSorter rightCngSorter'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!DualChangeSorter commentStamp: '<historical>' prior: 0!This class presents a view of a two change sets at once, and supports copying changes between change sets.!!DualChangeSorter methodsFor: 'initialization' stamp: 'di 5/20/1998 21:44'!okToChange	^ leftCngSorter okToChange & rightCngSorter okToChange! !!DualChangeSorter methodsFor: 'initialization' stamp: 'ssa 9/3/2008 11:07'!open	| topView |	leftCngSorter _ ChangeSorter new myChangeSet: ChangeSet current.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	topView _ (StandardSystemView new) model: self; borderWidth: 1.	topView label: leftCngSorter label.	topView minimumSize: 300 @ 200.	leftCngSorter openView: topView offsetBy: 0@0.	rightCngSorter openView: topView offsetBy: 360@0.	topView controller open.! !!DualChangeSorter methodsFor: 'initialization'!release	leftCngSorter release.	rightCngSorter release.! !!DualChangeSorter methodsFor: 'other'!isLeftSide: theOne	"Which side am I?"	^ theOne == leftCngSorter! !!DualChangeSorter methodsFor: 'other' stamp: 'sd 5/23/2003 14:38'!labelString	"The window label"	| leftName rightName changesName |	leftName _ leftCngSorter changeSetCategory categoryName.	rightName _ rightCngSorter changeSetCategory categoryName.	changesName _ 'Changes go to "', ChangeSet current name,  '"'.	^ ((leftName ~~ #All) or: [rightName ~~ #All])		ifTrue:			['(', leftName, ') - ', changesName, ' - (', rightName, ')']		ifFalse:			[changesName]! !!DualChangeSorter methodsFor: 'other' stamp: 'tk 5/8/1998 16:30'!modelWakeUp	"A window with me as model is being entered.  Make sure I am up-to-date with the changeSets."	"Dumb way"	leftCngSorter canDiscardEdits 		ifTrue: [leftCngSorter update]	"does both"		ifFalse: [rightCngSorter update].! !!DualChangeSorter methodsFor: 'other'!other: theOne	"Return the other side's ChangeSorter"	^ theOne == leftCngSorter		ifTrue: [rightCngSorter]		ifFalse: [leftCngSorter]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DualChangeSorter class	instanceVariableNames: ''!!DualChangeSorter class methodsFor: 'opening' stamp: 'sw 3/24/1999 17:50'!open	"Open a new instance of the receiver's class"	self new open! !!DualChangeSorter class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:44'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(DualChangeSorter		prototypicalToolWindow		'Change Sorter'		'Shows two change sets side by side')						forFlapNamed: 'Tools']! !!DualChangeSorter class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:33'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !Magnitude subclass: #Duration	instanceVariableNames: 'nanos seconds'	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!Duration commentStamp: '<historical>' prior: 0!I represent a duration of time. I have nanosecond precision
!!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:59'!* operand
	"operand is a Number" 	^ self class nanoSeconds: ( (self asNanoSeconds * operand) asInteger).
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:59'!+ operand

	"operand is a Duration" 	^ self class nanoSeconds: (self asNanoSeconds + operand asNanoSeconds)
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:59'!- operand
	"operand is a Duration" 	^ self + operand negated
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:00'!/ operand

	"operand is a Duration or a Number"


	^ operand isNumber
		ifTrue: [ self class nanoSeconds: (self asNanoSeconds / operand) asInteger ]
		ifFalse: [ self asNanoSeconds / operand asDuration asNanoSeconds ]
.
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:00'!< comparand

	^ self asNanoSeconds < comparand asNanoSeconds
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 1/9/2004 06:25'!= comparand 
	"Answer whether the argument is a <Duration> representing the same 
	period of time as the receiver."

	^ self == comparand
		ifTrue: [true]
		ifFalse: 
			[self species = comparand species 
				ifTrue: [self asNanoSeconds = comparand asNanoSeconds]
				ifFalse: [false] ]! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!abs

	^ self class seconds: seconds abs nanoSeconds: nanos abs
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!asDuration

	^ self
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!asSeconds


	^ seconds
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 1/7/2004 16:20'!days

	"Answer the number of days the receiver represents."

	^ seconds quo: SecondsInDay
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!hash 	^seconds bitXor: nanos
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!hours
	"Answer the number of hours the receiver represents."


	^ (seconds rem: SecondsInDay) quo: SecondsInHour
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!minutes

	"Answer the number of minutes the receiver represents."


	^ (seconds rem: SecondsInHour) quo: SecondsInMinute
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:02'!negated

	^ self class seconds: seconds negated nanoSeconds: nanos negated
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:02'!negative


	^ self positive not
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:02'!positive


	^ seconds = 0 ifTrue: [ nanos positive ] ifFalse: [ seconds positive ]
! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 10:03'!seconds
	"Answer the number of seconds the receiver represents."

	^ (seconds rem: SecondsInMinute) + (nanos / NanosInSecond)! !!Duration methodsFor: 'initialize-release' stamp: 'nk 3/30/2004 10:01'!initialize	self seconds: 0 nanoSeconds: 0.! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 14:29'!// operand

	"operand is a Duration or a Number"


	^ operand isNumber
		ifTrue: [ self class nanoSeconds: (self asNanoSeconds // operand) asInteger ]
		ifFalse: [ self asNanoSeconds // operand asDuration asNanoSeconds ]
! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:07'!\\ operand

	"modulo. Remainder defined in terms of //. Answer a Duration with the 
	same sign as aDuration. operand is a Duration or a Number."

	^ operand isNumber
		ifTrue: [ self class nanoSeconds: (self asNanoSeconds \\ operand) ]
		ifFalse: [ self - (operand * (self // operand)) ]
! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:03'!asNanoSeconds

	^ (seconds * NanosInSecond) + nanos
! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:03'!nanoSeconds


	^ nanos
! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 13:22'!printOn: aStream
	"Format as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]" 	| d h m s n |
	d _ self days abs.
	h _ self hours abs.
	m _ self minutes abs.
 	s _ self seconds abs truncated.
	n _ self nanoSeconds abs. 	self negative ifTrue: [ aStream nextPut: $- ].
	d printOn: aStream. aStream nextPut: $:.
	h < 10 ifTrue: [ aStream nextPut: $0. ].
	h printOn: aStream. aStream nextPut: $:.
	m < 10 ifTrue: [ aStream nextPut: $0. ].
	m printOn: aStream. aStream nextPut: $:.
	s < 10 ifTrue: [ aStream nextPut: $0. ].
	s printOn: aStream.
	n = 0 ifFalse:
		[ | z ps |
		aStream nextPut: $..
		ps _ n printString padded: #left to: 9 with: $0. 
		z _ ps findLast: [ :c | c asciiValue > $0 asciiValue ].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].
! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:42'!roundTo: aDuration
	"e.g. if the receiver is 5 minutes, 37 seconds, and aDuration is 2 minutes, answer 6 minutes."

	^ self class nanoSeconds: (self asNanoSeconds roundTo: aDuration asNanoSeconds)

! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:38'!truncateTo: aDuration
	"e.g. if the receiver is 5 minutes, 37 seconds, and aDuration is 2 minutes, answer 4 minutes."

	^ self class
		nanoSeconds: (self asNanoSeconds truncateTo: aDuration asNanoSeconds)

! !!Duration methodsFor: 'private' stamp: 'brp 7/27/2003 15:08'!seconds: secondCount nanoSeconds: nanoCount 
	"Private - only used by Duration class"

	seconds _ secondCount.
	nanos _ nanoCount! !!Duration methodsFor: 'private' stamp: 'brp 9/25/2003 14:42'!storeOn: aStream

	aStream
		nextPut: $(;
		nextPutAll: self className;
		nextPutAll: ' seconds: ';
		print: seconds;
		nextPutAll: ' nanoSeconds: ';
		print: nanos;
		nextPut: $).
! !!Duration methodsFor: 'private' stamp: 'brp 8/23/2003 20:31'!ticks
	"Answer an array {days. seconds. nanoSeconds}. Used by DateAndTime and Time"

	^ Array 
		with: self days
		with: (self hours * 3600) + (self minutes * 60 ) + (self seconds truncated)
		with: self nanoSeconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Duration class	instanceVariableNames: ''!!Duration class methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:55'!days: days hours: hours minutes: minutes seconds: seconds

	^ self days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: 0.! !!Duration class methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 10:05'!seconds: aNumber	^ (self basicNew) seconds: aNumber nanoSeconds: 0; yourself.! !!Duration class methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 10:06'!zero	^ (self basicNew) seconds: 0 nanoSeconds: 0; yourself.! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:00'!days: aNumber

	^ self days: aNumber hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 1/7/2004 15:38'!days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: nanos 	^ self nanoSeconds: 
			( ( (days * SecondsInDay) 
				+ (hours * SecondsInHour)
					+ (minutes * SecondsInMinute) 
						+ seconds ) * NanosInSecond )
							+ nanos.
! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 5/16/2003 11:29'!fromString: aString


	^ self readFrom: (ReadStream on: aString)
! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:00'!hours: aNumber


	^ self days: 0 hours: aNumber minutes: 0 seconds: 0 nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:01'!minutes: aNumber

	^ self days: 0 hours: 0 minutes: aNumber seconds: 0 nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 5/21/2003 08:27'!nanoSeconds: nanos

	^ self new
		seconds: (nanos quo: NanosInSecond) 
		nanoSeconds: (nanos rem: NanosInSecond) rounded;
		yourself.
! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 12:47'!readFrom: aStream
	"Formatted as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]
	To assiste DateAndTime>>#readFrom: SS may be unpadded or absent."

	| sign days hours minutes seconds nanos ws ch |
	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].

	days _ (aStream upTo: $:) asInteger sign: sign.
	hours _ (aStream upTo: $:) asInteger sign: sign.
	minutes _ (aStream upTo: $:) asInteger sign: sign.

	aStream atEnd 
		ifTrue: [seconds _ 0. nanos _ 0]
		ifFalse: 
			[ ws _ String new writeStream.
			[ch _ aStream next. (ch isNil) | (ch = $.)]
				whileFalse: [ ws nextPut: ch ].
			seconds _ ws contents asInteger sign: sign.
			ws reset.
			9 timesRepeat: 
				[ ch _ aStream next. 
				ws nextPut: (ch ifNil: [$0] ifNotNil: [ch]) ].
			nanos _ ws contents asInteger sign: sign].

	^ self days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: nanos.

	"	'0:00:00:00' asDuration
		'0:00:00:00.000000001' asDuration
		'0:00:00:00.999999999' asDuration
		'0:00:00:00.100000000' asDuration
		'0:00:00:00.10' asDuration
		'0:00:00:00.1' asDuration
		'0:00:00:01' asDuration
		'0:12:45:45' asDuration
		'1:00:00:00' asDuration
		'365:00:00:00' asDuration
		'-7:09:12:06.10' asDuration
		'+0:01:02' asDuration
		'+0:01:02:3' asDuration
 	"
! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:01'!seconds: seconds nanoSeconds: nanos

	^ self days: 0 hours: 0 minutes: 0 seconds: seconds nanoSeconds: nanos
! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 8/6/2003 18:54'!weeks: aNumber

	^ self days: (aNumber * 7) hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0
! !ObjectWithDocumentation subclass: #ElementCategory	instanceVariableNames: 'categoryName keysInOrder elementDictionary'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Kernel'!!ElementCategory commentStamp: '<historical>' prior: 0!ElementCategory	Contains a list of elements that affords keyed access but also has an inherent order.Add items to the category by sending it elementAt:put:.Obtain the elements in order by sending #elementsInOrderObtain the value of an element at a given key by sending #elementAt:!!ElementCategory methodsFor: 'elements' stamp: 'sw 12/1/2000 22:46'!elementAt: aKey	"Answer the element at the given key"	^ elementDictionary at: aKey ifAbsent: [nil]! !!ElementCategory methodsFor: 'elements' stamp: 'sw 1/26/2001 22:54'!elementAt: sym put: element	"Add symbol at the end of my sorted list (unless it is already present), and put the element in the dictionary"	(keysInOrder includes: sym) ifFalse: [keysInOrder add: sym].	^ elementDictionary at: sym put: element! !!ElementCategory methodsFor: 'elements' stamp: 'sw 9/12/2001 22:59'!elementSymbol	"Answer the element symbol for the receiver.  Here, the categoryName dominates"	^ categoryName! !!ElementCategory methodsFor: 'elements' stamp: 'sw 12/1/2000 22:47'!elementsInOrder	"Answer the elements in order"	^ keysInOrder collect: [:aKey | elementDictionary at: aKey]! !!ElementCategory methodsFor: 'elements' stamp: 'sw 4/3/2001 11:06'!fasterElementAt: sym put: element	"Add symbol at the end of my sorted list and put the element in the dictionary.  This variant adds the key at the end of the keys list without checking whether it already exists."	keysInOrder add: sym.	^ elementDictionary at: sym put: element! !!ElementCategory methodsFor: 'elements' stamp: 'sw 4/11/2001 20:08'!removeElementAt: aKey	"Remove the element at the given key"	elementDictionary removeKey: aKey ifAbsent: [^ self].	keysInOrder remove: aKey ifAbsent: []! !!ElementCategory methodsFor: 'copying' stamp: 'sw 12/1/2000 22:45'!copy	"Answer a copy of the receiver"	^ super copy copyFrom: self! !!ElementCategory methodsFor: 'copying' stamp: 'sw 12/1/2000 22:46'!copyFrom: donor	"Copy the receiver's contents from the donor"	keysInOrder _ donor keysInOrder.	elementDictionary _ donor copyOfElementDictionary! !!ElementCategory methodsFor: 'copying' stamp: 'sw 12/1/2000 22:46'!copyOfElementDictionary	"Answer a copy of the element dictionary"	^ elementDictionary copy! !!ElementCategory methodsFor: 'keys' stamp: 'sw 12/11/2000 15:36'!includesKey: aKey	"Answer whether the receiver's dictionary holds the given key"	^ elementDictionary includesKey: aKey! !!ElementCategory methodsFor: 'keys' stamp: 'sw 12/1/2000 22:47'!keysInOrder	"Answer the keys in their sorted order"	^ keysInOrder copy! !!ElementCategory methodsFor: 'category name' stamp: 'sw 1/26/2001 22:45'!categoryName	"Answer the formal name of the category"	^ categoryName! !!ElementCategory methodsFor: 'category name' stamp: 'sw 1/26/2001 22:46'!categoryName: aName	"Set the category name"	categoryName _ aName! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 3/30/2001 00:12'!addCategoryItem: anItem	"Add the item at the end, obtaining its key from itself (it must respond to #categoryName)"	self elementAt: anItem categoryName put: anItem! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 3/28/2001 19:46'!clear	"Clear the receiber's keysInOrder and elementDictionary"	keysInOrder _ OrderedCollection new.	elementDictionary _ IdentityDictionary new! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 3/28/2001 19:47'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	super initialize.	self clear! !!ElementCategory methodsFor: 'printing' stamp: 'sw 1/26/2001 22:47'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that identifies the receiver."	super printOn: aStream.	categoryName ifNotNil: [aStream nextPutAll: ' named ', categoryName asString]! !!ElementCategory methodsFor: 'translation' stamp: 'dgd 12/4/2003 20:22'!translated	"answer the receiver translated to the current language"		^ self class new categoryName: categoryName asString translated asSymbol! !Object subclass: #ElementTranslation	instanceVariableNames: 'wording helpMessage naturalLanguageSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Kernel'!!ElementTranslation methodsFor: 'access' stamp: 'sw 5/22/2001 10:34'!helpMessage	"Answer the helpMessage"	^ helpMessage! !!ElementTranslation methodsFor: 'access' stamp: 'sw 5/22/2001 10:33'!wording	"Answer the wording"	^ wording! !!ElementTranslation methodsFor: 'initialization' stamp: 'sw 9/12/2001 23:00'!language	"Answer the natural language symbol of the receiver"	^ naturalLanguageSymbol ifNil: [naturalLanguageSymbol _ #English]! !!ElementTranslation methodsFor: 'initialization' stamp: 'sw 9/12/2001 10:15'!wording: aWording helpMessage: aHelpMessage language: aLanguageSymbol	"Set state directly"	wording _ aWording.	helpMessage _ aHelpMessage.	naturalLanguageSymbol _ aLanguageSymbol! !!ElementTranslation methodsFor: 'printing' stamp: 'sw 9/12/2001 16:08'!printOn: aStream	"Print the receiver on the stream"	aStream nextPutAll: '('.	super printOn: aStream.	aStream nextPutAll: ' language: ', naturalLanguageSymbol asString, ' wording: ', wording asString, ')'! !!ElementTranslation methodsFor: 'translation' stamp: 'dgd 12/4/2003 20:22'!translated	"answer the receiver translated to the current language"	| translatedWording translatedHelpMessage |		translatedWording := wording isNil				ifFalse: [wording asString translated].	translatedHelpMessage := helpMessage isNil				ifFalse: [helpMessage asString translated].	""	^ self class new		wording: translatedWording		helpMessage: translatedHelpMessage		language: self currentWorld currentNaturalLanguage! !ParseNode subclass: #Encoder	instanceVariableNames: 'scopeTable nTemps supered requestor class literalStream selectorSet litIndSet litSet sourceRanges globalSourceRanges'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!Encoder commentStamp: '<historical>' prior: 0!I encode names and literals into tree nodes with byte codes for the compiler. Byte codes for literals are not assigned until the tree-sizing pass of the compiler, because only then is it known which literals are actually needed. I also keep track of sourceCode ranges during parsing and code generation so I can provide an inverse map for the debugger.!!Encoder methodsFor: 'initialize-release'!fillDict: dict with: nodeClass mapping: keys to: codeArray	| codeStream |	codeStream _ ReadStream on: codeArray.	keys do: 		[:key | dict 				at: key				put:  (nodeClass new name: key key: key code: codeStream next)]! !!Encoder methodsFor: 'initialize-release' stamp: 'di 12/4/1999 22:22'!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class allInstVarNames do: 		[:variable | 		node _ VariableNode new					name: variable					index: (n _ n + 1)					type: LdInstType.		scopeTable at: variable put: node].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ MessageAsTempNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!Encoder methodsFor: 'initialize-release'!initScopeAndLiteralTables	scopeTable _ StdVariables copy.	litSet _ StdLiterals copy.	selectorSet _ StdSelectors copy.	litIndSet _ Dictionary new: 16.	literalStream _ WriteStream on: (Array new: 32)! !!Encoder methodsFor: 'initialize-release'!noteSuper	supered _ true! !!Encoder methodsFor: 'initialize-release'!release	requestor _ nil! !!Encoder methodsFor: 'initialize-release' stamp: 'ajh 7/21/2003 00:53'!temps: tempVars literals: lits class: cl 	"Decompile."	supered _ false.	class _ cl.	nTemps _ tempVars size.	tempVars do: [:node | scopeTable at: node name put: node].	literalStream _ ReadStream on: lits.	literalStream position: lits size.	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!Encoder methodsFor: 'encoding'!cantStoreInto: varName	^StdVariables includesKey: varName! !!Encoder methodsFor: 'encoding'!encodeLiteral: object	^self		name: object		key: (class literalScannedAs: object notifying: self)		class: LiteralNode		type: LdLitType		set: litSet! !!Encoder methodsFor: 'encoding'!encodeSelector: selector	^self		name: selector		key: selector		class: SelectorNode		type: SendType		set: selectorSet! !!Encoder methodsFor: 'encoding' stamp: 'di 12/4/1999 20:09'!encodeVariable: name	^ self encodeVariable: name sourceRange: nil ifUnknown: [ self undeclared: name ]! !!Encoder methodsFor: 'encoding' stamp: 'RAA 2/5/2001 10:44'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [action value]].	range ifNotNil: [		name first isUppercase ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!Encoder methodsFor: 'encoding'!litIndex: literal	| p |	p _ literalStream position.	p = 256 ifTrue:		[self notify: 'More than 256 literals referenced. You must split or otherwise simplify this method.The 257th literal is: ', literal printString. ^nil].		"Would like to show where it is in the source code, 		 but that info is hard to get."	literalStream nextPut: literal.	^ p! !!Encoder methodsFor: 'encoding' stamp: 'di 1/7/2000 15:24'!sharableLitIndex: literal	"Special access prevents multiple entries for post-allocated super send special selectors"	| p |	p _ literalStream originalContents indexOf: literal.	p = 0 ifFalse: [^ p-1].	^ self litIndex: literal! !!Encoder methodsFor: 'encoding' stamp: 'tk 4/20/1999 15:41'!undeclared: name	| sym |	requestor interactive ifTrue: [		requestor requestor == #error: ifTrue: [requestor error: 'Undeclared'].		^ self notify: 'Undeclared'].	Transcript show: ' (' , name , ' is Undeclared) '.	sym _ name asSymbol.	Undeclared at: sym put: nil.	^self global: (Undeclared associationAt: sym) name: sym! !!Encoder methodsFor: 'temps'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node _ scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self notify: 'Name already used in a Pool or Global'].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'di 10/12/1999 16:53'!bindAndJuggle: name	| node nodes first thisCode |	node _ self reallyBind: name.	"Declared temps must precede block temps for decompiler and debugger to work right"	nodes _ self tempNodes.	(first _ nodes findFirst: [:n | n scope > 0]) > 0 ifTrue:		[node == nodes last ifFalse: [self error: 'logic error'].		thisCode _ (nodes at: first) code.		first to: nodes size - 1 do:			[:i | (nodes at: i) key: (nodes at: i) key							code: (nodes at: i+1) code].		nodes last key: nodes last key code: thisCode].		^ node! !!Encoder methodsFor: 'temps' stamp: 'jm 9/18/97 21:06'!bindArg: name 	"Declare an argument."	| node |	nTemps >= 15		ifTrue: [^self notify: 'Too many arguments'].	node _ self bindTemp: name.	^ node nowHasDef nowHasRef! !!Encoder methodsFor: 'temps' stamp: 'crl 2/26/1999 12:18'!bindBlockTemp: name 	"Declare a temporary block variable; complain if it's not a field or class variable."	| node |	node _ scopeTable at: name ifAbsent: [^self reallyBind: name].	node isTemp		ifTrue: [			node scope >= 0 ifTrue: [^ self notify: 'Name already used in this method'].			node scope: 0]		ifFalse: [^self notify: 'Name already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'ar 7/12/1999 00:24'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp or:[requestor interactive])			ifTrue:[^self notify:'Name is already defined']			ifFalse:[Transcript show: '(', name, ' is shadowed)']].	^self reallyBind: name! !!Encoder methodsFor: 'temps'!maxTemp	^nTemps! !!Encoder methodsFor: 'temps'!newTemp: name	nTemps _ nTemps + 1.	^ TempVariableNode new		name: name		index: nTemps - 1		type: LdTempType		scope: 0! !!Encoder methodsFor: 'results'!allLiterals	supered ifTrue: [self litIndex: (self associationFor: class)].	^ literalStream contents! !!Encoder methodsFor: 'results' stamp: 'ar 2/13/1999 21:18'!associationFor: aClass	| name |	name _ Smalltalk keyAtIdentityValue: aClass ifAbsent: [^Association new value: aClass].	^Smalltalk associationAt: name! !!Encoder methodsFor: 'results'!literals	"Should only be used for decompiling primitives"	^ literalStream contents! !!Encoder methodsFor: 'results' stamp: 'di 10/12/1999 16:12'!tempNames 	^ self tempNodes collect:		[:node | (node isMemberOf: MessageAsTempNode)					ifTrue: [scopeTable keyAtValue: node]					ifFalse: [node key]]! !!Encoder methodsFor: 'results' stamp: 'di 10/12/1999 15:31'!tempNodes 	| tempNodes |	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn | assn value isTemp ifTrue: [tempNodes add: assn value]].	^ tempNodes! !!Encoder methodsFor: 'results' stamp: 'di 10/12/1999 17:15'!unusedTempNames 	| unused name |	unused _ OrderedCollection new.	scopeTable associationsDo:		[:assn | (assn value isUnusedTemp)			ifTrue: [name _ assn value key.					name ~= 'homeContext' ifTrue: [unused add: name]]].	^ unused! !!Encoder methodsFor: 'error handling'!notify: string	"Put a separate notifier on top of the requestor's window"	| req |	requestor == nil		ifFalse: 			[req _ requestor.			self release.			req notify: string].	^false! !!Encoder methodsFor: 'error handling'!notify: string at: location	| req |	requestor == nil		ifFalse: 			[req _ requestor.			self release.			req notify: string at: location].	^false! !!Encoder methodsFor: 'error handling'!requestor: req	"Often the requestor is a BrowserCodeController"	requestor _ req! !!Encoder methodsFor: 'source mapping'!noteSourceRange: range forNode: node	sourceRanges at: node put: range! !!Encoder methodsFor: 'source mapping' stamp: 'RAA 8/21/1999 06:52'!rawSourceRanges	^ sourceRanges ! !!Encoder methodsFor: 'source mapping'!sourceMap	"Answer with a sorted set of associations (pc range)."	^ (sourceRanges keys collect: 		[:key |  Association key: key pc value: (sourceRanges at: key)])			asSortedCollection! !!Encoder methodsFor: 'private'!classEncoding	"This is a hack so that the parser may findout what class it was parsing for when it wants to create a syntax error view."	^ class! !!Encoder methodsFor: 'private' stamp: 'ar 8/14/2001 23:12'!global: ref name: name	^self		name: name		key: ref		class: LiteralVariableNode		type: LdLitIndType		set: litIndSet! !!Encoder methodsFor: 'private' stamp: 'ar 5/17/2003 14:16'!lookupInPools: varName ifFound: assocBlock	Symbol hasInterned: varName ifTrue:[:sym|		(class bindingOf: sym) ifNotNilDo:[:assoc| 			assocBlock value: assoc.			^true].		(Preferences valueOfFlag: #lenientScopeForGlobals)  "**Temporary**"			ifTrue: [^ Smalltalk lenientScopeHas: sym ifTrue: assocBlock]			ifFalse: [^ false]].	(class bindingOf: varName) ifNotNilDo:[:assoc|		assocBlock value: assoc.		^true].	^false! !!Encoder methodsFor: 'private'!name: name key: key class: leafNodeClass type: type set: dict	| node |	^dict 		at: key		ifAbsent: 			[node _ leafNodeClass new						name: name						key: key						index: nil						type: type.			dict at: key put: node.			^node]! !!Encoder methodsFor: 'private'!possibleVariablesFor: proposedVariable	| results |	results _ proposedVariable correctAgainstDictionary: scopeTable								continuedFrom: nil.	proposedVariable first isUppercase ifTrue:		[ results _ class possibleVariablesFor: proposedVariable						continuedFrom: results ].	^ proposedVariable correctAgainst: nil continuedFrom: results.! !!Encoder methodsFor: 'private'!reallyBind: name	| node |	node _ self newTemp: name.	scopeTable at: name put: node.	^node! !Error subclass: #EndOfStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Extensions'!!EndOfStream commentStamp: '<historical>' prior: 0!Signalled when ReadStream>>next encounters a premature end.!!EndOfStream methodsFor: 'description' stamp: 'hh 5/17/2000 00:30'!isResumable	"EndOfStream is resumable, so ReadStream>>next can answer"	^ true! !!EndOfStream methodsFor: 'exceptionDescription' stamp: 'RAA 5/17/2000 03:10'!defaultAction	"Answer ReadStream>>next default reply."	^ nil! !Exception subclass: #Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!Error commentStamp: '<historical>' prior: 0!>From the ANSI standard:This protocol describes the behavior of instances of class Error. These are used to represent error conditions that prevent the normal continuation of processing. Actual error exceptions used by an application may be subclasses of this class.As Error is explicitly specified  to be subclassable, conforming implementations must implement its behavior in a non-fragile manner.Additional notes:Error>defaultAction uses an explicit test for the presence of the Debugger class to decide whether or not it is in development mode.  In the future, TFEI hopes to enhance the semantics of #defaultAction to improve support for pluggable default handlers.!!Error methodsFor: 'private' stamp: 'ajh 2/1/2003 00:54'!isResumable	"Determine whether an exception is resumable."	^ false! !!Error methodsFor: 'exceptionDescription' stamp: 'ajh 9/4/2002 19:24'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object Events'!!EventManager methodsFor: 'copying' stamp: 'reThink 3/3/2001 10:22'!copy	| answer |	answer := super copy.	answer release.	^answer! !!EventManager methodsFor: 'accessing' stamp: 'reThink 2/18/2001 15:37'!actionMap    ^actionMap == nil        ifTrue: [self createActionMap]        ifFalse: [actionMap]! !!EventManager methodsFor: 'accessing' stamp: 'reThink 3/3/2001 10:07'!changedEventSelector	^#changed:! !!EventManager methodsFor: 'accessing' stamp: 'reThink 2/18/2001 15:39'!releaseActionMap    actionMap := nil! !!EventManager methodsFor: 'accessing' stamp: 'reThink 3/3/2001 10:07'!updateEventSelector	^#update:! !!EventManager methodsFor: 'accessing' stamp: 'reThink 2/18/2001 15:38'!updateableActionMap    actionMap == nil        ifTrue: [actionMap := self createActionMap].    ^actionMap! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:07'!addDependent: anObject	"Make the given object one of the receiver's dependents."	self		when: self changedEventSelector		send: self updateEventSelector		to: anObject.	^anObject! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:07'!breakDependents	"Remove all of the receiver's dependents."	self removeActionsForEvent: self changedEventSelector! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:18'!dependents	^(self actionSequenceForEvent: self changedEventSelector) asSet		collect:			[:each | each receiver]! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:07'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	self 		removeActionsWithReceiver: anObject		forEvent: self changedEventSelector.	^ anObject! !!EventManager methodsFor: 'updating' stamp: 'reThink 3/3/2001 10:20'!changed: aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self 		triggerEvent: self changedEventSelector		with: aParameter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EventManager class	instanceVariableNames: ''!!EventManager class methodsFor: 'accessing' stamp: 'reThink 2/18/2001 14:42'!actionMapFor: anObject    ^self actionMaps        at: anObject        ifAbsent: [self createActionMap]! !!EventManager class methodsFor: 'accessing' stamp: 'rww 10/2/2001 07:20'!actionMaps	ActionMaps == nil		ifTrue: [ActionMaps := WeakIdentityKeyDictionary new].	^ActionMaps! !!EventManager class methodsFor: 'accessing' stamp: 'reThink 2/25/2001 08:52'!updateableActionMapFor: anObject    ^self actionMaps        at: anObject        ifAbsentPut: [self createActionMap]! !!EventManager class methodsFor: 'releasing' stamp: 'reThink 2/18/2001 15:34'!releaseActionMapFor: anObject	self actionMaps		removeKey: anObject		ifAbsent: []! !!EventManager class methodsFor: 'initialize-release' stamp: 'rw 2/10/2002 13:09'!flushEvents	"Object flushEvents"	| msgSet |	self actionMaps keysAndValuesDo:[:rcvr :evtDict| rcvr ifNotNil:[		"make sure we don't modify evtDict while enumerating"		evtDict keys do:[:evtName|			msgSet _ evtDict at: evtName ifAbsent:[nil].			(msgSet == nil) ifTrue:[rcvr removeActionsForEvent: evtName]]]].	EventManager actionMaps finalizeValues. ! !InputSensor subclass: #EventSensor	instanceVariableNames: 'mouseButtons mousePosition keyboardBuffer interruptKey interruptSemaphore eventQueue inputSemaphore lastEventPoll hasInputSemaphore'	classVariableNames: 'EventPollPeriod EventTicklerProcess'	poolDictionaries: 'EventSensorConstants'	category: 'Kernel-Processes'!!EventSensor commentStamp: 'nk 4/13/2004 11:18' prior: 0!EventSensor is a replacement for InputSensor based on a set of (optional) event primitives. An EventSensor updates its state when events are received so that all state based users of Sensor (e.g., Sensor keyboard, Sensor leftShiftDown, Sensor mouseButtons) will work exactly as before, by moving the current VM mechanisms into EventSensor itself. An optional input semaphore is part of the new design.For platforms that support true asynchronous event notification, the semaphore will be signaled to indicate pending events.On platforms that do not support asynchronous notifications about events, the UI will have to poll EventSensor periodically to read events from the VM.Instance variables:	mouseButtons <Integer>	- mouse button state as replacement for primMouseButtons	mousePosition <Point>	- mouse position as replacement for primMousePt	keyboardBuffer <SharedQueue>	- keyboard input buffer	interruptKey <Integer>			- currently defined interrupt key	interruptSemaphore <Semaphore>	- the semaphore signaled when the interruptKey is detected	eventQueue <SharedQueue>	- an optional event queue for event driven applications	inputSemaphore <Semaphore>- the semaphore signaled by the VM if asynchronous event notification is supported	lastEventPoll <Integer>		- the last millisecondClockValue at which we called fetchMoreEvents	hasInputSemaphore <Boolean>	- true if my inputSemaphore has actually been signaled at least once.Class variables:	EventPollPeriod <Integer>	- the number of milliseconds to wait between polling for more events in the userInterruptHandler.	EventTicklerProcess <Process>	- the process that makes sure that events are polled for often enough (at least every EventPollPeriod milliseconds).Event format:The current event format is very simple. Each event is recorded into an 8 element array. All events must provide some SmallInteger ID (the first field in the event buffer) and a time stamp (the second field in the event buffer), so that the difference between the time stamp of an event and the current time can be reported.Currently, the following events are defined:Null event=============The Null event is returned when the ST side asks for more events but no more events are available.Structure:[1]		- event type 0[2-8]	- unusedMouse event structure==========================Mouse events are generated when mouse input is detected.Structure:[1]	- event type 1[2]	- time stamp[3]	- mouse x position[4]	- mouse y position[5]	- button state; bitfield with the following entries:		1	-	yellow (e.g., right) button		2	-	blue (e.g., middle) button		4	-	red (e.g., left) button		[all other bits are currently undefined][6]	- modifier keys; bitfield with the following entries:		1	-	shift key		2	-	ctrl key		4	-	(Mac specific) option key		8	-	Cmd/Alt key		[all other bits are currently undefined][7]	- reserved.[8]	- reserved.Keyboard events====================Keyboard events are generated when keyboard input is detected.[1]	- event type 2[2]	- time stamp[3]	- character code		For now the character code is in Mac Roman encoding.[4]	- press state; integer with the following meaning		0	-	character		1	-	key press (down)		2	- 	key release (up)[5]	- modifier keys (same as in mouse events)[6]	- reserved.[7]	- reserved.[8]	- reserved.!!EventSensor methodsFor: 'accessing' stamp: 'ar 7/23/2000 14:37'!eventQueue	"Return the current event queue"	^eventQueue! !!EventSensor methodsFor: 'accessing' stamp: 'nk 4/12/2004 19:36'!eventTicklerProcess	"Answer my event tickler process, if any"	^EventTicklerProcess! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/6/2004 14:48'!flushAllButDandDEvents	| newQueue oldQueue  |		newQueue _ SharedQueue new.	self eventQueue ifNil: 		[eventQueue := newQueue.		^self].	oldQueue _ self eventQueue.	[oldQueue size > 0] whileTrue: 		[| item type | 		item _ oldQueue next.		type _ item at: 1.		type = EventTypeDragDropFiles ifTrue: [ newQueue nextPut: item]].	eventQueue := newQueue.! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/7/2001 17:13'!flushEvents	eventQueue ifNotNil:[eventQueue flush].! !!EventSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 19:21'!initialize	"Initialize the receiver"	mouseButtons := 0.	mousePosition := 0 @ 0.	keyboardBuffer := SharedQueue new.	self setInterruptKey: (interruptKey ifNil: [$. asciiValue bitOr: 16r0800 ]). 	"cmd-."	interruptSemaphore := (Smalltalk specialObjectsArray at: 31) ifNil: [Semaphore new].	self flushAllButDandDEvents.	inputSemaphore := Semaphore new.	hasInputSemaphore := false.! !!EventSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 20:13'!shutDown	super shutDown.	EventTicklerProcess ifNotNil: [		EventTicklerProcess terminate.		EventTicklerProcess _ nil. ].	inputSemaphore ifNotNil:[Smalltalk unregisterExternalObject: inputSemaphore].! !!EventSensor methodsFor: 'initialize' stamp: 'BG 8/18/2004 12:12'!startUp	"Run the I/O process"	self initialize.	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).	super startUp.	self installEventTickler.	" Smalltalk isMorphic ifTrue:[self flushAllButDandDEvents]. "	"Attempt to discover whether the input semaphore is actually being signaled."	hasInputSemaphore := false.	inputSemaphore initSignals.! !!EventSensor methodsFor: 'mouse' stamp: 'ar 5/18/2003 18:27'!createMouseEvent	"create and return a new mouse event from the current mouse 	position; this is useful for restarting normal event queue 	processing after manual polling"	| buttons modifiers pos mapped eventBuffer |	eventBuffer _ Array new: 8.	buttons _ self primMouseButtons.	pos _ self primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	eventBuffer		at: 1		put: EventTypeMouse;		 at: 2 put: Time millisecondClockValue;		 at: 3 put: pos x;		 at: 4 put: pos y;		 at: 5 put: mapped;		 at: 6 put: modifiers.	^ eventBuffer! !!EventSensor methodsFor: 'private' stamp: 'nk 4/12/2004 20:16'!eventTickler	"Poll infrequently to make sure that the UI process is not been stuck. 	If it has been stuck, then spin the event loop so that I can detect the 	interrupt key."	| delay |	delay := Delay forMilliseconds: self class eventPollPeriod.	self lastEventPoll.	"ensure not nil."	[| delta | 	[ delay wait.	delta := Time millisecondClockValue - lastEventPoll.	(delta < 0			or: [delta > self class eventPollPeriod])		ifTrue: ["force check on rollover"			self fetchMoreEvents]] on: Error do: [:ex | ].	true ] whileTrue.! !!EventSensor methodsFor: 'private' stamp: 'di 10/1/2001 20:52'!flushNonKbdEvents	eventQueue ifNil: [^ self].	eventQueue flushAllSuchThat:		[:buf | (self isKbdEvent: buf) not]! !!EventSensor methodsFor: 'private' stamp: 'nk 6/21/2004 10:40'!installEventTickler	"Initialize the interrupt watcher process. Terminate the old process if any."	"Sensor installEventTickler"	EventTicklerProcess ifNotNil: [EventTicklerProcess terminate].	EventTicklerProcess _ [self eventTickler] forkAt: Processor lowIOPriority.! !!EventSensor methodsFor: 'private' stamp: 'di 10/1/2001 20:51'!isKbdEvent: buf	^ (buf at: 1) = EventTypeKeyboard and: [(buf at: 4) = EventKeyChar]! !!EventSensor methodsFor: 'private' stamp: 'nk 3/18/2004 13:21'!lastEventPoll	"Answer the last clock value at which fetchMoreEvents was called."	^lastEventPoll ifNil: [ lastEventPoll _ Time millisecondClockValue ]! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 00:34'!primInterruptSemaphore: aSemaphore 	"Primitive. Install the argument as the semaphore to be signalled whenever the user presses the interrupt key. The semaphore will be signaled once each time the interrupt key is pressed."	interruptSemaphore _ aSemaphore.	"backward compatibility: use the old primitive which is obsolete now"	super primInterruptSemaphore: aSemaphore! !!EventSensor methodsFor: 'private' stamp: 'ar 2/6/2004 14:41'!primKbdNext	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| evtBuf |	self fetchMoreEvents.	keyboardBuffer isEmpty ifFalse:[^ keyboardBuffer next].	eventQueue ifNotNil:		[evtBuf _ eventQueue nextOrNilSuchThat: [:buf | self isKbdEvent: buf].		self flushNonKbdEvents].	^ evtBuf ifNotNil: [evtBuf at: 3]! !!EventSensor methodsFor: 'private' stamp: 'ar 2/6/2004 14:41'!primKbdPeek	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| char |	self fetchMoreEvents.	keyboardBuffer isEmpty ifFalse: [^ keyboardBuffer peek].	char _ nil.	eventQueue ifNotNil:		[eventQueue nextOrNilSuchThat:  "NOTE: must not return out of this block, so loop to end"			[:buf | (self isKbdEvent: buf) ifTrue: [char ifNil: [char _ buf at: 3]].			false  "NOTE: block value must be false so Queue won't advance"]].	^ char! !!EventSensor methodsFor: 'private' stamp: 'ar 2/6/2004 14:42'!primMouseButtons	self fetchMoreEvents.	self flushNonKbdEvents.	^ mouseButtons! !!EventSensor methodsFor: 'private' stamp: 'ar 2/6/2004 14:41'!primMousePt	self fetchMoreEvents.	self flushNonKbdEvents.	^ mousePosition! !!EventSensor methodsFor: 'private' stamp: 'ls 10/23/2000 14:14'!primSetInterruptKey: anInteger	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."	interruptKey _ anInteger.	"backward compatibility: use the old primitive which is obsolete now"	super primSetInterruptKey: anInteger! !!EventSensor methodsFor: 'private-I/O' stamp: 'nk 4/12/2004 20:01'!fetchMoreEvents	"Fetch more events from the VM"	| eventBuffer type |	"Reset input semaphore so clients can wait for the next events after this one."	inputSemaphore isSignaled		ifTrue: [ hasInputSemaphore _ true.			inputSemaphore initSignals ].	"Remember the last time that I checked for events."	lastEventPoll := Time millisecondClockValue.	eventBuffer := Array new: 8.	[self primGetNextEvent: eventBuffer.	type := eventBuffer at: 1.	type = EventTypeNone]		whileFalse: [self processEvent: eventBuffer].! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:12'!mapButtons: buttons modifiers: modifiers	"Map the buttons to yellow or blue based on the given modifiers.	If only the red button is pressed, then map		Ctrl-RedButton -> BlueButton.		Cmd-RedButton -> YellowButton.	"	(buttons = RedButtonBit)		ifFalse:[^buttons].	(modifiers allMask: CtrlKeyBit) 		ifTrue:[^BlueButtonBit].	(modifiers allMask: CommandKeyBit) 		ifTrue:[^YellowButtonBit].	^buttons! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:06'!primGetNextEvent: array	"Store the next OS event available into the provided array.	Essential. If the VM is not event driven the ST code will fall	back to the old-style mechanism and use the state based	primitives instead."	| kbd buttons modifiers pos mapped |	<primitive: 94>	"Simulate the events"	array at: 1 put: EventTypeNone. "assume no more events"	"First check for keyboard"	kbd _ super primKbdNext.	kbd = nil ifFalse:[		"simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^self].	"Then check for mouse"	buttons _ super primMouseButtons.	pos _ super primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	(pos = mousePosition and:[(mapped bitOr: (modifiers bitShift: 3)) = mouseButtons])		ifTrue:[^self].	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:16'!primSetInputSemaphore: semaIndex	"Set the input semaphore the VM should use for asynchronously signaling the availability of events. Primitive. Optional."	<primitive: 93>	^nil! !!EventSensor methodsFor: 'private-I/O' stamp: 'nk 2/11/2002 12:18'!processEvent: evt	"Process a single event. This method is run at high priority."	| type |	type _ evt at: 1.	"Check if the event is a user interrupt"	(type = EventTypeKeyboard and:[(evt at: 4) = 0 and:[		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])			 ifTrue:["interrupt key is meta - not reported as event"					^interruptSemaphore signal].	"Store the event in the queue if there's any"	type = EventTypeMouse ifTrue:		[evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)].	type = EventTypeKeyboard ifTrue:		["swap ctrl/alt keys"		KeyDecodeTable at: { evt at: 3 . evt at: 5 } ifPresent: [:a |			evt at: 3 put: a first;				at: 5 put: a second]].	self queueEvent: evt.	"Update state for InputSensor."	EventTypeMouse = type ifTrue:[self processMouseEvent: evt].	EventTypeKeyboard = type ifTrue:[self processKeyboardEvent: evt]! !!EventSensor methodsFor: 'private-I/O' stamp: 'nk 4/11/2001 18:28'!processKeyboardEvent: evt	"process a keyboard event, updating InputSensor state"	| charCode pressCode |	"Never update keyboardBuffer if we have an eventQueue active"	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).	eventQueue ifNotNil:[^self]. 	charCode _ evt at: 3.	charCode = nil ifTrue:[^self]. "extra characters not handled in MVC"	pressCode _ evt at: 4.	pressCode = EventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"	"mix in modifiers"	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).	keyboardBuffer nextPut: charCode.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:07'!processMouseEvent: evt	"process a mouse event, updating InputSensor state"	| modifiers buttons mapped |	mousePosition _ (evt at: 3) @ (evt at: 4).	buttons _ evt at: 5.	modifiers _ evt at: 6.	mapped _ self mapButtons: buttons modifiers: modifiers.	mouseButtons _ mapped bitOr: (modifiers bitShift: 3).! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/23/2000 14:55'!queueEvent: evt	"Queue the given event in the event queue (if any).	Note that the event buffer must be copied since it	will be reused later on."	eventQueue ifNil:[^self].	eventQueue nextPut: evt clone.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EventSensor class	instanceVariableNames: ''!!EventSensor class methodsFor: 'class initialization' stamp: 'nk 4/12/2004 18:55'!eventPollPeriod	^EventPollPeriod ifNil: [ EventPollPeriod _ 500 ].! !!EventSensor class methodsFor: 'class initialization' stamp: 'ar 7/23/2000 15:06'!install	"EventSensor install"	"Install an EventSensor in place of the current Sensor."	| newSensor |	Sensor shutDown.	newSensor _ self new.	newSensor startUp.	"Note: We must use #become: here to replace all references to the old sensor with the new one, since Sensor is referenced from all the existing controllers."	Sensor becomeForward: newSensor. "done"! !SharedPool subclass: #EventSensorConstants	instanceVariableNames: ''	classVariableNames: 'BlueButtonBit CommandKeyBit CtrlKeyBit EventKeyChar EventKeyDown EventKeyUp EventTypeDragDropFiles EventTypeKeyboard EventTypeMouse EventTypeNone OptionKeyBit RedButtonBit ShiftKeyBit YellowButtonBit'	poolDictionaries: ''	category: 'Kernel-Processes'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EventSensorConstants class	instanceVariableNames: ''!!EventSensorConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:26'!initialize	"EventSensorConstants initialize"	RedButtonBit := 4.	BlueButtonBit := 2.	YellowButtonBit := 1.	ShiftKeyBit := 1.	CtrlKeyBit := 2.	OptionKeyBit := 4.	CommandKeyBit := 8.	"Types of events"	EventTypeNone := 0.	EventTypeMouse := 1.	EventTypeKeyboard := 2.	EventTypeDragDropFiles := 3.	"Press codes for keyboard events"	EventKeyChar := 0.	EventKeyDown := 1.	EventKeyUp := 2.! !Object subclass: #Exception	instanceVariableNames: 'messageText tag signalContext handlerContext outerContext'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!Exception commentStamp: '<historical>' prior: 0!This is the main class used to implement the exception handling system (EHS).  It plays two distinct roles:  that of the exception, and that of the exception handler.  More specifically, it implements the bulk of the protocols laid out in the ANSI specification - those protocol names are reflected in the message categories.Exception is an abstract class.  Instances should neither be created nor trapped.  In most cases, subclasses should inherit from Error or Notification rather than directly from Exception.In implementing this EHS, The Fourth Estate Inc. incorporated some ideas and code from Craig Latta's EHS.  His insights were crucial in allowing us to implement BlockContext>>valueUninterruptably (and by extension, #ensure: and #ifCurtailed:), and we imported the following methods with little or no modification:ContextPart>>terminateTo:ContextPart>>terminateMethodContext>>receiver:MethodContext>>answer:Thanks, Craig!!!!Exception methodsFor: 'handling' stamp: 'ajh 2/1/2003 01:33'!pass	"Yield control to the enclosing exception action for the receiver."	handlerContext nextHandlerContext handleSignal: self! !!Exception methodsFor: 'handling' stamp: 'ajh 1/13/2002 15:09'!resume	"Return from the message that signaled the receiver."	self resume: nil! !!Exception methodsFor: 'handling' stamp: 'ajh 1/13/2002 15:14'!resume: resumptionValue	"Return resumptionValue as the value of the signal message."	self isResumable ifFalse: [IllegalResumeAttempt signal].	self resumeUnchecked: resumptionValue! !!Exception methodsFor: 'handling' stamp: 'ajh 6/27/2003 22:30'!resumeUnchecked: resumptionValue	"Return resumptionValue as the value of #signal, unless this was called after an #outer message, then return resumptionValue as the value of #outer."	| ctxt |	outerContext ifNil: [		signalContext return: resumptionValue	] ifNotNil: [		ctxt _ outerContext.		outerContext _ ctxt tempAt: 1. "prevOuterContext in #outer"		ctxt return: resumptionValue	].! !!Exception methodsFor: 'handling' stamp: 'ajh 9/30/2001 15:33'!return	"Return nil as the value of the block protected by the active exception handler."	self return: nil! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:37'!return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	handlerContext return: returnValue! !!Exception methodsFor: 'printing' stamp: 'pnm 8/16/2000 14:53'!description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !!Exception methodsFor: 'printing' stamp: 'ajh 9/30/2001 15:33'!messageText	"Return an exception's message text."	^messageText! !!Exception methodsFor: 'printing' stamp: 'ajh 9/30/2001 15:33'!printOn: stream	stream nextPutAll: self description! !!Exception methodsFor: 'printing' stamp: 'ajh 10/22/2001 14:24'!receiver	^ self signalerContext receiver! !!Exception methodsFor: 'printing' stamp: 'ar 6/28/2003 00:13'!signalerContext	"Find the first sender of signal(:)"	^ signalContext findContextSuchThat: [:ctxt |		(ctxt receiver == self or: [ctxt receiver == self class]) not]! !!Exception methodsFor: 'signaling' stamp: 'ajh 9/30/2001 15:33'!messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !!Exception methodsFor: 'signaling' stamp: 'ajh 2/1/2003 01:33'!signal	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."	signalContext _ thisContext contextTag.	^ thisContext nextHandlerContext handleSignal: self! !!Exception methodsFor: 'signaling' stamp: 'ajh 9/30/2001 20:13'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	^ self signal! !!Exception methodsFor: 'priv handling' stamp: 'ajh 9/30/2001 15:33'!defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !!Exception methodsFor: 'priv handling' stamp: 'ajh 2/1/2003 00:58'!isResumable	"Determine whether an exception is resumable."	^ true! !!Exception methodsFor: 'priv handling' stamp: 'ajh 1/29/2003 13:44'!privHandlerContext: aContextTag	handlerContext _ aContextTag! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exception class	instanceVariableNames: ''!!Exception class methodsFor: 'exceptionInstantiator' stamp: 'ajh 9/30/2001 21:54'!signal	"Signal the occurrence of an exceptional condition."	^ self new signal! !!Exception class methodsFor: 'exceptionInstantiator' stamp: 'ajh 9/30/2001 21:54'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	^ self new signal: signalerText! !!Exception class methodsFor: 'exceptionSelector' stamp: 'ajh 9/30/2001 15:33'!, anotherException	"Create an exception set."	^ExceptionSet new		add: self;		add: anotherException;		yourself! !!Exception class methodsFor: 'exceptionSelector' stamp: 'ajh 8/5/2003 11:33'!handles: exception	"Determine whether an exception handler will accept a signaled exception."	^ exception isKindOf: self! !Object subclass: #ExceptionSet	instanceVariableNames: 'exceptions'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ExceptionSet commentStamp: '<historical>' prior: 0!An ExceptionSet is a grouping of exception handlers which acts as a single handler.  Within the group, the most recently added handler will be the last handler found during a handler search (in the case where more than one handler in the group is capable of handling a given exception). !!ExceptionSet methodsFor: 'private' stamp: 'tfei 7/16/1999 1:07'!add: anException	exceptions add: anException! !!ExceptionSet methodsFor: 'private' stamp: 'tfei 3/23/1999 14:07'!initialize	exceptions := OrderedCollection new! !!ExceptionSet methodsFor: 'exceptionSelector' stamp: 'tfei 6/4/1999 18:37'!, anException	"Return an exception set that contains the receiver and the argument exception. This is commonly used to specify a set of exception selectors for an exception handler."	self add: anException.	^self! !!ExceptionSet methodsFor: 'exceptionSelector' stamp: 'pnm 8/16/2000 15:15'!handles: anException	"Determine whether an exception handler will accept a signaled exception."	exceptions do:		[:ex |		(ex handles: anException)			ifTrue: [^true]].	^false! !Object subclass: #ExternalSemaphoreTable	instanceVariableNames: ''	classVariableNames: 'ProtectTable'	poolDictionaries: ''	category: 'System-Support'!!ExternalSemaphoreTable commentStamp: '<historical>' prior: 0!By John M McIntosh johnmci@smalltalkconsulting.comThis class was written to mange the external semaphore table. When I was writing a Socket test server I discovered various race conditions on the access to the externalSemaphore table. This new class uses class side methods to restrict access using a mutex semaphore. It seemed cleaner to deligate the reponsibility here versus adding more code and another class variable to SystemDictionary Note that in Smalltalk recreateSpecialObjectsArray we still directly play with the table.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExternalSemaphoreTable class	instanceVariableNames: ''!!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:36'!clearExternalObjects	"Clear the array of objects that have been registered for use in non-Smalltalk code."	ProtectTable critical: [Smalltalk specialObjectsArray at: 39 put: Array new].! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:44'!registerExternalObject: anObject	^ ProtectTable critical: [self safelyRegisterExternalObject: anObject]! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:57'!safelyRegisterExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	| objects firstEmptyIndex obj sz newObjects |	objects _ Smalltalk specialObjectsArray at: 39.	"find the first empty slot"	firstEmptyIndex _ 0.	1 to: objects size do: [:i |		obj _ objects at: i.		obj == anObject ifTrue: [^ i].  "object already there, just return its index"		(obj == nil and: [firstEmptyIndex = 0]) ifTrue: [firstEmptyIndex _ i]].	"if no empty slots, expand the array"	firstEmptyIndex = 0 ifTrue: [		sz _ objects size.		newObjects _ objects species new: sz + 20.  "grow linearly"		newObjects replaceFrom: 1 to: sz with: objects startingAt: 1.		firstEmptyIndex _ sz + 1.		Smalltalk specialObjectsArray at: 39 put: newObjects.		objects _ newObjects].	objects at: firstEmptyIndex put: anObject.	^ firstEmptyIndex! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:59'!safelyUnregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered.	JMM change to return if we clear the element, since it should only appear once in the array"	| objects |	anObject ifNil: [^ self].	objects _ Smalltalk specialObjectsArray at: 39.	1 to: objects size do: [:i |		(objects at: i) == anObject ifTrue: 		[objects at: i put: nil.		^self]].! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:45'!unregisterExternalObject: anObject	ProtectTable critical: [self safelyUnregisterExternalObject: anObject]! !!ExternalSemaphoreTable class methodsFor: 'initialize' stamp: 'JMM 6/6/2000 20:32'!initialize	ProtectTable _ Semaphore forMutualExclusion! !Object subclass: #FakeClassPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!FakeClassPool commentStamp: '<historical>' prior: 0!The sole purpose of this class is to allow the Browser code pane to evaluate the class variables of the class whose method it is showing.  It does this by stuffing a pointer to the classpool dictionary of the class being shown into its own classpool.  It does this just around a doIt in the code pane.  An instance of FakeClasspool is then used as the receiver of the doIt.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FakeClassPool class	instanceVariableNames: ''!!FakeClassPool class methodsFor: 'as yet unclassified' stamp: 'di 5/10/1998 21:32'!adopt: classOrNil	"Temporarily use the classPool and sharedPools of another class"	classOrNil == nil		ifTrue: [classPool _ nil.				sharedPools _ nil]		ifFalse: [classPool _ classOrNil classPool.				sharedPools _ classOrNil sharedPools]! !Boolean subclass: #False	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!False commentStamp: '<historical>' prior: 0!False defines the behavior of its single instance, false -- logical negation. Notice how the truth-value checks become direct message sends, without the need for explicit testing.Be aware however that most of these methods are not sent as real messages in normal use. Most are inline coded by the compiler as test and jump bytecodes - avoiding the overhead of the full message sends. So simply redefining these methods here will have no effect.!!False methodsFor: 'logical operations'!& alternativeObject 	"Evaluating conjunction -- answer false since receiver is false."	^self! !!False methodsFor: 'logical operations'!not	"Negation -- answer true since the receiver is false."	^true! !!False methodsFor: 'logical operations'!| aBoolean 	"Evaluating disjunction (OR) -- answer with the argument, aBoolean."	^aBoolean! !!False methodsFor: 'controlling'!and: alternativeBlock 	"Nonevaluating conjunction -- answer with false since the receiver is false."	^self! !!False methodsFor: 'controlling'!ifFalse: alternativeBlock 	"Answer the value of alternativeBlock. Execution does not actually	reach here because the expression is compiled in-line."	^alternativeBlock value! !!False methodsFor: 'controlling'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 	"Answer the value of falseAlternativeBlock. Execution does not	actually reach here because the expression is compiled in-line."	^falseAlternativeBlock value! !!False methodsFor: 'controlling'!ifTrue: alternativeBlock 	"Since the condition is false, answer the value of the false alternative, 	which is nil. Execution does not actually reach here because the	expression is compiled in-line."	^nil! !!False methodsFor: 'controlling'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 	"Answer the value of falseAlternativeBlock. Execution does not	actually reach here because the expression is compiled in-line."	^falseAlternativeBlock value! !!False methodsFor: 'controlling'!or: alternativeBlock 	"Nonevaluating disjunction -- answer value of alternativeBlock."	^alternativeBlock value! !!False methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'false'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False class	instanceVariableNames: ''!!False class methodsFor: 'as yet unclassified' stamp: 'sw 5/8/2000 11:09'!initializedInstance	^ false! !Browser subclass: #FileContentsBrowser	instanceVariableNames: 'packages infoString'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!FileContentsBrowser commentStamp: '<historical>' prior: 0!I am a class browser view on a fileout (either a source file (.st) or change set (.cs)). I do not actually load the code into to the system, nor do I alter the classes in the image. Use me to vet code in a comfortable way before loading it into your image.From a FileList, I can be invoked by selecting a source file and selecting the "browse code" menu item from the yellow button menu.I use PseudoClass, PseudoClassOrganizers, and PseudoMetaclass to model the class structure of the source file.!!FileContentsBrowser methodsFor: 'accessing'!contents	self updateInfoView.	(editSelection == #newClass and:[self selectedPackage notNil])		ifTrue: [^self selectedPackage packageInfo].	editSelection == #editClass		ifTrue:[^self modifiedClassDefinition].	^super contents! !!FileContentsBrowser methodsFor: 'accessing' stamp: 'sw 5/23/2001 14:28'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [self inform: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText. ^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	self inform:'You cannot change the current selection'.	^false! !!FileContentsBrowser methodsFor: 'accessing'!packages	^packages! !!FileContentsBrowser methodsFor: 'accessing'!packages: aDictionary	packages := aDictionary.! !!FileContentsBrowser methodsFor: 'accessing'!selectedPackage	| cat |	cat := self selectedSystemCategoryName.	cat isNil ifTrue:[^nil].	^self packages at: cat asString ifAbsent:[nil]! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeClass	| class |	classListIndex = 0 ifTrue: [^ self].	class _ self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'ar 8/2/2003 21:00'!removeMessage	| messageName |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName _ self selectedMessageName.	(self selectedClass confirmRemovalOf: messageName)		ifFalse: [^ false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.	"In case organization not cached"	self changed: #messageList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:51'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:52'!removePackage	systemCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self confirm: 'Are you sure you want toremove this package and all its classes?') ifFalse:[^self].	(systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) do:[:el|		systemOrganizer removeElement: el].	self packages removeKey: self selectedPackage packageName.	systemOrganizer removeCategory: self selectedSystemCategoryName.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 2/3/1999 18:47'!removeUnmodifiedCategories	| theClass |	self okToChange ifFalse: [^self].	theClass _ self selectedClass.	theClass isNil ifTrue: [^self].	Cursor wait showWhile:		[theClass removeUnmodifiedMethods: theClass selectors.		theClass metaClass removeUnmodifiedMethods: theClass metaClass selectors].	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeUnmodifiedClasses	| packageList |	self okToChange ifFalse:[^self].	packageList := self selectedPackage isNil						ifTrue:[self packages] 						ifFalse:[Array with: self selectedPackage].	packageList do:[:package|		package classes copy do:[:theClass|			Cursor wait showWhile:[				theClass removeAllUnmodified.			].			theClass hasChanges ifFalse:[				package removeClass: theClass.			].		]].	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 2/3/1999 18:47'!removeUnmodifiedMethods	| theClass cat |	self okToChange ifFalse:[^self].	theClass := self selectedClassOrMetaClass.	theClass isNil ifTrue:[^self].	cat := self selectedMessageCategoryName.	cat isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'class list' stamp: 'sma 5/6/2000 18:48'!browseMethodFull	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass realClass selector: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'class list'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(systemCategoryListIndex = 0 or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asSortedCollection].! !!FileContentsBrowser methodsFor: 'class list'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser methodsFor: 'class list' stamp: 'wod 5/24/1998 20:37'!renameClass	| oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategoryName.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).! !!FileContentsBrowser methodsFor: 'class list'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	self selectedClassName == nil ifTrue: [^nil].	^self selectedPackage classAt: self selectedClassName! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'dew 9/22/2001 23:06'!selectedBytecodes	"Compile the source code for the selected message selector and extract and return	the bytecode listing."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	contents _ Compiler new					parse: contents					in: class					notifying: nil.	contents _ contents generate: #(0 0 0 0).	^ contents symbolic asText! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'sw 11/13/2001 08:41'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue: [contents _ Compiler new					format: contents					in: class					notifying: nil					decorated: Preferences colorWhenPrettyPrinting].	self showingAnyKindOfDiffs ifTrue:		[contents _ self			methodDiffFor: contents			class: self selectedClass			selector: self selectedMessageName			meta: self metaClassIndicated].	^ contents asText makeSelectorBoldIn: class! !!FileContentsBrowser methodsFor: 'diffs' stamp: 'sw 5/20/2001 21:03'!methodDiffFor: aString class: aPseudoClass selector: selector meta: meta 	"Answer the diff between the current copy of the given class/selector/meta for the string provided"	| theClass source |	theClass _ Smalltalk				at: aPseudoClass name				ifAbsent: [^ aString copy].	meta		ifTrue: [theClass _ theClass class].	(theClass includesSelector: selector)		ifFalse: [^ aString copy].	source _ theClass sourceCodeAt: selector.	^ Cursor wait		showWhile: [TextDiffBuilder buildDisplayPatchFrom: source to: aString inClass: theClass prettyDiffs: self showingPrettyDiffs]! !!FileContentsBrowser methodsFor: 'diffs'!modifiedClassDefinition	| pClass rClass old new diff |	pClass := self selectedClassOrMetaClass.	pClass hasDefinition ifFalse:[^pClass definition].	rClass := Smalltalk at: self selectedClass name asSymbol ifAbsent:[nil].	rClass isNil ifTrue:[^pClass definition].	self metaClassIndicated ifTrue:[ rClass := rClass class].	old := rClass definition.	new := pClass definition.	Cursor wait showWhile:[		diff := ClassDiffBuilder buildDisplayPatchFrom: old to: new	].	^diff! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInClass	Cursor read showWhile:[		self selectedClass fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 6/16/1998 17:14'!fileInMessage		self selectedMessageName ifNil: [^self].	Cursor read showWhile: [		self selectedClassOrMetaClass fileInMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 2/3/1999 18:46'!fileInMessageCategories	Cursor read showWhile:[		self selectedClassOrMetaClass fileInCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 12:50'!fileInPackage	Cursor read showWhile:[		self selectedPackage fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'nb 6/17/2003 12:25'!fileIntoNewChangeSet	| p ff |	(p _ self selectedPackage) ifNil: [^ Beeper beep].	ff _ StandardFileStream readOnlyFileNamed: p fullPackageName.	ChangeSorter newChangesFromStream: ff named: p packageName! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutClass	Cursor write showWhile:[		self selectedClass fileOut.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 6/16/1998 17:14'!fileOutMessage	self selectedMessageName ifNil: [^self].	Cursor write showWhile: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 2/3/1999 18:46'!fileOutMessageCategories	Cursor write showWhile:[		self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutPackage	Cursor write showWhile:[		self selectedPackage fileOut.	].! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'sma 5/6/2000 19:19'!extraInfo	^ (self		methodDiffFor: (self selectedClassOrMetaClass sourceCodeAt: self selectedMessageName)		class: self selectedClass		selector: self selectedMessageName		meta: self metaClassIndicated) unembellished			ifTrue: [' - identical']			ifFalse: [' - modified']! !!FileContentsBrowser methodsFor: 'infoView'!infoString	^infoString isNil		ifTrue:[infoString := StringHolder new]		ifFalse:[infoString]! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'sma 5/6/2000 18:26'!infoViewContents	| theClass |	editSelection == #newClass ifTrue: [^ self packageInfo: self selectedPackage].	self selectedClass isNil ifTrue: [^ ''].	theClass _ Smalltalk at: self selectedClass name asSymbol ifAbsent: [].	editSelection == #editClass ifTrue: [^ theClass notNil			ifTrue: ['Class exists already in the system']			ifFalse: ['New class']].	editSelection == #editMessage ifFalse: [^ ''].	(theClass notNil and: [self metaClassIndicated])		ifTrue: [theClass _ theClass class].	^ (theClass notNil and: [theClass includesSelector: self selectedMessageName])		ifTrue: ['Method already exists' , self extraInfo]		ifFalse: ['New method']! !!FileContentsBrowser methodsFor: 'infoView'!packageInfo: p	| nClasses newClasses oldClasses |	p isNil ifTrue:[^''].	nClasses := newClasses := oldClasses := 0.	p classes do:[:cls|		nClasses := nClasses + 1.		(Smalltalk includesKey: (cls name asSymbol))			ifTrue:[oldClasses := oldClasses + 1]			ifFalse:[newClasses := newClasses + 1]].	^nClasses printString,' classes (', newClasses printString, ' new / ', oldClasses printString, ' modified)'! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'BG 10/28/2003 20:55'!updateInfoView	Smalltalk isMorphic 		ifFalse: [			self infoString contents: self infoViewContents.			self infoString changed].! !!FileContentsBrowser methodsFor: 'metaclass' stamp: 'asm 10/6/2003 11:29'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	| cls |	self metaClassIndicated		ifTrue: [^ (cls _ self selectedClass) ifNotNil: [cls metaClass]]		ifFalse: [^ self selectedClass]! !!FileContentsBrowser methodsFor: 'metaclass'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'bkv 8/13/2003 23:59'!browseSenders	"Create and schedule a message set browser on all senders of the 	currently selected message selector. Do nothing if no message is selected."	messageListIndex ~= 0 		ifTrue: [self systemNavigation browseAllCallsOn: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'other' stamp: 'dew 9/20/2001 19:03'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		(class exists and: [class realClass includesSelector: selector]) ifTrue:			[VersionsBrowser				browseVersionsOf: (class realClass compiledMethodAt: selector)				class: class realClass theNonMetaClass				meta: class realClass isMeta				category: self selectedMessageCategoryName				selector: selector]]! !!FileContentsBrowser methodsFor: 'other'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self classListIndex: classListIndex.	^ true! !!FileContentsBrowser methodsFor: 'other' stamp: 'asm 5/30/2003 18:11'!didCodeChangeElsewhere	"Determine whether the code for the currently selected method and class has been changed somewhere else."	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ false].	(aClass isKindOf: PseudoClass) ifTrue: [^ false]. "class not installed"	^super didCodeChangeElsewhere! !!FileContentsBrowser methodsFor: 'other' stamp: 'sw 10/1/2001 11:16'!labelString	"Answer the string for the window title"	^ 'File Contents Browser ', (self selectedSystemCategoryName ifNil: [''])! !!FileContentsBrowser methodsFor: 'other' stamp: 'sma 2/6/2000 12:27'!methodHierarchy	(self selectedClassOrMetaClass isNil or:		[self selectedClassOrMetaClass hasDefinition])			ifFalse: [super methodHierarchy]! !!FileContentsBrowser methodsFor: 'creation' stamp: 'BG 10/28/2003 20:55'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	contentsSymbol _ self defaultDiffsSymbol.  "#showDiffs or #prettyDiffs"		(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:				keystroke: #packageListKey:from:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:				keystroke: #packageListKey:from:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sma 5/6/2000 18:36'!classListMenu: aMenu	^ aMenu 		labels:'definitioncommentbrowse full (b)class refs (N)fileInfileOutrename...removeremove existing'		lines: #(2 4 6 8)		selections: #(editClass editComment browseMethodFull browseClassRefs fileInClass fileOutClass renameClass removeClass removeUnmodifiedCategories) ! !!FileContentsBrowser methodsFor: 'menus' stamp: 'tpr 3/11/2001 21:26'!classListMenu: aMenu shifted: ignored	"Answer the class list menu, ignoring the state of the shift key in this case"	^ self classListMenu: aMenu! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sw 11/13/2001 09:12'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane.  For the file-contents browser, the choices are restricted to source and the two diffing options"	^ self sourceAndDiffsQuintsOnly! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 17:39'!messageCategoryMenu: aMenu	^ aMenu 		labels:'fileInfileOutreorganizeadd item...rename...removeremove existing'		lines: #(2 3 6)		selections: #(fileInMessageCategories fileOutMessageCategories editMessageCategories addCategory renameCategory removeMessageCategory removeUnmodifiedMethods)! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sma 2/6/2000 12:28'!messageListMenu: aMenu	^ aMenu 		labels:'fileInfileOutsenders (n)implementors (m)method inheritance (h)versions (v)remove'		lines: #(2 6)		selections: #(fileInMessage fileOutMessagebrowseSenders browseImplementors methodHierarchy browseVersionsremoveMessage).! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sma 4/22/2000 20:52'!packageListMenu: aMenu	^ aMenu 		labels:'find class... (f)fileInfile into new changesetfileOutremoveremove existing'		lines: #(1 4 5)		selections: #(findClass fileInPackage fileIntoNewChangeSet fileOutPackage removePackage removeUnmodifiedClasses)! !!FileContentsBrowser methodsFor: 'keys' stamp: 'sma 5/6/2000 18:48'!classListKey: aChar from: view	aChar == $b ifTrue: [^ self browseMethodFull].	aChar == $N ifTrue: [^ self browseClassRefs].	self packageListKey: aChar from: view! !!FileContentsBrowser methodsFor: 'keys' stamp: 'sma 5/6/2000 18:50'!messageListKey: aChar from: view	aChar == $b ifTrue: [^ self browseMethodFull].	super messageListKey: aChar from: view! !!FileContentsBrowser methodsFor: 'keys' stamp: 'sma 2/6/2000 12:05'!packageListKey: aChar from: view	aChar == $f ifTrue: [^ self findClass].	self arrowKey: aChar from: view! !!FileContentsBrowser methodsFor: 'initialize-release' stamp: 'dew 9/15/2001 16:19'!defaultBrowserTitle	^ 'File Contents Browser'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileContentsBrowser class	instanceVariableNames: ''!!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nb 6/17/2003 12:25'!browseFile: aFilename	"Open a file contents browser on a file of the given name"	aFilename ifNil: [^ Beeper beep].	self browseFiles: (Array with: aFilename)! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'dew 8/2/2000 20:02'!browseFiles: fileList	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict _ Dictionary new.		organizer _ SystemOrganizer defaultList: Array new.		fileList do: [:fileName |			package _ FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self new)			systemOrganizer: organizer;			packages: packageDict].	self		openBrowserView: browser createViews		label: 'File Contents Browser'.! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nk 2/17/2004 19:26'!browseStream: aStream	self browseStream: aStream named: aStream name! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nk 2/17/2004 19:25'!browseStream: aStream named: aString	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict _ Dictionary new.		organizer _ SystemOrganizer defaultList: Array new.		package _ (FilePackage new fullName: aString; fileInFrom: aStream).		packageDict 			at: package packageName 			put: package.		organizer 			classifyAll: package classes keys 			under: package packageName.		(browser := self new)			systemOrganizer: organizer;			packages: packageDict].	self		openBrowserView: browser createViews		label: 'File Contents Browser'.! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nk 2/17/2004 19:18'!fileReaderServicesForFile: fullName suffix: suffix	((FileStream isSourceFileSuffix: suffix) or: [ suffix = '*' ])		ifTrue: [ ^Array with: self serviceBrowseCode].	^(fullName endsWith: 'cs.gz')		ifTrue: [ Array with: self serviceBrowseCompressedCode ]		ifFalse: [#()]! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'SD 11/14/2001 22:13'!selectAndBrowseFile: aFileList	"When no file are selected you can ask to browse several of them"	| selectionPattern files |	selectionPattern := FillInTheBlank request:'What files?' initialAnswer: aFileList pattern.	files _ (aFileList directory fileNamesMatching: selectionPattern) 				collect: [:each | aFileList directory fullNameFor: each].	FileContentsBrowser browseFiles: files.! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nk 4/29/2004 10:35'!serviceBrowseCode	"Answer the service of opening a file-contents browser"	^ (SimpleServiceEntry		provider: self 		label: 'code-file browser'		selector: #browseStream:		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'		buttonLabel: 'code')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nk 4/29/2004 10:35'!serviceBrowseCompressedCode	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'code-file browser'		selector: #browseCompressedCodeStream:		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'		buttonLabel: 'code')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'sd 2/1/2002 21:40'!services	^ Array with: self serviceBrowseCode! !!FileContentsBrowser class methodsFor: 'class initialization' stamp: 'hg 8/3/2000 18:17'!initialize	FileList registerFileReader: self! !!FileContentsBrowser class methodsFor: 'class initialization' stamp: 'SD 11/15/2001 22:21'!unload	FileList unregisterFileReader: self ! !Object subclass: #FileDirectory	instanceVariableNames: 'pathName'	classVariableNames: 'DefaultDirectory DirectoryClass StandardMIMEMappings'	poolDictionaries: ''	category: 'System-Files'!!FileDirectory commentStamp: '<historical>' prior: 0!A FileDirectory represents a folder or directory in the underlying platform's file system. It carries a fully-qualified path name for the directory it represents, and can enumerate the files and directories within that directory.A FileDirectory can be thought of as a Dictionary whose keys are the local names of files in that directory, and whose values are directory "entries". Each entry is an array of five items:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>The times are given in seconds, and can be converted to a time and date via Time>dateAndTimeFromSeconds:. See the comment in lookupEntry:... which provides primitive access to this information.!!FileDirectory methodsFor: 'path access' stamp: 'ar 12/18/1999 01:01'!fullPathFor: path	^path isEmpty ifTrue:[pathName] ifFalse:[path]! !!FileDirectory methodsFor: 'path access' stamp: 'tk 5/18/1998 22:29'!on: fullPath	"Return another instance"	^ self class on: fullPath! !!FileDirectory methodsFor: 'path access' stamp: 'jm 12/5/97 12:18'!pathName	"Return the path from the root of the file system to this directory."	^ pathName! !!FileDirectory methodsFor: 'path access' stamp: 'jm 12/5/97 12:19'!pathNameDelimiter	"Return the delimiter character for this kind of directory. This depends on the current platform."	^ self class pathNameDelimiter! !!FileDirectory methodsFor: 'path access' stamp: 'jm 12/5/97 12:17'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names."	^ pathName findTokens: self pathNameDelimiter asString! !!FileDirectory methodsFor: 'path access' stamp: 'ar 12/18/1999 00:36'!slash	^self class slash! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!fileNamed: localFileName	"Open the file with the given name in this directory for writing."	^ FileStream concreteStream fileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'dew 10/26/2000 02:08'!forceNewFileNamed: localFileName	"Open the file with the given name in this directory for writing.  If it already exists, delete it first without asking."	^ FileStream concreteStream forceNewFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!newFileNamed: localFileName	"Create a new file with the given name in this directory."	^ FileStream concreteStream newFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!oldFileNamed: localFileName	"Open the existing file with the given name in this directory."	^ FileStream concreteStream oldFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tpr 10/13/2003 12:34'!oldFileOrNoneNamed: fileName	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."	^ FileStream oldFileOrNoneNamed: fileName! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!readOnlyFileNamed: localFileName	"Open the existing file with the given name in this directory for read-only access."	^ FileStream concreteStream readOnlyFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 1/5/98 20:49'!containingDirectory	"Return the directory containing this directory."	^ FileDirectory on: (FileDirectory dirPathFor: pathName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'tpr 10/13/2003 10:58'!directoryEntryFor: filenameOrPath	"Answer the directory entry for the given file or path. Sorta like a poor man's stat()."	| fName dir |	DirectoryClass splitName: filenameOrPath to:[:filePath :name |		fName _ name.		filePath isEmpty			ifTrue: [dir _ self]			ifFalse: [dir _ FileDirectory on: filePath]].	self isCaseSensitive 		ifTrue:[^dir entries detect:[:entry| entry name = fName] ifNone:[nil]]		ifFalse:[^dir entries detect:[:entry| entry name sameAs: fName] ifNone:[nil]]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:46'!directoryNamed: localFileName	"Return the subdirectory of this directory with the given name."	^ FileDirectory on: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:44'!directoryNames	"Return a collection of names for the subdirectories of this directory."	"FileDirectory default directoryNames"	^ (self entries select: [:entry | entry at: 4])		collect: [:entry | entry first]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 12:23'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name><creationTime><modificationTime><dirFlag><fileSize>). See primLookupEntryIn:index: for further details."	"FileDirectory default entries"	^ self directoryContentsFor: pathName! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:39'!fileAndDirectoryNames	"FileDirectory default fileAndDirectoryNames"	^ self entries collect: [:entry | entry first]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:44'!fileNames	"Return a collection of names for the files (but not directories) in this directory."	"FileDirectory default fileNames"	^ (self entries select: [:entry | (entry at: 4) not])		collect: [:entry | entry first]! !!FileDirectory methodsFor: 'enumeration' stamp: 'ar 3/15/2001 23:20'!fullName	"Return the full name of this directory."	^pathName! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:39'!keysDo: nameBlock	"Evaluate the given block for each file or directory name in this directory."	^ self fileAndDirectoryNames do: nameBlock! !!FileDirectory methodsFor: 'enumeration' stamp: 'ar 2/6/2001 15:48'!localName	"Return the local name of this directory."	^FileDirectory localNameFor: pathName! !!FileDirectory methodsFor: 'testing' stamp: 'tpr 2/17/2004 19:56'!directoryExists: filenameOrPath	"Answer true if a directory of the given name exists. The given name may be either a full path name or a local directory within this directory."	"FileDirectory default directoryExists: FileDirectory default pathName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ self directoryNamed: filePath]].	^dir exists and: [		self isCaseSensitive 			ifTrue:[dir directoryNames includes: fName]			ifFalse:[dir directoryNames anySatisfy: [:name| name sameAs: fName]]].! !!FileDirectory methodsFor: 'testing' stamp: 'nk 11/30/2002 14:06'!exists"Answer whether the directory exists"	| result |	result _ self primLookupEntryIn: pathName index: 1.	^ result ~= #badDirectoryPath! !!FileDirectory methodsFor: 'testing' stamp: 'tpr 10/13/2003 10:59'!fileExists: filenameOrPath	"Answer true if a file of the given name exists. The given name may be either a full path name or a local file within this directory."	"FileDirectory default fileExists: Smalltalk sourcesName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	self isCaseSensitive 		ifTrue:[^dir fileNames includes: fName]		ifFalse:[^dir fileNames anySatisfy: [:name| name sameAs: fName]].	! !!FileDirectory methodsFor: 'testing' stamp: 'di 11/21/1999 20:17'!includesKey: localName	"Answer true if this directory includes a file or directory of the given name. Note that the name should be a local file name, in contrast with fileExists:, which takes either local or full-qualified file names."	"(FileDirectory on: Smalltalk vmPath) includesKey: 'SqueakV2.sources'"	self isCaseSensitive		ifTrue:[^ self fileAndDirectoryNames includes: localName]		ifFalse:[^ self fileAndDirectoryNames anySatisfy: [:str| str sameAs: localName]].! !!FileDirectory methodsFor: 'testing' stamp: 'ar 5/30/2001 21:42'!isAFileNamed: fName	^FileStream isAFileNamed: (self fullNameFor: fName)! !!FileDirectory methodsFor: 'testing' stamp: 'ar 5/1/1999 01:51'!isCaseSensitive	"Return true if file names are treated case sensitive"	^self class isCaseSensitive! !!FileDirectory methodsFor: 'file operations' stamp: 'MPH 10/15/2000 12:43'!copyFile: fileStream1 toFile: fileStream2	| buffer |	buffer _ String new: 50000.	[fileStream1 atEnd] whileFalse:		[fileStream2 nextPutAll: (fileStream1 nextInto: buffer)].! !!FileDirectory methodsFor: 'file operations' stamp: 'dew 10/26/2000 02:23'!copyFileWithoutOverwriteConfirmationNamed: fileName1 toFileNamed: fileName2	"Copy the contents of the existing file with the first name into a file with the second name (which may or may not exist). If the second file exists, force an overwrite without confirming.  Both files are assumed to be in this directory."	"FileDirectory default copyFileWithoutOverwriteConfirmationNamed: 'todo.txt' toFileNamed: 'todocopy.txt'"	| file1 file2 |	fileName1 = fileName2 ifTrue: [^ self].	file1 _ (self readOnlyFileNamed: fileName1) binary.	file2 _ (self forceNewFileNamed: fileName2) binary.	self copyFile: file1 toFile: file2.	file1 close.	file2 close.! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/4/97 22:55'!createDirectory: localFileName	"Create a directory with the given name in this directory. Fail if the name is bad or if a file or directory with that name already exists." 	self primCreateDirectory: (self fullNameFor: localFileName).! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 4/9/1999 18:02'!deleteDirectory: localDirName	"Delete the directory with the given name in this directory. Fail if the path is bad or if a directory by that name does not exist." 	self primDeleteDirectory: (self fullNameFor: localDirName).! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/5/97 16:33'!deleteFileNamed: localFileName	"Delete the file with the given name in this directory."	self deleteFileNamed: localFileName ifAbsent: [].! !!FileDirectory methodsFor: 'file operations' stamp: 'ar 12/12/2001 15:56'!deleteFileNamed: localFileName ifAbsent: failBlock	"Delete the file of the given name if it exists, else evaluate failBlock.	If the first deletion attempt fails do a GC to force finalization of any lost references. ar 3/21/98 17:53"	| fullName |	fullName _ self fullNameFor: localFileName.	(StandardFileStream 		retryWithGC:[self primDeleteFileNamed: (self fullNameFor: localFileName)]		until:[:result| result notNil]		forFileNamed: fullName) == nil			ifTrue: [^failBlock value].! !!FileDirectory methodsFor: 'file operations' stamp: 'tpr 10/13/2003 10:59'!fileOrDirectoryExists: filenameOrPath	"Answer true if either a file or a directory file of the given name exists. The given name may be either a full path name or a local name within this directory."	"FileDirectory default fileOrDirectoryExists: Smalltalk sourcesName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	^ (dir includesKey: fName) or: [ fName = '' and:[ dir entries size > 1]]! !!FileDirectory methodsFor: 'file operations' stamp: 'ar 12/12/2001 15:57'!rename: oldFileName toBe: newFileName	| selection oldName newName |	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	"Modified for retry after GC ar 3/21/98 18:09"	oldName _ self fullNameFor: oldFileName.	newName _ self fullNameFor: newFileName.	(StandardFileStream 		retryWithGC:[self primRename: oldName to: newName]		until:[:result| result notNil]		forFileNamed: oldName) ~~ nil ifTrue:[^self].	(self fileExists: oldFileName) ifFalse:[		^self error:'Attempt to rename a non-existent file'.	].	(self fileExists: newFileName) ifTrue:[		selection _ (PopUpMenu labels:'delete old versioncancel')				startUpWithCaption: 'Trying to rename a file to be', newFileName , 'and it already exists.'.		selection = 1 ifTrue:			[self deleteFileNamed: newFileName.			^ self rename: oldFileName toBe: newFileName]].	^self error:'Failed to rename file'.! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 3/27/98 06:40'!setMacFileNamed: fileName type: typeString creator: creatorString	"Set the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. Does nothing on other platforms (where the underlying primitive is a noop)."	"FileDirectory default setMacFileNamed: 'foo' type: 'TEXT' creator: 'ttxt'" 	self primSetMacFileNamed: (self fullNameFor: fileName)		type: typeString		creator: creatorString.! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 5/8/1998 20:48'!checkName: aFileName fixErrors: fixing	"Check a string aFileName for validity as a file name. Answer the original file name if it is valid. If the name is not valid (e.g., it is too long or contains illegal characters) and fixing is false, raise an error. If fixing is true, fix the name (usually by truncating and/or tranforming characters), and answer the corrected name. The default behavior is just to truncate the name to the maximum length for this platform. Subclasses can do any kind of checking and correction appropriate for their platform."	| maxLength |	aFileName size = 0 ifTrue: [self error: 'zero length file name'].	maxLength _ self class maxFileNameLength.	aFileName size > maxLength ifTrue: [		fixing			ifTrue: [^ aFileName contractTo: maxLength]			ifFalse: [self error: 'file name is too long']].	^ aFileName! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 12/4/97 21:01'!fileNamesMatching: pat	"FileDirectory default fileNamesMatching: '*'"	^ self fileNames select: [:name | pat match: name]! !!FileDirectory methodsFor: 'file name utilities' stamp: 'tpr 10/13/2003 10:59'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	"Details: Note that path relative to a directory, such as '../../foo' are disallowed by this algorithm.  Also note that this method is tolerent of a nil argument -- is simply returns nil in this case."	| correctedLocalName prefix |	fileName ifNil: [^ nil].	DirectoryClass splitName: fileName to:		[:filePath :localName |			correctedLocalName _ localName isEmpty 				ifFalse: [self checkName: localName fixErrors: true]				ifTrue: [localName].			prefix _ self fullPathFor: filePath].	prefix isEmpty		ifTrue: [^correctedLocalName].	prefix last = self pathNameDelimiter		ifTrue:[^ prefix, correctedLocalName]		ifFalse:[^ prefix, self slash, correctedLocalName]! !!FileDirectory methodsFor: 'file name utilities' stamp: 'djp 10/27/1999 09:01'!nextNameFor: baseFileName extension: extension	"Assumes a file name includes a version number encoded as '.' followed by digits 	preceding the file extension.  Increment the version number and answer the new file name.	If a version number is not found, set the version to 1 and answer a new file name"	| files splits version |	files _ self fileNamesMatching: (baseFileName,'*', self class dot, extension).	splits _ files 			collect: [:file | self splitNameVersionExtensionFor: file]			thenSelect: [:split | (split at: 1) = baseFileName].	splits _ splits asSortedCollection: [:a :b | (a at: 2) < (b at: 2)].	splits isEmpty 			ifTrue: [version _ 1]			ifFalse: [version _ (splits last at: 2) + 1].	^ (baseFileName, '.', version asString, self class dot, extension) asFileName! !!FileDirectory methodsFor: 'file name utilities' stamp: 'djp 10/27/1999 08:58'!splitNameVersionExtensionFor: fileName	" answer an array with the root name, version # and extension.	See comment in nextSequentialNameFor: for more details"	| baseName version extension i j |	baseName _ self class baseNameFor: fileName.	extension _ self class extensionFor: fileName.	i _ j _ baseName findLast: [:c | c isDigit not].	i = 0		ifTrue: [version _ 0]		ifFalse:			[(baseName at: i) = $.				ifTrue:					[version _ (baseName copyFrom: i+1 to: baseName size) asNumber.					j _ j - 1]				ifFalse: [version _ 0].			baseName _ baseName copyFrom: 1 to: j].	^ Array with: baseName with: version with: extension! !!FileDirectory methodsFor: 'file name utilities' stamp: 'gk 2/10/2004 13:23'!url	"Convert my path into a file:// type url String."		^self asUrl toText! !!FileDirectory methodsFor: 'printing' stamp: 'jm 12/4/97 19:41'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: self class name.	aStream nextPutAll: ' on '.	pathName printOn: aStream.! !!FileDirectory methodsFor: 'private' stamp: 'ar 5/30/2001 20:49'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primCreateDirectory: fullPath	"Create a directory named by the given path. Fail if the path is bad or if a file or directory by that name already exists." 	<primitive: 'primitiveDirectoryCreate' module: 'FilePlugin'>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primDeleteDirectory: fullPath	"Delete the directory named by the given path. Fail if the path is bad or if a directory by that name does not exist." 	<primitive: 'primitiveDirectoryDelete' module: 'FilePlugin'>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primDeleteFileNamed: aFileName	"Delete the file of the given name. Return self if the primitive succeeds, nil otherwise."	<primitive: 'primitiveFileDelete' module: 'FilePlugin'>	^ nil! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 'primitiveDirectoryLookup' module: 'FilePlugin'>	^ #badDirectoryPath! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primRename: oldFileFullName to: newFileFullName 	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name.	Changed to return nil instead of failing ar 3/21/98 18:04"	<primitive: 'primitiveFileRename' module: 'FilePlugin'>	^nil! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSetMacFileNamed: fileName type: typeString creator: creatorString	"Set the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. This primitive is Mac specific; it is a noop on other platforms." 	<primitive: 'primitiveDirectorySetMacTypeAndCreator' module: 'FilePlugin'>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 22:44'!setPathName: pathString	pathName _ pathString.! !!FileDirectory methodsFor: 'file directory' stamp: 'hg 2/2/2002 16:37'!assureExistence	"Make sure the current directory exists. If necessary, create all parts in between"	self containingDirectory assureExistenceOfPath: self localName! !!FileDirectory methodsFor: 'file directory' stamp: 'nk 3/13/2003 10:18'!assureExistenceOfPath: localPath	"Make sure the local directory exists. If necessary, create all parts in between"	localPath isEmpty ifTrue: [ ^self ]. "Assumed to exist"	(self directoryExists: localPath) ifTrue: [^ self]. "exists"	"otherwise check parent first and then create local dir"	self containingDirectory assureExistenceOfPath: self localName.	self createDirectory: localPath! !!FileDirectory methodsFor: 'file directory' stamp: 'RAA 7/28/2000 13:47'!localNameFor: fullName	"Return the local part the given name."	^self class localNameFor: fullName! !!FileDirectory methodsFor: 'file directory' stamp: 'tk 12/13/1999 18:55'!sleep	"Leave the FileList window.  Do nothing.  Disk directories do not have to be shut down."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileDirectory class	instanceVariableNames: ''!!FileDirectory class methodsFor: 'instance creation' stamp: 'jm 12/4/97 19:24'!default	"Answer the default directory."	^ DefaultDirectory! !!FileDirectory class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 00:59'!forFileName: aString	| path |	path _ self dirPathFor: aString.	path isEmpty ifTrue: [^ self default].	^ self on: path! !!FileDirectory class methodsFor: 'instance creation' stamp: 'tpr 10/13/2003 10:49'!on: pathString	"Return a new file directory for the given path, of the appropriate FileDirectory subclass for the current OS platform."	| pathName |	DirectoryClass ifNil: [self setDefaultDirectoryClass].	"If path ends with a delimiter (: or /) then remove it"	((pathName _ pathString) endsWith: self pathNameDelimiter asString) ifTrue: [		pathName _ pathName copyFrom: 1 to: pathName size - 1].	^ DirectoryClass new setPathName: pathName! !!FileDirectory class methodsFor: 'instance creation' stamp: 'jm 12/4/97 23:29'!root	"Answer the root directory."	^ self on: ''! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 3/6/2004 20:18'!baseNameFor: fileName	"Return the given file name without its extension, if any. We have to remember that many (most?) OSs allow extension separators within directory names and so the leaf filename needs to be extracted, trimmed and rejoined. Yuck"	"The test is 		FileDirectory baseNameFor: ((FileDirectory default directoryNamed: 'foo.bar') fullNameFor:'blim.blam') 		should end 'foo.bar/blim' (or as appropriate for your platform AND		FileDirectory baseNameFor: ((FileDirectory default directoryNamed: 'foo.bar') fullNameFor:'blim')		should be the same and NOT  'foo'		Oh, and FileDirectory baseNameFor: 'foo.bar' should be 'foo' not '/foo' "	| delim i leaf |	self splitName: fileName to: [:path : fn|				delim _ DirectoryClass extensionDelimiter.		i _ fn findLast: [:c | c = delim].		leaf _ i = 0			ifTrue: [fn]			ifFalse: [fn copyFrom: 1 to: i - 1].		path isEmpty ifTrue:[^leaf].		^path, self slash, leaf]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:32'!changeSuffix"if 'changes' is not suitable, override this message to return something that is ok"	^'changes'! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jf 2/7/2004 17:22'!checkName: fileName fixErrors: flag	"Check a string fileName for validity as a file name on the current default file system. Answer the original file name if it is valid. If the name is not valid (e.g., it is too long or contains illegal characters) and fixing is false, raise an error. If fixing is true, fix the name (usually by truncating and/or tranforming characters), and answer the corrected name. The default behavior is to truncate the name to 31 chars. Subclasses can do any kind of checking and correction appropriate to the underlying platform."	^ DefaultDirectory		checkName: fileName		fixErrors: flag! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 10/13/2003 10:59'!dirPathFor: fullName 	"Return the directory part the given name."	DirectoryClass		splitName: fullName		to: [:dirPath :localName | ^ dirPath]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'ar 4/7/2002 15:47'!directoryEntryFor: filenameOrPath	^self default directoryEntryFor: filenameOrPath! !!FileDirectory class methodsFor: 'name utilities'!extensionFor: fileName	"Return the extension of given file name, if any."	| delim i |	delim _ DirectoryClass extensionDelimiter.	i _ fileName findLast: [:c | c = delim].	i = 0		ifTrue: [^ '']		ifFalse: [^ fileName copyFrom: i + 1 to: fileName size].! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:31'!imageSuffix"if 'image' is not suitable, override this message to return something that is ok"	^'image'! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 10/13/2003 10:59'!localNameFor: fullName 	"Return the local part the given name."	DirectoryClass		splitName: fullName		to: [:dirPath :localName | ^ localName]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'bf 3/22/2000 18:04'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. FileName must be of the form: <dirPath><delimiter><localName>, where <dirPath><delimiter> is optional. The <dirPath> part may contain delimiters."	| delimiter i dirName localName |	delimiter _ self pathNameDelimiter.	(i _ fullName findLast: [:c | c = delimiter]) = 0		ifTrue:			[dirName _ String new.			localName _ fullName]		ifFalse:			[dirName _ fullName copyFrom: 1 to: (i - 1 max: 1).			localName _ fullName copyFrom: i + 1 to: fullName size].	^ pathAndNameBlock value: dirName value: localName! !!FileDirectory class methodsFor: 'name utilities' stamp: 'ssa 9/3/2008 11:25'!startUp	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."	self setDefaultDirectoryClass.	self setDefaultDirectory: (self dirPathFor: SmalltalkImage current imageName).	Preferences startInUntrustedDirectory 		ifTrue:[				DefaultDirectory assureExistence].	SmalltalkImage current openSourceFiles.! !!FileDirectory class methodsFor: 'create/delete file' stamp: 'tk 1/13/98 17:21'!deleteFilePath: fullPathToAFile	"Delete the file after finding its directory"	| dir |	dir _ self on: (self dirPathFor: fullPathToAFile).	dir deleteFileNamed: (self localNameFor: fullPathToAFile).! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 10/9/2003 16:27'!openChanges: changesName forImage: imageName"find the changes file by looking ina) the directory derived from the image nameb) the DefaultDirectory (which will normally be the directory derived from the image name or the SecurityManager's choice)If an old file is not found in either place, check for a read-only file in the same places. If that fails, return nil"	| changes fd |	"look for the changes file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: changesName)		ifTrue: [changes _ fd oldFileNamed: changesName].	changes ifNotNil:[^changes].	"look for the changes in the default directory"	fd _ DefaultDirectory.	(fd fileExists: changesName)		ifTrue: [changes _ fd oldFileNamed: changesName].	changes ifNotNil:[^changes].	"look for read-only changes in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: changesName)		ifTrue: [changes _ fd readOnlyFileNamed: changesName].	changes ifNotNil:[^changes].	"look for read-only changes in the default directory"	fd _ DefaultDirectory.	(fd fileExists: changesName)		ifTrue: [changes _ fd readOnlyFileNamed: changesName].	"this may be nil if the last try above failed to open a file"	^changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 12/15/2003 12:02'!openSources: sourcesName andChanges: changesName forImage: imageName 	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or CR/CRLF mixups."	"Note: SourcesName and imageName are full paths; changesName is a  	local name."	| sources changes msg wmsg |	msg _ 'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	wmsg _ 'Squeak cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.	sources _ self openSources: sourcesName forImage: imageName.	changes _ self openChanges: changesName forImage: imageName.	((sources == nil or: [sources atEnd])			and: [Preferences valueOfFlag: #warnIfNoSourcesFile])		ifTrue: [SmalltalkImage current platformName = 'Mac OS'				ifTrue: [msg _ msg , 'Make sure the sources file is not an Alias.'].self inform: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName)].	(changes == nil			and: [Preferences valueOfFlag: #warnIfNoChangesFile])		ifTrue: [self inform: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	((Preferences valueOfFlag: #warnIfNoChangesFile) and: [changes notNil])		ifTrue: [changes isReadOnly				ifTrue: [self inform: (wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].			((changes next: 200)					includesSubString: String crlf)				ifTrue: [self inform: 'The changes file named ' , changesName , 'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.']].	SourceFiles _ Array with: sources with: changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 2/17/2004 19:59'!openSources: fullSourcesName forImage: imageName "We first do a check to see if a compressed version ofthe sources file is present.Open the .sources file read-only after searching in:a) the directory where the VM livesb) the directory where the image came fromc) the DefaultDirectory (which is likely the same as b unless the SecurityManager has changed it)."	| sources fd sourcesName |	(fullSourcesName endsWith: 'sources') ifTrue:		["Look first for a sources file in compressed format."		sources _ self openSources: (fullSourcesName allButLast: 7) , 'stc'						forImage: imageName.		sources ifNotNil: [^ CompressedSourceStream on: sources]].	sourcesName _ FileDirectory localNameFor: fullSourcesName.	"look for the sources file or an alias to it in the VM's directory"	fd _ FileDirectory on: SmalltalkImage current vmPath.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil: [^ sources].	"look for the sources file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil: [^ sources].	"look for the sources in the current directory"	fd _ DefaultDirectory.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	"sources may still be nil here"	^sources! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 10/13/2003 10:49'!setDefaultDirectory: directoryName	"Initialize the default directory to the directory supplied. This method is called when the image starts up, very early in the #startUp sequence."	DefaultDirectory _ self on: directoryName.! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 10/13/2003 10:39'!setDefaultDirectoryClass	"Initialize the default directory class to suit this platform. This method is called when the image starts up - it needs to be right at the front of the list of the startup sequence"	DirectoryClass _ self activeDirectoryClass! !!FileDirectory class methodsFor: 'system start up' stamp: 'sd 11/16/2003 13:13'!shutDown	SmalltalkImage current closeSourceFiles.! !!FileDirectory class methodsFor: 'platform specific' stamp: 'jm 3/27/98 08:17'!dot	"Return a one-character string containing the filename extension delimiter for this platform (i.e., the local equivalent of 'dot')"	^ self extensionDelimiter asString! !!FileDirectory class methodsFor: 'platform specific' stamp: 'jm 3/27/98 06:57'!extensionDelimiter	"Return the character used to delimit filename extensions on this platform. Most platforms use the period (.) character."	^ $.! !!FileDirectory class methodsFor: 'platform specific' stamp: 'ar 5/1/1999 01:48'!isCaseSensitive	"Return true if file names are treated case sensitive"	^true! !!FileDirectory class methodsFor: 'platform specific' stamp: 'jm 5/8/1998 20:45'!maxFileNameLength	^ 31! !!FileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:49'!pathNameDelimiter"return the active directory class's directory seperator character"	^ DirectoryClass pathNameDelimiter! !!FileDirectory class methodsFor: 'platform specific' stamp: 'ar 4/18/1999 18:18'!slash	^ self pathNameDelimiter asString! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:47'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	FileDirectory allSubclasses do: [:class |		class isActiveDirectoryClass ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:40'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	Default test is whether the primPathNameDelimiter matches the one for this class. Other tests are possible"	^self pathNameDelimiter = self primPathNameDelimiter! !!FileDirectory class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primPathNameDelimiter	"Return the path delimiter for the underlying platform's file system." 	<primitive: 'primitiveDirectoryDelimitor' module: 'FilePlugin'>	self primitiveFailed! !FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!FileDoesNotExistException methodsFor: 'accessing' stamp: 'mir 7/25/2000 16:41'!readOnly	^readOnly == true! !!FileDoesNotExistException methodsFor: 'accessing' stamp: 'mir 7/25/2000 16:40'!readOnly: aBoolean	readOnly _ aBoolean! !!FileDoesNotExistException methodsFor: 'exceptionDescription' stamp: 'mir 7/25/2000 18:22'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [StandardFileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [StandardFileStream fileDoesNotExistUserHandling: self fileName]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileDoesNotExistException class	instanceVariableNames: ''!!FileDoesNotExistException class methodsFor: 'examples' stamp: 'mir 2/29/2000 11:44'!example	"FileDoesNotExistException example"	| result |	result _ [(StandardFileStream readOnlyFileNamed: 'error42.log') contentsOfEntireFile]		on: FileDoesNotExistException		do: [:ex | 'No error log'].	Transcript show: result; cr! !FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!FileExistsException methodsFor: 'accessing' stamp: 'LC 10/24/2001 21:49'!fileClass	^ fileClass ifNil: [StandardFileStream]! !!FileExistsException methodsFor: 'accessing' stamp: 'LC 10/24/2001 21:42'!fileClass: aClass	fileClass _ aClass! !!FileExistsException methodsFor: 'exceptionDescription' stamp: 'LC 10/24/2001 21:50'!defaultAction	"The default action taken if the exception is signaled."	^ self fileClass fileExistsUserHandling: self fileName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileExistsException class	instanceVariableNames: ''!!FileExistsException class methodsFor: 'exceptionInstantiator' stamp: 'LC 10/24/2001 21:50'!fileName: aFileName fileClass: aClass 	^ self new		fileName: aFileName;		fileClass: aClass! !StringHolder subclass: #FileList	instanceVariableNames: 'fileName directory volList volListIndex list listIndex pattern sortMode brevityState'	classVariableNames: 'FileReaderRegistry RecentDirs'	poolDictionaries: ''	category: 'Tools-FileList'!!FileList commentStamp: 'nk 11/26/2002 11:52' prior: 0!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.The FileList now provides a registration mechanism to which any tools the filelist uses ***MUST*** register.  This way it is possible to dynamically load or unload a new tool and have the FileList automatically updated.  This change supports a decomposition of Squeak and removes a problem with dead reference to classes after a major shrink.Tools should implement the following methods (look for implementors in the image):#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)#services (all provided services, to be displayed in full list)These methods both return a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.Tools must register with the FileList calling the class method #registerFileReader: when they load. They also must call #unregisterFileReader: when they unload.There is a testSuite called FileListTest that presents some examples. Stef (I do not like really this distinction passing always a file list could be better)Old Comments: FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/19/2003 10:08'!acceptDroppingMorph: aTransferMorph event: evt inMorph: dest	| oldName oldEntry destDirectory newName newEntry baseName response |	destDirectory _ self dropDestinationDirectory: dest event: evt.	oldName _ aTransferMorph passenger.	baseName _ FileDirectory localNameFor: oldName.	newName _ destDirectory fullNameFor: baseName.	newName = oldName ifTrue: [ "Transcript nextPutAll: 'same as old name'; cr." ^ true ].	oldEntry _ FileDirectory directoryEntryFor: oldName.	newEntry _ FileDirectory directoryEntryFor: newName.	newEntry ifNotNil: [ | msg |		msg _ String streamContents: [ :s |			s nextPutAll: 'destination file ';				nextPutAll: newName;				nextPutAll: ' exists already,';				cr;				nextPutAll: 'and is ';				nextPutAll: (oldEntry modificationTime < newEntry modificationTime					ifTrue: [ 'newer' ] ifFalse: [ 'not newer' ]);				nextPutAll: ' than source file ';				nextPutAll: oldName;				nextPut: $.;				cr;				nextPutAll: 'Overwrite file ';				nextPutAll: newName;				nextPut: $?		].		response _ self confirm: msg.		response ifFalse: [ ^false ].	].	aTransferMorph shouldCopy		ifTrue: [ self primitiveCopyFileNamed: oldName to: newName ]		ifFalse: [ directory rename: oldName toBe: newName ].	self updateFileList; fileListIndex: 0.	aTransferMorph source model ~= self		ifTrue: [ aTransferMorph source model updateFileList; fileListIndex: 0 ].	"Transcript nextPutAll: 'copied'; cr."	^true! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/14/2003 12:58'!dragPassengerFor: item inMorph: dragSource	^self directory fullNameFor: ((self fileNameFromFormattedItem: item contents copy)		copyReplaceAll: self folderString with: '').! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/14/2003 11:16'!dragTransferTypeForMorph: aMorph	^#file! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/15/2003 13:07'!dropDestinationDirectory: dest event: evt 	"Answer a FileDirectory representing the drop destination in the volume list morph dest"	| index dir delim path |	index _ volList indexOf: (dest itemFromPoint: evt position) contents.	index = 1		ifTrue: [dir _ FileDirectory on: '']		ifFalse: [delim _ directory pathNameDelimiter.			path _ String						streamContents: [:str | 							2								to: index								do: [:d | 									str nextPutAll: (volList at: d) withBlanksTrimmed.									d < index										ifTrue: [str nextPut: delim]].							nil].			dir _ directory on: path].	^ dir! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/15/2003 21:58'!isDirectoryList: aMorph	^aMorph getListSelector == #volumeList! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/12/2004 16:17'!primitiveCopyFileNamed: srcName to: dstName 	"Copied from VMMaker code.	This really ought to be a facility in file system. The major annoyance 	here is that file types and permissions are not handled by current 	Squeak code.	NOTE that this will clobber the destination file!!"	| buffer src dst |	<primitive: 'primitiveFileCopyNamedTo' module:'FileCopyPlugin'> "primitiveExternalCall" 	"If the plugin doesn't do it, go the slow way and lose the filetype info"	"This method may signal FileDoesNotExistException if either the source or 	dest files cannnot be opened; possibly permissions or bad name problems"	[[src _ FileStream readOnlyFileNamed: srcName]		on: FileDoesNotExistException		do: [^ self error: ('could not open file ', srcName)].	[dst _ FileStream forceNewFileNamed: dstName]		on: FileDoesNotExistException		do: [^ self error: ('could not open file ', dstName)].	buffer _ String new: 50000.	[src atEnd]		whileFalse: [dst				nextPutAll: (src nextInto: buffer)]]		ensure: [src				ifNotNil: [src close].			dst				ifNotNil: [dst close]]! !!FileList methodsFor: 'file list'!fileList	"Answer the list of files in the current volume."	^ list! !!FileList methodsFor: 'file list'!fileListIndex	"Answer the index of the currently selected file."	^ listIndex! !!FileList methodsFor: 'file list' stamp: 'BG 10/29/2003 10:05'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self halt. "self directory: (ServerDirectory serverNamed: name allButFirst)"]						ifFalse: [volListIndex = 1 ifTrue: [name _ name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.	self updateButtonRow! !!FileList methodsFor: 'file list' stamp: 'sd 2/14/2002 16:58'!fileName	^ fileName! !!FileList methodsFor: 'file list' stamp: 'nk 4/29/2004 10:34'!readOnlyStream	"Answer a read-only stream on the selected file. For the various stream-reading services."	^self directory ifNotNilDo: [ :dir | dir readOnlyFileNamed: self fileName ]! !!FileList methodsFor: 'file list menu' stamp: 'RAA 2/2/2002 08:18'!dirAndFileName	^{directory. fileName}! !!FileList methodsFor: 'file list menu' stamp: 'dgd 9/19/2003 11:20'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| shiftMenu services maybeLine extraLines |	shifted ifTrue:		[shiftMenu _ ParagraphEditor shiftedYellowButtonMenu.		^ aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: shiftMenu selections].	fileName ifNotNil:		[services _ OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		maybeLine _ services size.		(#('st' 'cs') includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines _ OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList methodsFor: 'file list menu' stamp: 'LEG 10/24/2001 15:37'!fileListMenu: aMenu	fileName		ifNil: [^ self noFileSelectedMenu: aMenu]		ifNotNil: [^ self fileSelectedMenu: aMenu].! !!FileList methodsFor: 'file list menu' stamp: 'nk 11/16/2002 13:00'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 services |	firstItems _ self itemsForFile: self fullName.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems size.	n2 _ n1 + secondItems size.	n3 _ n2 + thirdItems size.	services _ firstItems, secondItems, thirdItems, self serviceAllFileOptions.	services do: [ :svc | svc addDependent: self ].	^ aMenu 		addServices2: services 		for: self		extraLines: (Array with: n1 with: n2 with: n3)! !!FileList methodsFor: 'file list menu' stamp: 'ssa 9/3/2008 11:18'!fullFileListMenu: aMenu shifted: aBoolean	"Fill the menu with all possible items for the file list pane, regardless of selection."	| services servicesPlus extraLines linePointer |	aMenu title: 'all possible file operations'.	servicesPlus := self servicesFromSelectorSpecs:  #(		fromFileName: openFromFile:  		-		openOn: fileIntoNewChangeSet: fileIn: browseChangesFile: browseRecentLogOnPath:		-		viewContents: saveContents: openOn:		-				removeLineFeeds: ).	extraLines _ OrderedCollection new.	linePointer _ 1.	services _ OrderedCollection new.	servicesPlus doWithIndex:		[:svc :ind |			svc == #-				ifTrue:					[extraLines add: linePointer - 1]				ifFalse:					[services add: svc.					linePointer _ linePointer + 1]].	aMenu 		addServices: services 		for: self fullName		extraLines: extraLines! !!FileList methodsFor: 'file list menu' stamp: 'sw 11/8/2003 13:32'!itemsForAnyFile	"Answer a list of universal services that could apply to any file"		| services |	services := OrderedCollection new: 4.	services add: self serviceCopyName. 	services add: self serviceRenameFile. 	services add: self serviceDeleteFile.	services add: self serviceViewContentsInWorkspace.	^ services! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:56'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| suffix |	suffix _ self class suffixOf: fullName.	^ (self class itemsForFile: fullName) , (self myServicesForFile: fullName suffix: suffix)! !!FileList methodsFor: 'file list menu' stamp: 'sd 1/31/2002 12:08'!itemsForNoFile	| services |	services := OrderedCollection new: 6.	services add: self serviceSortByName.	services add: self serviceSortBySize.	services add: (self serviceSortByDate useLineAfter: true).	(self isFileSelected not and: [self class isReaderNamedRegistered: #FileContentsBrowser])			ifTrue:[ services add: (self serviceBrowseCodeFiles useLineAfter: true)].	services add: self serviceAddNewFile.	services add: self serviceAddNewDirectory.	^ services		! !!FileList methodsFor: 'file list menu' stamp: 'BG 11/2/2003 21:04'!myServicesForFile: fullName suffix: suffix	^(FileStream isSourceFileSuffix: suffix)		ifTrue: [ #() ]		ifFalse: [ #() ]! !!FileList methodsFor: 'file list menu' stamp: 'SD 11/8/2001 20:34'!noFileSelectedMenu: aMenu	^ aMenu		addServices: self itemsForNoFile 		for: self		extraLines: #()		! !!FileList methodsFor: 'file list menu' stamp: 'sw 2/27/2001 13:52'!offerAllFileOptions	"Put up a menu offering all possible file options, whatever the suffix of the current selection may be.  Specially useful if you're wanting to keep the menu up"	self offerMenuFrom: #fullFileListMenu:shifted: shifted: true! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:57'!suffixOfSelectedFile	"Answer the file extension of the receiver's selected file"	^ self class suffixOf: self fullName.! !!FileList methodsFor: 'file menu action' stamp: 'dgd 12/27/2003 12:18'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response := FillInTheBlank						request: ('New {1} Name?' translated format: {aString translated})						initialAnswer: ('{1}Name' translated format: {aString translated}))		isEmpty ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index := list indexOf: newName.	index = 0 ifTrue: [ending := ') ',newName.		index := list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file menu action' stamp: 'sge 11/28/1999 09:04'!addNewDirectory	self 		addNew: 'Directory'		byEvaluating: [:newName | directory createDirectory: newName]! !!FileList methodsFor: 'file menu action' stamp: 'sge 11/28/1999 09:04'!addNewFile	self 		addNew: 'File'		byEvaluating: [:newName | (directory newFileNamed: newName) close]! !!FileList methodsFor: 'file menu action' stamp: 'dgd 9/21/2003 17:37'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: ('Really delete {1}?' translated format:{fileName})) ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState _ #FileList.	self get! !!FileList methodsFor: 'file menu action' stamp: 'jm 5/3/1998 18:03'!get	"Get contents of file again, it may have changed. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		self okToChange ifFalse: [^ nil].		brevityState == #briefHex			ifTrue: [brevityState _ #needToGetFullHex]			ifFalse: [brevityState _ #needToGetFull].		self changed: #contents].! !!FileList methodsFor: 'file menu action' stamp: 'jm 5/3/1998 18:04'!getHex	"Get contents of file again, and display in Hex. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		brevityState _ #needToGetBriefHex.		self changed: #contents].! !!FileList methodsFor: 'file menu action' stamp: 'dgd 12/27/2003 12:20'!renameFile	"Rename the currently selected file"	| newName response |	listIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'NewFileName?' translated 					initialAnswer: fileName)		isEmpty ifTrue: [^ self].	newName _ response asFileName.	newName = fileName ifTrue: [^ self].	directory rename: fileName toBe: newName.	self updateFileList.	listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].	listIndex > 0 ifTrue: [fileName _ newName].	self changed: #fileListIndex.! !!FileList methodsFor: 'file menu action' stamp: 'di 4/15/98 12:36'!sortByDate	self resort: #date! !!FileList methodsFor: 'file menu action' stamp: 'di 4/15/98 12:37'!sortByName	self resort: #name! !!FileList methodsFor: 'file menu action' stamp: 'di 4/15/98 12:36'!sortBySize	self resort: #size! !!FileList methodsFor: 'file menu action' stamp: 'sd 2/1/2002 20:02'!spawn: code	"Open a simple Edit window"	listIndex = 0 ifTrue: [^ self].	self class openEditorOn: (directory readOnlyFileNamed: fileName)				"read only just for initial look"			editString: code! !!FileList methodsFor: 'initialization' stamp: 'sw 11/30/2002 00:05'!buttonSelectorsToSuppress	"Answer a list of action selectors whose corresponding services we would prefer *not* to have appear in the filelist's button pane; this can be hand-jimmied to suit personal taste."	^ #(removeLineFeeds: addFileToNewZip: compressFile: putUpdate:)! !!FileList methodsFor: 'initialization' stamp: 'BG 12/13/2002 15:32'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory _ dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode _ #date].	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	volListIndex := volList size.	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList methodsFor: 'initialization' stamp: 'sw 2/26/2002 00:37'!dynamicButtonServices	"Answer services for buttons that may come and go in the button pane, depending on selection"	^ fileName isEmptyOrNil		ifTrue:			[#()]		ifFalse:			[ | toReject |				toReject _ self buttonSelectorsToSuppress.				(self itemsForFile: self fullName) reject:					[:svc | toReject includes: svc selector]]! !!FileList methodsFor: 'initialization' stamp: 'tk 5/18/1998 17:22'!labelString	^ directory pathName contractTo: 50! !!FileList methodsFor: 'initialization' stamp: 'tk 12/17/1999 18:00'!modelSleep	"User has exited or collapsed the window -- close any remote connection."	directory ifNotNil: [directory sleep]! !!FileList methodsFor: 'initialization' stamp: 'BG 10/29/2003 10:06'!modelWakeUp	"User has entered or expanded the window -- reopen any remote connection.""	(directory isKindOf: ServerDirectory) 		ifTrue: [directory wakeUp] " "It would be good to implement a null method wakeUp on the root of directory"! !!FileList methodsFor: 'initialization' stamp: 'sbw 12/30/1999 15:53'!optionalButtonHeight	^ 15! !!FileList methodsFor: 'initialization' stamp: 'sw 2/17/2002 00:07'!optionalButtonSpecs	"Answer a list of services underlying the optional buttons in their initial inception."	^ {self serviceSortByName. self serviceSortByDate. self serviceSortBySize}! !!FileList methodsFor: 'initialization' stamp: 'sw 2/17/2002 05:39'!optionalButtonView	"Answer a view of optional buttons"	| aView bHeight windowWidth offset previousView aButtonView wid services sel allServices |	aView _ View new model: self.	bHeight _ self optionalButtonHeight.	windowWidth _ 120.	aView window: (0 @ 0 extent: windowWidth @ bHeight).	offset _ 0.	allServices _ self universalButtonServices.	services _ allServices copyFrom: 1 to: (allServices size min: 5).	previousView _ nil.	services		do: [:service | sel _ service selector.		aButtonView _ sel asString numArgs = 0			ifTrue: [PluggableButtonView					on: service provider					getState: (service extraSelector == #none							ifFalse: [service extraSelector])					action: sel]			ifFalse: [PluggableButtonView					on: service provider					getState: (service extraSelector == #none							ifFalse: [service extraSelector])					action: sel					getArguments: #fullName					from: self].		service selector = services last selector			ifTrue: [wid _ windowWidth - offset]			ifFalse: [aButtonView					borderWidthLeft: 0					right: 1					top: 0					bottom: 0.				wid _ windowWidth // services size - 2].		aButtonView label: service buttonLabel asParagraph;			window: (offset @ 0 extent: wid @ bHeight).		offset _ offset + wid.		service selector = services first selector			ifTrue: [aView addSubView: aButtonView]			ifFalse: [aView addSubView: aButtonView toRightOf: previousView].		previousView _ aButtonView].	^ aView! !!FileList methodsFor: 'initialization' stamp: 'di 5/11/1999 22:25'!release	self modelSleep! !!FileList methodsFor: 'initialization' stamp: 'tk 5/21/1998 12:28'!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName _ aStream localName.	pattern _ '*'.	listIndex _ 1.  "pretend a file is selected"	aStream close.	brevityState _ #needToGetBrief.	self changed: #contents.! !!FileList methodsFor: 'initialization' stamp: 'sw 2/17/2002 05:38'!universalButtonServices	"Answer a list of services underlying the universal buttons in their initial inception.  For the moment, only the sorting buttons are shown."	^ {self serviceSortByName. self serviceSortByDate. self serviceSortBySize}! !!FileList methodsFor: 'initialization' stamp: 'BG 10/28/2003 20:45'!updateButtonRow	"Dynamically update the contents of the button row, if any."! !!FileList methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!copyName	listIndex = 0 ifTrue: [^ self].	Clipboard clipboardText: self fullName asText.! !!FileList methodsFor: 'own services' stamp: 'sw 2/15/2002 19:07'!serviceAddNewDirectory	"Answer a service entry characterizing the 'add new directory' command"	^ SimpleServiceEntry 		provider: self 		label: 'add new directory' 		selector: #addNewDirectory		description: 'adds a new, empty directory (folder)' ! !!FileList methodsFor: 'own services' stamp: 'sw 2/11/2002 23:36'!serviceAddNewFile	"Answer a service entry characterizing the 'add new file' command"	^ SimpleServiceEntry provider: self label: 'add new file' selector: #addNewFile description: 'create a new,. empty file, and add it to the current directory.'! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:12'!serviceAllFileOptions	^ {SimpleServiceEntry provider: self label: 'more...' selector: #offerAllFileOptions description: 'show all the options available'}! !!FileList methodsFor: 'own services' stamp: 'sw 2/17/2002 01:36'!serviceBroadcastUpdate	"Answer a service for broadcasting a file as an update"	^ SimpleServiceEntry		provider: self 		label: 'broadcast as update'		selector: #putUpdate:		description: 'broadcast file as update'		buttonLabel: 'broadcast'! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:24'!serviceBrowseCodeFiles	self flag: #stef.	"Here we are breaking the registration mechanism by a direct reference to the fileContentsBrowser.	The problem is that service is waiting for a filename and here this specific vicous service is used 	when no file is selected. I think that we should change that"	^  SimpleServiceEntry 		provider: FileContentsBrowser		label: 'browse code files' 		selector: #selectAndBrowseFile:! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:16'!serviceCopyName	^ (SimpleServiceEntry provider: self label: 'copy name to clipboard' selector: #copyName description:'copy name to clipboard' )! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 21:17'!serviceDeleteFile	^ (SimpleServiceEntry provider: self label: 'delete' selector: #deleteFile)			description: 'delete the seleted item'! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:39'!serviceGet	"Answer a service for getting the entire file"	^  (SimpleServiceEntry 			provider: self 			label: 'get entire file' 			selector: #get			description: 'if the file has only been partially read in, because it is very large, read the entire file in at this time.')! !!FileList methodsFor: 'own services' stamp: 'sd 2/1/2002 20:50'!serviceGetHex	^  (SimpleServiceEntry 			provider: self 			label: 'view as hex' 			selector: #getHex			description: 'view as hex')			! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:15'!serviceRenameFile	^ (SimpleServiceEntry provider: self label: 'rename' selector: #renameFile description: 'rename file')! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:39'!serviceSortByDate	"Answer a service for sorting by date"	^  (SimpleServiceEntry new			provider: self 			label: 'by date' 			selector: #sortByDate 			description: 'sort entries by date')		extraSelector: #sortingByDate;		buttonLabel: 'date'! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:39'!serviceSortByName	"Answer a service for soring by name"	^ (SimpleServiceEntry new		provider: self label: 'by name' selector: #sortByName 		description: 'sort entries by name')		extraSelector: #sortingByName;		buttonLabel: 'name'! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:40'!serviceSortBySize	"Answer a service for sorting by size"	^  (SimpleServiceEntry 			provider: self 			label: 'by size' 			selector: #sortBySize			description: 'sort entries by size')				extraSelector: #sortingBySize;				buttonLabel: 'size'! !!FileList methodsFor: 'own services' stamp: 'sw 11/8/2003 13:34'!serviceViewContentsInWorkspace	"Answer a service for viewing the contents of a file in a workspace"		^ (SimpleServiceEntry provider: self label: 'workspace with contents' selector: #viewContentsInWorkspace)			description: 'open a new Workspace whose contents are set to the contents of this file'! !!FileList methodsFor: 'own services' stamp: 'sw 2/15/2002 20:19'!servicesFromSelectorSpecs: symbolArray	"Answer an array of services represented by the incoming symbols, eliminating any that do not have a currently-registered service.  Pass the symbol #- along unchanged to serve as a separator between services"	"FileList new servicesFromSelectorSpecs: #(fileIn: fileIntoNewChangeSet: browseChangesFile:)"	| res services col | 	col := OrderedCollection new.	services := self class allRegisteredServices, (self myServicesForFile: #dummy suffix: '*').	symbolArray do: 		[:sel | 			sel == #-				ifTrue:					[col add: sel]				ifFalse:					[res := services							detect: [:each | each selector = sel] ifNone: [nil].					res notNil							ifTrue: [col add: res]]].	^ col! !!FileList methodsFor: 'own services' stamp: 'sw 11/8/2003 13:39'!viewContentsInWorkspace	"View the contents of my selected file in a new workspace"		| aString aFileStream aName |	aString _ (aFileStream _ directory readOnlyFileNamed: self fullName) contentsOfEntireFile.	aName _ aFileStream localName.	aFileStream close.	(Workspace new contents: aString) openLabel: 'Workspace from ', aName! !!FileList methodsFor: 'to be transformed in registration' stamp: 'sw 11/30/2002 15:38'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user.	If it's one of the three sort-by items, handle it specially.	If I can respond myself, then perform it on myself. 	If not, send it to otherTarget, presumably the editPane from which the menu was invoked."	^ (#(sortByDate sortBySize sortByName) includes: selector)		ifTrue:			[self resort: selector]		ifFalse:			[(#(get getHex copyName openImageInWindow importImage renameFile deleteFile addNewFile) includes: selector)				ifTrue: [self perform: selector]				ifFalse: [super perform: selector orSendTo: otherTarget]]! !!FileList methodsFor: 'to be transformed in registration' stamp: 'BG 10/29/2003 10:07'!removeServer	| choice names |	self flag: #ViolateNonReferenceToOtherClasses.	names := #(). "ServerDirectory serverNames asSortedArray."	choice := (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	"ServerDirectory removeServerNamed: choice"! !!FileList methodsFor: 'to be transformed in registration' stamp: 'BG 10/29/2003 10:04'!volumeMenu: aMenu	^ aMenu labels:'recent...remove server...delete directory...'		lines: # (1 2)		selections: #(recentDirs removeServer deleteDirectory)! !!FileList methodsFor: 'updating' stamp: 'sw 11/30/2002 16:49'!update: aParameter	"Receive a change notice from an object of whom the receiver is a dependent"	(aParameter == #fileListChanged) ifTrue: [self updateFileList].	super update: aParameter! !!FileList methodsFor: 'volume list and pattern' stamp: 'tpr 11/28/2003 11:44'!deleteDirectory	"Remove the currently selected directory"	| localDirName |	directory entries size = 0 ifFalse:[^self inform:'Directory must be empty'].	localDirName _ directory localName.	(self confirm: 'Really delete ' , localDirName , '?') ifFalse: [^ self].	self volumeListIndex: self volumeListIndex-1.	directory deleteDirectory: localDirName.	self updateFileList.! !!FileList methodsFor: 'volume list and pattern' stamp: 'SD 11/11/2001 13:59'!directory	^ directory! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/25/1998 01:15'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr _ (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr _ ((Date fromSeconds: (entry at: 3) )					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr _ (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileList methodsFor: 'volume list and pattern' stamp: 'BG 10/29/2003 10:06'!listForPattern: pat	"Make the list be those file names which match the pattern."	| sizePad newList |	newList _ (self entriesMatching: pat) asSortedCollection: self sortBlock.	sizePad _ (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ",		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])"].	^ newList asArray! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 4/7/98 15:26'!pattern	^ pattern ifNil: ['*']! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 19:01'!pattern: textOrStringOrNil	textOrStringOrNil		ifNil: [pattern _ '*']		ifNotNil: [pattern _ textOrStringOrNil asString].	self updateFileList.	^ true! !!FileList methodsFor: 'volume list and pattern' stamp: 'sw 3/6/1999 11:39'!veryDeepFixupWith: deepCopier	super veryDeepFixupWith: deepCopier.	volListIndex _ 1.	self directory: FileDirectory default.	self updateFileList! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 18:20'!volumeList	"Answer the current list of volumes."	^ volList! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 18:21'!volumeListIndex	"Answer the index of the currently selected volume."	^ volListIndex! !!FileList methodsFor: 'volume list and pattern' stamp: 'sw 2/21/2002 02:01'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex := index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim := directory pathNameDelimiter.				path := String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState := #FileList.	self addPath: path.	self changed: #fileList.	self changed: #contents.	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'stp 12/11/1999 20:05'!addPath: aString	"Add the given string to the list of recently visited directories."	| full |	aString ifNil: [^self].	full := String streamContents: 		[ :strm | 2 to: volList size do: 			[ :i | strm nextPutAll: (volList at: i) withBlanksTrimmed.			strm nextPut: FileDirectory pathNameDelimiter]].	full := full, aString."Remove and super-directories of aString from the collection."	RecentDirs removeAllSuchThat: [ :aDir | ((aDir, '*') match: full)]."If a sub-directory is in the list, do nothing."	(RecentDirs detect: [ :aDir | ((full, '*') match: aDir)] ifNone: [nil])		ifNotNil: [^self].	[RecentDirs size >= 10]		whileTrue: [RecentDirs removeFirst].	RecentDirs addLast: full! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:26'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22'!defaultContents	contents _ list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState _ #FileList.	^ contents! !!FileList methodsFor: 'private' stamp: 'sma 11/11/2000 17:00'!entriesMatching: patternString	"Answer a list of directory entries which match the patternString.	The patternString may consist of multiple patterns separated by ';'.	Each pattern can include a '*' or '#' as wildcards - see String>>match:"	| entries patterns |	entries _ directory entries.	patterns _ patternString findTokens: ';'.	(patterns anySatisfy: [:each | each = '*'])		ifTrue: [^ entries].	^ entries select: [:entry | 		entry isDirectory or: [patterns anySatisfy: [:each | each match: entry first]]]! !!FileList methodsFor: 'private' stamp: 'rhi 9/8/2001 02:17'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| from to |	self sortingByName		ifTrue: [			from _ item lastIndexOf: $( ifAbsent: [0].			to _ item lastIndexOf: $) ifAbsent: [0]]		ifFalse: [			from _ item indexOf: $( ifAbsent: [0].			to _ item indexOf: $) ifAbsent: [0]].	^ (from * to = 0		ifTrue: [item]		ifFalse: [item copyReplaceFrom: from to: to with: '']) withBlanksTrimmed! !!FileList methodsFor: 'private'!folderString	^ ' [...]'! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2003 17:08'!fullName	"Answer the full name for the currently selected file; answer nil if no file is selected."	^ fileName ifNotNil: [directory		ifNil:			[FileDirectory default fullNameFor: fileName]		ifNotNil:			[directory fullNameFor: fileName]]! !!FileList methodsFor: 'private' stamp: 'SD 11/14/2001 21:59'!isFileSelected	"return if a file is currently selected"	^ fileName isNil not! !!FileList methodsFor: 'private' stamp: 'BG 11/11/2003 14:21'!listForPatterns: anArray	"Make the list be those file names which match the pattern."	| sizePad newList |	newList _ Set new.	anArray do: [ :pat | newList addAll: (self entriesMatching: pat) ].	newList _ (SortedCollection sortBlock: self sortBlock) addAll: newList; yourself.	sizePad _ (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		"^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])"].	^ newList asArray! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:24'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected' translated.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' translated format:{type translated}).	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'BG 10/29/2003 10:07'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	brevityFlag ifTrue: [		"(directory isKindOf: ServerDirectory) ifTrue: [^ self readServerBrief]"].	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 100000]) ifTrue:		[contents _ f contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	contents _ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:11'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read' translated].	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData := s contents.	^ contents := ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. size. hexData}]		ifFalse: [hexData]).! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:09'!readServerBrief	| lString sizeStr fsize ff first5000 parts |	"If file on server is known to be long, just read the beginning.  Cheat badly by reading the fileList string."	listIndex = 0 ifTrue: [^ self].	"Get size from file list entry"	lString := list at: listIndex.	parts := lString findTokens: '()'.	sortMode = #name ifTrue: [sizeStr := (parts second findTokens: ' ') third].	sortMode = #date ifTrue: [sizeStr := (parts first findTokens: ' ') third].	sortMode = #size ifTrue: [sizeStr := (parts first findTokens: ' ') first].	fsize := (sizeStr copyWithout: $,) asNumber.	fsize <= 50000 ifTrue:		[ff := directory oldFileOrNoneNamed: self fullName.		ff ifNil: [^ 'For some reason, this file cannot be read' translated].		contents := ff contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := directory getOnly: 3500 from: fileName.	contents := 'File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 3500 characters...------------------------------------------{3}------------------------------------------... end of the first 3500 characters.' translated format: {fileName. sizeStr. first5000}.	brevityState := #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'stp 12/11/1999 20:03'!recentDirs	"Put up a menu and let the user select from the list of recently visited directories."	| dirName |	RecentDirs isEmpty ifTrue: [^self].	dirName := (SelectionMenu selections: RecentDirs) startUp.	dirName == nil ifTrue: [^self].	self directory: (FileDirectory on: dirName)! !!FileList methodsFor: 'private' stamp: 'SD 11/8/2001 21:11'!registeredFileReaderClasses	"return the list of classes that provide file reader services"	^ self class registeredFileReaderClasses! !!FileList methodsFor: 'private' stamp: 'sw 11/30/2002 16:34'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil: [		fileName _ name.		listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents].	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'sma 11/11/2000 17:04'!sortBlock	"Answer block to decide what order to display the directory entries."	^ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x fileSize = y fileSize 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ]! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:58'!sortingByDate	^ sortMode == #date! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:57'!sortingByName	^ sortMode == #name! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:58'!sortingBySize	^ sortMode == #size! !!FileList methodsFor: 'private' stamp: 'nk 12/10/2002 07:57'!updateFileList	"Update my files list with file names in the current directory  	that match the pattern.	The pattern string may have embedded newlines or semicolons; these separate different patterns."	| patterns |	patterns _ OrderedCollection new.	Cursor wait showWhile: [	(pattern findTokens: (String with: Character cr with: Character lf with: $;))		do: [ :each |			(each includes: $*) | (each includes: $#)					ifTrue: [ patterns add: each]					ifFalse: [each isEmpty										ifTrue: [ patterns add: '*']										ifFalse: [ patterns add: '*' , each , '*']]].	list _ self listForPatterns: patterns.	listIndex _ 0.	volListIndex _ volList size.	fileName _ nil.	contents _ ''.	self changed: #volumeListIndex.	self changed: #fileList.	self updateButtonRow]! !!FileList methodsFor: 'obsolete methods' stamp: 'BG 10/28/2003 20:56'!loadCRDictionary	self error: 'should not be used keep for temporary documentation'.	Smalltalk isMorphic ifFalse: 		[self beep.		^ self inform: 'Only available within morphic'].! !!FileList methodsFor: 'obsolete methods' stamp: 'BG 10/28/2003 20:55'!loadCRDisplayProperties	self error: 'should not be used keep for temporary documentation'.	Smalltalk isMorphic ifFalse: 		[self beep.		^ self inform: 'Only available within morphic'].! !!FileList methodsFor: 'obsolete methods' stamp: 'BG 10/28/2003 20:56'!openModelintoAlice	"If a Wonderland exists, load this model into it as an actor.  If it doesn't, make one first"	self error: 'should not be used keep for temporary documentation'.	Smalltalk isMorphic ifFalse: [^self error: 'Only works in Morphic -  sorry!!'].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileList class	instanceVariableNames: ''!!FileList class methodsFor: 'instance creation' stamp: 'sw 9/28/2001 09:21'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences		parameterAt: #defaultButtonPaneHeight		ifAbsentPut: [25]! !!FileList class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:56'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView underPane pHeight |		dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	aFileList wantsOptionalButtons		ifTrue:			[underPane _ aFileList optionalButtonView.			underPane isNil				ifTrue: [pHeight _ 60]				ifFalse: [					topView addSubView: underPane toRightOf: volListView.					pHeight _ 60 - aFileList optionalButtonHeight]]		ifFalse:			[underPane _ nil.			pHeight _ 60].	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@pHeight).	underPane isNil		ifTrue: [topView addSubView: fileListView toRightOf: volListView]		ifFalse: [topView addSubView: fileListView below: underPane].	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open! !!FileList class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:41'!openEditorOn: aFileStream editString: editString	"Open an editor on the given FileStream."	| fileModel topView fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	topView _ StandardSystemView new.	topView		model: fileModel;		label: aFileStream fullName;		minimumSize: 180@120.	topView borderWidth: 1.	fileContentsView _ PluggableTextView on: fileModel 		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 180@120).	topView addSubView: fileContentsView.	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'SD 11/8/2001 21:20'!openFileDirectly	| aResult |	(aResult _ StandardFileMenu oldFile) ifNotNil:		[self openEditorOn: (aResult directory readOnlyFileNamed: aResult name) editString: nil]! !!FileList class methodsFor: 'class initialization' stamp: 'dvf 8/23/2003 12:17'!initialize	"FileList initialize"	RecentDirs := OrderedCollection new.	(self systemNavigation allClassesImplementing: #fileReaderServicesForFile:suffix:) do: 		[:providerMetaclass |			self registerFileReader: providerMetaclass soleInstance]! !!FileList class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:47'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(FileList					prototypicalToolWindow		'File List'			'A File List is a tool for browsing folders and files on disks and on ftp types.') 						forFlapNamed: 'Tools']! !!FileList class methodsFor: 'class initialization' stamp: 'asm 4/08/2003 12:15'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!FileList class methodsFor: 'file reader registration' stamp: 'sd 2/1/2002 21:30'!allRegisteredServices	"self allRegisteredServices"	| col |	col := OrderedCollection new.	self registeredFileReaderClasses do: [:each | col addAll: (each services)].	^ col! !!FileList class methodsFor: 'file reader registration' stamp: 'sd 1/31/2002 21:42'!detectService: aBlock ifNone: anotherBlock	"self detectService: [:each | each selector = #fileIn:] ifNone: [nil]"	^ self allRegisteredServices			detect: aBlock			ifNone: anotherBlock! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/11/2001 13:53'!isReaderNamedRegistered: aSymbol	"return if a given reader class has been registered. Note that this is on purpose that the argument is	a symbol and not a class"	 ^ (self registeredFileReaderClasses collect: [:each | each name]) includes: aSymbol! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 12/7/2002 12:53'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| services suffix |	suffix _ self suffixOf: fullName.	services _ OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForFile: fullName suffix: suffix)]].	^ services! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/8/2001 21:17'!registerFileReader: aProviderClass	"register the given class as providing services for reading files"	| registeredReaders |	registeredReaders := self registeredFileReaderClasses.	(registeredReaders includes: aProviderClass) 			ifFalse: [ registeredReaders addLast: aProviderClass ]! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/8/2001 21:11'!registeredFileReaderClasses		FileReaderRegistry ifNil: [FileReaderRegistry _ OrderedCollection new].	^ FileReaderRegistry	! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 12/7/2002 12:52'!suffixOf: aName	"Answer the file extension of the given file"	^ aName		ifNil:			['']		ifNotNil:			[(FileDirectory extensionFor: aName) asLowercase]! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/8/2001 21:18'!unregisterFileReader: aProviderClass	"unregister the given class as providing services for reading files"	self registeredFileReaderClasses remove: aProviderClass ifAbsent: [nil]! !SimpleServiceEntry subclass: #FileModifyingSimpleServiceEntry	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!FileModifyingSimpleServiceEntry commentStamp: 'nk 11/26/2002 12:03' prior: 0!I represent a service that may change the contents of a directory.Such changes include:* file creation* file deletion* file modification!!FileModifyingSimpleServiceEntry methodsFor: 'as yet unclassified' stamp: 'nk 11/26/2002 12:08'!performServiceFor: anObject	| retval |	retval _ super performServiceFor: anObject.	self changed: #fileListChanged.	^retval	"is this used anywhere?"! !Object subclass: #FilePackage	instanceVariableNames: 'fullName sourceSystem classes doIts classOrder'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!FilePackage methodsFor: 'accessing'!classAt: className	^self classes at: className! !!FilePackage methodsFor: 'accessing'!classes	^classes! !!FilePackage methodsFor: 'accessing' stamp: 'pnm8/23/2000 17:10'!fullName: aString	fullName := aString! !!FilePackage methodsFor: 'accessing'!fullPackageName	^fullName! !!FilePackage methodsFor: 'accessing'!packageInfo	^String streamContents:[:s|		s nextPutAll:'Package: '.		s nextPutAll: self fullPackageName; cr; cr.		sourceSystem isEmpty ifFalse:[			s nextPutAll: sourceSystem; cr; cr].		doIts isEmpty ifFalse:[			s nextPutAll:'Unresolvable doIts:'; cr; cr.			doIts do:[:chgRec|				s nextPut:$!!; nextPutAll: chgRec string; nextPut: $!!; cr]]].! !!FilePackage methodsFor: 'accessing' stamp: 'pnm8/23/2000 17:12'!packageName	^FileDirectory localNameFor: self fullPackageName! !!FilePackage methodsFor: 'accessing'!removeClass: aPseudoClass	(self classes removeKey: aPseudoClass name).	classOrder copy do:[:cls|		cls name = aPseudoClass name ifTrue:[ classOrder remove: cls].	].! !!FilePackage methodsFor: 'accessing' stamp: 'ar 2/5/2004 15:11'!removeDoIts	doIts := OrderedCollection new.! !!FilePackage methodsFor: 'accessing'!renameClass: aPseudoClass to: newName	| oldName |	oldName := aPseudoClass name.	self classes removeKey: oldName.	self classes at: newName put: aPseudoClass.	aPseudoClass renameTo: newName.! !!FilePackage methodsFor: 'initialize' stamp: 'ar 2/5/2004 15:14'!fromFileNamed: aName	| stream |	fullName := aName.	stream := FileStream readOnlyFileNamed: aName.	[self fileInFrom: stream] ensure:[stream close].! !!FilePackage methodsFor: 'initialize' stamp: 'pnm8/23/2000 14:48'!initialize	classes := Dictionary new.	classOrder := OrderedCollection new.	sourceSystem := ''.	doIts := OrderedCollection new.! !!FilePackage methodsFor: 'private'!classDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	tokens size = 11 ifFalse:[^doIts add: chgRec].	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: 'private'!getClass: className	| pseudoClass |	(classes includesKey: className) ifTrue:[		^classes at: className.	].	pseudoClass := PseudoClass new.	pseudoClass name: className.	classes at: className put: pseudoClass.	^pseudoClass.! !!FilePackage methodsFor: 'private'!metaClassDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	theClass := self getClass: (tokens at: 1).	theClass metaClass definition: string.	classOrder add: theClass metaClass.! !!FilePackage methodsFor: 'private'!msgClassComment: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 3) class == String]) ifTrue:[		theClass := self getClass: tokens first.		^theClass commentString: tokens last].	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) class == String]]) ifTrue:[		theClass := self getClass: tokens first.		theClass metaClass commentString: tokens last].! !!FilePackage methodsFor: 'private'!possibleSystemSource: chgRec	| tokens |	sourceSystem isEmpty ifTrue:[		tokens := Scanner new scanTokens: chgRec string.		(tokens size = 1 and:[tokens first class == String]) ifTrue:[			sourceSystem := tokens first.			^self]].	doIts add: chgRec.! !!FilePackage methodsFor: 'private'!removedMethod: string with: chgRec	| class tokens |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 2) == #removeSelector: ]) ifTrue:[		class := self getClass: (tokens at: 1).		^class removeSelector: (tokens at: 3).	].	(tokens size = 4 and:[(tokens at: 2) == #class and:[(tokens at: 3) == #removeSelector:]]) ifTrue:[		class := self getClass: (tokens at: 1).		^class metaClass removeSelector: (tokens at: 4).	].	doIts add: chgRec! !!FilePackage methodsFor: 'change record types'!classComment: chgRec	(self getClass: chgRec methodClassName) classComment: chgRec! !!FilePackage methodsFor: 'change record types'!doIt: chgRec	| string |	string := chgRec string.	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'		match: string) ifTrue:[^self classDefinition: string with: chgRec].	('* class*instanceVariableNames:*'		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].	('* removeSelector: *'		match: string) ifTrue:[^self removedMethod: string with: chgRec].	('* comment:*'		match: string) ifTrue:[^self msgClassComment: string with: chgRec].	('* initialize'		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"	('''From *'		match: string) ifTrue:[^self possibleSystemSource: chgRec].	doIts add: chgRec.! !!FilePackage methodsFor: 'change record types'!method: chgRec	(self getClass: chgRec methodClassName) methodChange: chgRec! !!FilePackage methodsFor: 'change record types'!preamble: chgRec	self doIt: chgRec! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:57'!askForDoits	| menu choice choices |	choices := #('do not process' 'at the beginning' 'at the end' 'cancel').	menu _ SelectionMenu selections: choices.	choice := nil.	[choices includes: choice] whileFalse: [		choice _ menu startUpWithCaption: 'The package contains unprocessed doIts.When would like to process those?'].	^choices indexOf: choice! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 16:00'!fileIn	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileInDoits].	classOrder do:[:cls|		cls fileInDefinition.	].	classes do:[:cls|		Transcript cr; show:'Filing in ', cls name.		cls fileInMethods.		cls hasMetaclass ifTrue:[cls metaClass fileInMethods].	].	doitsMark = 3 ifTrue:[self fileInDoits].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileInDoits	doIts do:[:chgRec| chgRec fileIn].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'tk 3/7/2001 13:57'!fileOut	| fileName stream |	fileName := FillInTheBlank request: 'Enter the file name' initialAnswer:''.	stream := FileStream newFileNamed: fileName.	sourceSystem isEmpty ifFalse:[		stream nextChunkPut: sourceSystem printString;cr ].	self fileOutOn: stream.	stream cr; cr.	self classes do:[:cls|		cls needsInitialize ifTrue:[			stream cr; nextChunkPut: cls name,' initialize']].	stream cr.	stream close.	"DeepCopier new checkVariables."! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOutDoits: aStream	doIts do:[:chgRec| chgRec fileOutOn: aStream].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:59'!fileOutOn: aStream	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileOutDoits: aStream].	classOrder do:[:cls|		cls fileOutDefinitionOn: aStream.	].	classes do:[:cls|		cls fileOutMethodsOn: aStream.		cls hasMetaclass ifTrue:[cls metaClass fileOutMethodsOn: aStream].	].	doitsMark = 3 ifTrue:[self fileOutDoits: aStream].! !!FilePackage methodsFor: 'reading' stamp: 'pnm8/23/2000 17:24'!fileInFrom: aStream	| chgRec changes |	changes := (ChangeList new scanFile: aStream from: 0to: aStream size) changeList.	aStream close.	('Processing ', self packageName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbolwith: chgRec.			].		].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FilePackage class	instanceVariableNames: ''!!FilePackage class methodsFor: 'instance creation'!fromFileNamed: aName	^self new fromFileNamed: aName! !ReadWriteStream subclass: #FileStream	instanceVariableNames: 'rwmode'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!FileStream commentStamp: '<historical>' prior: 0!I represent a Stream that accesses a FilePage from a File. One use for my instance is to access larger "virtual Strings" than can be stored contiguously in main memory. I restrict the objects stored and retrieved to be Integers or Characters. An end of file pointer terminates reading; it can be extended by writing past it, or the file can be explicitly truncated.	To use the file system for most applications, you typically create a FileStream. This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me. Accesses to the file are then done via my instance.*** On DOS, files cannot be shortened!!  ***  To overwrite a file with a shorter one, first delete the old file (FileDirectory deleteFilePath: 'Hard Disk:aFolder:dataFolder:foo') or (aFileDirectory deleteFileNamed: 'foo').  Then write your new shorter version.!!FileStream methodsFor: 'accessing' stamp: 'ar 8/6/2001 18:34'!contents	"Return the contents of the receiver. Do not close or otherwise touch the receiver. Return data in whatever mode the receiver is in (e.g., binary or text)."	| s savePos |	savePos _ self position.	self position: 0.	s _ self next: self size.	self position: savePos.	^s! !!FileStream methodsFor: 'accessing'!contentsOfEntireFile	"Read all of the contents of the receiver."	| s binary |	self readOnly.	binary _ self isBinary.	self reset.	"erases knowledge of whether it is binary"	binary ifTrue: [self binary].	s _ self next: self size.	self close.	^s! !!FileStream methodsFor: 'accessing'!next	(position >= readLimit and: [self atEnd])		ifTrue: [^nil]		ifFalse: [^collection at: (position _ position + 1)]! !!FileStream methodsFor: 'accessing'!next: anInteger	| newCollection howManyRead increment |	newCollection _ collection species new: anInteger.	howManyRead _ 0.	[howManyRead < anInteger] whileTrue:		[self atEnd ifTrue:			[(howManyRead + 1) to: anInteger do: [:i | newCollection at: i put: (self next)].			^newCollection].		increment _ (readLimit - position) min: (anInteger - howManyRead).		newCollection replaceFrom: (howManyRead + 1)			to: (howManyRead _ howManyRead + increment)			with: collection			startingAt: (position + 1).		position _ position + increment].	^newCollection! !!FileStream methodsFor: 'accessing'!nextPut: aByte	"1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'accessing'!nextPutAll: aCollection	"1/31/96 sw: made subclass responsibility"	self subclassResponsibility! !!FileStream methodsFor: 'accessing'!size	"Answer the size of the file in characters.	 1/31/96 sw: made subclass responsibility"	self subclassResponsibility! !!FileStream methodsFor: 'testing'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'positioning'!position	"Answer the current character position in the file.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'positioning'!position: pos	"Set the current character position in the file to pos.	 1/31/96 sw: made subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'positioning'!reset	"Set the current character position to the beginning of the file.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'positioning'!setToEnd	"Set the current character position to the end of the File. The same as	self position: self size.  1/31/96 sw: made subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'positioning'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file	1/31/96 sw: made subclassResponsibility." 	self subclassResponsibility! !!FileStream methodsFor: 'printing' stamp: 'tk 12/5/2001 09:12'!longPrintOn: aStream	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."! !!FileStream methodsFor: 'printing' stamp: 'tk 12/5/2001 09:32'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."	aStream cr! !!FileStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on '.	self file printOn: aStream! !!FileStream methodsFor: 'editing' stamp: 'di 5/20/1998 23:20'!edit	"Create and schedule an editor on this file."	FileList openEditorOn: self editString: nil.! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!close	"Close this file."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:03'!flush	"When writing, flush the current buffer out to disk."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:04'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!binary	"Set this file to binary mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!text	"Set this file to text (ascii) mode."	self ascii.! !!FileStream methodsFor: 'file accessing'!file	"Answer the file for the page the receiver is streaming over.	 1/31/96 sw: made subclass responsibility"	self subclassResponsibility! !!FileStream methodsFor: 'file accessing' stamp: 'jm 12/5/97 12:53'!localName	^ FileDirectory localNameFor: self name! !!FileStream methodsFor: 'file accessing'!name	"Answer the name of the file for the page the receiver is streaming over.  1/31/96 sw: made subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'file accessing' stamp: 'gk 2/10/2004 13:21'!url	"Convert my path into a file:// type url String."		^self asUrl toText! !!FileStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:42'!fileIn	"Guarantee that the receiver is readOnly before fileIn for efficiency and	to eliminate remote sharing conflicts."	self readOnly.	self fileInAnnouncing: 'Loading ', self localName! !!FileStream methodsFor: 'fileIn/Out' stamp: 'di 10/31/2001 12:07'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangeSorter newChangesFromStream: self named: (self localName)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileStream class	instanceVariableNames: ''!!FileStream class methodsFor: 'instance creation'!fileNamed: fileName 	^ self concreteStream fileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'instance creation' stamp: 'tpr 10/16/2001 12:49'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, delete it without asking before creating the new file."	^self concreteStream forceNewFileNamed: fileName! !!FileStream class methodsFor: 'instance creation'!fullName: fileName	^ FileDirectory default fullNameFor: fileName! !!FileStream class methodsFor: 'instance creation' stamp: 'TPR 8/26/1999 10:49'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: (self fullName: fName)! !!FileStream class methodsFor: 'instance creation' stamp: 'di 2/15/98 14:03'!new	^ self basicNew! !!FileStream class methodsFor: 'instance creation'!newFileNamed: fileName 	^ self concreteStream newFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'instance creation'!oldFileNamed: fileName 	^ self concreteStream oldFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'instance creation' stamp: 'jm 5/8/1998 21:53'!oldFileOrNoneNamed: fileName	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."	| fullName |	fullName _ self fullName: fileName.	(self concreteStream isAFileNamed: fullName)		ifTrue: [^ self concreteStream readOnlyFileNamed: fullName]		ifFalse: [^ nil].! !!FileStream class methodsFor: 'instance creation'!readOnlyFileNamed: fileName 	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'concrete classes' stamp: 'ls 7/11/1998 02:58'!concreteStream	"Who should we really direct class queries to?  "	^ StandardFileStream  "may change this to CrLfFileStream"! !!FileStream class methodsFor: 'initialize-release' stamp: 'hg 8/3/2000 18:00'!initialize	FileList registerFileReader: self! !!FileStream class methodsFor: 'file reader services' stamp: 'ssa 9/3/2008 10:33'!fileIn: fullName	"File in the entire contents of the file specified by the name provided"	| fn ff |	fullName ifNil: [^ Beeper beep].	ff _ self readOnlyFileNamed: (fn _ fullName).	((FileDirectory extensionFor: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn! !!FileStream class methodsFor: 'file reader services' stamp: 'nk 7/16/2003 15:49'!fileReaderServicesForFile: fullName suffix: suffix	"Answer services for the given file"	^ ((self isSourceFileSuffix: suffix) or: [ suffix = '*' ])		ifTrue:			[{self serviceRemoveLineFeeds.			self serviceFileIn}]		ifFalse:			[#()]! !!FileStream class methodsFor: 'file reader services' stamp: 'hg 8/3/2000 18:13'!isSourceFileSuffix: suffix	^(suffix = 'st') | (suffix = 'cs') | (suffix = '*')! !!FileStream class methodsFor: 'file reader services' stamp: 'LEG 10/24/2001 23:35'!removeLineFeeds: fullName	| fileContents |	fileContents _ (CrLfFileStream readOnlyFileNamed: fullName) contentsOfEntireFile.	(StandardFileStream newFileNamed: fullName) 		nextPutAll: fileContents;		close.! !!FileStream class methodsFor: 'file reader services' stamp: 'sw 2/17/2002 01:38'!serviceFileIn	"Answer a service for filing in an entire file"	^ SimpleServiceEntry 		provider: self 		label: 'fileIn entire file'		selector: #fileIn:		description: 'file in the entire contents of the file, which is expected to contain Smalltalk code in fileout ("chunk") format'		buttonLabel: 'filein'! !!FileStream class methodsFor: 'file reader services' stamp: 'nk 11/26/2002 12:49'!serviceRemoveLineFeeds	"Answer a service for removing linefeeds from a file"	^ FileModifyingSimpleServiceEntry		provider: self 		label: 'remove line feeds'		selector: #removeLineFeeds:			description: 'remove line feeds in file'		buttonLabel: 'remove lfs'! !!FileStream class methodsFor: 'file reader services' stamp: 'sd 2/1/2002 22:28'!services	^ Array 			with: self serviceRemoveLineFeeds			with: self serviceFileIn	! !!FileStream class methodsFor: 'class initialization' stamp: 'SD 11/15/2001 22:21'!unload	FileList unregisterFileReader: self ! !Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!FileStreamException methodsFor: 'exceptionBuilder' stamp: 'mir 2/23/2000 20:13'!fileName: aFileName	fileName _ aFileName! !!FileStreamException methodsFor: 'exceptionDescription' stamp: 'mir 2/25/2000 17:29'!fileName	^fileName! !!FileStreamException methodsFor: 'exceptionDescription' stamp: 'mir 2/23/2000 20:13'!isResumable	"Determine whether an exception is resumable."	^true! !!FileStreamException methodsFor: 'exceptionDescription' stamp: 'mir 2/23/2000 20:14'!messageText		"Return an exception's message text."	^messageText == nil		ifTrue: [fileName printString]		ifFalse: [messageText]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileStreamException class	instanceVariableNames: ''!!FileStreamException class methodsFor: 'exceptionInstantiator' stamp: 'mir 2/23/2000 20:12'!fileName: aFileName	^self new fileName: aFileName! !StringHolder subclass: #FillInTheBlank	instanceVariableNames: 'acceptOnCR done responseUponCancel'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!FillInTheBlank commentStamp: '<historical>' prior: 0!I represent a prompt for string input from the user. The user is asked to type in and edit a string. The resulting string is supplied as the argument to a client-supplied action block.!!FillInTheBlank methodsFor: 'initialize-release' stamp: 'sw 1/31/2000 14:42'!initialize	super initialize.	acceptOnCR _ false.	done _ false.	responseUponCancel _ ''! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 4/28/1998 06:18'!acceptOnCR	"Answer whether a carriage return should cause input to be accepted."	^ acceptOnCR! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 4/28/1998 06:18'!acceptOnCR: aBoolean	acceptOnCR _ aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 5/6/1998 15:13'!done	"Answer whether the user has ended the interaction."	^ done! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 5/6/1998 15:13'!done: aBoolean	done _ aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:45'!responseUponCancel: resp	responseUponCancel _ resp! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:47'!setResponseForCancel	self contents: responseUponCancel! !!FillInTheBlank methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel _ ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!FillInTheBlank methodsFor: 'private' stamp: 'sma 6/18/2000 10:54'!show: fillInView	| savedArea |	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	contents isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: contents size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ contents! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FillInTheBlank class	instanceVariableNames: ''!!FillInTheBlank class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:57'!multiLineRequest: queryString centerAt: aPoint initialAnswer: defaultAnswer answerHeight: answerHeight	"Create a multi-line instance of me whose question is queryString with	the given initial answer. Invoke it centered at the given point, and	answer the string the user accepts.  Answer nil if the user cancels.  An	empty string returned means that the ussr cleared the editing area and	then hit 'accept'.  Because multiple lines are invited, we ask that the user	use the ENTER key, or (in morphic anyway) hit the 'accept' button, to 	submit; that way, the return key can be typed to move to the next line.	NOTE: The ENTER key does not work on Windows platforms."	"FillInTheBlank		multiLineRequest:'Enter several lines; end input by acceptingor canceling via menu or press Alt+s/Alt+l'		centerAt: Display center		initialAnswer: 'Once upon a time...'		answerHeight: 200"	| model fillInView |		model _ self new initialize.	model contents: defaultAnswer.	model responseUponCancel: nil.	model acceptOnCR: false.	fillInView _		self fillInTheBlankViewClass			multiLineOn: model			message: queryString			centerAt: aPoint			answerHeight: answerHeight.	^ model show: fillInView! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'ar 3/18/2001 00:53'!request: queryString 	"Create an instance of me whose question is queryString. Invoke it 	centered at the cursor, and answer the string the user accepts. Answer 	the empty string if the user cancels."	"FillInTheBlank request: 'Your name?'"	^ self		request: queryString		initialAnswer: ''		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'ar 3/18/2001 00:54'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given 	initial answer. Invoke it centered at the given point, and answer the 	string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank 		request: 'What is your favorite color?' 		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:57'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given	initial answer. Invoke it centered at the given point, and answer the	string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView |		model _ self new initialize.	model contents: defaultAnswer.	fillInView _		self fillInTheBlankViewClass			on: model			message: queryString			centerAt: aPoint.	^ model show: fillInView! !!FillInTheBlank class methodsFor: 'private' stamp: 'sma 6/18/2000 10:47'!fillInTheBlankViewClass	"By factoring out this class references, it becomes possible to discard 	MVC by simply removing this class.  All calls to this method needs	to be protected by 'Smalltalk isMorphic' tests."	^ FillInTheBlankView! !StringHolderController subclass: #FillInTheBlankController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!FillInTheBlankController commentStamp: '<historical>' prior: 0!I am the controller for a FillInTheBlankView. Based on a flag in the view, I can either accept the input string when a carriage return is typed, or I can allow multiple lines of input that is accepted by either typing enter or by invoking the 'accept' command.!!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'th 9/17/2002 16:46'!controlInitialize	model acceptOnCR ifFalse: [^ super controlInitialize].	self setMark: self markBlock stringIndex.	self setPoint: self pointBlock stringIndex.	self initializeSelection.	beginTypeInBlock _ nil.! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'jm 5/6/1998 15:11'!controlTerminate	| topController |	super controlTerminate.	topController _ view topView controller.	topController ifNotNil: [topController close].! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlActive	^ self isControlWanted! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlWanted	^ model done not! !!FillInTheBlankController methodsFor: 'other' stamp: 'jm 5/6/1998 15:13'!accept	super accept.	model done: true.! !!FillInTheBlankController methodsFor: 'other' stamp: 'sw 1/31/2000 14:47'!cancel	model setResponseForCancel.	super cancel.	model done: true.! !!FillInTheBlankController methodsFor: 'other' stamp: 'jm 4/28/1998 06:25'!dispatchOnCharacter: char with: typeAheadStream	"Accept the current input if the user hits the carriage return or the enter key."	(model acceptOnCR and:	 [(char = Character cr) | (char = Character enter)])		ifTrue: [			sensor keyboard.  "absorb the character"			self accept.			^ true]		ifFalse: [			^ super dispatchOnCharacter: char with: typeAheadStream].! !!FillInTheBlankController methodsFor: 'other' stamp: 'jm 4/28/1998 08:01'!processYellowButton	"Suppress yellow-button menu if acceptOnCR is true."	model acceptOnCR ifFalse: [^ super processYellowButton].! !StringHolderView subclass: #FillInTheBlankView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!FillInTheBlankView commentStamp: '<historical>' prior: 0!I am a view of a FillInTheBlank. I display a query and an editable view of the user's reply string.!!FillInTheBlankView methodsFor: 'controller access' stamp: 'jm 4/28/1998 06:37'!defaultControllerClass	^ FillInTheBlankController! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FillInTheBlankView class	instanceVariableNames: ''!!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 08:35'!multiLineOn: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView |	messageView _ DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView _ self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	topView _ View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 08:22'!on: aFillInTheBlank message: queryString centerAt: aPoint	"Answer an instance of me on aFillInTheBlank for a single line of input in response to the question queryString."	aFillInTheBlank acceptOnCR: true.	^ self		multiLineOn: aFillInTheBlank		message: queryString		centerAt: aPoint		answerHeight: 40! !Number variableWordSubclass: #Float	instanceVariableNames: ''	classVariableNames: 'E Epsilon Halfpi Infinity Ln10 Ln2 MaxVal MaxValLn MinValLogBase2 NaN NegativeInfinity NegativeZero Pi RadiansPerDegree Sqrt2 Twopi'	poolDictionaries: ''	category: 'Kernel-Numbers'!!Float commentStamp: '<historical>' prior: 0!My instances represent IEEE-754 floating-point double-precision numbers.  They have about 16 digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:		8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:	3r20.2 --> 6.66666666666667	8r20.2 --> 16.25If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...	sign		1 bit	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent						in the range -1023 .. +1024				- 16r000:					significand = 0: Float zero					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)				- 16r7FF:					significand = 0: Infinity					significand ~= 0: Not A Number (NaN) representation	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.The single-precision format is...	sign		1 bit	exponent	8 bits, with bias of 127, to represent -126 to +127                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)	mantissa	24 bits, but only 23 are storedThis format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.Thanks to Rich Harmon for asking many questions and to Tim Olson, Bruce Cohen, Rick Zaccone and others for the answers that I have collected here.!]style[(680 9 1189 21 6 26 149)f1,f1LFloat hex;,f1,f1LFloat asIEEE32BitWord;,f1,f1LFloat class fromIEEE32Bit:;,f1!!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!* aNumber 	"Primitive. Answer the result of multiplying the receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 49>	^ aNumber adaptToFloat: self andSend: #*! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:22'!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ aNumber adaptToFloat: self andSend: #+! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55'!- aNumber 	"Primitive. Answer the difference between the receiver and aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 42>	^ aNumber adaptToFloat: self andSend: #-! !!Float methodsFor: 'arithmetic' stamp: 'hh 10/3/2000 11:46'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber isZero ifTrue: [^(ZeroDivide dividend: self) signal].	^ aNumber adaptToFloat: self andSend: #/! !!Float methodsFor: 'arithmetic'!abs	"This is faster than using Number abs."	self < 0.0		ifTrue: [^ 0.0 - self]		ifFalse: [^ self]! !!Float methodsFor: 'arithmetic'!negated	"Answer a Number that is the negation of the receiver."	^0.0 - self! !!Float methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	self = 0 ifTrue: ["<- Chg"		^ (ZeroDivide dividend: self) signal"<- Chg"].	"<- Chg"	^ 1.0 / self! !!Float methodsFor: 'mathematical functions'!arcCos	"Answer the angle in radians."	^ Halfpi - self arcSin! !!Float methodsFor: 'mathematical functions' stamp: 'jsp 2/25/1999 11:15'!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions'!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta _ (self * Halfpi) / (self + 1.0).	"iterate"	eps _ Halfpi * Epsilon.	step _ theta.	[(step * step) > eps] whileTrue: [		sinTheta _ theta sin.		cosTheta _ theta cos.		step _ (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta _ theta - step].	^ theta! !!Float methodsFor: 'mathematical functions' stamp: 'jsp 3/30/1999 12:38'!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| result |	(self = 0.0) ifTrue: [ (denominator > 0.0) ifTrue: [ result _ 0 ]										    ifFalse: [ result _ Pi ]						]			    ifFalse: [(denominator = 0.0)					ifTrue: [ (self > 0.0) ifTrue: [ result _ Halfpi ]												ifFalse: [ result _ Halfpi negated ]							]					ifFalse: [ (denominator > 0) ifTrue: [ result _ (self / denominator) arcTan ]								 ifFalse: [ result _ ((self / denominator) arcTan) + Pi ]							].						].		^ result.! !!Float methodsFor: 'mathematical functions'!cos	"Answer the cosine of the receiver taken as an angle in radians."	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."	^ self degreesToRadians cos! !!Float methodsFor: 'mathematical functions'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."	^ self degreesToRadians sin! !!Float methodsFor: 'mathematical functions'!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base _ E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract _ self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction _ 1.0 + fract.	delta _ fract * fract / 2.0.	div _ 2.0.	[delta > Epsilon] whileTrue: [		correction _ correction + delta.		div _ div + 1.0.		delta _ delta * fract / div].	correction _ correction + delta.	^ base * correction! !!Float methodsFor: 'mathematical functions' stamp: 'jm 3/27/98 06:28'!floorLog: radix	"Answer the floor of the log base radix of the receiver."	^ (self log: radix) floor! !!Float methodsFor: 'mathematical functions'!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt _ self exponent.	n _ Ln2 * expt.	mant _ self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x _ mant - 1.0.	div _ 1.0.	pow _ delta _ sum _ x.	x _ x negated.  "x <= 0"	eps _ Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta.		"pass two: delta is negative"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions'!log	"Answer the base 10 logarithm of the receiver."	^ self ln / Ln10! !!Float methodsFor: 'mathematical functions' stamp: 'AFi 11/23/2002 21:06'!raisedTo: aNumber	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].	self < 0.0 ifTrue:		[ ArithmeticError signal: ' raised to a non-integer power' ].	0.0 = aNumber ifTrue: [^ 1.0].				"special case for exponent = 0.0"	(self= 0.0) | (aNumber = 1.0) ifTrue: [^ self].	"special case for self = 1.0"	^ (self ln * aNumber asFloat) exp			"otherwise use logarithms"! !!Float methodsFor: 'mathematical functions' stamp: 'tao 4/19/98 23:22'!reciprocalFloorLog: radix 	"Quick computation of (self log: radix) floor, when self < 1.0.	Avoids infinite recursion problems with denormalized numbers"	| adjust scale n |	adjust _ 0.	scale _ 1.0.	[(n _ radix / (self * scale)) isInfinite]		whileTrue:			[scale _ scale * radix.			adjust _ adjust + 1].	^ ((n floorLog: radix) + adjust) negated! !!Float methodsFor: 'mathematical functions' stamp: 'tao 10/15/97 14:23'!reciprocalLogBase2	"optimized for self = 10, for use in conversion for printing"	^ self = 10.0		ifTrue: [Ln2 / Ln10]		ifFalse: [Ln2 / self ln]! !!Float methodsFor: 'mathematical functions'!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum _ delta _ self.	self2 _ 0.0 - (self * self).	i _ 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta _ (delta * self2) / (i * (i + 1.0)).		i _ i + 2.0.		sum _ sum + delta.		"twice"		delta _ (delta * self2) / (i * (i + 1.0)).		i _ i + 2.0.		sum _ sum + delta].	^ sum! !!Float methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49'!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: ["v Chg"					^ FloatingPointException signal: 'undefined if less than zero.']].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'mathematical functions'!tan	"Answer the tangent of the receiver taken as an angle in radians."	^ self sin / self cos! !!Float methodsFor: 'mathematical functions'!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ aNumber adaptToFloat: self andSend: #<! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ aNumber adaptToFloat: self andSend: #<=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:56'!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ aNumber adaptToFloat: self andSend: #=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'comparing' stamp: 'tk 11/27/1999 21:47'!closeTo: num	"are these two numbers close?"	| fuzz ans |	num isNumber ifFalse: [		[ans _ self = num] ifError: [:aString :aReceiver | ^ false].		^ ans].	self = 0.0 ifTrue: [^ num abs < 0.0001].	num = 0.0 ifTrue: [^ self abs < 0.0001].	self isNaN == num isNaN ifFalse: [^ false].	self isInfinite == num isInfinite ifFalse: [^ false].	fuzz := (self abs max: num abs) * 0.0001.	^ (self - num) abs <= fuzz! !!Float methodsFor: 'comparing' stamp: 'jm 4/28/1998 01:04'!hash	"Hash is reimplemented because = is implemented. Both words of the float are used; 8 bits are removed from each end to clear most of the exponent regardless of the byte ordering. (The bitAnd:'s ensure that the intermediate results do not become a large integer.) Slower than the original version in the ratios 12:5 to 2:1 depending on values. (DNS, 11 May, 1997)"	^ (((self basicAt: 1) bitAnd: 16r00FFFF00) +	   ((self basicAt: 2) bitAnd: 16r00FFFF00)) bitShift: -8! !!Float methodsFor: 'comparing'!~= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is not equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 48>	^super ~= aNumber! !!Float methodsFor: 'testing' stamp: 'bf 8/20/1999 12:56'!hasContentsInExplorer	^false! !!Float methodsFor: 'testing'!isFloat	^ true! !!Float methodsFor: 'testing' stamp: 'jm 4/30/1998 13:50'!isInfinite	"Return true if the receiver is positive or negative infinity."	^ self = Infinity or: [self = NegativeInfinity]! !!Float methodsFor: 'testing'!isLiteral	^true! !!Float methodsFor: 'testing' stamp: 'tao 10/10/97 16:39'!isNaN	"simple, byte-order independent test for Not-a-Number"	^ self ~= self! !!Float methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two.	Floats never return true here."	^false! !!Float methodsFor: 'testing'!isZero	^self = 0.0! !!Float methodsFor: 'testing' stamp: 'jm 4/28/1998 01:10'!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.	Handle IEEE-754 negative-zero by reporting a sign of -1"	self > 0 ifTrue: [^ 1].	(self < 0 or: [((self at: 1) bitShift: -31) = 1]) ifTrue: [^ -1].	^ 0! !!Float methodsFor: 'truncation and round off'!exponent	"Primitive. Consider the receiver to be represented as a power of two	multiplied by a mantissa (between one and two). Answer with the	SmallInteger to whose power two is raised. Optional. See Object	documentation whatIsAPrimitive."	| positive |	<primitive: 53>	self >= 1.0 ifTrue: [^self floorLog: 2].	self > 0.0		ifTrue: 			[positive _ (1.0 / self) exponent.			self = (1.0 / (1.0 timesTwoPower: positive))				ifTrue: [^positive negated]				ifFalse: [^positive negated - 1]].	self = 0.0 ifTrue: [^-1].	^self negated exponent! !!Float methodsFor: 'truncation and round off'!fractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 52>	^self - self truncated asFloat! !!Float methodsFor: 'truncation and round off'!integerPart	"Answer a Float whose value is the receiver's truncated value."	^self - self fractionPart! !!Float methodsFor: 'truncation and round off' stamp: 'tk 12/30/2000 20:04'!reduce    "If self is close to an integer, return that integer"    (self closeTo: self rounded) ifTrue: [^ self rounded]! !!Float methodsFor: 'truncation and round off'!rounded	"Answer the integer nearest the receiver."	self >= 0.0		ifTrue: [^(self + 0.5) truncated]		ifFalse: [^(self - 0.5) truncated]! !!Float methodsFor: 'truncation and round off' stamp: 'tao 4/19/98 13:14'!significand	^ self timesTwoPower: (self exponent negated)! !!Float methodsFor: 'truncation and round off' stamp: 'tao 4/19/98 14:27'!significandAsInteger	| exp sig |	exp _ self exponent.	sig _ (((self at: 1) bitAnd: 16r000FFFFF) bitShift: 32) bitOr: (self at: 2).	exp > -1023		ifTrue: [sig _ sig bitOr: (1 bitShift: 52)].	^ sig.! !!Float methodsFor: 'truncation and round off' stamp: 'di 7/1/1998 23:01'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	(self isInfinite or: [self isNaN]) ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:38'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:07'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert receiverScaledDecimal to a Float and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal asFloat perform: arithmeticOpSelector with: self! !!Float methodsFor: 'converting'!asApproximateFraction	"Answer a Fraction approximating the receiver. This conversion uses the 	continued fraction method to approximate a floating point number."	| num1 denom1 num2 denom2 int frac newD temp |	num1 _ self asInteger.	"The first of two alternating numerators"	denom1 _ 1.		"The first of two alternating denominators"	num2 _ 1.		"The second numerator"	denom2 _ 0.		"The second denominator--will update"	int _ num1.		"The integer part of self"	frac _ self fractionPart.		"The fractional part of self"	[frac = 0]		whileFalse: 			["repeat while the fractional part is not zero"			newD _ 1.0 / frac.			"Take reciprocal of the fractional part"			int _ newD asInteger.		"get the integer part of this"			frac _ newD fractionPart.	"and save the fractional part for next time"			temp _ num2.				"Get old numerator and save it"			num2 _ num1.				"Set second numerator to first"			num1 _ num1 * int + temp.	"Update first numerator"			temp _ denom2.				"Get old denominator and save it"			denom2 _ denom1.			"Set second denominator to first"			denom1 _ int * denom1 + temp.		"Update first denominator"			10000000000.0 < denom1				ifTrue: 					["Is ratio past float precision?  If so, pick which 					of the two ratios to use"					num2 = 0.0 						ifTrue: ["Is second denominator 0?"								^ Fraction numerator: num1 denominator: denom1].					^ Fraction numerator: num2 denominator: denom2]].	"If fractional part is zero, return the first ratio"	denom1 = 1		ifTrue: ["Am I really an Integer?"				^ num1 "Yes, return Integer result"]		ifFalse: ["Otherwise return Fraction result"				^ Fraction numerator: num1 denominator: denom1]! !!Float methodsFor: 'converting'!asFloat	"Answer the receiver itself."	^self! !!Float methodsFor: 'converting' stamp: 'sma 5/3/2000 21:46'!asFraction	^ self asTrueFraction ! !!Float methodsFor: 'converting' stamp: 'di 2/8/1999 12:51'!asIEEE32BitWord	"Convert the receiver into a 32 bit Integer value representing the same number in IEEE 32 bit format. Used for conversion in FloatArrays only."	| word1 word2 sign mantissa exponent destWord |	self = 0.0 ifTrue:[^0].	word1 _ self basicAt: 1.	word2 _ self basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^0]. "Underflow"	exponent > 254 ifTrue:["Overflow"		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ (sign bitOr: (exponent bitShift: 23)) bitOr: mantissa.	^ destWord! !!Float methodsFor: 'converting' stamp: 'di 7/1/1998 22:20'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does not handle gradual underflow or NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| shifty sign expPart exp fraction fractionPart result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction "	fraction := fractionPart bitOr: 16r0010000000000000.	"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := sign * fraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount _ fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := sign * fraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (sign * fractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Float methodsFor: 'converting'!degreesToRadians	"Answer the receiver in radians. Assumes the receiver is in degrees."	^self * RadiansPerDegree! !!Float methodsFor: 'converting' stamp: 'tao 10/10/97 16:38'!isInf	"simple, byte-order independent test for +/- Infinity"	^ self = (self * 1.5 + 1.0)! !!Float methodsFor: 'converting'!radiansToDegrees	"Answer the receiver in degrees. Assumes the receiver is in radians."	^self / RadiansPerDegree! !!Float methodsFor: 'copying'!deepCopy	^self copy! !!Float methodsFor: 'copying'!shallowCopy	^self + 0.0! !!Float methodsFor: 'copying' stamp: 'tk 8/19/1998 16:08'!veryDeepCopyWith: deepCopier	"Return self.  Do not record me."	^ self clone! !!Float methodsFor: 'printing' stamp: 'tao 4/22/98 11:58'!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits _ 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase _ base asFloat.	exp _ self exponent.	baseExpEstimate _ (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r _ self.			s _ 1.0.			mPlus _ 1.0 timesTwoPower: exp - significantBits.			mMinus _ self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r _ self timesTwoPower: significantBits.			s _ 1.0 timesTwoPower:  significantBits.			mMinus _ 1.0 timesTwoPower: (exp max: -1024).			mPlus _				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[s _ s * (fBase raisedToInteger: baseExpEstimate).			exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r _ r / fBase.					s _ s / fBase.					mPlus _ mPlus / fBase.					mMinus _ mMinus / fBase]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d _ (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale _ fBase raisedToInteger: d.					r _ r * scale.					mPlus _ mPlus * scale.					mMinus _ mMinus * scale.					scale _ fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale _ fBase raisedToInteger: baseExpEstimate negated].			s _ s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate _ baseExpEstimate + 1]		ifFalse:			[s _ s / fBase].	(fixedFormat _ baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount _ baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount _ 1].	[d _ (r / s) truncated.	r _ r - (d * s).	(tc1 _ r <= mMinus) | (tc2 _ r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r _ r * fBase.		mPlus _ mPlus * fBase.		mMinus _ mMinus * fBase.		decPointCount _ decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d _ d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing'!hex  "If ya really want to know..."	| word nibble |	^ String streamContents:		[:strm |		1 to: 2 do:			[:i | word _ self at: i.			1 to: 8 do: 				[:s | nibble _ (word bitShift: -8+s*4) bitAnd: 16rF.				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]"(-2.0 to: 2.0) collect: [:f | f hex]"! !!Float methodsFor: 'printing' stamp: 'tao 4/19/98 23:31'!printOn: aStream base: base	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:" 	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"	self > 0.0		ifTrue: [self absPrintOn: aStream base: base]		ifFalse:			[self sign = -1				ifTrue: [aStream nextPutAll: '-'].			self = 0.0				ifTrue: [aStream nextPutAll: '0.0'. ^ self]				ifFalse: [self negated absPrintOn: aStream base: base]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Float class	instanceVariableNames: ''!!Float class methodsFor: 'class initialization' stamp: 'jm 4/30/1998 13:48'!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi _ 3.14159265358979323846264338327950288.	Halfpi _ Pi / 2.0.	Twopi _ Pi * 2.0.	RadiansPerDegree _ Pi / 180.0.	Ln2 _ 0.69314718055994530941723212145817657.	Ln10 _ 10.0 ln.	Sqrt2 _ 1.41421356237309504880168872420969808.	E _ 2.718281828459045235360287471353.	Epsilon _ 0.000000000001.  "Defines precision of mathematical functions"	MaxVal _ 1.7976931348623159e308.	MaxValLn _ 709.782712893384.	MinValLogBase2 _ -1074.	Infinity _ MaxVal * MaxVal.	NegativeInfinity _ 0.0 - Infinity.	NaN _ Infinity - Infinity.	NegativeZero _ 1.0 / Infinity negated.! !!Float class methodsFor: 'instance creation' stamp: 'di 2/8/1999 12:58'!fromIEEE32Bit: word	"Convert the given 32 bit word (which is supposed to be a positive 32bit value) from a 32bit IEEE floating point representation into an actual Squeak float object (being 64bit wide). Should only be used for conversion in FloatArrays or likewise objects."	| sign mantissa exponent newFloat |	word negative ifTrue: [^ self error:'Cannot deal with negative numbers'].	word = 0 ifTrue:[^ 0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^ Float nan].		sign = 0 			ifTrue:[^ Float infinity]			ifFalse:[^ Float infinity negated]].	"Create new float"	newFloat _ self new: 2.	newFloat basicAt: 1 put: ((sign bitOr: (1023 + exponent bitShift: 20)) bitOr: (mantissa bitShift: -3)).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!Float class methodsFor: 'instance creation'!readFrom: aStream 	"Answer a new Float as described on the stream, aStream."	^(super readFrom: aStream) asFloat! !!Float class methodsFor: 'constants' stamp: 'tao 4/23/98 11:37'!infinity	"Answer the value used to represent an infinite magnitude"	^ Infinity! !!Float class methodsFor: 'constants' stamp: 'tao 4/23/98 11:38'!nan	"Answer the canonical value used to represent Not-A-Number"	^ NaN! !!Float class methodsFor: 'constants' stamp: 'tao 4/23/98 12:05'!negativeZero	^ NegativeZero! !!Float class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	#Numeric.	"add 200/01/19 For <number> protocol support."	^ 1.0! !!Float class methodsFor: 'constants'!pi	"Answer the constant, Pi."	^Pi! !!Float class methodsFor: 'plugin generation' stamp: 'bf 3/16/2000 19:06'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asFloatValueFrom: anInteger on: aStream! !!Float class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:05'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToFloatObjectFrom: aNode on: aStream! !!Float class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:10'!ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToFloatValueFrom: aNode on: aStream! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:08'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asFloatValueFrom: anInteger! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:22'!ccgCanConvertFrom: anObject	^anObject class == self! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:09'!ccgDeclareCForVar: aSymbolOrString	^'double ', aSymbolOrString! !ArrayedCollection variableWordSubclass: #FloatArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!FloatArray commentStamp: '<historical>' prior: 0!FloatArrays store 32bit IEEE floating point numbers.!!FloatArray methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!at: index	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!FloatArray methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!at: index put: value	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!FloatArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0.0! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!* anObject	^self clone *= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!*= anObject	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!+ anObject	^self clone += anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:48'!+= anObject	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!- anObject	^self clone -= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!-= anObject	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:34'!/ anObject	^self clone /= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 10/7/1998 19:58'!/= anObject	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/7/2001 23:07'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a Number. If possible,	convert it to a float and perform the (more efficient) primitive operation."	selector == #+ ifTrue:[^self + rcvr].	selector == #* ifTrue:[^self * rcvr].	selector == #- ifTrue:[^self negated += rcvr].	selector == #/ ifTrue:[^self * (1.0 / rcvr)].	^super adaptToNumber: rcvr andSend: selector! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/7/2001 23:04'!negated	^self clone *= -1! !!FloatArray methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!= aFloatArray 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	aFloatArray class = self class ifFalse: [^ false].	length _ self size.	length = aFloatArray size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aFloatArray at: i) ifFalse: [^ false]].	^ true! !!FloatArray methodsFor: 'comparing' stamp: 'ar 5/3/2001 13:02'!hash	| result |	<primitive:'primitiveHashArray' module: 'FloatArrayPlugin'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primAddArray: floatArray	<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primAddScalar: scalarValue	<primitive: 'primitiveAddScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primDivArray: floatArray	<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primDivScalar: scalarValue	<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primMulArray: floatArray	<primitive: 'primitiveMulFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primMulScalar: scalarValue	<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primSubArray: floatArray	<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primSubScalar: scalarValue	<primitive: 'primitiveSubScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'jcg 6/12/2003 17:54'!sum	<primitive: 'primitiveSum' module: 'FloatArrayPlugin'>	^ super sum! !!FloatArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asFloatArray	^self! !!FloatArray methodsFor: 'private' stamp: 'ar 10/9/1998 11:27'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!FloatArray methodsFor: 'user interface' stamp: 'ar 2/13/1999 21:33'!inspect	"Open a OrderedCollectionInspector on the receiver.  Use basicInspect to get a normal (less useful) type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!FloatArray methodsFor: 'user interface' stamp: 'ar 2/13/1999 21:33'!inspectWithLabel: aLabel	"Open a OrderedCollectionInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true withLabel: aLabel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FloatArray class	instanceVariableNames: ''!!FloatArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:17'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asFloatPtrFrom: anInteger on: aStream! !!FloatArray class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:07'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asWBFloatPtrFrom: anInteger! !!FloatArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:14'!ccgDeclareCForVar: aSymbolOrString	^'float *', aSymbolOrString! !ArithmeticError subclass: #FloatingPointException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!DisplayMedium subclass: #Form	instanceVariableNames: 'bits width height depth offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!Form commentStamp: 'ls 1/4/2004 17:16' prior: 0!A rectangular array of pixels, used for holding images.  All pictures, including character images are Forms.  The depth of a Form is how many bits are used to specify the color at each pixel.  The actual bits are held in a Bitmap, whose internal structure is different at each depth.  Class Color allows you to deal with colors without knowing how they are actually encoded inside a Bitmap.	  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.	Forms are indexed starting at 0 instead of 1; thus, the top-left pixel of a Form has coordinates 0@0.	Forms are combined using BitBlt.  See the comment in class BitBlt.  Forms that repeat many times to fill a large destination are InfiniteForms.	colorAt: x@y		Returns the abstract Color at this location	displayAt: x@y		shows this form on the screen	displayOn: aMedium at: x@y	shows this form in a Window, a Form, or other DisplayMedium	fillColor: aColor		Set all the pixels to the color.	edit		launch an editor to change the bits of this form.	pixelValueAt: x@y	The encoded color.  The encoding depends on the depth.!]style[(223 6 62 5 374 6 11 23 64 12 382)f1,f1LBitmap Definition;,f1,f1LColor Definition;,f1,f1LBitBlt Definition;,f1,f1LBitBlt Comment;,f1,f1LInfiniteForm Definition;,f1!!Form methodsFor: 'accessing'!bits	"Answer the receiver's Bitmap containing its bits."	^ bits! !!Form methodsFor: 'accessing'!bits: aBitmap 	"Reset the Bitmap containing the receiver's bits."	bits _ aBitmap! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:41'!bitsSize	| pixPerWord |	depth == nil ifTrue: [depth _ 1].	pixPerWord _ 32 // self depth.	^ width + pixPerWord - 1 // pixPerWord * height! !!Form methodsFor: 'accessing' stamp: 'tk 3/9/97'!center	"Note that offset is ignored here.  Are we really going to embrace offset?  "	^ (width @ height) // 2! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:03'!defaultCanvasClass	"Return the default canvas used for drawing onto the receiver"	^Display defaultCanvasClass! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!depth	^ depth < 0 ifTrue:[0-depth] ifFalse:[depth]! !!Form methodsFor: 'accessing'!depth: bitsPerPixel	(bitsPerPixel > 32 or:		[(bitsPerPixel bitAnd: bitsPerPixel-1) ~= 0])		ifTrue: [self halt: 'bitsPerPixel must be 1, 2, 4, 8, 16 or 32'].	depth _ bitsPerPixel! !!Form methodsFor: 'accessing' stamp: 'ar 5/27/2000 16:56'!displayScreen	"Return the display screen the receiver is allocated on. 	Forms in general are Squeak internal and not allocated on any particular display."	^nil! !!Form methodsFor: 'accessing'!extent	^ width @ height! !!Form methodsFor: 'accessing'!form	"Answer the receiver's form.  For vanilla Forms, this degenerates to self.  Makes several methods that operate on both Forms and MaskedForms much more straightforward.   6/1/96 sw"	^ self! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:03'!getCanvas	"Return a Canvas that can be used to draw onto the receiver"	^self defaultCanvasClass on: self! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified	"Return true if something *might* have been drawn into the receiver"	^(bits == nil or:[bits class == ByteArray]) not	"Read the above as: If the receiver has forgotten its contents (bits == nil) 	or is still hibernated it can't be modified."! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified: aBool	"Change the receiver to reflect the modification state"	aBool ifTrue:[^self unhibernate].	self shouldPreserveContents		ifTrue:[self hibernate]		ifFalse:[bits _ nil]! !!Form methodsFor: 'accessing'!height	^ height! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:50'!nativeDepth	"Return the 'native' depth of the receiver, e.g., including the endianess"	^depth! !!Form methodsFor: 'accessing' stamp: 'ar 2/16/2000 22:00'!offset	^offset ifNil:[0@0]! !!Form methodsFor: 'accessing'!offset: aPoint	offset _ aPoint! !!Form methodsFor: 'accessing'!size	"Should no longer be used -- use bitsSize instead.  length of variable part of instance."	^ super size! !!Form methodsFor: 'accessing'!width	^ width! !!Form methodsFor: 'analyzing'!cgForPixelValue: pv orNot: not	"Return the center of gravity for all pixels of value pv.	Note:  If orNot is true, then produce the center of gravity for all pixels	that are DIFFERENT from the supplied (background) value"	| pixCount weighted xAndY |	xAndY _ (Array with: (self xTallyPixelValue: pv orNot: not)					with: (self yTallyPixelValue: pv orNot: not)) collect:		[:profile |	"For both x and y profiles..."		pixCount _ 0.  weighted _ 0.		profile doWithIndex:			[:t :i | pixCount _ pixCount + t.			weighted _ weighted + (t*i)].		pixCount = 0  "Produce average of nPixels weighted by coordinate"			ifTrue: [0.0]			ifFalse: [weighted asFloat / pixCount asFloat - 1.0]].	^ xAndY first @ xAndY last"| f cg |[Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: (Sensor cursorPoint extent: 50@50).	cg _ f cgForPixelValue: (Color black pixelValueForDepth: f depth) orNot: false.	f displayAt: 0@0.	Display fill: (cg extent: 2@2) fillColor: Color red].	ScheduledControllers restore"! !!Form methodsFor: 'analyzing' stamp: 'jm 12/5/97 19:48'!colorsUsed	"Return a list of the Colors this form uses."	| tallies tallyDepth usedColors |	tallies _ self tallyPixelValues.	tallyDepth _ (tallies size log: 2) asInteger.	usedColors _ OrderedCollection new.	tallies doWithIndex: [:count :i |		count > 0 ifTrue: [			usedColors add: (Color colorFromPixelValue: i - 1 depth: tallyDepth)]].	^ usedColors asArray! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40'!dominantColor	| tally max maxi |	self depth > 16 ifTrue:		[^(self asFormOfDepth: 16) dominantColor].	tally _ self tallyPixelValues.	max _ maxi _ 0.	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !!Form methodsFor: 'analyzing'!innerPixelRectFor: pv orNot: not	"Return a rectangle describing the smallest part of me that includes 	all pixels of value pv.	Note:  If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	| xTally yTally |	xTally _ self xTallyPixelValue: pv orNot: not.	yTally _ self yTallyPixelValue: pv orNot: not.	^ ((xTally findFirst: [:t | t>0]) - 1) @ ((yTally findFirst: [:t | t>0]) - 1)		corner:			(xTally findLast: [:t | t>0])@(yTally findLast: [:t | t>0])! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//self depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt current toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt current toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:42'!primCountBits	"Count the non-zero pixels of this form."	self depth > 8 ifTrue:		[^(self asFormOfDepth: 8) primCountBits].	^ (BitBlt current toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:37'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm _ Bitmap new: (1 bitShift: (self depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice _ Form extent: width@1 depth: 1.	copyBlt _ (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt _ (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top _ (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom _ (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH _ bottom - top + 1.	slice _ Form extent: 1@newH depth: 1.	copyBlt _ (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt _ (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left _ (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right _ (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!Form methodsFor: 'analyzing' stamp: 'jm 6/18/1999 18:41'!tallyPixelValues	"Answer a Bitmap whose elements contain the number of pixels in this Form with the pixel value corresponding to their index. Note that the pixels of multiple Forms can be tallied together using tallyPixelValuesInRect:into:."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'analyzing' stamp: 'ar 5/28/2000 12:09'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBlt current toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'analyzing' stamp: 'ar 5/28/2000 12:09'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt current destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt current toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'analyzing' stamp: 'ar 5/28/2000 12:09'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt current destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt current toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'bordering' stamp: 'ar 5/28/2000 12:07'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a border whose rectangular area is defined by rect. Thewidth of the border of each side is borderWidth. Uses fillColor for drawingthe border."        | blt |        blt _ (BitBlt current toForm: self) combinationRule: rule; fillColor: fillColor.        blt sourceOrigin: 0@0.        blt destOrigin: rect origin.        blt width: rect width; height: borderWidth; copyBits.        blt destY: rect corner y - borderWidth; copyBits.        blt destY: rect origin y + borderWidth.        blt height: rect height - borderWidth - borderWidth; width:borderWidth; copyBits.        blt destX: rect corner x - borderWidth; copyBits! !!Form methodsFor: 'bordering' stamp: 'ar 5/17/2001 15:42'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self deepCopy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt current toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'bordering'!borderWidth: anInteger 	"Set the width of the border for the receiver to be anInteger and paint it 	using black as the border color."	self border: self boundingBox width: anInteger fillColor: Color black! !!Form methodsFor: 'bordering'!borderWidth: anInteger color: aMask	"Set the width of the border for the receiver to be anInteger and paint it 	using aMask as the border color."	self border: self boundingBox width: anInteger fillColor: aMask! !!Form methodsFor: 'bordering'!borderWidth: anInteger fillColor: aMask	"Set the width of the border for the receiver to be anInteger and paint it 	using aMask as the border color."	self border: self boundingBox width: anInteger fillColor: aMask! !!Form methodsFor: 'bordering' stamp: 'di 10/21/2001 09:39'!shapeBorder: aColor width: borderWidth	"A simplified version for shapes surrounded by transparency (as SketchMorphs).	Note also this returns a new form that may be larger, and does not affect the original."	| shapeForm borderForm newForm |	newForm _ Form extent: self extent + (borderWidth*2) depth: self depth.	newForm fillColor: Color transparent.	self displayOn: newForm at: (0@0) + borderWidth.	"First identify the shape in question as a B/W form"	shapeForm _ (newForm makeBWForm: Color transparent) reverse.	"Now find the border of that shape"	borderForm _ shapeForm borderFormOfWidth: borderWidth sharpCorners: false.	"Finally use that shape as a mask to paint the border with color"	^ newForm fillShape: borderForm fillColor: aColor! !!Form methodsFor: 'bordering'!shapeBorder: aColor width: borderWidth interiorPoint: interiorPoint	sharpCorners: sharpen internal: internal	"Identify the shape (region of identical color) at interiorPoint,	and then add an outline of width=borderWidth and color=aColor.	If sharpen is true, then cause right angles to be outlined by	right angles.  If internal is true, then produce a border that lies	within the identified shape.  Thus one can put an internal border	around the whole background, thus effecting a normal border	around every other foreground image."	| shapeForm borderForm interiorColor |	"First identify the shape in question as a B/W form"	interiorColor _ self colorAt: interiorPoint.	shapeForm _ (self makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Reverse the image to grow the outline inward"	internal ifTrue: [shapeForm reverse].	"Now find the border fo that shape"	borderForm _ shapeForm borderFormOfWidth: borderWidth sharpCorners: sharpen.	"Finally use that shape as a mask to paint the border with color"	self fillShape: borderForm fillColor: aColor! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!balancedPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	self hasNonStandardPalette		ifTrue:[^self bitPatternFor: aColor]		ifFalse:[^aColor balancedPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!bitPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	aColor isColor ifFalse:[^aColor bitPatternForDepth: self depth].	self hasNonStandardPalette		ifTrue:[^Bitmap with: (self pixelWordFor: aColor)]		ifFalse:[^aColor bitPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB space into the receiver.	Note: This version is optimized for Squeak forms."	| map nBits |	self hasNonStandardPalette 		ifTrue:[^ColorMap mappingFromARGB: self rgbaBitMasks].	self depth <= 8 ifTrue:[		map _ Color colorMapIfNeededFrom: 32 to: self depth.		map size = 512 ifTrue:[nBits _ 3].		map size = 4096 ifTrue:[nBits _ 4].		map size = 32768 ifTrue:[nBits _ 5].		^ColorMap			shifts: (Array 						with: 3 * nBits - 24						with: 2 * nBits - 16						with: 1 * nBits - 8						with: 0)			masks: (Array						with: (1 << nBits) - 1 << (24 - nBits)						with: (1 << nBits) - 1 << (16 - nBits)						with: (1 << nBits) - 1 << (8 - nBits)						with: 0)			colors: map].	self depth = 16 ifTrue:[		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 5/16/2001 22:23'!colormapIfNeededFor: destForm	"Return a ColorMap mapping from the receiver to destForm."	(self hasNonStandardPalette or:[destForm hasNonStandardPalette]) 		ifTrue:[^self colormapFromARGB mappingTo: destForm colormapFromARGB]		ifFalse:[^self colormapIfNeededForDepth: destForm depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"	^ Color colorMapIfNeededFrom: self depth to: destDepth! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapToARGB	"Return a ColorMap mapping from the receiver into canonical ARGB space."	self hasNonStandardPalette 		ifTrue:[^self colormapFromARGB inverseMap].	self depth <= 8 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)			colors: (Color colorMapIfNeededFrom: self depth to: 32)].	self depth = 16 ifTrue:[		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping'!makeBWForm: foregroundColor	"Map this form into a B/W form with 1's in the foreground regions."	| bwForm map |	bwForm _ Form extent: self extent.	map _ self newColorMap.  "All non-foreground go to 0's"	map at: (foregroundColor indexInMap: map) put: 1.	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	^ bwForm! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:38'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	map _ (Color cachedColormapFrom: self depth to: self depth) copy.	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:40'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	self depth < 16		ifTrue: [map _ (Color cachedColormapFrom: self depth to: self depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: self depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'color mapping' stamp: 'ar 12/14/2001 18:11'!maskingMap	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."	^Color maskingMap: self depth! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:41'!newColorMap 	"Return an uninitialized color map array appropriate to this Form's depth."	^ Bitmap new: (1 bitShift: (self depth min: 15))! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelValueFor: aColor	"Return the pixel word for representing the given color on the receiver"	self hasNonStandardPalette		ifTrue:[^self colormapFromARGB mapPixel: (aColor pixelValueForDepth: 32)]		ifFalse:[^aColor pixelValueForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelWordFor: aColor	"Return the pixel word for representing the given color on the receiver"	| basicPattern |	self hasNonStandardPalette 		ifFalse:[^aColor pixelWordForDepth: self depth].	basicPattern _ self pixelValueFor: aColor.	self depth = 32 		ifTrue:[^basicPattern]		ifFalse:[^aColor pixelWordFor: self depth filledWith: basicPattern]! !!Form methodsFor: 'color mapping' stamp: 'di 10/16/2001 15:23'!reducedPaletteOfSize: nColors	"Return an array of colors of size nColors, such that those colors	represent well the pixel values actually found in this form."	| threshold tallies colorTallies dist delta palette cts top cluster |	tallies _ self tallyPixelValues.  "An array of tallies for each pixel value"	threshold _ width * height // 500.	"Make an array of (color -> tally) for all tallies over threshold"	colorTallies _ Array streamContents:		[:s | tallies withIndexDo:			[:v :i | v >= threshold ifTrue:				[s nextPut: (Color colorFromPixelValue: i-1 depth: depth) -> v]]].	"Extract a set of clusters by picking the top tally, and then removing all others	whose color is within dist of it.  Iterate the process, adjusting dist until we get nColors."	dist _ 0.2.  delta _ dist / 2.		[cts _ colorTallies copy.		palette _ Array streamContents: [:s |			[cts isEmpty] whileFalse:				[top _ cts detectMax: [:a | a value].				cluster _ cts select: [:a | (a key diff: top key) < dist].				s nextPut: top key -> (cluster detectSum: [:a | a value]).				cts _ cts copyWithoutAll: cluster]].		palette size = nColors or: [delta < 0.001]]		whileFalse:			[palette size > nColors				ifTrue: [dist _ dist + delta]				ifFalse: [dist _ dist - delta].			delta _ delta / 2].	^ palette collect: [:a | a key]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 20:14'!rgbaBitMasks	"Return the masks for specifying the R,G,B, and A components in the receiver"	self depth <= 8		ifTrue:[^#(16rFF0000 16rFF00 16rFF 16rFF000000)].	self depth = 16		ifTrue:[^#(16r7C00 16r3E0 16r1F 16r0)].	self depth = 32		ifTrue:[^#(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth for form'! !!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28'!as8BitColorForm	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."	| f map |	f _ ColorForm extent: self extent depth: 8.	self displayOn: f at: self offset negated.	map _ Color indexedColors copy.	map at: 1 put: Color transparent.	f colors: map.	f offset: self offset.	^ f! !!Form methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:13'!asCursorForm	^ self as: StaticForm! !!Form methodsFor: 'converting' stamp: 'ar 6/16/2002 17:44'!asFormOfDepth: d	| newForm |	d = self depth ifTrue:[^self].	newForm _ Form extent: self extent depth: d.	(BitBlt current toForm: newForm)		colorMap: (self colormapIfNeededFor: newForm);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	^newForm! !!Form methodsFor: 'converting' stamp: 'ar 5/17/2001 15:39'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	self depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt current toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt current toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Form methodsFor: 'converting' stamp: 'jm 4/5/1999 19:20'!colorReduced	"Return a color-reduced ColorForm version of the receiver, if possible, or the receiver itself if not."	| tally tallyDepth colorCount newForm cm oldPixelValues newFormColors nextColorIndex c |	tally _ self tallyPixelValues asArray.	tallyDepth _ (tally size log: 2) asInteger.	colorCount _ 0.	tally do: [:n | n > 0 ifTrue: [colorCount _ colorCount + 1]].	(tally at: 1) = 0 ifTrue: [colorCount _ colorCount + 1].  "include transparent"	colorCount > 256 ifTrue: [^ self].  "cannot reduce"	newForm _ self formForColorCount: colorCount.	"build an array of just the colors used, and a color map to translate	 old pixel values to their indices into this color array"	cm _ Bitmap new: tally size.	oldPixelValues _ self colormapIfNeededForDepth: 32.	newFormColors _ Array new: colorCount.	newFormColors at: 1 put: Color transparent.	nextColorIndex _ 2.	2 to: cm size do: [:i |		(tally at: i) > 0 ifTrue: [			oldPixelValues = nil				ifTrue: [c _ Color colorFromPixelValue: i - 1 depth: tallyDepth]				ifFalse: [c _ Color colorFromPixelValue: (oldPixelValues at: i) depth: 32].			newFormColors at: nextColorIndex put: c.			cm at: i put: nextColorIndex - 1.  "pixel values are zero-based indices"			nextColorIndex _ nextColorIndex + 1]].	"copy pixels into new ColorForm, mapping to new pixel values"	newForm copyBits: self boundingBox		from: self		at: 0@0		clippingBox: self boundingBox		rule: Form over		fillColor: nil		map: cm.	newForm colors: newFormColors.	newForm offset: offset.	^ newForm! !!Form methodsFor: 'converting' stamp: 'di 10/16/2001 19:23'!copyWithColorsReducedTo: nColors	"Note: this has not been engineered.	There are better solutions in the literature."	| palette colorMap pc closest |	palette _ self reducedPaletteOfSize: nColors.	colorMap _ (1 to: (1 bitShift: depth)) collect:		[:i | pc _ Color colorFromPixelValue: i-1 depth: depth.		closest _ palette detectMin: [:c | c diff: pc].		closest pixelValueForDepth: depth].	^ self deepCopy copyBits: self boundingBox from: self at: 0@0 colorMap: (colorMap as: Bitmap)		! !!Form methodsFor: 'converting' stamp: 'ar 7/23/1999 17:04'!orderedDither32To16	"Do an ordered dithering for converting from 32 to 16 bit depth."	| ditherMatrix ii out inBits outBits index pv dmv r di dmi dmo g b pvOut outIndex |	self depth = 32 ifFalse:[^self error:'Must be 32bit for this'].	ditherMatrix _ #(	0	8	2	10						12	4	14	6						3	11	1	9						15	7	13	5).	ii _ (0 to: 31) collect:[:i| i].	out _ Form extent: self extent depth: 16.	inBits _ self bits.	outBits _ out bits.	index _ outIndex _ 0.	pvOut _ 0.	0 to: self height-1 do:[:y|		0 to: self width-1 do:[:x|			pv _ inBits at: (index _ index + 1).			dmv _ ditherMatrix at: (y bitAnd: 3) * 4 + (x bitAnd: 3) + 1.			r _ pv bitAnd: 255.	di _ r * 496 bitShift: -8.			dmi _ di bitAnd: 15.	dmo _ di bitShift: -4.			r _ dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			g _ (pv bitShift: -8) bitAnd: 255.	di _ g * 496 bitShift: -8.			dmi _ di bitAnd: 15.	dmo _ di bitShift: -4.			g _ dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			b _ (pv bitShift: -16) bitAnd: 255.	di _ b * 496 bitShift: -8.			dmi _ di bitAnd: 15.	dmo _ di bitShift: -4.			b _ dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			pvOut _ (pvOut bitShift: 16) + 						(b bitShift: 10) + (g bitShift: 5) + r.			(x bitAnd: 1) = 1 ifTrue:[				outBits at: (outIndex _ outIndex+1) put: pvOut.				pvOut _ 0].		].		(self width bitAnd: 1) = 1 ifTrue:[			outBits at: (outIndex _ outIndex+1) put: (pvOut bitShift: -16).			pvOut _ 0].	].	^out! !!Form methodsFor: 'copying' stamp: 'RAA 9/28/1999 11:20'!blankCopyOf: aRectangle scaledBy: scale        ^ self class extent: (aRectangle extent * scale) truncated depth: depth! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 18:59'!contentsOfArea: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	^self contentsOfArea: aRect 		into: (self class extent: aRect extent depth: depth).! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 19:00'!contentsOfArea: aRect into: newForm 	"Return a new form which derives from the portion of the original form delineated by aRect."	^ newForm copyBits: aRect from: self at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!Form methodsFor: 'copying'!copy: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	| newForm |	newForm _ self class extent: aRect extent depth: depth.	^ newForm copyBits: aRect from: self at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copy: destRectangle from: sourcePt in: sourceForm rule: rule 	"Make up a BitBlt table and copy the bits."	(BitBlt current toForm: self)		copy: destRectangle		from: sourcePt in: sourceForm		fillColor: nil rule: rule! !!Form methodsFor: 'copying'!copy: sourceRectangle from: sourceForm to: destPt rule: rule	^ self copy: (destPt extent: sourceRectangle extent)		from: sourceRectangle topLeft in: sourceForm rule: rule! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm 	"Make up a BitBlt table and copy the bits."	(BitBlt current 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) copyBits! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map	"Make up a BitBlt table and copy the bits.  Use a colorMap."	((BitBlt current 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) colorMap: map) copyBits! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceRect from: sourceForm at: destOrigin colorMap: map 	"Make up a BitBlt table and copy the bits with the given colorMap."	((BitBlt current 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: self boundingBox) colorMap: map) copyBits! !!Form methodsFor: 'copying' stamp: 'jm 2/27/98 09:35'!deepCopy	^ self shallowCopy		bits: bits copy;		offset: offset copy! !!Form methodsFor: 'copying' stamp: 'tk 8/19/1998 16:11'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."	^ self! !!Form methodsFor: 'display box access'!boundingBox	^ Rectangle origin: 0 @ 0			corner: width @ height! !!Form methodsFor: 'display box access'!computeBoundingBox	^ Rectangle origin: 0 @ 0			corner: width @ height! !!Form methodsFor: 'displaying' stamp: 'ar 2/13/2001 22:13'!displayInterpolatedIn: aRectangle on: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine adjustedR |	self extent = aRectangle extent ifTrue:[^self displayOn: aForm at: aRectangle origin].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine _ (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aRectangle;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	"there seems to be a slight bug in B3D which the following adjusts for"	adjustedR _ (aRectangle withRight: aRectangle right + 1) translateBy: 0@1.	engine viewport: adjustedR.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.! !!Form methodsFor: 'displaying' stamp: 'ar 2/13/2001 22:12'!displayInterpolatedOn: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine _ (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.! !!Form methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:33'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: rule fillColor: aForm	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm		map: (self colormapIfNeededFor: aDisplayMedium).! !!Form methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Graphically, it means nothing to scale a Form by floating point values.  	Because scales and other display parameters are kept in floating point to 	minimize round off errors, we are forced in this routine to round off to the 	nearest integer."	| absolutePoint scale magnifiedForm |	absolutePoint _ displayTransformation applyTo: relativePoint.	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.	displayTransformation noScale		ifTrue: [magnifiedForm _ self]		ifFalse: 			[scale _ displayTransformation scale.			scale _ scale x @ scale y.			(1@1 = scale)					ifTrue: [scale _ nil. magnifiedForm _ self]					ifFalse: [magnifiedForm _ self magnify: self boundingBox by: scale]].	magnifiedForm		displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Form methodsFor: 'displaying'!displayOnPort: port at: location	port copyForm: self to: location rule: Form over! !!Form methodsFor: 'displaying' stamp: 'ar 5/17/2001 15:40'!displayResourceFormOn: aForm	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine ifPresentAndInMemory:		[:engineClass | engine _ engineClass defaultForPlatformOn: aForm].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	tx _ self asTexture.	(blitter _ BitBlt current toForm: tx)		sourceForm: self; destRect: aForm boundingBox;		sourceOrigin: 0@0;		combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:) ifTrue: [		cmap _ Bitmap new: (self depth <= 8 ifTrue: [1 << self depth] ifFalse: [4096]).		cmap at: 1 put: (tx pixelWordFor: World color).		blitter colorMap: cmap.	].	blitter copyBits.	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel values intact"	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form and;		colorMap: (Color maskingMap: self depth);		warpBits.! !!Form methodsFor: 'displaying' stamp: 'ar 3/2/2001 21:32'!displayScaledOn: aForm	"Display the receiver on aForm, scaling if necessary.		Form fromUser displayScaledOn: Display.	"	self extent = aForm extent ifTrue:[^self displayOn: aForm].	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form paint;		cellSize: 2;		warpBits.! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Refer to the comment in 	DisplayMedium|drawLine:from:to:clippingBox:rule:mask:." 		| dotSetter |	"set up an instance of BitBlt for display"	dotSetter _ BitBlt current		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: anInteger		destOrigin: beginPoint		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: clipRect.	dotSetter drawFrom: beginPoint to: endPoint! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'displaying' stamp: 'BG 10/28/2003 20:58'!setAsBackground	"Set this form as a background image."	Smalltalk isMorphic 				ifFalse:			[ScheduledControllers screenController model form: self.			Display restoreAfter: []]! !!Form methodsFor: 'encoding' stamp: 'RAA 7/29/2000 09:01'!addDeltasFrom: previousForm	(BitBlt 		destForm: self 		sourceForm: previousForm 		fillColor: nil 		combinationRule: Form reverse		destOrigin: 0@0		sourceOrigin: 0@0		extent: self extent 		clipRect: self boundingBox) copyBits.	^self! !!Form methodsFor: 'encoding' stamp: 'RAA 7/29/2000 09:01'!deltaFrom: previousForm	| newForm |	newForm _ previousForm deepCopy.	(BitBlt 		destForm: newForm 		sourceForm: self 		fillColor: nil 		combinationRule: Form reverse 		destOrigin: 0@0		sourceOrigin: 0@0		extent: self extent 		clipRect: self boundingBox) copyBits.	^newForm! !!Form methodsFor: 'encoding' stamp: 'RAA 8/1/2000 06:15'!deltaFrom: smallerForm at: offsetInMe	| newForm |	newForm _ smallerForm deepCopy.	(BitBlt 		destForm: newForm 		sourceForm: self 		fillColor: nil 		combinationRule: Form reverse 		destOrigin: 0@0		sourceOrigin: offsetInMe		extent: smallerForm extent 		clipRect: newForm boundingBox) copyBits.	^newForm! !!Form methodsFor: 'encoding' stamp: 'RAA 8/13/2000 15:32'!encodeForRemoteCanvas	| header binaryForm |	"encode into a bitstream for use with RemoteCanvas.  The format does not require invoking the Compiler"	header := String streamContents: [ :str |	str "nextPutAll: 'F|';"		nextPutAll: self depth printString;		nextPut: $,;		nextPutAll: self width printString;		nextPut: $,;		nextPutAll: self height printString;		nextPut: $|. ].	binaryForm := ByteArray streamContents: [ :str |		self unhibernate.		bits writeOn: str. ].	^header, binaryForm asString! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: Bitmap) ifFalse: [^ self  "already hibernated or weird state"].	compactBits _ ByteArray new: (bits size*4) + 7 + (bits size//1984*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 3/15/1999 14:50'!printOn: aStream    aStream        nextPutAll: self class name;        nextPut: $(; print: width;        nextPut: $x; print: height;        nextPut: $x; print: depth;        nextPut: $).! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:44'!readAttributesFrom: aBinaryStream	| offsetX offsetY |	depth _ aBinaryStream next.	(self depth isPowerOfTwo and: [self depth between: 1 and: 32])		ifFalse: [self error: 'invalid depth; bad Form file?'].	width _ aBinaryStream nextWord.	height _ aBinaryStream nextWord.	offsetX  _ aBinaryStream nextWord.	offsetY _ aBinaryStream nextWord.	offsetX > 32767 ifTrue: [offsetX _ offsetX - 65536].	offsetY > 32767 ifTrue: [offsetY _ offsetY - 65536].	offset _ Point x: offsetX y: offsetY.	! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:43'!readBitsFrom: aBinaryStream		bits _ Bitmap newFromStream: aBinaryStream.	bits size = self bitsSize ifFalse: [self error: 'wrong bitmap size; bad Form file?'].	^ self! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:44'!readFrom: aBinaryStream	"Reads the receiver from the given binary stream with the format:		depth, extent, offset, bits."	self readAttributesFrom: aBinaryStream.	self readBitsFrom: aBinaryStream! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 3/27/98 16:54'!readFromOldFormat: aBinaryStream	"Read a Form in the original ST-80 format."	| w h offsetX offsetY newForm theBits pos |	self error: 'this method must be updated to read into 32-bit word bitmaps'.	w _ aBinaryStream nextWord.	h _ aBinaryStream nextWord.	offsetX  _ aBinaryStream nextWord.	offsetY _ aBinaryStream nextWord.	offsetX > 32767 ifTrue: [offsetX _ offsetX - 65536].	offsetY > 32767 ifTrue: [offsetY _ offsetY - 65536].	newForm _ Form extent: w @ h offset: offsetX @ offsetY.	theBits _ newForm bits.	pos _ 0.	1 to: w + 15 // 16 do: [:j |		1 to: h do: [:i |			theBits at: (pos _ pos+1) put: aBinaryStream nextWord]].	newForm bits: theBits.	^ newForm! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 2/24/2001 22:39'!replaceByResource: aForm	"Replace the receiver by some resource that just got loaded"	(self extent = aForm extent and:[self depth = aForm depth]) ifTrue:[		bits _ aForm bits.	].! !!Form methodsFor: 'fileIn/Out' stamp: 'nk 12/31/2003 16:06'!store15To24HexBitsOn:aStream	| buf i lineWidth |	"write data for 16-bit form, optimized for encoders writing directly to files to do one single file write rather than 12. I'm not sure I understand the significance of the shifting pattern, but I think I faithfully translated it from the original"	lineWidth _ 0.	buf _ String new: 12.	bits do: [:word | 		i _ 0.		"upper pixel"		buf at: (i _ i + 1) put: ((word bitShift: -27) bitAnd: 15) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -32) bitAnd: 8) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -22) bitAnd: 15) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -27) bitAnd: 8) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -17) bitAnd: 15) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -22) bitAnd: 8) asHexDigit.		"lower pixel"		buf at: (i _ i + 1) put: ((word bitShift: -11) bitAnd: 15) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -16) bitAnd: 8) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -6) bitAnd: 15) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -11) bitAnd: 8) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -1) bitAnd: 15) asHexDigit.		buf at: (i _ i + 1) put: ((word bitShift: -6) bitAnd: 8) asHexDigit.		aStream nextPutAll: buf.		lineWidth _ lineWidth + 12.		lineWidth > 100 ifTrue: [ aStream cr. lineWidth _ 0 ].		"#( 31 26 21 15 10 5 )  do:[:startBit | ]"	].! !!Form methodsFor: 'fileIn/Out'!store32To24HexBitsOn:aStream	^self storeBits:20 to:0 on:aStream.! !!Form methodsFor: 'fileIn/Out'!storeBits:startBit to:stopBit on:aStream	bits storeBits:startBit to:stopBit on:aStream.! !!Form methodsFor: 'fileIn/Out'!storeBitsOn:aStream base:anInteger	bits do: [:word | 		anInteger = 10			ifTrue: [aStream space]			ifFalse: [aStream crtab: 2].		word printOn: aStream base: anInteger].! !!Form methodsFor: 'fileIn/Out'!storeHexBitsOn:aStream	^self storeBits:28 to:0 on:aStream.! !!Form methodsFor: 'fileIn/Out'!storeOn: aStream	self storeOn: aStream base: 10! !!Form methodsFor: 'fileIn/Out'!storeOn: aStream base: anInteger 	"Store the receiver out as an expression that can be evaluated to recreate a Form with the same contents as the original."	self unhibernate.	aStream nextPut: $(.	aStream nextPutAll: self species name.	aStream crtab: 1.	aStream nextPutAll: 'extent: '.	self extent printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'depth: '.	self depth printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'fromArray: #('.	self storeBitsOn:aStream base:anInteger.	aStream nextPut: $).	aStream crtab: 1.	aStream nextPutAll: 'offset: '.	self offset printOn: aStream.	aStream nextPut: $).! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 15:50'!unhibernate	"If my bitmap has been compressed into a ByteArray,	then expand it now, and return true."	| resBits |	bits isForm ifTrue:[		resBits _ bits.		bits _ Bitmap new: self bitsSize.		resBits displayResourceFormOn: self.		^true].	bits == nil ifTrue:[bits _ Bitmap new: self bitsSize. ^true].	(bits isMemberOf: ByteArray)		ifTrue: [bits _ Bitmap decompressFromByteArray: bits. ^ true].	^ false! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:35'!writeAttributesOn: file	self unhibernate.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file nextWordPut: ((self offset x) >=0					ifTrue: [self offset x]					ifFalse: [self offset x + 65536]).	file nextWordPut: ((self offset y) >=0					ifTrue: [self offset y]					ifFalse: [self offset y + 65536]).	! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:35'!writeBitsOn: file	bits writeOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:36'!writeOn: file	"Write the receiver on the file in the format		depth, extent, offset, bits."	self writeAttributesOn: file.	self writeBitsOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'di 7/6/1998 23:00'!writeOnMovie: file	"Write just my bits on the file."	self unhibernate.	bits writeUncompressedOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'tk 2/19/1999 07:30'!writeUncompressedOn: file	"Write the receiver on the file in the format depth, extent, offset, bits.  Warning:  Caller must put header info on file!!  Use writeUncompressedOnFileNamed: instead."	self unhibernate.	file binary.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file nextWordPut: ((self offset x) >=0					ifTrue: [self offset x]					ifFalse: [self offset x + 65536]).	file nextWordPut: ((self offset y) >=0					ifTrue: [self offset y]					ifFalse: [self offset y + 65536]).	bits writeUncompressedOn: file! !!Form methodsFor: 'filling' stamp: 'di 2/19/1999 07:07'!anyShapeFill	"Fill the interior of the outermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape:fillColor: to paint a solid color.  See also convexShapeFill:"	| shape |	"Draw a seed line around the edge and fill inward from the outside."	shape _ self findShapeAroundSeedBlock: [:f | f borderWidth: 1].	"Reverse so that this becomes solid in the middle"	shape _ shape reverse.	"Finally erase any bits from the original so the fill is only elsewhere"	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling'!bitPatternForDepth: suspectedDepth	"Only called when a Form is being used as a fillColor.  Use a Pattern or InfiniteForm instead for this purpose.	Interpret me as an array of (32/depth) Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary. 6/18/96 tk"	^ self! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!Form methodsFor: 'filling' stamp: 'di 10/17/2001 10:09'!eraseShape: bwForm	"use bwForm as a mask to clear all pixels where bwForm has 1's"	((BitBlt current destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:08'!fill: aRectangle rule: anInteger fillColor: aForm 	"Replace a rectangular area of the receiver with the pattern described by aForm 	according to the rule anInteger."	(BitBlt current toForm: self)		copy: aRectangle		from: 0@0 in: nil		fillColor: aForm rule: anInteger! !!Form methodsFor: 'filling'!fillFromXColorBlock: colorBlock	"Horizontal Gradient Fill.	Supply relative x in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| xRel |	0 to: width-1 do:		[:x |  xRel _ x asFloat / (width-1) asFloat.		self fill: (x@0 extent: 1@height) 			fillColor: (colorBlock value: xRel)]"((Form extent: 100@100 depth: Display depth)	fillFromXColorBlock: [:x | Color r: x g: 0.0 b: 0.5]) display"! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!fillFromXYColorBlock: colorBlock	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker _ BitBlt current bitPokerToForm: self.	0 to: height-1 do:		[:y | yRel _ y asFloat / (height-1) asFloat.		0 to: width-1 do:			[:x |  xRel _ x asFloat / (width-1) asFloat.			poker pixelAt: x@y				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: self depth)]]" | d |((Form extent: 100@20 depth: Display depth)	fillFromXYColorBlock:	[:x :y | d _ 1.0 - (x - 0.5) abs - (y - 0.5) abs.	Color r: d g: 0 b: 1.0-d]) display"! !!Form methodsFor: 'filling'!fillFromYColorBlock: colorBlock	"Vertical Gradient Fill.	Supply relative y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| yRel |	0 to: height-1 do:		[:y |  yRel _ y asFloat / (height-1) asFloat.		self fill: (0@y extent: width@1) 			fillColor: (colorBlock value: yRel)]"((Form extent: 100@100 depth: Display depth)	fillFromYColorBlock: [:y | Color r: y g: 0.0 b: 0.5]) display"! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all _ self boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"	previousSmear _ smearForm deepCopy.	count _ 1.	[count = 10 and:   "check for no change every 10 smears"		[count _ 1.		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1@0 rule: Form under.			smearPort copyForm: smearForm to: -1@0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			smearPort copyForm: smearForm to: 0@1 rule: Form under.			smearPort copyForm: smearForm to: 0@-1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			count _ count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'filling' stamp: 'ar 5/14/2001 23:46'!floodFill2: aColor at: interiorPoint	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE: This is a less optimized variant for flood filling which is precisely along the lines of Heckbert's algorithm. For almost all cases #floodFill:at: will be faster (see the comment there) but this method is left in both as reference and as a fallback if such a strange case is encountered in reality."	| peeker poker stack old new x y top x1 x2 dy left goRight |	peeker _ BitBlt current bitPeekerFromForm: self.	poker _ BitBlt current bitPokerToForm: self.	stack _ OrderedCollection new: 50.	"read old pixel value"	old _ peeker pixelAt: interiorPoint.	"compute new value"	new _ self pixelValueFor: aColor.	old = new ifTrue:[^self]. "no point, is there?!!"	x _ interiorPoint x.	y _ interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		top _ stack removeLast.		y _ top at: 1. x1 _ top at: 2. x2 _ top at: 3. dy _ top at: 4.		y _ y + dy.		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		x _ x1.		[x >= 0 and:[(peeker pixelAt: x@y) = old]] whileTrue:[			poker pixelAt: x@y put: new.			x _ x - 1].		goRight _ x < x1.		left _ x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x _ x1 + 1].		[			goRight ifTrue:[				[x < width and:[(peeker pixelAt: x@y) = old]] whileTrue:[					poker pixelAt: x@y put: new.					x _ x + 1].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x _ x + 1) <= x2 and:[(peeker pixelAt: x@y) ~= old]] whileTrue.			left _ x.			goRight _ true.		x <= x2] whileTrue.	].! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 10:09'!floodFillMapFrom: sourceForm to: scanlineForm mappingColorsWithin: dist to: centerPixVal	"This is a helper routine for floodFill.  It's written for clarity (scanning the entire	map using colors) rather than speed (which would require hacking rgb components	in the nieghborhood of centerPixVal.  Note that some day a better proximity metric	would be (h s v) where tolerance could be reduced in hue."	| colorMap centerColor |	scanlineForm depth = 32 ifFalse: [self error: 'depth 32 assumed'].	"First get a modifiable identity map"	colorMap _ 	(Color cachedColormapFrom: sourceForm depth to: scanlineForm depth) copy.	centerColor _ Color colorFromPixelValue: (centerPixVal bitOr: 16rFFe6) depth: scanlineForm depth.	"Now replace all entries that are close to the centerColor"	1 to: colorMap size do:		[:i | ((Color colorFromPixelValue: ((colorMap at: i) bitOr: 16rFFe6) depth: scanlineForm depth)				diff: centerColor) <= dist ifTrue: [colorMap at: i put: centerPixVal]].	^ colorMap! !!Form methodsFor: 'filling' stamp: 'di 10/17/2001 10:10'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	self depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."		"bwForm _ self makeBWForm: interiorColor."	"won't work for two whites"	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (self depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ self depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: self depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	self eraseShape: bwForm.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!shapeFill: aColor seedBlock: seedBlock	self depth > 1 ifTrue: [self error: 'This call only meaningful for B/W forms'].	(self findShapeAroundSeedBlock: seedBlock)		displayOn: self at: 0@0 clippingBox: self boundingBox		rule: Form under fillColor: aColor ! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:40'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	self depth = 32		ifTrue: [cm _ (Color  cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm _ Bitmap new: (1 bitShift: (self depth min: 15)).				1 to: cm size do: [:i | cm at: i put: i - 1]].	newInd _ newColor pixelValueForDepth: self depth.	cm at: (oldColor pixelValueForDepth: (self depth min: 16))+1 put: newInd.	target _ newColor isTransparent 		ifTrue: [ff _ Form extent: self extent depth: depth.			ff fillWithColor: newColor.  ff]		ifFalse: [self].	(BitBlt current toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!smear: dir distance: dist	"Smear any black pixels in this form in the direction dir in Log N steps"	| skew bb |	bb _ BitBlt current destForm: self sourceForm: self fillColor: nil		combinationRule: Form under destOrigin: 0@0 sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox.	skew _ 1.	[skew < dist] whileTrue:		[bb destOrigin: dir*skew; copyBits.		skew _ skew+skew]! !!Form methodsFor: 'image manipulation' stamp: 'jm 6/30/1999 15:36'!trimBordersOfColor: aColor	"Answer a copy of this Form with each edge trimmed in to the first pixel that is not of the given color. (That is, border strips of the given color are removed)."	| r |	r _ self rectangleEnclosingPixelsNotOfColor: aColor.	^ self copy: r! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/17/2001 22:54'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver and can be used for accelerated blts"	^Form extent: extentPoint depth: self nativeDepth! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:46'!finish	"If there are any pending operations on the receiver complete them. Do not return before all modifications have taken effect."! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:45'!flush	"If there are any pending operations on the receiver start doing them. In time, they will show up on the receiver but not necessarily immediately after this method returns."! !!Form methodsFor: 'initialize-release'!fromDisplay: aRectangle 	"Create a virtual bit map from a user specified rectangular area on the 	display screen. Reallocates bitmap only if aRectangle ~= the receiver's 	extent."	(width = aRectangle width and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	self		copyBits: (aRectangle origin extent: self extent)		from: Display		at: 0 @ 0		clippingBox: self boundingBox		rule: Form over		fillColor: nil! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 18:45'!shutDown	"The system is going down. Try to preserve some space"	self hibernate! !!Form methodsFor: 'initialize-release' stamp: 'ar 6/16/2002 18:39'!swapEndianness	"Swap from big to little endian pixels and vice versa"	depth := 0 - depth.! !!Form methodsFor: 'other' stamp: 'ar 12/12/2003 18:24'!fixAlpha	"Fix the alpha channel if the receiver is 32bit"	| bb |	self depth = 32 ifFalse:[^self].	bb := BitBlt toForm: self.	bb combinationRule: 40 "fixAlpha:with:".	bb copyBits.! !!Form methodsFor: 'other' stamp: 'jm 9/27/97 21:02'!formForColorCount: colorCount	"Return a ColorForm of sufficient depth to represent the given number of colors. The maximum number of colors is 256."	colorCount > 256 ifTrue: [^ self error: 'too many colors'].	colorCount > 16 ifTrue: [^ ColorForm extent: self extent depth: 8].	colorCount > 4 ifTrue: [^ ColorForm extent: self extent depth: 4].	colorCount > 2 ifTrue: [^ ColorForm extent: self extent depth: 2].	^ ColorForm extent: self extent depth: 1! !!Form methodsFor: 'other' stamp: 'sw 5/3/2001 16:23'!graphicForViewerTab	"Answer the graphic to be used in the tab of a viewer open on me"	^ self! !!Form methodsFor: 'other' stamp: 'jm 1/6/98 10:37'!primPrintHScale: hScale vScale: vScale landscape: aBoolean	"On platforms that support it, this primitive prints the receiver, assumed to be a Form, to the default printer."	"(Form extent: 10@10) primPrintHScale: 1.0 vScale: 1.0 landscape: true"	<primitive: 232>	self primitiveFailed! !!Form methodsFor: 'other' stamp: 'RAA 1/30/2002 16:42'!relativeTextAnchorPosition	^nil		"so forms can be in TextAnchors"! !!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42'!colorAt: aPoint	"Return the color in the pixel at the given point.  "	^ Color 		colorFromPixelValue: (self pixelValueAt: aPoint)		depth: self depth! !!Form methodsFor: 'pixel access' stamp: 'ar 5/14/2001 23:46'!colorAt: aPoint put: aColor	"Store a Color into the pixel at coordinate aPoint.  "	self pixelValueAt: aPoint put: (self pixelValueFor: aColor)."[Sensor anyButtonPressed] whileFalse:	[Display colorAt: Sensor cursorPoint put: Color red]"! !!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:39'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	self depth = 1 ifTrue: [^ false].  "no transparency at depth 1"	^ (self pixelValueAt: aPoint) = (self pixelValueFor: Color transparent)! !!Form methodsFor: 'pixel access' stamp: 'ar 5/28/2000 12:08'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. This pixel value depends on the receiver's depth. Typical clients use colorAt: to get a Color.  "	^ (BitBlt current bitPeekerFromForm: self) pixelAt: aPoint! !!Form methodsFor: 'pixel access' stamp: 'ar 5/28/2000 12:08'!pixelValueAt: aPoint put: pixelValue	"Store the given raw pixel value at the given point. Typical clients use colorAt:put: to store a color. "	(BitBlt current bitPokerToForm: self) pixelAt: aPoint put: pixelValue.! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:36'!bitsPerComponent	^self depth <= 8 ifTrue:[self depth] ifFalse:[8].! !!Form methodsFor: 'postscript generation' stamp: 'mpw 11/14/1999 22:22'!bytesPerRow	^ self numComponents * self paddedWidth * self bitsPerComponent / 8.! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:39'!decodeArray	^self depth <= 8 ifTrue:['[1 0]'] ifFalse:['[0 1 0 1 0 1 ]'].! !!Form methodsFor: 'postscript generation' stamp: 'RAA 4/20/2001 15:40'!encodePostscriptOn: aStream 	self unhibernate.	"since current Postscript support treats 8-bit forms as 0 to 255 gray scale, convert	to 16 first so we get more faithful results"	self depth <= 8 ifTrue: [^(self asFormOfDepth: 16) encodePostscriptOn: aStream].	^ self printPostscript: aStream operator: (self depth = 1			ifTrue: ['imagemask']			ifFalse: ['image'])! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:43'!numComponents	^self depth <= 8 ifTrue:[1] ifFalse:[3].! !!Form methodsFor: 'postscript generation'!paddedWidth	^ (self width + (self rowPadding-1)// self rowPadding) * self rowPadding.! !!Form methodsFor: 'postscript generation' stamp: 'nk 12/31/2003 15:46'!printPostscript: aStream operator: operator 	aStream preserveStateDuring: 			[:inner | 			inner rectclip: (0 @ 0 extent: width @ height).			self setColorspaceOn: inner.			inner				print: '[ ';				cr;				print: '/ImageType 1';				cr;				print: '/ImageMatrix [1 0 0 1 0 0]';				cr;				print: '/MultipleDataSources false';				cr;				print: '/DataSource level1 { { currentfile ';				write: self bytesPerRow;				print: ' string readhexstring pop }} bind { currentfile /ASCIIHexDecode filter } ifelse';				cr;				print: '/Width ';				write: self paddedWidth;				cr;				print: '/Height ';				write: self height;				cr;				print: '/Decode ';				print: self decodeArray;				cr;				print: '/BitsPerComponent ';				write: self bitsPerComponent;				cr;				print: 'makeDict ';				print: operator;				cr.			self storePostscriptHexOn: inner.			inner				print: $>;				cr.			inner cr].	aStream cr! !!Form methodsFor: 'postscript generation' stamp: 'mpw 11/15/1999 08:34'!rowPadding	^ 32 // self depth! !!Form methodsFor: 'postscript generation'!setColorspaceOn:aStream	self numComponents = 1 ifTrue:[aStream print:'/DeviceGray setcolorspace 0 setgray'; cr.]		ifFalse:[aStream print:'/DeviceRGB setcolorspace'; cr.].! !!Form methodsFor: 'postscript generation' stamp: 'nk 12/31/2003 15:46'!storePostscriptHexOn: inner 	self depth <= 8 ifTrue: [self storeHexBitsOn: inner].	self depth = 16 ifTrue: [self store15To24HexBitsOn: inner].	self depth = 32 ifTrue: [self store32To24HexBitsOn: inner]! !!Form methodsFor: 'resources' stamp: 'ar 12/9/2002 16:04'!readNativeResourceFrom: byteStream	| img aStream |	(byteStream isKindOf: FileStream) ifTrue:[		"Ugly, but ImageReadWriter will send #reset which is implemented as #reopen and we may not be able to do so."		aStream _ RWBinaryOrTextStream with: byteStream contents.	] ifFalse:[		aStream _ byteStream.	].	img _ [ImageReadWriter formFromStream: aStream] on: Error do:[:ex| nil].	img ifNil:[^nil].	(img isColorForm and:[self isColorForm]) ifTrue:[		| cc |		cc := img colors.		img colors: nil.		img displayOn: self.		img colors: cc.	] ifFalse:[		img displayOn: self.	].	img _ nil.! !!Form methodsFor: 'resources' stamp: 'sd 6/28/2003 09:48'!readResourceFrom: aStream	"Store a resource representation of the receiver on aStream.	Must be specific to the receiver so that no code is filed out."	| bitsSize msb |	(aStream next: 4) asString = self resourceTag 		ifFalse:[	aStream position: aStream position - 4.				^self readNativeResourceFrom: aStream].	width _ aStream nextNumber: 4.	height _ aStream nextNumber: 4.	depth _ aStream nextNumber: 4.	bitsSize _ aStream nextNumber: 4.	bitsSize = 0 ifFalse:[		bits _ aStream next: bitsSize.		^self].	msb _ (aStream nextNumber: 4) = 1.	bitsSize _ aStream nextNumber: 4.	bits _ Bitmap new: self bitsSize.	(Form extent: width@height depth: depth bits: (aStream next: bitsSize * 4))		displayOn: self.	msb = Smalltalk isBigEndian ifFalse:[		Bitmap swapBytesIn: bits from: 1 to: bits size.	].! !!Form methodsFor: 'resources' stamp: 'ar 2/27/2001 14:56'!resourceTag	^'FORM'! !!Form methodsFor: 'resources' stamp: 'sd 9/30/2003 13:41'!storeResourceOn: aStream	"Store a resource representation of the receiver on aStream.	Must be specific to the receiver so that no code is filed out."	self hibernate.	aStream nextPutAll: self resourceTag asByteArray. "tag"	aStream nextNumber: 4 put: width.	aStream nextNumber: 4 put: height.	aStream nextNumber: 4 put: depth.	(bits isMemberOf: ByteArray) ifFalse:[		"must store bitmap"		aStream nextNumber: 4 put: 0. "tag"		aStream nextNumber: 4 put: (SmalltalkImage current  isBigEndian ifTrue:[1] ifFalse:[0]).	].	aStream nextNumber: 4 put: bits size.	aStream nextPutAll: bits.! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/14/2001 23:33'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ self class extent: self extent depth: depth.	quad _ self boundingBox innerCorners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededFor: newForm);		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation'!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f magnify: f boundingBox by: 5@3.	(f2 shrink: f2 boundingBox by: 5@3) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/14/2001 23:33'!magnify: aRectangle by: scale smoothing: cellSize        "Answer a Form created as a scaling of the receiver.        Scale may be a Float, and may be greater or less than 1.0."        | newForm |        newForm _ self blankCopyOf: aRectangle scaledBy: scale.        (WarpBlt current toForm: newForm)                sourceForm: self;                colorMap: (self colormapIfNeededFor: newForm);                cellSize: cellSize;  "installs a new colormap if cellSize > 1"                combinationRule: 3;                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.        ^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:        [(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:        [cp _ Sensor cursorPoint.        (f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation' stamp: 'di 8/17/1998 22:17'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: self boundingBox by: scale			smoothing: (scale < 1 ifTrue: [2] ifFalse: [1])! !!Form methodsFor: 'scaling, rotation'!rotateBy: deg	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5)) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/14/2001 23:33'!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #none, #right, #left, or #pi"	| newForm quad rot |	direction == #none ifTrue: [^ self].	newForm _ self class extent: (direction = #pi ifTrue: [width@height]											ifFalse: [height@width]) depth: depth.	quad _ self boundingBox innerCorners.	rot _ #(right pi left) indexOf: direction.	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededFor: newForm);		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/14/2001 23:33'!rotateBy: deg magnify: scale smoothing: cellSize	"Rotate the receiver by the indicated number of degrees and magnify.  "	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts p bigSide |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	bigSide _ (side * scale) rounded.	rot _ Form extent: bigSide@bigSide depth: self depth.	warp _ (WarpBlt current toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededFor: rot);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint.	r1 _ (0@0 extent: side@side) align: (side@side)//2 with: self boundingBox center.	"Rotate the corners of the source rectangle." 	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) magnify: 0.75 smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/14/2001 23:34'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt current toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededFor: rot);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'RAA 7/13/2000 12:09'!scaledToSize: newExtent	| scale |	newExtent = self extent ifTrue: [^self].	scale _ newExtent x / self width min: newExtent y / self height.	^self magnify: self boundingBox by: scale smoothing: 2.! !!Form methodsFor: 'scaling, rotation'!shrink: aRectangle by: scale 	| scalePt |	scalePt _ scale asPoint.	^ self magnify: aRectangle by: (1.0 / scalePt x asFloat) @ (1.0 / scalePt y asFloat)! !!Form methodsFor: 'testing' stamp: 'RAA 1/19/2001 15:04'!appearsToBeSameCostumeAs: anotherForm	(anotherForm isKindOf: self class) ifFalse: [^false].	anotherForm depth = self depth ifFalse: [^false].	^anotherForm bits = bits! !!Form methodsFor: 'testing' stamp: 'ar 5/15/2001 16:14'!hasNonStandardPalette	"Return true if the receiver has a non-standard palette.	Non-standard means that RGBA components may be located	at positions differing from the standard Squeak RGBA layout	at the receiver's depth."	^false! !!Form methodsFor: 'testing' stamp: 'di 3/2/98 12:42'!isAllWhite	"Answer whether all bits in the receiver are white (=0)."	self unhibernate.	1 to: bits size do: [:i | (bits at: i) = 0 ifFalse: [^ false]].	^ true! !!Form methodsFor: 'testing' stamp: 'ar 5/17/2001 15:46'!isBigEndian	"Return true if the receiver contains big endian pixels, meaning the left-most pixel is stored in the most significant bits of a word."	^depth > 0! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 14:58'!isBltAccelerated: ruleInteger for: sourceForm	"Return true if the receiver can perform accelerated blts operations by itself"	^false! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 15:04'!isDisplayScreen	^false! !!Form methodsFor: 'testing' stamp: 'ar 5/27/2000 16:54'!isExternalForm	^false! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 14:58'!isFillAccelerated: ruleInteger for: aColor	"Return true if the receiver can perform accelerated fill operations by itself"	^false! !!Form methodsFor: 'testing' stamp: 'ar 10/30/2000 23:23'!isForm	^true! !!Form methodsFor: 'testing' stamp: 'ar 5/17/2001 15:47'!isLittleEndian	"Return true if the receiver contains little endian pixels, meaning the left-most pixel is stored in the least significant bits of a word."	^depth < 0! !!Form methodsFor: 'testing' stamp: 'RAA 8/14/2000 10:00'!isStatic	^false! !!Form methodsFor: 'testing' stamp: 'ar 2/10/2004 17:18'!isTranslucent	"Answer whether this form may be translucent"	^self depth = 32! !!Form methodsFor: 'testing' stamp: 'ar 5/28/2000 14:58'!shouldPreserveContents	"Return true if the receiver should preserve it's contents when flagged to be clean. Most forms can not be trivially restored by some drawing operation but some may."	^true! !!Form methodsFor: 'transitions' stamp: 'jm 5/21/1998 23:46'!fadeImage: otherImage at: topLeft	indexAndMaskDo: indexAndMaskBlock	"This fade uses halftones as a blending hack.	Zeros in the halftone produce the original image (self), and 	ones in the halftone produce the 'otherImage'.	IndexAndMaskBlock gets evaluated prior to each cycle,	and the resulting boolean determines whether to continue cycling."	| index imageRect maskForm resultForm |	imageRect _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: imageRect extent).	maskForm _ Form extent: 32@32.	index _ 0.	[indexAndMaskBlock value: (index _ index+1) value: maskForm]	whileTrue:		[maskForm reverse.		resultForm copyBits: imageRect from: resultForm at: 0@0			clippingBox: imageRect rule: Form over fillColor: maskForm.		maskForm reverse.		resultForm copyBits: imageRect from: otherImage at: 0@0			clippingBox: imageRect rule: Form under fillColor: maskForm.		self copyBits: imageRect from: resultForm at: topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:42'!fadeImageCoarse: otherImage at: topLeft	"Display fadeImageCoarse: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| pix j d |	d _ self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		i=1 ifTrue: [pix _ (1 bitShift: d) - 1.					1 to: 8//d-1 do: [:q | pix _ pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[j _ i-1//4+1.		(0 to: 28 by: 4) do: [:k |			mask bits at: j+k				put: ((mask bits at: j+k) bitOr: (pix bitShift: i-1\\4*d))].		"mask display." true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:41'!fadeImageFine: otherImage at: topLeft	"Display fadeImageFine: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| pix j ii d |	d _ self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		i=1 ifTrue: [pix _ (1 bitShift: d) - 1.					1 to: 8//d-1 do:						[:q | pix _ pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[ii _ #(0 10 2 8 7 13 5 15 1 11 3 9 6 12 4 14) at: i.		j _ ii//4+1.		(0 to: 28 by: 4) do:			[:k | mask bits at: j+k put:				((mask bits at: j+k) bitOr: (pix bitShift: ii\\4*d))].		true]		ifFalse: [false]]! !!Form methodsFor: 'transitions'!fadeImageHor: otherImage at: topLeft	"Display fadeImageHor: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: (0@(mask height//2-i) extent: mask width@(i*2)) fillColor: Color black.		(i*2) <= mask width]! !!Form methodsFor: 'transitions'!fadeImageHorFine: otherImage at: topLeft	"Display fadeImageHorFine: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: (0@(i-1) extent: mask width@1) fillColor: Color black.		mask fill: (0@(i-1+16) extent: mask width@1) fillColor: Color black.		(i*2) <= mask width]! !!Form methodsFor: 'transitions'!fadeImageSquares: otherImage at: topLeft 	"Display fadeImageSquares: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((16-i) asPoint extent: (i*2) asPoint) fillColor: Color black.		i <= 16]! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:39'!fadeImageVert: otherImage at: topLeft	"Display fadeImageVert: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	| d |	d _ self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((mask width//2//d-i*d)@0 extent: i*2*d@mask height) fillColor: Color black.		i <= (mask width//d)]! !!Form methodsFor: 'transitions' stamp: 'jm 6/1/1998 10:55'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'ar 5/28/2000 12:12'!pageWarp: otherImage at: topLeft forward: forward	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.	forward == true means turn pages toward you, else away. [ignored for now]"	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |	pageRect _ otherImage boundingBox.	oldPage _ self copy: (pageRect translateBy: topLeft).	(forward ifTrue: [oldPage] ifFalse: [otherImage])		border: pageRect		widthRectangle: (Rectangle				left: 0				right: 2				top: 1				bottom: 1)		rule: Form over		fillColor: Color black.	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).	nSteps _ 8.	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.	1 to: nSteps-1 do:		[:i | forward			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * i // nSteps)]			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).		sourceQuad _ Array with: pageRect topLeft			with: pageRect bottomLeft + (0@p y)			with: pageRect bottomRight			with: pageRect topRight - (0@p y).		warp _ (WarpBlt current toForm: buffer)				clipRect: leafRect;				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);				combinationRule: Form paint.		warp copyQuad: sourceQuad toRect: leafRect.		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.		Display forceDisplayUpdate].	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.	Display forceDisplayUpdate."1 to: 4 do: [:corner | Display pageWarp:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 forward: false]"! !!Form methodsFor: 'transitions' stamp: 'jm 5/21/1998 23:46'!slideImage: otherImage at: topLeft delta: delta	"Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse		at: 40@40 delta: 3@-4"	| bb nSteps clipRect |	bb _ otherImage boundingBox.	clipRect _ topLeft extent: otherImage extent.	nSteps _ 1.	delta x = 0 ifFalse: [nSteps _ nSteps max: (bb width//delta x abs) + 1].	delta y = 0 ifFalse: [nSteps _ nSteps max: (bb height//delta y abs) + 1].	1 to: nSteps do:			[:i | self copyBits: bb from: otherImage				at: delta*(i-nSteps) + topLeft				clippingBox: clipRect rule: Form paint fillColor: nil.			Display forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[rectOrList _ rectForIndexBlock value: (i _ i + 1).	 rectOrList == nil]		whileFalse: [			t _ Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime _ 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:21'!wipeImage: otherImage at: topLeft delta: delta	"Display wipeImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse		at: 40@40 delta: 0@-2"	self wipeImage: otherImage at: topLeft delta: delta clippingBox: nil.! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:17'!wipeImage: otherImage at: topLeft delta: delta clippingBox: clipBox	| wipeRect bb nSteps |	bb _ otherImage boundingBox.	wipeRect _ delta x = 0		ifTrue:		[delta y = 0 ifTrue: [nSteps _ 1. bb "allow 0@0"] ifFalse: [		nSteps _ bb height//delta y abs + 1.  "Vertical movement"		delta y > 0			ifTrue: [bb topLeft extent: bb width@delta y]			ifFalse: [bb bottomLeft+delta extent: bb width@delta y negated]]]		ifFalse:		[nSteps _ bb width//delta x abs + 1.  "Horizontal movement"		delta x > 0			ifTrue: [bb topLeft extent: delta x@bb height]			ifFalse: [bb topRight+delta extent: delta x negated@bb height]].	^ self wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex:		[:i | i <= nSteps			ifTrue: [wipeRect translateBy: (delta* (i-1))]			ifFalse: [nil]]! !!Form methodsFor: 'transitions' stamp: 'di 1/28/1999 09:20'!zoomIn: goingIn orOutTo: otherImage at: topLeft vanishingPoint: vp 	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40.	Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40."	| nSteps j bigR lilR minTime startTime lead |	nSteps _ 16.	minTime _ 500.  "milliseconds"	startTime _ Time millisecondClockValue.	^ self wipeImage: otherImage at: topLeft clippingBox: nil rectForIndex:		[:i | "i runs from 1 to nsteps"		i > nSteps			ifTrue: [nil "indicates all done"]			ifFalse:			["If we are going too fast, delay for a bit"			lead _ startTime + (i-1*minTime//nSteps) - Time millisecondClockValue.			lead > 10 ifTrue: [(Delay forMilliseconds: lead) wait].			"Return an array with the difference rectangles for this step."			j _ goingIn ifTrue: [i] ifFalse: [nSteps+1-i].			bigR _ vp - (vp*(j)//nSteps) corner:				vp + (otherImage extent-vp*(j)//nSteps).			lilR _ vp - (vp*(j-1)//nSteps) corner:				vp + (otherImage extent-vp*(j-1)//nSteps).			bigR areasOutside: lilR]]! !!Form methodsFor: 'transitions' stamp: 'di 3/2/98 09:14'!zoomInTo: otherImage at: topLeft	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self zoomIn: true orOutTo: otherImage at: topLeft		vanishingPoint: otherImage extent//2+topLeft! !!Form methodsFor: 'transitions' stamp: 'di 3/2/98 09:15'!zoomOutTo: otherImage at: topLeft	"Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self zoomIn: false orOutTo: otherImage at: topLeft		vanishingPoint: otherImage extent//2+topLeft! !!Form methodsFor: 'private' stamp: 'tk 3/13/2000 15:21'!hackBits: bitThing	"This method provides an initialization so that BitBlt may be used, eg, to 	copy ByteArrays and other non-pointer objects efficiently.	The resulting form looks 4 wide, 8 deep, and bitThing-size-in-words high."	width _ 4.	depth _ 8.	bitThing class isBits ifFalse: [self error: 'bitThing must be a non-pointer object'].	bitThing class isBytes		ifTrue: [height _ bitThing basicSize // 4]		ifFalse: [height _ bitThing basicSize].	bits _ bitThing! !!Form methodsFor: 'private'!initFromArray: array	"Fill the bitmap from array.  If the array is shorter,	then cycle around in its contents until the bitmap is filled."	| ax aSize array32 i j word16 |	ax _ 0.	aSize _ array size.	aSize > bits size ifTrue:		["backward compatibility with old 16-bit bitmaps and their forms"		array32 _ Array new: height * (width + 31 // 32).		i _ j _ 0.		1 to: height do:			[:y | 1 to: width+15//16 do:				[:x16 | word16 _ array at: (i _ i + 1).				x16 odd ifTrue: [array32 at: (j _ j+1) put: (word16 bitShift: 16)]						ifFalse: [array32 at: j put: ((array32 at: j) bitOr: word16)]]].		^ self initFromArray: array32].	1 to: bits size do:		[:index |		(ax _ ax + 1) > aSize ifTrue: [ax _ 1].		bits at: index put: (array at: ax)]! !!Form methodsFor: 'private' stamp: 'ar 12/19/2000 16:23'!privateFloodFillValue: aColor	"Private. Compute the pixel value in the receiver's depth but take into account implicit color conversions by BitBlt."	| f1 f2 bb |	f1 _ Form extent: 1@1 depth: depth.	f2 _ Form extent: 1@1 depth: 32.	bb _ BitBlt toForm: f1.	bb fillColor: aColor; 		destRect: (0@0 corner: 1@1); 		combinationRule: 3; 		copyBits.	bb _ BitBlt toForm: f2.	bb sourceForm: f1; 		sourceOrigin: 0@0;		destRect: (0@0 corner: 1@1);		combinationRule: 3;		copyBits.	^f2 pixelValueAt: 0@0.! !!Form methodsFor: 'private' stamp: '6/9/97 16:10 di'!setExtent: extent depth: bitsPerPixel	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	bits _ Bitmap new: self bitsSize! !!Form methodsFor: 'private' stamp: 'ar 5/28/2000 15:49'!setExtent: extent depth: bitsPerPixel bits: bitmap	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	(bits isNil or:[self bitsSize = bitmap size]) ifFalse:[^self error:'Bad dimensions'].	bits _ bitmap! !!Form methodsFor: 'private' stamp: 'ar 10/30/2000 23:22'!setResourceBits: aForm	"Private. Really. Used for setting the 'resource bits' when externalizing some form"	bits _ aForm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Form class	instanceVariableNames: ''!!Form class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:07'!dotOfSize: diameter	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius _ diameter//2.	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).		bb _ (BitBlt current toForm: form)		sourceX: 0; sourceY: 0;		combinationRule: Form over;		fillColor: Color black.	rect _ form boundingBox.	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		bb	destX: centerX - centerXBias - dx			destY: centerY - centerYBias - dy			width: dx + dx + centerXBias + 1			height: 1;			copyBits.		bb	destY: centerY + dy;			copyBits].	^ form"Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]"! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:27'!extent: extentPoint	"Answer an instance of me with a blank bitmap of depth 1."	^ self extent: extentPoint depth: 1! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:36'!extent: extentPoint depth: bitsPerPixel	"Answer an instance of me with blank bitmap of the given dimensions and depth."	^ self basicNew setExtent: extentPoint depth: bitsPerPixel! !!Form class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 23:44'!extent: extentPoint depth: bitsPerPixel bits: aBitmap	"Answer an instance of me with blank bitmap of the given dimensions and depth."	^ self basicNew setExtent: extentPoint depth: bitsPerPixel bits: aBitmap! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:35'!extent: extentPoint depth: bitsPerPixel fromArray: anArray offset: offsetPoint 	"Answer an instance of me with a pixmap of the given depth initialized from anArray."	^ (self extent: extentPoint depth: bitsPerPixel)		offset: offsetPoint;		initFromArray: anArray! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:33'!extent: extentPoint fromArray: anArray offset: offsetPoint 	"Answer an instance of me of depth 1 with bitmap initialized from anArray."	^ (self extent: extentPoint depth: 1)		offset: offsetPoint;		initFromArray: anArray! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:28'!extent: extentPoint fromStipple: fourNibbles	"Answer an instance of me with bitmap initialized from	a repeating 4x4 bit stipple encoded in a 16-bit constant."	| nibble |	^ (self extent: extentPoint depth: 1)		initFromArray: ((1 to: 4) collect:				[:i | nibble _ (fourNibbles bitShift: -4*(4-i)) bitAnd: 16rF.				16r11111111 * nibble])  "fill 32 bits with each 4-bit nibble"! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:26'!extent: extentPoint offset: offsetPoint 	"Answer an instance of me with a blank bitmap of depth 1."	^ (self extent: extentPoint depth: 1) offset: offsetPoint! !!Form class methodsFor: 'instance creation' stamp: 'BG 11/11/2003 14:19'!fromBinaryStream: aBinaryStream	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."	| firstByte |	aBinaryStream binary.	firstByte _ aBinaryStream next.	firstByte = 1 ifTrue: [		"old Squeakform format"		^ self new readFromOldFormat: aBinaryStream].	firstByte = 2 ifTrue: [		"new Squeak form format"		^ self new readFrom: aBinaryStream].	"Try for JPG, GIF, or PCX..."	"Note: The following call closes the stream."  self halt."	^ ImageReadWriter formFromStream: aBinaryStream "! !!Form class methodsFor: 'instance creation'!fromDisplay: aRectangle 	"Answer an instance of me with bitmap initialized from the area of the 	display screen defined by aRectangle."	^ (self extent: aRectangle extent depth: Display depth)		fromDisplay: aRectangle! !!Form class methodsFor: 'instance creation'!fromDisplay: aRectangle using: oldForm	"Like fromDisplay: only if oldForm is the right size, copy into it and answer it instead."	((oldForm ~~ nil) and: [oldForm extent = aRectangle extent])		ifTrue:			[oldForm fromDisplay: aRectangle.			 ^ oldForm]		ifFalse:			[^ self fromDisplay: aRectangle]! !!Form class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:58'!fromFileNamed: fileName	"Read a Form or ColorForm from the given file."	| file form |	file _ (FileStream readOnlyFileNamed: fileName) binary.	form _ self fromBinaryStream: file.		file close.	^ form! !!Form class methodsFor: 'instance creation'!fromUser	"Answer an instance of me with bitmap initialized from the area of the 	display screen designated by the user. The grid for selecting an area is 	1@1."	^self fromUser: 1 @ 1! !!Form class methodsFor: 'instance creation'!fromUser: aPoint 	"Answer an instance of me with bitmap initialized from the area of the 	display screen designated by the user. The grid for selecting an area is 	aPoint."	^ self fromDisplay: (Rectangle fromUser: aPoint)! !!Form class methodsFor: 'instance creation' stamp: 'jm 12/5/97 19:32'!fromUserWithExtent: anExtent	"Answer an instance of me with bitmap initialized from the area of the 	display screen whose origin is designated by the user and whose size is anExtent"	^ self fromDisplay: (Rectangle originFromUser: anExtent)"(Form fromUserWithExtent: 50@50) displayAt: 10@10"! !!Form class methodsFor: 'mode constants'!and	"Answer the integer denoting the logical 'and' combination rule."	^1! !!Form class methodsFor: 'mode constants'!blend	"Answer the integer denoting BitBlt's alpha blend combination rule."	^24! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!blendAlpha	"Answer the integer denoting BitBlt's blend-with-constant-alpha rule."	^ 30! !!Form class methodsFor: 'mode constants'!erase	"Answer the integer denoting mode erase."	^4! !!Form class methodsFor: 'mode constants'!erase1bitShape	"Answer the integer denoting mode erase."	^ 26! !!Form class methodsFor: 'mode constants'!oldErase1bitShape	"Answer the integer denoting mode erase."	^ 17! !!Form class methodsFor: 'mode constants'!oldPaint	"Answer the integer denoting the 'paint' combination rule."	^16! !!Form class methodsFor: 'mode constants'!over	"Answer the integer denoting mode over."	^3! !!Form class methodsFor: 'mode constants'!paint	"Answer the integer denoting the 'paint' combination rule."	^25! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!paintAlpha	"Answer the integer denoting BitBlt's paint-with-constant-alpha rule."	^ 31! !!Form class methodsFor: 'mode constants'!reverse	"Answer the integer denoting mode reverse."	^6! !!Form class methodsFor: 'mode constants' stamp: 'hg 1/29/2001 17:28'!rgbMul	"Answer the integer denoting 'Multiply each color component, 	 their values regarded as fractions of 1' rule."	^ 37! !!Form class methodsFor: 'mode constants'!under	"Answer the integer denoting mode under."	^7! !!Form class methodsFor: 'examples'!exampleBorder    "Form exampleBorder"	"This example demonstrates the border finding algorithm. Start	by having the user sketch on the screen (end with option-click) and then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of the region to be	outlined, and the region begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.		"sketch a little area with an enclosed region"	r _ Rectangle fromUser.	f _ Form fromDisplay: r.	Cursor crossHair showWhile:		[interiorPoint _ Sensor waitButton - r origin].	Cursor execute showWhile:		[f shapeBorder: Color blue width: 2 interiorPoint: interiorPoint			sharpCorners: false internal: false].	f displayOn: Display at: r origin	! !!Form class methodsFor: 'examples'!exampleEdits	"In Form category editing are messages edit and bitEdit that make it possible to 	create editors on instances of Form. 	 	This is the general form editor:	| f | 	f _ Form fromUser. 	f edit. 	 	This is the general bit editor:	| f | 	f _ Form fromUser. 	f bitEdit."! !!Form class methodsFor: 'examples'!exampleMagnify	| f m |	f _ Form fromUser.	m _ f magnify: f boundingBox by: 5 @ 5.	m displayOn: Display at: Sensor waitButton	"Form exampleMagnify."! !!Form class methodsFor: 'examples'!exampleShrink	| f s |	f _ Form fromUser.	s _ f shrink: f boundingBox by: 2 @ 5.	s displayOn: Display at: Sensor waitButton		"Form exampleShrink."! !!Form class methodsFor: 'examples'!exampleSketch	"This is a simple drawing algorithm to get a sketch on the display screen.	Draws whenever mouse button down.  Ends with option-click."	| aPen color |	aPen _ Pen new.	color _ 0.	[Sensor yellowButtonPressed]		whileFalse:		[aPen place: Sensor cursorPoint; color: (color _ color + 1).		[Sensor redButtonPressed]			whileTrue: [aPen goto: Sensor cursorPoint]].	Sensor waitNoButton.	"Form exampleSketch"! !!Form class methodsFor: 'examples'!exampleSpaceFill    "Form exampleSpaceFill"	"This example demonstrates the area filling algorithm. Starts by having	the user sketch on the screen (ended by option-click) and then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of some region to be	filled, and the filling begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.		"sketch a little area with an enclosed region"	r _ Rectangle fromUser.	f _ Form fromDisplay: r.	Cursor crossHair showWhile:		[interiorPoint _ Sensor waitButton - r origin].	Cursor execute showWhile:		[f shapeFill: Color gray interiorPoint: interiorPoint].	f displayOn: Display at: r origin	! !!Form class methodsFor: 'examples'!makeStar  "See the similar example in OpaqueForm"	| sampleForm pen |	sampleForm _ Form extent: 50@50.  "Make a form"	pen _ Pen newOnForm: sampleForm.	pen place: 24@50; turn: 18.		"Draw a 5-pointed star on it."	1 to: 5 do: [:i | pen go: 19; turn: 72; go: 19; turn: -144].	^ sampleForm"Form makeStar follow: [Sensor cursorPoint]				while: [Sensor noButtonPressed]"! !!Form class methodsFor: 'examples' stamp: 'tk 7/4/2000 12:08'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors _ Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade _ Form extent: diam@diam offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball _ Form dotOfSize: diam.	color _ 8.	[ true ] whileTrue:		[port _ BitBlt current toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue _ OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ Sensor cursorPoint.		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"		colr2 _ colr alphaMixed: 0.3 with: Color white.		[Sensor redButtonPressed or: [queue size > 0]] whileTrue:			[filter _ filter * 4 + Sensor cursorPoint // 5.			point _ Sensor redButtonPressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q _ queue removeFirst) == nil ifTrue: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor redButtonPressed ifTrue: [queue addLast: point]]].! !!Form class methodsFor: 'examples'!xorHack: size  "Display restoreAfter: [Form xorHack: 256]"	"Draw a smiley face or stick figure, and end with option-click.	Thereafter image gets 'processed' as long as you have button down.	If you stop at just the right time, you'll see you figure upside down,	and at the end of a full cycle, you'll see it perfectly restored.	Dude -- this works in color too!!"	| rect form i bb |	rect _ 5@5 extent: size@size.	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	Display border: (rect topRight - (0@2) extent: rect extent*2 + 4) width: 2.	Form exampleSketch.	form _ Form fromDisplay: rect.	bb _ form boundingBox.	i _ 0.	[Sensor yellowButtonPressed] whileFalse:		[[Sensor redButtonPressed] whileTrue:			[i _ i + 1.			(Array with: 0@1 with: 0@-1 with: 1@0 with: -1@0) do:				[:d | form copyBits: bb from: form at: d					clippingBox: bb rule: Form reverse fillColor: nil].			form displayAt: rect topLeft.			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].		(form magnify: form boundingBox by: 2@2) displayAt: rect topRight + (2@0).		Sensor waitButton].! !!Form class methodsFor: 'shut down' stamp: 'ar 5/28/2000 23:35'!shutDown  "Form shutDown"	"Compress all instances in the system.  Will decompress on demand..."	Form allInstancesDo: [:f | f hibernate].	ColorForm allInstancesDo: [:f | f hibernate].! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 6/16/2002 17:41'!fromBMPFile: aBinaryStream	"Obsolete"	^self fromBinaryStream: aBinaryStream.! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 6/16/2002 17:41'!fromBMPFileNamed: fileName	"Obsolete"	^self fromFileNamed: fileName! !!Form class methodsFor: 'initialize-release' stamp: 'hg 8/3/2000 16:25'!initialize	FileList registerFileReader: self! !!Form class methodsFor: 'fileIn/Out' stamp: 'hg 8/3/2000 16:26'!openAsBackground: fullName	"Set an image as a background image.  Support Squeak's common file format 	(GIF, JPG, PNG, 'Form stoteOn: (run coded)' and BMP)"	(self fromFileNamed: fullName) setAsBackground! !!Form class methodsFor: 'fileIn/Out' stamp: 'BG 10/28/2003 20:58'!openImageInWindow: fullName	"Handle five file formats: GIF, JPG, PNG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream _ (FileStream readOnlyFileNamed: fullName) binary.	image _ self fromBinaryStream: myStream.	myStream close.		Smalltalk isMorphic		ifFalse: [FormView open: image named: fullName]! !!Form class methodsFor: 'fileIn/Out' stamp: 'sw 2/17/2002 01:38'!serviceImageAsBackground	"Answer a service for setting the desktop background from a given graphical file's contents"	^ SimpleServiceEntry 		provider: self 		label: 'use graphic as background'		selector: #openAsBackground:		description: 'use the graphic as the background for the desktop'		buttonLabel: 'background'! !!Form class methodsFor: 'fileIn/Out' stamp: 'sw 2/17/2002 00:31'!serviceOpenImageInWindow	"Answer a service for opening a graphic in a window"	^ SimpleServiceEntry 		provider: self 		label: 'open graphic in a window'		selector: #openImageInWindow:		description: 'open a graphic file in a window'		buttonLabel: 'open'! !!Form class methodsFor: 'class initialization' stamp: 'SD 11/15/2001 22:21'!unload	FileList unregisterFileReader: self ! !View subclass: #FormView	instanceVariableNames: 'rule mask'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Views'!!FormView commentStamp: '<historical>' prior: 0!I represent a view of a Form.!!FormView methodsFor: 'accessing'!fillColor	"Answer an instance of class Form that is the mask used when displaying 	the receiver's model (a Form) on the display screen (see BitBlt for the 	meaning of this mask)."	^ mask! !!FormView methodsFor: 'accessing'!fillColor: aForm 	"Set the display mask for displaying the receiver's model to be the 	argument, aForm."	mask _ aForm! !!FormView methodsFor: 'accessing'!mask	"Answer an instance of class Form that is the mask used when displaying 	the receiver's model (a Form) on the display screen (see BitBlt for the 	meaning of this mask)."	^ mask! !!FormView methodsFor: 'accessing'!rule	"Answer a number from 0 to 15 that indicates which of the sixteen 	display rules (logical function of two boolean values) is to be used when 	copying the receiver's model (a Form) onto the display screen."	rule == nil		ifTrue: [^self defaultRule]		ifFalse: [^rule]! !!FormView methodsFor: 'accessing'!rule: anInteger 	"Set the display rule for the receiver to be the argument, anInteger."	rule _ anInteger! !!FormView methodsFor: 'controller access' stamp: 'ssa 10/8/2008 13:14'!defaultControllerClass  ^ NoController! !!FormView methodsFor: 'model access'!changeValueAt: location put: anInteger	"The receiver's model is a form which has an array of bits. Change the 	bit at index, location, to be anInteger (either 1 or 0). Inform all objects 	that depend on the model that it has changed."	model pixelValueAt: location put: anInteger.	model changed: self! !!FormView methodsFor: 'window access'!defaultWindow 	"Refer to the comment in View|defaultWindow."	^(Rectangle origin: 0 @ 0 extent: model extent)		expandBy: borderWidth! !!FormView methodsFor: 'window access'!windowBox	"For comaptibility with Control manager (see senders)"	^ self insetDisplayBox! !!FormView methodsFor: 'displaying'!displayOn: aPort	model displayOnPort: aPort at: self displayBox origin! !!FormView methodsFor: 'displaying' stamp: 'hmm 7/21/97 20:45'!displayView 	"Refer to the comment in View|displayView."	| oldOffset |	super displayView.	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].	oldOffset _ model offset.	model offset: "borderWidth origin" 0@0.	model		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model offset: oldOffset! !!FormView methodsFor: 'displaying'!uncacheBits	"Placed vacuously here so that when ControlManager>>restore calls uncacheBits for a project with no windows, we don't hang.  1/24/96 sw"! !!FormView methodsFor: 'displaying'!updateDisplay	"overridden by subclass"! !!FormView methodsFor: 'updating'!update: aFormView 	"Refer to the comment in View|update:."	self == aFormView ifFalse: [self display]! !!FormView methodsFor: 'menu messages'!accept	"The receiver's model is set to the working version, the one in which 	edits are carried out."	^self! !!FormView methodsFor: 'menu messages'!cancel	"Set the working form to be a copy of the model."	^self! !!FormView methodsFor: 'private'!defaultRule 	"The default display rule is 3=over or storing."	^Form over! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FormView class	instanceVariableNames: ''!!FormView class methodsFor: 'examples'!exampleOne	"Frame a Form (specified by the user) with a border of 2 bits in width and display it offset 60 x 40 from the cornor of the display screen. "	| f view |	f _ Form fromUser.	view _ self new model: f.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleOne"! !!FormView class methodsFor: 'examples'!exampleTwo	"Frame a Form (specified by the user) that is scaled by 2. The border is 2 bits in width. Displays at location 60, 40."	| f view |	f _ Form fromUser.	view _ self new model: f.	view scaleBy: 2.0.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleTwo"! !!FormView class methodsFor: 'examples' stamp: 'BG 12/5/2003 14:45'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView _ StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: aForm extent;	          maximumSize: aForm extent.	aView _ FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !Number subclass: #Fraction	instanceVariableNames: 'numerator denominator'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Fraction commentStamp: '<historical>' prior: 0!Fraction provides methods for dealing with fractions like 1/3 as fractions (not as 0.33333...).  All public arithmetic operations answer reduced fractions (see examples).instance variables: 'numerator denominator 'Examples: (note the parentheses required to get the right answers in Smalltalk and Squeak):(2/3) + (2/3)(2/3) + (1/2)		 "answers shows the reduced fraction" (2/3) raisedToInteger: 5		 "fractions also can have exponents"!!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction ifTrue: 		[d1 _ numerator gcd: aNumber denominator.		d2 _ denominator gcd: aNumber numerator.		(d2 = denominator and: [d1 = aNumber denominator])			ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].		^ Fraction numerator: numerator // d1 * (aNumber numerator // d2)				denominator: denominator // d2 * (aNumber denominator // d1)].	^ aNumber adaptToFraction: self andSend: #*! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction ifTrue: 		[d _ denominator gcd: aNumber denominator.		n _ numerator * (d1 _ aNumber denominator // d) + (aNumber numerator * (d2 _ denominator // d)).		d1 _ d1 * d2.		n _ n // (d2 _ n gcd: d).		(d _ d1 * (d // d2)) = 1 ifTrue: [^ n].		^ Fraction numerator: n denominator: d].	^ aNumber adaptToFraction: self andSend: #+! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!- aNumber	"Answer the difference between the receiver and aNumber."	aNumber isFraction ifTrue:		[^ self + aNumber negated].	^ aNumber adaptToFraction: self andSend: #-! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!/ aNumber	"Answer the result of dividing the receiver by aNumber."	aNumber isFraction		ifTrue: [^self * aNumber reciprocal].	^ aNumber adaptToFraction: self andSend: #/! !!Fraction methodsFor: 'arithmetic'!negated 	"Refer to the comment in Number|negated."	^ Fraction		numerator: numerator negated		denominator: denominator! !!Fraction methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	"Refer to the comment in Number|reciprocal."	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	numerator = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	numerator = 1 ifTrue: [^ denominator].	numerator = -1 ifTrue: [^ denominator negated].	^ Fraction numerator: denominator denominator: numerator! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58'!< aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator < (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #<! !!Fraction methodsFor: 'comparing' stamp: 'di 8/31/1999 10:33'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [numerator = 0 ifTrue: [^ aNumber numerator = 0].				^ (numerator * aNumber denominator) =					(aNumber numerator * denominator)				"Note: used to just compare num and denom,					but this fails for improper fractions"].	^ aNumber adaptToFraction: self andSend: #=! !!Fraction methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:33'!hash	"Hash is reimplemented because = is implemented."	^numerator hash bitXor: denominator hash! !!Fraction methodsFor: 'truncation and round off'!truncated 	"Refer to the comment in Number|truncated."	^numerator quo: denominator! !!Fraction methodsFor: 'converting' stamp: 'di 11/6/1998 13:10'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Fraction."	^ rcvr asFraction perform: selector with: self! !!Fraction methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert receiverScaledDecimal to a Fraction and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal asFraction perform: arithmeticOpSelector with: self! !!Fraction methodsFor: 'converting' stamp: 'mrm 10/10/2000 22:58'!asFloat	"Answer a Float that closely approximates the value of the receiver.	Ideally, answer the Float that most closely approximates the receiver."	| nScaleBits dScaleBits nScaled dScaled |	"Scale the numerator by throwing away all but the	top 8 digits (57 to 64 significant bits) then making that a Float.	This keeps all of the precision of a Float (53 significand bits) but	guarantees that we do not exceed the range representable as a Float	(about 2 to the 1024th)"	nScaleBits _ 8 * ((numerator digitLength - 8) max: 0).	nScaled _ (numerator bitShift: nScaleBits negated) asFloat.	"Scale the denominator the same way."	dScaleBits _ 8 * ((denominator digitLength - 8) max: 0).	dScaled _ (denominator bitShift: dScaleBits negated) asFloat.	"Divide the scaled numerator and denominator to make the right mantissa, then scale to correct the exponent."	^ (nScaled / dScaled) timesTwoPower: (nScaleBits - dScaleBits).! !!Fraction methodsFor: 'converting'!asFraction		"Answer the receiver itself."	^self! !!Fraction methodsFor: 'converting'!isFraction	^ true! !!Fraction methodsFor: 'printing'!printOn: aStream	aStream nextPut: $(.	numerator printOn: aStream.	aStream nextPut: $/.	denominator printOn: aStream.	aStream nextPut: $).! !!Fraction methodsFor: 'private'!denominator	^denominator! !!Fraction methodsFor: 'private'!numerator	^numerator! !!Fraction methodsFor: 'private'!reduced	| gcd numer denom |	numerator = 0 ifTrue: [^0].	gcd _ numerator gcd: denominator.	numer _ numerator // gcd.	denom _ denominator // gcd.	denom = 1 ifTrue: [^numer].	^Fraction numerator: numer denominator: denom! !!Fraction methodsFor: 'private' stamp: 'tfei 4/12/1999 12:45'!setNumerator: n denominator: d	d = 0		ifTrue: [^(ZeroDivide dividend: n) signal]		ifFalse: 			[numerator _ n asInteger.			denominator _ d asInteger abs. "keep sign in numerator"			d < 0 ifTrue: [numerator _ numerator negated]]! !!Fraction methodsFor: 'mathematical functions' stamp: 'LC 4/22/1998 14:03'!raisedToInteger: anInteger 	"See Number | raisedToInteger:"	anInteger = 0 ifTrue: [^ 1].	anInteger < 0 ifTrue: [^ self reciprocal raisedToInteger: anInteger negated].	^ Fraction numerator: (numerator raisedToInteger: anInteger)		denominator: (denominator raisedToInteger: anInteger)! !!Fraction methodsFor: 'mathematical functions' stamp: 'LC 4/22/1998 14:05'!squared	"See Fraction (Number) | squared"	^ Fraction numerator: numerator squared denominator: denominator squared! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Fraction class	instanceVariableNames: ''!!Fraction class methodsFor: 'instance creation' stamp: 'di 8/31/1999 10:16'!numerator: numInteger denominator: denInteger 	"Answer an instance of me (numInteger/denInteger).	NOTE: This primitive initialization method will not reduce improper fractions,	so normal usage should be coded as, eg,		(Fraction numerator: a denominator: b) reduced	or, more simply, as		a / b."	^self new setNumerator: numInteger denominator: denInteger! !!Fraction class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	#Numeric.	"add 200/01/19 For <number> protocol support."	^ self numerator: 1 denominator: 1! !ImageReadWriter subclass: #GIFReadWriter	instanceVariableNames: 'width height bitsPerPixel colorPalette rowByteSize xpos ypos pass interlace codeSize clearCode eoiCode freeCode maxCode prefixTable suffixTable remainBitCount bufByte bufStream transparentIndex mapOf32 localColorTable delay loopCount offset'	classVariableNames: 'Extension ImageSeparator Terminator'	poolDictionaries: ''	category: 'Graphics-Files'!!GIFReadWriter commentStamp: '<historical>' prior: 0!Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.Used with permission.  Modified for use in Squeak.!!GIFReadWriter methodsFor: 'accessing' stamp: 'bf 5/29/2003 01:43'!delay: aNumberOrNil	"Set delay for next image in hundredth (1/100) of seconds"	delay := aNumberOrNil! !!GIFReadWriter methodsFor: 'accessing' stamp: 'bf 5/29/2003 01:39'!loopCount: aNumber	"Set looping. This must be done before any image is written!!"	loopCount := aNumber! !!GIFReadWriter methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:18'!nextImage	"Read in the next GIF image from the stream. Read it all intomemory first for speed."	| f thisImageColorTable |	stream class == ReadWriteStream ifFalse: [		stream binary.		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].	localColorTable _ nil.	self readHeader.	f _ self readBody.	self close.	f == nil ifTrue: [^ self error: 'corrupt GIF file'].	thisImageColorTable _ localColorTable ifNil: [colorPalette].	transparentIndex ifNotNil: [		transparentIndex + 1 > thisImageColorTable size ifTrue: [			thisImageColorTable _ thisImageColorTable 				forceTo: transparentIndex + 1 				paddingWith: Color white		].		thisImageColorTable at: transparentIndex + 1 put: Color transparent	].	f colors: thisImageColorTable.	^ f! !!GIFReadWriter methodsFor: 'accessing' stamp: 'nk 4/17/2004 19:44'!nextPutImage: aForm	| f newF |	aForm unhibernate.	f _ aForm colorReduced.  "minimize depth"	f depth > 8 ifTrue: [		"Not enough color space; do it the hard way."		f _ f asFormOfDepth: 8].	f depth < 8 ifTrue: [		"writeBitData: expects depth of 8"		newF _ f class extent: f extent depth: 8.		(f isColorForm)			ifTrue: [				newF					copyBits: f boundingBox					from: f at: 0@0					clippingBox: f boundingBox					rule: Form over					fillColor: nil					map: nil.				newF colors: f colors]			ifFalse: [f displayOn: newF].		f _ newF].	(f isColorForm)		ifTrue: [			(f colorsUsed includes: Color transparent) ifTrue: [				transparentIndex _ (f colors indexOf: Color transparent) - 1]]		ifFalse: [transparentIndex _ nil].	width _ f width.	height _ f height.	bitsPerPixel _ f depth.	colorPalette _ f colormapIfNeededForDepth: 32.	interlace _ false.	self writeHeader.	self writeBitData: f bits.! !!GIFReadWriter methodsFor: 'accessing' stamp: '6/18/97 13:18 '!setStream: aStream	"Feed it in from an existing source"	stream _ aStream! !!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!understandsImageFormat	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !!GIFReadWriter methodsFor: 'private-encoding'!flushCode	self flushBits! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'tk 9/14/97 16:25'!readPixelFrom: bits	"Since bits is a Bitmap with 32 bit values, watch out for thepadding at the end of each row.  But, GIF format already wants padding to32 bit boundary!!  OK as is.  tk 9/14/97"	| pixel |	ypos >= height ifTrue: [^nil].	pixel _ bits byteAt: (ypos * rowByteSize + xpos + 1).	self updatePixelPosition.	^pixel! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'bf 5/29/2003 01:21'!writeBitData: bits	"using modified Lempel-Ziv Welch algorithm."	| maxBits maxMaxCode tSize initCodeSize ent tShift fCode pixel index disp nomatch |	pass _ 0.	xpos _ 0.	ypos _ 0.	rowByteSize _ width * 8 + 31 // 32 * 4.	remainBitCount _ 0.	bufByte _ 0.	bufStream _ WriteStream on: (ByteArray new: 256).	maxBits _ 12.	maxMaxCode _ 1 bitShift: maxBits.	tSize _ 5003.	prefixTable _ Array new: tSize.	suffixTable _ Array new: tSize.	initCodeSize _ bitsPerPixel <= 1 ifTrue: [2] ifFalse: [bitsPerPixel].	self nextPut: initCodeSize.	self setParameters: initCodeSize.	tShift _ 0.	fCode _ tSize.	[fCode < 65536] whileTrue:		[tShift _ tShift + 1.		fCode _ fCode * 2].	tShift _ 8 - tShift.	1 to: tSize do: [:i | suffixTable at: i put: -1].	self writeCodeAndCheckCodeSize: clearCode.	ent _ self readPixelFrom: bits.	[(pixel _ self readPixelFrom: bits) == nil] whileFalse:		[		fCode _ (pixel bitShift: maxBits) + ent.		index _ ((pixel bitShift: tShift) bitXor: ent) + 1.		(suffixTable at: index) = fCode			ifTrue: [ent _ prefixTable at: index]			ifFalse:				[nomatch _ true.				(suffixTable at: index) >= 0					ifTrue:						[disp _ tSize - index + 1.						index = 1 ifTrue: [disp _ 1].						"probe"						[(index _ index - disp) < 1 ifTrue: [index _ index + tSize].						(suffixTable at: index) = fCode							ifTrue:								[ent _ prefixTable at: index.								nomatch _ false.								"continue whileFalse:"].						nomatch and: [(suffixTable at: index) > 0]]							whileTrue: ["probe"]].				"nomatch"				nomatch ifTrue:					[self writeCodeAndCheckCodeSize: ent.					ent _ pixel.					freeCode < maxMaxCode						ifTrue:							[prefixTable at: index put: freeCode.							suffixTable at: index put: fCode.							freeCode _ freeCode + 1]						ifFalse:							[self writeCodeAndCheckCodeSize: clearCode.							1 to: tSize do: [:i | suffixTable at: i put: -1].							self setParameters: initCodeSize]]]].	prefixTable _ suffixTable _ nil.	self writeCodeAndCheckCodeSize: ent.	self writeCodeAndCheckCodeSize: eoiCode.	self flushCode.	self nextPut: 0.	"zero-length packet"! !!GIFReadWriter methodsFor: 'private-encoding'!writeCode: aCode	self nextBitsPut: aCode! !!GIFReadWriter methodsFor: 'private-encoding'!writeCodeAndCheckCodeSize: aCode	self writeCode: aCode.	self checkCodeSize! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'bf 5/29/2003 01:38'!writeHeader	| byte |	stream position = 0 ifTrue: [		"For first image only"		self nextPutAll: 'GIF89a' asByteArray.		self writeWord: width.	"Screen Width"		self writeWord: height.	"Screen Height"		byte _ 16r80.  "has color map"		byte _ byte bitOr: ((bitsPerPixel - 1) bitShift: 5).  "color resolution"		byte _ byte bitOr: bitsPerPixel - 1.  "bits per pixel"		self nextPut: byte.		self nextPut: 0.		"background color."		self nextPut: 0.		"reserved"		colorPalette do: [:pixelValue |			self	nextPut: ((pixelValue bitShift: -16) bitAnd: 255);				nextPut: ((pixelValue bitShift: -8) bitAnd: 255);				nextPut: (pixelValue bitAnd: 255)].		loopCount notNil ifTrue: [			"Write a Netscape loop chunk"			self nextPut: Extension.			self nextPutAll: #(255 11 78 69 84 83 67 65 80 69 50 46 48 3 1) asByteArray.			self writeWord: loopCount.			self nextPut: 0]].	delay notNil | transparentIndex notNil ifTrue: [		self nextPut: Extension;			nextPutAll: #(16rF9 4) asByteArray;			nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [9]);			writeWord: (delay isNil ifTrue: [0] ifFalse: [delay]);			nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [transparentIndex]);			nextPut: 0].	self nextPut: ImageSeparator.	self writeWord: 0.		"Image Left"	self writeWord: 0.		"Image Top"	self writeWord: width.	"Image Width"	self writeWord: height.	"Image Height"	byte _ interlace ifTrue: [16r40] ifFalse: [0].	self nextPut: byte.! !!GIFReadWriter methodsFor: 'private-encoding'!writeWord: aWord	self nextPut: (aWord bitAnd: 255).	self nextPut: ((aWord bitShift: -8) bitAnd: 255).	^aWord! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'mir 11/19/2003 12:19'!readBitData	"using modified Lempel-Ziv Welch algorithm."	| outCodes outCount bitMask initCodeSize code curCode oldCode inCode finChar i bytes f c packedBits hasLocalColor localColorSize maxOutCodes |	maxOutCodes _ 4096.	offset := self readWord@self readWord. "Image Left@Image Top"	width _ self readWord.	height _ self readWord.	"---	Local Color Table Flag        1 Bit	Interlace Flag                1 Bit	Sort Flag                     1 Bit	Reserved                      2 Bits	Size of Local Color Table     3 Bits	----"	packedBits _ self next.	interlace _ (packedBits bitAnd: 16r40) ~= 0.	hasLocalColor _ (packedBits bitAnd: 16r80) ~= 0.	localColorSize _ 1 bitShift: ((packedBits bitAnd: 16r7) + 1).	hasLocalColor ifTrue: [localColorTable _ self readColorTable: localColorSize].	pass _ 0.	xpos _ 0.	ypos _ 0.	rowByteSize _ ((width + 3) // 4) * 4.	remainBitCount _ 0.	bufByte _ 0.	bufStream _ ReadStream on: ByteArray new.	outCodes _ ByteArray new: maxOutCodes + 1.	outCount _ 0.	bitMask _ (1 bitShift: bitsPerPixel) - 1.	prefixTable _ Array new: 4096.	suffixTable _ Array new: 4096.	initCodeSize _ self next.	self setParameters: initCodeSize.	bitsPerPixel > 8 ifTrue: [^self error: 'never heard of a GIF that deep'].	bytes _ ByteArray new: rowByteSize * height.	[(code _ self readCode) = eoiCode] whileFalse:		[code = clearCode			ifTrue:				[self setParameters: initCodeSize.				curCode _ oldCode _ code _ self readCode.				finChar _ curCode bitAnd: bitMask.				"Horrible hack to avoid running off the end of the bitmap.  Seems to cure problem reading some gifs!!? tk 6/24/97 20:16"				xpos = 0 ifTrue: [						ypos < height ifTrue: [							bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar]]					ifFalse: [bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar].				self updatePixelPosition]			ifFalse:				[curCode _ inCode _ code.				curCode >= freeCode ifTrue:					[curCode _ oldCode.					outCodes at: (outCount _ outCount + 1) put: finChar].				[curCode > bitMask] whileTrue:					[outCount > maxOutCodes						ifTrue: [^self error: 'corrupt GIF file (OutCount)'].					outCodes at: (outCount _ outCount + 1)						put: (suffixTable at: curCode + 1).					curCode _ prefixTable at: curCode + 1].				finChar _ curCode bitAnd: bitMask.				outCodes at: (outCount _ outCount + 1) put: finChar.				i _ outCount.				[i > 0] whileTrue:					["self writePixel: (outCodes at: i) to: bits"					bytes at: (ypos * rowByteSize) + xpos + 1 put: (outCodes at: i).					self updatePixelPosition.					i _ i - 1].				outCount _ 0.				prefixTable at: freeCode + 1 put: oldCode.				suffixTable at: freeCode + 1 put: finChar.				oldCode _ inCode.				freeCode _ freeCode + 1.				self checkCodeSize]].	prefixTable _ suffixTable _ nil.	f _ ColorForm extent: width@height depth: 8.	f bits copyFromByteArray: bytes.	"Squeak can handle depths 1, 2, 4, and 8"	bitsPerPixel > 4 ifTrue: [^ f].	"reduce depth to save space"	c _ ColorForm extent: width@height		depth: (bitsPerPixel = 3 ifTrue: [4] ifFalse: [bitsPerPixel]).	f displayOn: c.	^ c! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'KLC 1/25/2004 14:04'!readBody	"Read the GIF blocks. Modified to return a form.  "	| form extype block blocksize packedFields delay1 |	form _ nil.	[stream atEnd] whileFalse: [		block _ self next.		block = Terminator ifTrue: [^ form].		block = ImageSeparator ifTrue: [			form isNil				ifTrue: [form _ self readBitData]				ifFalse: [self skipBitData].		] ifFalse: [			block = Extension				ifFalse: [^ form "^ self error: 'Unknown block type'"].			"Extension block"			extype _ self next.	"extension type"			extype = 16rF9 ifTrue: [  "graphics control"				self next = 4 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].				"====				Reserved                      3 Bits				Disposal Method               3 Bits				User Input Flag               1 Bit				Transparent Color Flag        1 Bit				===" 				packedFields _ self next.				delay1 := self next.	"delay time 1"				delay := (self next*256 + delay1) *10.	 "delay time 2"				transparentIndex _ self next.				(packedFields bitAnd: 1) = 0 ifTrue: [transparentIndex _ nil].				self next = 0 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].			] ifFalse: [				"Skip blocks"				[(blocksize _ self next) > 0]					whileTrue: [						"Read the block and ignore it and eat the block terminator"						self next: blocksize]]]]! !!GIFReadWriter methodsFor: 'private-decoding'!readCode	^self nextBits! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:48'!readColorTable: numberOfEntries	| array r g b |	array _ Array new: numberOfEntries.	1 to: array size do: [ :i |		r _ self next.  		g _ self next.  		b _ self next.		array at: i put: (Color r: r g: g b: b range: 255)	].	^array! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:49'!readHeader	| is89 byte hasColorMap |	(self hasMagicNumber: 'GIF87a' asByteArray)		ifTrue: [is89 _ false]		ifFalse: [(self hasMagicNumber: 'GIF89a' asByteArray)			ifTrue: [is89 _ true]			ifFalse: [^ self error: 'This does not appear to be a GIF file']].	self readWord.	"skip Screen Width"	self readWord.	"skip Screen Height"	byte _ self next.	hasColorMap _ (byte bitAnd: 16r80) ~= 0.	bitsPerPixel _ (byte bitAnd: 7) + 1.	byte _ self next.	"skip background color."	self next ~= 0		ifTrue: [is89			ifFalse: [^self error: 'corrupt GIF file (screen descriptor)']].	hasColorMap		ifTrue:			[colorPalette _ self readColorTable: (1 bitShift: bitsPerPixel)]		ifFalse:			["Transcript cr; show: 'GIF file does not have a color map.'."			colorPalette _ nil "Palette monochromeDefault"].! !!GIFReadWriter methodsFor: 'private-decoding'!readWord	^self next + (self next bitShift: 8)! !!GIFReadWriter methodsFor: 'private-decoding'!skipBitData	| misc blocksize |	self readWord.  "skip Image Left"	self readWord.  "skip Image Top"	self readWord.  "width"	self readWord.  "height"	misc _ self next.	(misc bitAnd: 16r80) = 0 ifFalse: [ "skip colormap"		1 to: (1 bitShift: (misc bitAnd: 7) + 1) do: [:i |			self next; next; next]].	self next.  "minimum code size"	[(blocksize _ self next) > 0]		whileTrue: [self next: blocksize]! !!GIFReadWriter methodsFor: 'private-bits access'!flushBits	remainBitCount = 0 ifFalse:		[self nextBytePut: bufByte.		remainBitCount _ 0].	self flushBuffer! !!GIFReadWriter methodsFor: 'private-bits access'!nextBits	| integer readBitCount shiftCount byte |	integer _ 0.	remainBitCount = 0		ifTrue:			[readBitCount _ 8.			shiftCount _ 0]		ifFalse:			[readBitCount _ remainBitCount.			shiftCount _ remainBitCount - 8].	[readBitCount < codeSize]		whileTrue:			[byte _ self nextByte.			byte == nil ifTrue: [^eoiCode].			integer _ integer + (byte bitShift: shiftCount).			shiftCount _ shiftCount + 8.			readBitCount _ readBitCount + 8].	(remainBitCount _ readBitCount - codeSize) = 0		ifTrue:	[byte _ self nextByte]		ifFalse:	[byte _ self peekByte].	byte == nil ifTrue: [^eoiCode].	^(integer + (byte bitShift: shiftCount)) bitAnd: maxCode! !!GIFReadWriter methodsFor: 'private-bits access'!nextBitsPut: anInteger	| integer writeBitCount shiftCount |	shiftCount _ 0.	remainBitCount = 0		ifTrue:			[writeBitCount _ 8.			integer _ anInteger]		ifFalse:			[writeBitCount _ remainBitCount.			integer _ bufByte + (anInteger bitShift: 8 - remainBitCount)].	[writeBitCount < codeSize]		whileTrue:			[self nextBytePut: ((integer bitShift: shiftCount) bitAnd: 255).			shiftCount _ shiftCount - 8.			writeBitCount _ writeBitCount + 8].	(remainBitCount _ writeBitCount - codeSize) = 0		ifTrue: [self nextBytePut: (integer bitShift: shiftCount)]		ifFalse: [bufByte _ integer bitShift: shiftCount].	^anInteger! !!GIFReadWriter methodsFor: 'private-packing'!fillBuffer	| packSize |	packSize _ self next.	bufStream _ ReadStream on: (self next: packSize)! !!GIFReadWriter methodsFor: 'private-packing'!flushBuffer	bufStream isEmpty ifTrue: [^self].	self nextPut: bufStream size.	self nextPutAll: bufStream contents.	bufStream _ WriteStream on: (ByteArray new: 256)! !!GIFReadWriter methodsFor: 'private-packing'!nextByte	bufStream atEnd		ifTrue:			[self atEnd ifTrue: [^nil].			self fillBuffer].	^bufStream next! !!GIFReadWriter methodsFor: 'private-packing'!nextBytePut: aByte	bufStream nextPut: aByte.	bufStream size >= 254 ifTrue: [self flushBuffer]! !!GIFReadWriter methodsFor: 'private-packing'!peekByte	bufStream atEnd		ifTrue:			[self atEnd ifTrue: [^nil].			self fillBuffer].	^bufStream peek! !!GIFReadWriter methodsFor: 'private'!checkCodeSize	(freeCode > maxCode and: [codeSize < 12])		ifTrue:			[codeSize _ codeSize + 1.			maxCode _ (1 bitShift: codeSize) - 1]! !!GIFReadWriter methodsFor: 'private'!setParameters: initCodeSize	clearCode _ 1 bitShift: initCodeSize.	eoiCode _ clearCode + 1.	freeCode _ clearCode + 2.	codeSize _ initCodeSize + 1.	maxCode _ (1 bitShift: codeSize) - 1! !!GIFReadWriter methodsFor: 'private'!updatePixelPosition	(xpos _ xpos + 1) >= width ifFalse: [^self].	xpos _ 0.	interlace		ifFalse: [ypos _ ypos + 1. ^self].	pass = 0 ifTrue:		[(ypos _ ypos + 8) >= height			ifTrue:				[pass _ pass + 1.				ypos _ 4].		^self].	pass = 1 ifTrue:		[(ypos _ ypos + 8) >= height			ifTrue:				[pass _ pass + 1.				ypos _ 2].		^self].	pass = 2 ifTrue:		[(ypos _ ypos + 4) >= height			ifTrue:				[pass _ pass + 1.				ypos _ 1].		^self].	pass = 3 ifTrue:		[ypos _ ypos + 2.		^self].	^self error: 'can''t happen'! !!GIFReadWriter methodsFor: 'stream access' stamp: 'bf 5/29/2003 01:23'!close	"Write terminator"	self nextPut: Terminator.	^super close! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GIFReadWriter class	instanceVariableNames: ''!!GIFReadWriter class methodsFor: 'class initialization'!initialize	"GIFReadWriter initialize"	ImageSeparator _ $, asInteger.	Extension _ $!! asInteger.	Terminator _ $; asInteger.! !!GIFReadWriter class methodsFor: 'examples' stamp: 'bf 5/29/2003 01:56'!exampleAnim	"GIFReadWriter exampleAnim"	| writer extent center |	writer := GIFReadWriter on: (FileStream newFileNamed: 'anim.gif').	writer loopCount: 20.		"Repeat 20 times"	writer delay: 10.		"Wait 10/100 seconds"	extent := 42@42.	center := extent / 2.	Cursor write showWhile: [		[2 to: center x - 1 by: 2 do: [:r |			"Make a fancy anim without using Canvas - inefficient as hell"			| image |			image := ColorForm extent: extent depth: 8.			0.0 to: 359.0 do: [:theta | image colorAt: (center + (Point r: r degrees: theta)) rounded put: Color red].			writer nextPutImage: image]		]	ensure: [writer close]].! !!GIFReadWriter class methodsFor: 'examples' stamp: 'sd 9/27/2003 19:01'!grabScreenAndSaveOnDisk  	"GIFReaderWriter grabScreenAndSaveOnDisk"	| form fileName |	form _ Form fromUser.	form bits size = 0 ifTrue: [^ self beep].	fileName _ FileDirectory default nextNameFor: 'Squeak' extension: 'gif'.	Utilities informUser: 'Writing ' , fileName		during: [GIFReadWriter putForm: form onFileNamed: fileName].! !!GIFReadWriter class methodsFor: 'image reading/writing' stamp: 'asm 12/11/2003 21:29'!typicalFileExtensions	"Answer a collection of file extensions (lowercase) which files that I can 	read might commonly have"	self		allSubclasses detect: [:cls | cls wantsToHandleGIFs ]					 ifNone: ["if none of my subclasses wants , then i''ll have to do"							^ #('gif' )].	^ #( )! !!GIFReadWriter class methodsFor: 'image reading/writing' stamp: 'asm 12/11/2003 21:29'!wantsToHandleGIFs	^ false! !Exception subclass: #Halt	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Extensions'!!Halt commentStamp: '<historical>' prior: 0!Halt is provided to support Object>>halt.!!Halt methodsFor: 'description' stamp: 'tfei 5/10/1999 14:24'!isResumable	^true! !!Halt methodsFor: 'priv handling' stamp: 'ajh 8/5/2003 11:30'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !Browser subclass: #HierarchyBrowser	instanceVariableNames: 'classList centralClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 5/8/2000 01:28'!changed: sym	sym == #classList ifTrue: [self updateAfterClassChange].	super changed: sym! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'tk 4/3/98 11:09'!classListIndex: newIndex	"Cause system organization to reflect appropriate category"	| newClassName ind |	newIndex ~= 0 ifTrue:		[newClassName _ (classList at: newIndex) copyWithout: $ .		systemCategoryListIndex _			systemOrganizer numberOfCategoryOfElement: newClassName].	ind _ super classListIndex: newIndex.	self changed: #systemCategorySingleton.	^ ind! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'dew 9/15/2001 16:19'!defaultBrowserTitle	^ 'Hierarchy Browser'! !!HierarchyBrowser methodsFor: 'initialization'!initAlphabeticListing	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	classList _ Smalltalk classNames.! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 5/8/2000 01:02'!initHierarchyForClass: aClassOrMetaClass	| tab stab index nonMetaClass |	centralClass _ aClassOrMetaClass.	nonMetaClass _ aClassOrMetaClass theNonMetaClass.	self systemOrganizer: SystemOrganization.	metaClassIndicated _ aClassOrMetaClass isMeta.	classList _ OrderedCollection new.	tab _ ''.	nonMetaClass allSuperclasses reverseDo: 		[:aClass | 		classList add: tab , aClass name.		tab _ tab , '  '].	index _ classList size + 1.	nonMetaClass allSubclassesWithLevelDo:		[:aClass :level |		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].		classList add: tab , stab , aClass name]	 	startingLevel: 0.	self classListIndex: index! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'tk 4/5/98 10:29'!openEditString: aString	"Create a pluggable version of all the views for a HierarchyBrowser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	^ self openSystemCatEditString: aString! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 11/8/1999 09:38'!potentialClassNames	"Answer the names of all the classes that could be viewed in this browser"	^ self classList collect:		[:aName | aName copyWithout: $ ]! !!HierarchyBrowser methodsFor: 'initialization'!selectClass: classNotMeta	| name |	name _ classNotMeta name.	self classListIndex: (self classList findFirst:			[:each | (each endsWith: name)					and: [each size = name size							or: [(each at: each size - name size) isSeparator]]])! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 12/4/96'!selectedClassName	"Answer the name of the class currently selected.   di	  bug fix for the case where name cannot be found -- return nil rather than halt"	| aName |	aName _ super selectedClassName.	^ aName == nil		ifTrue:			[aName]		ifFalse:			[(aName copyWithout: $ ) asSymbol]! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'di 4/26/2000 20:20'!systemCategorySingleton	| cls |	cls _ self selectedClass.	^ cls ifNil: [Array new]		ifNotNil: [Array with: cls category]! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'rhi 12/2/2001 21:32'!updateAfterClassChange	"It is possible that some the classes comprising the hierarchy have changed, so reinitialize the entire browser."	(centralClass notNil and: [centralClass isObsolete not])		ifTrue: [self initHierarchyForClass: centralClass]! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'tk 4/7/98 13:53'!buildClassBrowserEditString: aString 	"Create and schedule a new class browser for the current selection, if one 	exists, with initial textual contents set to aString."	self spawnHierarchy! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'tk 4/3/98 11:22'!removeSystemCategory	"If a class category is selected, create a Confirmer so the user can 	verify that the currently selected class category and all of its classes 	should be removed from the system. If so, remove it."	self inform: 'Use a normal Browser, in which you can see the entire category you are trying to remove.'! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'sw 11/8/1999 13:35'!systemCatSingletonKey: aChar from: aView	^ self systemCatListKey: aChar from: aView! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'sw 11/8/1999 14:08'!systemCatSingletonMenu: aMenu	^ aMenu labels:'find class... (f)browseprintOutfileOutupdaterename...remove' 	lines: #(1 4)	selections:		#(findClass buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory updateSystemCategories		 renameSystemCategory removeSystemCategory )! !!HierarchyBrowser methodsFor: 'class list' stamp: 'sw 3/24/2002 01:55'!assureSelectionsShow	"This is a workaround for the fact that a hierarchy browser, when launched, often does not show the selected class"	| saveCatIndex saveMsgIndex |	saveCatIndex _ messageCategoryListIndex.	saveMsgIndex _ messageListIndex.	self classListIndex: classListIndex.	self messageCategoryListIndex: saveCatIndex.	self messageListIndex: saveMsgIndex! !!HierarchyBrowser methodsFor: 'class list' stamp: 'mir 3/22/2000 13:02'!classList	classList _ classList select: [:each | Smalltalk includesKey: each withBlanksTrimmed asSymbol].	^ classList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HierarchyBrowser class	instanceVariableNames: ''!!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'dew 9/15/2001 16:19'!newFor: aClass	"Open a new HierarchyBrowser on the given class"	|  newBrowser |	newBrowser _ HierarchyBrowser new initHierarchyForClass: aClass.	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString"HierarchyBrowser newFor: Boolean"! !!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 18:20'!newFor: aClass labeled: aLabel	"Open a new HierarchyBrowser on the given class, using aLabel as the window title."	|  newBrowser |	newBrowser _ HierarchyBrowser new initHierarchyForClass: aClass.	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)		label: aLabel"HierarchyBrowser newFor: Boolean labeled: 'Testing'"! !Bag subclass: #IdentityBag	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!IdentityBag commentStamp: '<historical>' prior: 0!Like a Bag, except that items are compared with #== instead of #= .See the comment of IdentitySet for more information.!]style[(88 11 23)f3,f3LIdentitySet Comment;,f3!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IdentityBag class	instanceVariableNames: ''!!IdentityBag class methodsFor: 'instance creation' stamp: 'nk 3/17/2001 09:53'!contentsClass	^IdentityDictionary! !Dictionary subclass: #IdentityDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!IdentityDictionary commentStamp: 'ls 06/15/02 22:35' prior: 0!Like a Dictionary, except that keys are compared with #== instead of #= .See the comment of IdentitySet for more information.!]style[(94 11 22)f1,f1LIdentitySet Comment;,f1!!IdentityDictionary methodsFor: 'private' stamp: 'di 12/1/1999 20:54'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock." 	self associationsDo: 		[:association | value == association value ifTrue: [^ association key]].	^ exceptionBlock value! !!IdentityDictionary methodsFor: 'private' stamp: 'di 10/1/97 20:51'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ IdentitySet new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!IdentityDictionary methodsFor: 'private' stamp: 'jm 2/18/98 13:18'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish hash start element |	finish _ array size.	finish > 4096		ifTrue: [hash _ anObject identityHash * (finish // 4096)]		ifFalse: [hash _ anObject identityHash].	start _ (hash \\ array size) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !Set subclass: #IdentitySet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!IdentitySet commentStamp: 'sw 1/14/2003 22:35' prior: 0!The same as a Set, except that items are compared using #== instead of #=.Almost any class named IdentityFoo is the same as Foo except for the way items are compared.  In Foo, #= is used, while in IdentityFoo, #== is used.  That is, identity collections will treat items as the same only if they have the same identity.For example, note that copies of a string are equal:	('abc' copy) = ('abc' copy)but they are not identitcal:	('abc' copy) == ('abc' copy)A regular Set will only include equal objects once:	| aSet |	aSet := Set new.	aSet add: 'abc' copy.	aSet add: 'abc' copy.	aSetAn IdentitySet will include multiple equal objects if they are not identical:	| aSet |	aSet := IdentitySet new.	aSet add: 'abc' copy.	aSet add: 'abc' copy.	aSet!!IdentitySet methodsFor: 'private' stamp: 'jm 2/18/98 13:19'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish hash start element |	finish _ array size.	finish > 4096		ifTrue: [hash _ anObject identityHash * (finish // 4096)]		ifFalse: [hash _ anObject identityHash].	start _ (hash \\ array size) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentitySet methodsFor: 'converting' stamp: 'ar 9/22/2000 10:13'!asIdentitySet	^self! !Exception subclass: #IllegalResumeAttempt	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!IllegalResumeAttempt commentStamp: '<historical>' prior: 0!This class is private to the EHS implementation.  An instance of it is signaled whenever an attempt is made to resume from an exception which answers false to #isResumable.!!IllegalResumeAttempt methodsFor: 'comment' stamp: 'ajh 9/4/2002 19:24'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !!IllegalResumeAttempt methodsFor: 'comment' stamp: 'ajh 2/1/2003 00:57'!isResumable		^ false! !Object subclass: #ImageReadWriter	instanceVariableNames: 'stream'	classVariableNames: 'ImageNotStoredSignal MagicNumberErrorSignal'	poolDictionaries: ''	category: 'Graphics-Files'!!ImageReadWriter commentStamp: '<historical>' prior: 0!Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.I am an abstract class to provide for encoding and/or decoding an image on a stream.Instance Variables:	stream		<ReadStream | WriteStream>	stream for image storagesClass Variables:	ImageNotStoredSignal		<Signal>	image not stored error signal	MagicNumberErrorSignal		<Signal>	magic number error signalSubclasses must implement the following messages:	accessing		nextImage		nextPutImage:	testing		canUnderstand         (added tao 10/26/97)!!ImageReadWriter methodsFor: 'accessing'!nextImage	"Dencoding an image on stream and answer the image."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'accessing'!nextPutImage: anImage	"Encoding anImage on stream."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'stream access'!atEnd	^stream atEnd! !!ImageReadWriter methodsFor: 'stream access' stamp: 'sd 1/30/2004 15:18'!close		stream close! !!ImageReadWriter methodsFor: 'stream access'!contents	^stream contents! !!ImageReadWriter methodsFor: 'stream access'!cr	^stream nextPut: Character cr asInteger! !!ImageReadWriter methodsFor: 'stream access'!lf	"PPM and PBM are used LF as CR."	^stream nextPut: Character lf asInteger! !!ImageReadWriter methodsFor: 'stream access'!next	^stream next! !!ImageReadWriter methodsFor: 'stream access'!next: size	^stream next: size! !!ImageReadWriter methodsFor: 'stream access'!nextLong	"Read a 32-bit quantity from the input stream."	^(stream next bitShift: 24) + (stream next bitShift: 16) +		(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextLongPut: a32BitW	"Write out a 32-bit integer as 32 bits."	stream nextPut: ((a32BitW bitShift: -24) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -16) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a32BitW bitAnd: 16rFF).	^a32BitW! !!ImageReadWriter methodsFor: 'stream access'!nextPut: aByte	^stream nextPut: aByte! !!ImageReadWriter methodsFor: 'stream access'!nextPutAll: aByteArray	^stream nextPutAll: aByteArray! !!ImageReadWriter methodsFor: 'stream access'!nextWord	"Read a 16-bit quantity from the input stream."	^(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextWordPut: a16BitW	"Write out a 16-bit integer as 16 bits."	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a16BitW bitAnd: 16rFF).	^a16BitW! !!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!peekFor: aValue	^stream peekFor: aValue! !!ImageReadWriter methodsFor: 'stream access'!position	^stream position! !!ImageReadWriter methodsFor: 'stream access'!position: anInteger	^stream position: anInteger! !!ImageReadWriter methodsFor: 'stream access'!size	^stream size! !!ImageReadWriter methodsFor: 'stream access'!skip: anInteger	^stream skip: anInteger! !!ImageReadWriter methodsFor: 'stream access'!space	^stream nextPut: Character space asInteger! !!ImageReadWriter methodsFor: 'stream access'!tab	^stream nextPut: Character tab asInteger! !!ImageReadWriter methodsFor: 'private'!changePadOfBits: bits width: width height: height depth: depth from: oldPadto: newPad	"Change padding size of bits."	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |	(#(8 16 32) includes: oldPad)		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].	(#(8 16 32) includes: newPad)		ifFalse: [^self error: 'Invalid pad: ', newPad printString].	srcRowByteSize _ width * depth + oldPad - 1 // oldPad * (oldPad / 8).	srcRowByteSize * height = bits size		ifFalse: [^self error: 'Incorrect bitmap array size.'].	dstRowByteSize _ width * depth + newPad - 1 // newPad * (newPad / 8).	newBits _ ByteArray new: dstRowByteSize * height.	srcRowBase _ 1.	rowEndOffset _ dstRowByteSize - 1.	1 to: newBits size by: dstRowByteSize do:		[:dstRowBase |		newBits replaceFrom: dstRowBase			to: dstRowBase + rowEndOffset			with: bits			startingAt: srcRowBase.		srcRowBase _ srcRowBase + srcRowByteSize].	^newBits! !!ImageReadWriter methodsFor: 'private'!hasMagicNumber: aByteArray	| position |	position _ stream position.	((stream size - position) >= aByteArray size and:	[(stream next: aByteArray size)  = aByteArray])		ifTrue: [^true].	stream position: position.	^false! !!ImageReadWriter methodsFor: 'private' stamp: 'sd 1/30/2004 15:18'!on: aStream	(stream _ aStream) reset.	stream binary.	"Note that 'reset' makes a file be text.  Must do this after."! !!ImageReadWriter methodsFor: 'private'!unpackBits: bits depthTo8From: depth with: width height: height pad: pad	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth	 trailingSize upBits bitIndex upBitIndex val |	(#(1 2 4) includes: depth)		ifFalse: [^self error: 'depth must be 1, 2, or 4'].	(#(8 16 32) includes: pad)		ifFalse: [^self error: 'pad must be 8, 16, or 32'].	bitMask _ (1 bitShift: depth) - 1.	pixelInByte _ 8 / depth.	bitsWidth _ width * depth + pad - 1 // pad * (pad / 8).	upBitsWidth _ width * 8 + pad - 1 // pad * (pad / 8).	stopWidth _ width * depth + 7 // 8.	trailingSize _ width - (stopWidth - 1 * pixelInByte).	upBits _ ByteArray new: upBitsWidth * height.	1 to: height do: [:i |		bitIndex _ i - 1 * bitsWidth.		upBitIndex _ i - 1 * upBitsWidth.		1 to: stopWidth - 1 do: [:j |			val _ bits at: (bitIndex _ bitIndex + 1).			upBitIndex _ upBitIndex + pixelInByte.			1 to: pixelInByte do: [:k |				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).				val _ val bitShift: depth negated]].		val _ (bits at: (bitIndex _ bitIndex + 1))				bitShift: depth negated * (pixelInByte - trailingSize).		upBitIndex _ upBitIndex + trailingSize.		1 to: trailingSize do: [:k |			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).			val _ val bitShift: depth negated]].	^ upBits! !!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know	about all possible image file types."	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ImageReadWriter class	instanceVariableNames: ''!!ImageReadWriter class methodsFor: 'instance creation'!on: aStream	"Answer an instance of the receiver for encoding and/or decoding images on the given."	^ self new on: aStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:59'!allTypicalFileExtensions	"Answer a collection of file extensions (lowercase) which files that my subclasses can read might commonly have"	"ImageReadWriter allTypicalFileExtensions"	| extensions |	extensions _ Set new.	self allSubclassesDo: [ :cls | extensions addAll: cls typicalFileExtensions ].	^extensions! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| stream |	stream _ FileStream readOnlyFileNamed: fileName.	^self formFromStream: stream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'sd 1/30/2004 15:18'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | subclass understandsImageFormat: aBinaryStream]		ifNone: [			aBinaryStream close.			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing'!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer _ self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk9/13/97 16:13'!putForm: aForm onStream: aWriteStream	"Store the given form on a file of the given name."	| writer |	writer _ self on: aWriteStream.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:55'!typicalFileExtensions	"Answer a collection of file extensions (lowercase) which files that I can read might commonly have"	^#()! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ar 6/16/2002 17:33'!understandsImageFormat: aStream	^(self new on: aStream) understandsImageFormat! !Notification subclass: #InMidstOfFileinNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!InMidstOfFileinNotification methodsFor: 'as yet unclassified' stamp: 'RAA 5/28/2001 17:07'!defaultAction	self resume: false! !DisplayObject subclass: #InfiniteForm	instanceVariableNames: 'patternForm'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!InfiniteForm commentStamp: '<historical>' prior: 0!I represent a Form obtained by replicating a pattern form indefinitely in all directions.!!InfiniteForm methodsFor: 'accessing' stamp: 'mjg 7/9/2001 14:12'!asColor	^ patternForm dominantColor! !!InfiniteForm methodsFor: 'accessing'!asForm	^ patternForm! !!InfiniteForm methodsFor: 'accessing' stamp: 'di 9/2/97 20:21'!dominantColor	^ patternForm dominantColor! !!InfiniteForm methodsFor: 'accessing'!offset 	"Refer to the comment in DisplayObject|offset."	^0 @ 0! !!InfiniteForm methodsFor: 'displaying' stamp: 'sw 2/16/98 03:42'!colorForInsets	^ Color transparent! !!InfiniteForm methodsFor: 'displaying' stamp: 'nk 4/17/2004 19:48'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the real display message, but it doesn't get used until the new	display protocol is installed."	| targetBox patternBox bb |	(patternForm isForm) ifFalse:		[^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm].	"Do it iteratively"	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.	patternBox _ patternForm boundingBox.	bb _ BitBlt current destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0		extent: patternBox extent clipRect: clipRectangle.	bb colorMap:		(patternForm colormapIfNeededFor: aDisplayMedium).	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			bb destOrigin: x@y; copyBits]]! !!InfiniteForm methodsFor: 'displaying' stamp: 'nk 4/17/2004 19:48'!displayOnPort: aPort at: offset	| targetBox patternBox savedMap top left |	self flag: #bob.	"this *may* not get called at the moment. I have been trying to figure out the right way for this to work and am using #displayOnPort:offsetBy: as my current offering - Bob"	(patternForm isForm) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox _ aPort clipRect.	patternBox _ patternForm boundingBox.	savedMap _ aPort colorMap.	aPort sourceForm: patternForm;		fillColor: nil;		combinationRule: Form paint;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededFor: aPort destForm).	top _ (targetBox top truncateTo: patternBox height) "- (offset y \\ patternBox height)".	left _  (targetBox left truncateTo: patternBox width) "- (offset x \\ patternBox width)".	left to: (targetBox right - 1) by: patternBox width do:		[:x | top to: (targetBox bottom - 1) by: patternBox height do:			[:y | aPort destOrigin: x@y; copyBits]].	aPort colorMap: savedMap.! !!InfiniteForm methodsFor: 'displaying' stamp: 'ar 8/16/2001 12:47'!raisedColor	^ Color transparent! !!InfiniteForm methodsFor: 'display box access'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	^0 @ 0 corner: SmallInteger maxVal @ SmallInteger maxVal! !!InfiniteForm methodsFor: 'private'!form: aForm	patternForm _ aForm! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'bolot 9/15/1999 10:13'!bitPatternForDepth: suspectedDepth	^ patternForm! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:56'!direction	^patternForm width @ 0! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:54'!form	"Bitmap fills respond to #form"	^patternForm! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:54'!isBitmapFill	^true! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:54'!isGradientFill	^false! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:59'!isOrientedFill	^true! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:54'!isSolidFill	^false! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 9/2/1999 14:32'!isTranslucent	"Return true since the bitmap may be translucent and we don't really want to check"	^true! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:57'!normal	^0 @ patternForm height! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:56'!origin	^0@0! !!InfiniteForm methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 10:50'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	"prevents a walkback when control menu is built for morph with me as color"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InfiniteForm class	instanceVariableNames: ''!!InfiniteForm class methodsFor: 'instance creation'!with: aForm 	"Answer an instance of me whose pattern form is the argument, aForm."	^self new form: aForm! !Object subclass: #InputSensor	instanceVariableNames: ''	classVariableNames: 'ButtonDecodeTable InterruptSemaphore InterruptWatcherProcess KeyDecodeTable'	poolDictionaries: ''	category: 'Kernel-Processes'!!InputSensor commentStamp: '<historical>' prior: 0!An InputSensor is an interface to the user input devices.There is at least one (sub)instance of InputSensor named Sensor in the system.Class variables:ButtonDecodeTable <ByteArray> - maps mouse buttons as reported by the VM to ones reported in the events.KeyDecodeTable <Dictionary<SmallInteger->SmallInteger>> - maps some keys and their modifiers to other keys (used for instance to map Ctrl-X to Alt-X)InterruptSemaphore <Semaphore> - signalled by the the VM and/or the event loop upon receiving an interrupt keystroke.InterruptWatcherProcess <Process> - waits on the InterruptSemaphore and then responds as appropriate.!!InputSensor methodsFor: 'accessing' stamp: 'ar 10/11/2000 17:34'!eventQueue	^nil! !!InputSensor methodsFor: 'accessing' stamp: 'ar 10/11/2000 17:35'!eventQueue: aSharedQueue! !!InputSensor methodsFor: 'accessing' stamp: 'JMM 10/5/2001 12:54'!flushAllButDandDEvents! !!InputSensor methodsFor: 'cursor' stamp: 'di 4/13/2000 12:15'!currentCursor	"The current cursor is maintained in class Cursor."	^ Cursor currentCursor! !!InputSensor methodsFor: 'cursor' stamp: 'di 4/13/2000 12:16'!currentCursor: newCursor 	"The current cursor is maintained in class Cursor."	Cursor currentCursor: newCursor.! !!InputSensor methodsFor: 'cursor'!cursorPoint	"Answer a Point indicating the cursor location."	^self mousePoint! !!InputSensor methodsFor: 'cursor'!cursorPoint: aPoint 	"Set aPoint to be the current cursor location."	^self primCursorLocPut: aPoint! !!InputSensor methodsFor: 'initialize' stamp: 'ar 9/26/2000 21:35'!flushEvents	"Do nothing"! !!InputSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 19:45'!shutDown	InterruptWatcherProcess ifNotNil: [		InterruptWatcherProcess terminate.		InterruptWatcherProcess _ nil ].! !!InputSensor methodsFor: 'initialize' stamp: 'ar 7/23/2000 00:00'!startUp	self installInterruptWatcher.! !!InputSensor methodsFor: 'keyboard'!flushKeyboard	"Remove all characters from the keyboard buffer."	[self keyboardPressed]		whileTrue: [self keyboard]! !!InputSensor methodsFor: 'keyboard'!keyboard	"Answer the next character from the keyboard."	^ self characterForKeycode: self primKbdNext! !!InputSensor methodsFor: 'keyboard'!keyboardPeek	"Answer the next character in the keyboard buffer without removing it, or nil if it is empty."	^ self characterForKeycode: self primKbdPeek! !!InputSensor methodsFor: 'keyboard'!keyboardPressed	"Answer true if keystrokes are available."	^self primKbdPeek notNil! !!InputSensor methodsFor: 'modifier keys'!commandKeyPressed	"Answer whether the command key on the keyboard is being held down."	^ self primMouseButtons anyMask: 64! !!InputSensor methodsFor: 'modifier keys'!controlKeyPressed	"Answer whether the control key on the keyboard is being held down."	^ self primMouseButtons anyMask: 16! !!InputSensor methodsFor: 'modifier keys'!leftShiftDown	"Answer whether the shift key on the keyboard is being held down. The name of this message is a throwback to the Alto, which had independent left and right shift keys."	^ self primMouseButtons anyMask: 8! !!InputSensor methodsFor: 'modifier keys' stamp: 'jm 5/21/1998 16:13'!shiftPressed	"Answer whether the shift key on the keyboard is being held down."	^ self primMouseButtons anyMask: 8! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:24'!anyButtonPressed	"Answer whether at least one mouse button is currently being pressed."	^ self primMouseButtons anyMask: 7! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:24'!blueButtonPressed	"Answer whether only the blue mouse button is being pressed. 	This is the third mouse button or cmd+click on the Mac."	^ (self primMouseButtons bitAnd: 7) = 1! !!InputSensor methodsFor: 'mouse'!mousePoint	"Answer a Point indicating the coordinates of the current mouse location."	^self primMousePt! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:02'!noButtonPressed	"Answer whether any mouse button is not being pressed."	^self anyButtonPressed not! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:16'!redButtonPressed	"Answer true if only the red mouse button is being pressed.	This is the first mouse button, usually the left one."	^ (self primMouseButtons bitAnd: 7) = 4! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:22'!waitButton	"Wait for the user to press any mouse button and then answer with the 	current location of the cursor."	| delay |	delay _ Delay forMilliseconds: 50.	[self anyButtonPressed] whileFalse: [ delay wait ].	^self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:22'!waitButtonOrKeyboard	"Wait for the user to press either any mouse button or any key. 	Answer the current cursor location or nil if a keypress occured."	| delay |	delay := Delay forMilliseconds: 50.	[self anyButtonPressed]		whileFalse: [delay wait.			self keyboardPressed				ifTrue: [^ nil]].	^ self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:25'!waitNoButton	"Wait for the user to release any mouse button and then answer the current location of the cursor."	| delay |	delay _ Delay forMilliseconds: 50.	[self anyButtonPressed] whileTrue: [ delay wait].	^self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:05'!yellowButtonPressed	"Answer whether only the yellow mouse button is being pressed. 	This is the second mouse button or option+click on the Mac."	^ (self primMouseButtons bitAnd: 7) = 2! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/13/1999 11:02'!tabletExtent	"Answer the full tablet extent in tablet coordinates."	| params |	params _ self primTabletGetParameters: 1.	params ifNil: [^ self error: 'no tablet available'].	^ (params at: 1)@(params at: 2)! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/13/1999 11:12'!tabletPoint	"Answer the current position of the first tablet pointing device (pen, puck, or eraser) in tablet coordinates."	| data |	data _ self primTabletRead: 1.  "state of first/primary pen"	^ (data at: 3) @ (data at: 4)! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/12/1999 13:05'!tabletPressure	"Answer the current pressure of the first tablet pointing device (pen, puck, or eraser), a number between 0.0 (no pressure) and 1.0 (max pressure)"	| params data |	params _ self primTabletGetParameters: 1.	params ifNil: [^ self].	data _ self primTabletRead: 1.  "state of first/primary pen"	^ (data at: 10) asFloat / ((params at: 10) - 1)! !!InputSensor methodsFor: 'user interrupts' stamp: 'nk 4/12/2004 19:36'!eventTicklerProcess	"Answer my event tickler process, if any"	^nil! !!InputSensor methodsFor: 'user interrupts' stamp: 'nk 6/21/2004 10:41'!installInterruptWatcher	"Initialize the interrupt watcher process. Terminate the old process if any."	"Sensor installInterruptWatcher"	InterruptWatcherProcess ifNotNil: [InterruptWatcherProcess terminate].	InterruptSemaphore _ Semaphore new.	InterruptWatcherProcess _ [self userInterruptWatcher] forkAt: Processor lowIOPriority.	self primInterruptSemaphore: InterruptSemaphore.! !!InputSensor methodsFor: 'user interrupts' stamp: 'nk 10/28/2000 20:33'!interruptWatcherProcess	"Answer my interrupt watcher process, if any"	^InterruptWatcherProcess! !!InputSensor methodsFor: 'user interrupts'!setInterruptKey: anInteger	"Register the given keycode as the user interrupt key."	self primSetInterruptKey: anInteger.! !!InputSensor methodsFor: 'user interrupts' stamp: 'di 2/4/1999 15:24'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Display deferUpdates: false.		Smalltalk at: #SoundPlayer ifPresent: [:theClass | theClass shutDown].		Smalltalk handleUserInterrupt]! !!InputSensor methodsFor: 'private'!characterForKeycode: keycode	"Map the given keycode to a Smalltalk character object. Encoding:		A keycode is 12 bits:   <4 modifer bits><8 bit ISO character>		Modifier bits are:       <command><option><control><shift>"	"NOTE: the command and option keys are specific to the Macintosh and may not have equivalents on other platforms."	keycode = nil ifTrue: [ ^nil ].	keycode class = Character ifTrue: [ ^keycode ].  "to smooth the transition!!"	^ Character value: (keycode bitAnd: 16rFF)! !!InputSensor methodsFor: 'private'!primCursorLocPut: aPoint	"If the primitive fails, try again with a rounded point."	<primitive: 91>	^ self primCursorLocPutAgain: aPoint rounded! !!InputSensor methodsFor: 'private'!primCursorLocPutAgain: aPoint	"Do nothing if primitive is not implemented."	<primitive: 91>	^ self! !!InputSensor methodsFor: 'private' stamp: 'ar 7/23/2000 15:38'!primInterruptSemaphore: aSemaphore 	"Primitive. Install the argument as the semaphore to be signalled whenever the user presses the interrupt key. The semaphore will be signaled once each time the interrupt key is pressed."	<primitive: 134>	^self primitiveFailed"Note: This primitive is obsolete with the new event driven architecture in which EventSensor can handle the interrupts itself. However, for supporting older images running on newer VMs the primitive must still be implemented."! !!InputSensor methodsFor: 'private'!primKbdNext	<primitive: 108>	^ nil! !!InputSensor methodsFor: 'private'!primKbdPeek	<primitive: 109>	^ nil! !!InputSensor methodsFor: 'private'!primMouseButtons	<primitive: 107>	^ 0! !!InputSensor methodsFor: 'private'!primMousePt	"Primitive. Poll the mouse to find out its position. Return a Point. Fail if	event-driven tracking is used instead of polling. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 90>	^ 0@0! !!InputSensor methodsFor: 'private' stamp: 'ar 7/23/2000 15:38'!primSetInterruptKey: anInteger	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."	<primitive: 133>	^self primitiveFailed"Note: This primitive is obsolete with the new event driven architecture in which EventSensor can handle the interrupts itself. However, for supporting older images running on newer VMs the primitive must still be implemented."! !!InputSensor methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primTabletGetParameters: cursorIndex	"Answer the pen tablet parameters. For parameters that differ from cursor to cursor, answer those associated with the cursor having the given index. Answer nil if there is no pen tablet. The parameters are:	1. tablet width, in tablet units	2. tablet height, in tablet units	3. number of tablet units per inch	4. number of cursors (pens, pucks, etc; some tablets have more than one)	5. this cursor index	6. and 7. x scale and x offset for scaling tablet coordintes (e.g., to fit the screen)	8. and 9. y scale and y offset for scaling tablet coordintes  (e.g., to fit the screen)	10. number of pressure levels	11. presure threshold needed close pen tip switch 	12. number of pen tilt angles"	<primitive: 'primitiveGetTabletParameters' module: 'JoystickTabletPlugin'>	^ nil! !!InputSensor methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primTabletRead: cursorIndex	"Answer the pen tablet data for the cursor having the given index. Answer nil if there is no pen tablet. The data is:	1. index of the cursor to which this data applies	2. timestamp of the last state chance for this cursor	3., 4., and 5. x, y, and z coordinates of the cursor (z is typically 0)	6. and 7. xTilt and yTilt of the cursor; (signed)	8. type of cursor (0 = unknown, 1 = pen, 2 = puck, 3 = eraser)	9. cursor buttons	10. cursor pressure, downward	11. cursor pressure, tangential	12. flags"	<primitive: 'primitiveReadTablet' module: 'JoystickTabletPlugin'>	self primitiveFailed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InputSensor class	instanceVariableNames: ''!!InputSensor class methodsFor: 'public'!default	"Answer the default system InputSensor, Sensor."	^ Sensor! !!InputSensor class methodsFor: 'public' stamp: 'nk 7/11/2002 07:09'!installDuplicateKeyEntryFor: c	| key |	key _ c asInteger.	"first do control->alt key"	KeyDecodeTable at: { key bitAnd: 16r9F . 2 } put: { key . 8 }.	"then alt->alt key"	KeyDecodeTable at: { key . 8 } put: { key . 8 }! !!InputSensor class methodsFor: 'public' stamp: 'nk 2/11/2002 12:39'!installSwappedKeyEntryFor: c	| key |	key _ c asInteger.	"first do control->alt key"	KeyDecodeTable at: { key bitAnd: 16r9F . 2 } put: { key . 8 }.	"then alt->control key"	KeyDecodeTable at: { key . 8 } put: { key bitAnd: 16r9F . 2 }! !!InputSensor class methodsFor: 'class initialization' stamp: 'nk 7/11/2002 07:41'!defaultCrossPlatformKeys	"Answer a list of key letters that are used for common editing operations	on different platforms."	^{ $c . $x . $v . $a . $s . $f . $g . $z }! !!InputSensor class methodsFor: 'class initialization' stamp: 'nk 7/11/2002 07:41'!installKeyDecodeTable	"Create a decode table that swaps some keys if 	Preferences swapControlAndAltKeys is set"	KeyDecodeTable _ Dictionary new.	Preferences duplicateControlAndAltKeys 		ifTrue: [ self defaultCrossPlatformKeys do:				[ :c | self installDuplicateKeyEntryFor: c ] ].	Preferences swapControlAndAltKeys 		ifTrue: [ self defaultCrossPlatformKeys do:				[ :c | self installSwappedKeyEntryFor: c ] ].! !!InputSensor class methodsFor: 'class initialization' stamp: 'nk 2/10/2002 11:55'!installMouseDecodeTable	"Create a decode table that swaps the lowest-order 2 bits if 	Preferences swapMouseButtons is set"	ButtonDecodeTable _ Preferences swapMouseButtons				ifTrue: [ByteArray withAll:							((0 to: 255) collect: [:ea |								((ea bitAnd: 1) << 1									bitOr: (ea bitAnd: 2) >> 1)										bitOr: (ea bitAnd: 16rFC) ])]				ifFalse: [ByteArray						withAll: (0 to: 255)]! !!InputSensor class methodsFor: 'system startup' stamp: 'nk 6/21/2004 10:36'!shutDown	self default shutDown.! !!InputSensor class methodsFor: 'system startup' stamp: 'nk 2/10/2002 11:57'!startUp		self installMouseDecodeTable.	self installKeyDecodeTable.	self default startUp! !StringHolder subclass: #Inspector	instanceVariableNames: 'object selectionIndex timeOfLastListUpdate selectionUpdateTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!Inspector commentStamp: '<historical>' prior: 0!I represent a query path into the internal representation of an object. As a StringHolder, the string I represent is the value of the currently selected variable of the observed object.!!Inspector methodsFor: 'accessing'!baseFieldList	"Answer an Array consisting of 'self'	and the instance variable names of the inspected object."	^ (Array with: 'self' with: 'all inst vars')			, object class allInstVarNames! !!Inspector methodsFor: 'accessing'!fieldList	"Answer the base field list plus an abbreviated list of indices."	object class isVariable ifFalse: [^ self baseFieldList].	^ self baseFieldList ,		(object basicSize <= (self i1 + self i2)			ifTrue: [(1 to: object basicSize)						collect: [:i | i printString]]			ifFalse: [(1 to: self i1) , (object basicSize-(self i2-1) to: object basicSize)						collect: [:i | i printString]])! !!Inspector methodsFor: 'accessing'!i1	"This is the max index shown before skipping to the 	last i2 elements of very long arrays"	^ 100! !!Inspector methodsFor: 'accessing'!i2	"This is the number of elements to show at the end	of very long arrays"	^ 10! !!Inspector methodsFor: 'accessing' stamp: 'sw 5/22/96'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 250 @ 200! !!Inspector methodsFor: 'accessing' stamp: 'ajh 2/3/2003 19:19'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection."	| c |	c _ anObject inspectorClass.	(self class ~= c and: [self class format = c format]) ifTrue: [		self primitiveChangeClassTo: c basicNew].	self initialize.	object _ anObject.	selectionIndex _ 0.	contents _ ''! !!Inspector methodsFor: 'accessing' stamp: 'svp 3/14/2000 21:57'!modelWakeUpIn: aWindow	| newText |	self updateListsAndCodeIn: aWindow.	newText _ self contentsIsString		ifTrue: [newText _ self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/30/1999 23:59'!noteSelectionIndex: anInteger for: aSymbol	aSymbol == #fieldList		ifTrue:			[selectionIndex _ anInteger]! !!Inspector methodsFor: 'accessing'!object	"Answer the object being inspected by the receiver."	^object! !!Inspector methodsFor: 'accessing' stamp: 'hg 10/14/2001 16:20'!object: anObject 	"Set anObject to be the object being inspected by the receiver."	| oldIndex |	anObject == object		ifTrue: [self update]		ifFalse:			[oldIndex _ selectionIndex <= 2 ifTrue: [selectionIndex] ifFalse: [0].			self inspect: anObject.			oldIndex _ oldIndex min: self fieldList size.			self changed: #inspectObject.			oldIndex > 0				ifTrue: [self toggleIndex: oldIndex].			self changed: #fieldList.			self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:37'!selectedClass	"Answer the class of the receiver's current selection"	self selectionUnmodifiable ifTrue: [^ object class].	^ self selection class! !!Inspector methodsFor: 'accessing' stamp: 'svp 3/14/2000 21:57'!stepAt: millisecondClockValue in: aWindow	| newText |	(Preferences smartUpdating and: [(millisecondClockValue - self timeOfLastListUpdate) > 8000]) "Not more often than once every 8 seconds"		ifTrue:			[self updateListsAndCodeIn: aWindow.			timeOfLastListUpdate _ millisecondClockValue].	newText _ self contentsIsString		ifTrue: [newText _ self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'sma 6/15/2000 16:48'!stepTimeIn: aSystemWindow	^ (selectionUpdateTime ifNil: [0]) * 10 max: 1000! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/20/1999 15:54'!timeOfLastListUpdate	^ timeOfLastListUpdate ifNil: [timeOfLastListUpdate _ 0]! !!Inspector methodsFor: 'accessing' stamp: 'tk 4/10/1998 11:28'!trash	"What goes in the bottom pane"	^ ''! !!Inspector methodsFor: 'accessing' stamp: 'tk 6/11/1998 22:23'!trash: newText	"Don't save it"	^ true! !!Inspector methodsFor: 'accessing' stamp: 'hmm 7/12/2001 20:35'!update	"Reshow contents, assuming selected value may have changed."	selectionIndex = 0		ifFalse:			[self contentsIsString				ifTrue: [contents _ self selection]				ifFalse: [contents _ self selectionPrintString].			self changed: #contents.			self changed: #selection.			self changed: #selectionIndex]! !!Inspector methodsFor: 'accessing' stamp: 'di 1/13/1999 14:36'!wantsSteps	^ true! !!Inspector methodsFor: 'selecting' stamp: 'tk 4/13/1998 09:19'!accept: aString	| result |	result _ self doItReceiver class evaluatorClass new				evaluate: (ReadStream on: aString)				in: self doItContext				to: self doItReceiver				notifying: nil	"fix this"				ifFail:  [^ false].	result == #failedDoit ifFalse: 			[contents _ result printString.			self replaceSelectionValue: result.	"may put contents back"			self changed: #contents.			^ true].	^ false! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:24'!contentsIsString	"Hacked so contents empty when deselected and = long printString when item 2"	^ (selectionIndex = 2) | (selectionIndex = 0)! !!Inspector methodsFor: 'selecting' stamp: 'tk 4/13/1998 09:23'!replaceSelectionValue: anObject 	"The receiver has a list of variables of its inspected object. One of these 	is selected. The value of the selected variable is set to the value, 	anObject."	| basicIndex si |	selectionIndex <= 2 ifTrue: [		self toggleIndex: (si _ selectionIndex).  		self toggleIndex: si.		^ object].	object class isVariable		ifFalse: [^ object instVarAt: selectionIndex - 2 put: anObject].	basicIndex _ selectionIndex - 2 - object class instSize.	(object basicSize <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [^object basicAt: basicIndex put: anObject]		ifFalse: [^object basicAt: object basicSize - (self i1 + self i2) + basicIndex					put: anObject]! !!Inspector methodsFor: 'selecting' stamp: 'hg 10/8/2000 14:46'!selectedSlotName	^ self fieldList at: self selectionIndex! !!Inspector methodsFor: 'selecting' stamp: 'tk 4/10/1998 17:57'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	| basicIndex |	selectionIndex = 0 ifTrue: [^ ''].	selectionIndex = 1 ifTrue: [^ object].	selectionIndex = 2 ifTrue: [^ object longPrintString].	(selectionIndex - 2) <= object class instSize		ifTrue: [^ object instVarAt: selectionIndex - 2].	basicIndex _ selectionIndex - 2 - object class instSize.	(object basicSize <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [^ object basicAt: basicIndex]		ifFalse: [^ object basicAt: object basicSize - (self i1 + self i2) + basicIndex]! !!Inspector methodsFor: 'selecting'!selectionIndex	"The receiver has a list of variables of its inspected object. One of these 	is selected. Answer the index into the list of the selected variable."	^selectionIndex! !!Inspector methodsFor: 'selecting' stamp: 'sma 6/15/2000 16:45'!selectionPrintString	| text nm |	selectionUpdateTime _ [text _ [self selection printStringLimitedTo: 5000]		on: Error do: 		[nm _ self selectionIndex < 3					ifTrue: ['self']					ifFalse: [self selectedSlotName].		text _ ('<error in printString: evaluate "' , nm , ' printString" to debug>') asText.		text			addAttribute: TextColor red			from: 1			to: text size.		text]] timeToRun.	^ text! !!Inspector methodsFor: 'selecting'!selectionUnmodifiable	"Answer if the current selected variable is modifiable via acceptance in the code pane.  For most inspectors, no selection and a selection of self (selectionIndex = 1) are unmodifiable"	^ selectionIndex <= 2! !!Inspector methodsFor: 'selecting' stamp: 'sma 6/15/2000 16:50'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionUpdateTime _ 0.	selectionIndex = anInteger		ifTrue: 			["same index, turn off selection"			selectionIndex _ 0.			contents _ '']		ifFalse:			["different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [contents _ self selection]				ifFalse: [contents _ self selectionPrintString]].	self changed: #selection.	self changed: #contents.	self changed: #selectionIndex.! !!Inspector methodsFor: 'code'!doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^object! !!Inspector methodsFor: 'menu commands' stamp: 'BG 10/29/2003 08:14'!addCollectionItemsTo: aMenu	"If the current selection is an appropriate collection, add items to aMenu that cater to that kind of selection"	| sel |	((((sel _ self selection) isMemberOf: Array) or: [sel isMemberOf: OrderedCollection]) and: 		[sel size > 0]) ifTrue: [			aMenu addList: #(				('inspect element...'					inspectElement))].! !!Inspector methodsFor: 'menu commands' stamp: 'BG 10/28/2003 21:00'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.  If in mvc, an old-style protocol browser is opened instead."	Smalltalk isMorphic ifFalse: [^ self spawnProtocol].! !!Inspector methodsFor: 'menu commands' stamp: 'nk 7/24/2003 10:11'!chasePointers	| saved |	self selectionIndex == 0 ifTrue: [^ self changed: #flash].	saved _ self object.	[self object: nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: saved]		ifFalse: [self objectReferencesToSelection]]		ensure: [self object: saved]! !!Inspector methodsFor: 'menu commands' stamp: 'tk 4/10/1998 17:53'!classOfSelection	"Answer the class of the receiver's current selection"	self selectionUnmodifiable ifTrue: [^ object class].	^ self selection class! !!Inspector methodsFor: 'menu commands' stamp: 'sd 4/15/2003 16:14'!classVarRefs	"Request a browser of methods that store into a chosen instance variable"	| aClass |	(aClass _ self classOfSelection) ifNotNil:		[self systemNavigation  browseClassVarRefs: aClass].! !!Inspector methodsFor: 'menu commands' stamp: 'ar 1/15/2001 18:38'!copyName	"Copy the name of the current variable, so the user can paste it into the window below and work with is.  If collection, do (xxx at: 1). "	| sel aClass |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: selectionIndex - 2.	(self selection isKindOf: Collection) ifTrue: [sel _ '(',sel,' at: 1)'].	Clipboard clipboardText: sel asText.	"no undo allowed"! !!Inspector methodsFor: 'menu commands' stamp: 'sd 4/15/2003 16:14'!defsOfSelection	"Open a browser on all defining references to the selected instance variable, if that's what currently selected. "	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: self selectionIndex - 2.	self systemNavigation  browseAllStoresInto: sel from: aClass! !!Inspector methodsFor: 'menu commands' stamp: 'BG 10/28/2003 21:00'!fieldListMenu: aMenu	"Arm the supplied menu with items for the field-list of the receiver"	aMenu addList: #(		('inspect (i)'						inspectSelection)).	self addCollectionItemsTo: aMenu.	aMenu addList: #(		-		('method refs to this inst var'		referencesToSelection)		('methods storing into this inst var'	defsOfSelection)		('objects pointing to this value'		objectReferencesToSelection)		('chase pointers'					chasePointers)		-		('browse full (b)'					browseMethodFull)		('browse class'						browseClass)		('browse hierarchy'					classHierarchy)		('browse protocol (p)'				browseFullProtocol)		-		('inst var refs...'					browseInstVarRefs)		('inst var defs...'					browseInstVarDefs)		('class var refs...'					classVarRefs)		('class variables'					browseClassVariables)		('class refs (N)'						browseClassRefs)		-		('copy name (c)'					copyName)				('basic inspect'						inspectBasic)).	^ aMenu"			-			('alias for this value'			aliasForValue)			('watcher for this slot'			watcherForSlot)"! !!Inspector methodsFor: 'menu commands' stamp: 'tk 4/12/1998 08:49'!inspectBasic	"Bring up a non-special inspector"	selectionIndex = 0 ifTrue: [^ object basicInspect].	self selection basicInspect! !!Inspector methodsFor: 'menu commands' stamp: 'BG 11/1/2003 22:25'!inspectElement	| sel selSize countString count |	"Create and schedule an Inspector on an element of the receiver's model's currently selected collection."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	((sel _ self selection) isKindOf: SequenceableCollection) ifFalse:		[		^ sel inspect].	(selSize _ sel size) == 1 ifTrue: [^ sel first inspect].	selSize <= 15 ifTrue:		[count _ (SelectionMenu selections: (1 to: selSize) asArray) startUpWithCaption: 'which element?'.		count ifNil: [^ self] ifNotNil: [^ (sel at: count) inspect]].	countString _ FillInTheBlank request: 'Which element? (1 - ', selSize printString, ')' initialAnswer: '1'.	countString isEmptyOrNil ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	(count > 0 and: [count <= selSize])		ifTrue:			[(sel  at: count) inspect]		ifFalse:			[self beep]! !!Inspector methodsFor: 'menu commands' stamp: 'sw 1/14/2000 13:39'!inspectSelection	"Create and schedule an Inspector on the receiver's model's currently selected object."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	^ self selection inspect! !!Inspector methodsFor: 'menu commands' stamp: 'BG 8/18/2004 17:07'!inspectorKey: aChar from: view	"Respond to a Command key issued while the cursor is over my field list"	aChar == $i ifTrue: [^ self selection inspect].	aChar == $I ifTrue: [^ self selection explore].	aChar == $b ifTrue:	[^ self browseMethodFull].	aChar == $h ifTrue:	[^ self classHierarchy].	aChar == $c ifTrue: [^ self copyName].	aChar == $p ifTrue: [^ self browseFullProtocol].	aChar == $N ifTrue: [^ self browseClassRefs].	"aChar == $t ifTrue: [^ self tearOffTile]."	aChar == $v ifTrue: [^ self viewerForValue].	^ self arrowKey: aChar from: view! !!Inspector methodsFor: 'menu commands' stamp: 'sd 4/16/2003 11:41'!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  "	self selectionIndex == 0 ifTrue: [^ self changed: #flash].	self systemNavigation		browseAllObjectReferencesTo: self selection		except: (Array with: self object)		ifNone: [:obj | self changed: #flash].! !!Inspector methodsFor: 'menu commands' stamp: 'sd 4/15/2003 16:14'!referencesToSelection	"Open a browser on all references to the selected instance variable, if that's what currently selected.  1/25/96 sw"	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: self selectionIndex - 2.	self systemNavigation   browseAllAccessesTo: sel from: aClass! !!Inspector methodsFor: 'menu commands' stamp: 'sw 12/11/2000 15:52'!spawnFullProtocol	"Spawn a window showing full protocol for the receiver's selection"	| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openFullProtocolForClass: objectToRepresent class! !!Inspector methodsFor: 'menu commands' stamp: 'sw 12/11/2000 15:52'!spawnProtocol	"Spawn a protocol on browser on the receiver's selection"	| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openSubProtocolForClass: objectToRepresent class! !!Inspector methodsFor: 'menu commands' stamp: 'sw 10/23/2000 18:27'!viewerForValue	"Open up a viewer on the value of the receiver's current selection"	| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	objectToRepresent beViewed	! !!Inspector methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:47'!convertToCurrentVersion: varDict refStream: smartRefStrm		timeOfLastListUpdate ifNil: [timeOfLastListUpdate _ 0].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Inspector class	instanceVariableNames: ''!!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/19/1999 14:38'!horizontalDividerProportion	^ 0.3! !!Inspector class methodsFor: 'instance creation'!inspect: anObject 	"Answer an instance of me to provide an inspector for anObject."	^self new inspect: anObject! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval 	"Create and schedule an instance of me on the model, anInspector. "	^ self openOn: anObject withEvalPane: withEval withLabel: anObject defaultLabelForInspector! !!Inspector class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 14:56'!openOn: anObject withEvalPane: withEval withLabel: label
        
        ^ self openOn: anObject 
                withEvalPane: withEval 
                withLabel: label 
                valueViewClass: PluggableTextView
! !!Inspector class methodsFor: 'instance creation' stamp: 'di 2/16/2000 10:52'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass inheritsFrom: FormView) ifTrue: [		valueView model: inspector].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView setUpdatablePanesFrom: #(fieldList).	topView controller open! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/19/1999 14:38'!verticalDividerProportion	^ 0.7! !Inspector subclass: #InspectorBrowser	instanceVariableNames: 'fieldList msgList msgListIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 4/16/1998 15:51'!fieldList	fieldList ifNotNil: [^ fieldList].	^ (fieldList _ super fieldList)! !!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 4/16/1998 15:52'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject."	fieldList _ nil.	super inspect: anObject.	msgListIndex _ 0.	self changed: #msgText! !!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 4/17/1998 10:19'!msgList	msgList ifNotNil: [^ msgList].	^ (msgList _ object class selectors asSortedCollection asArray)! !!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 4/16/1998 14:18'!msgListIndex 	^msgListIndex! !!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 4/16/1998 14:38'!msgText	msgListIndex = 0 ifTrue: [^ nil].	^ object class sourceCodeAt: (msgList at: msgListIndex)! !!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 4/18/1998 09:48'!step	| list fieldString msg |	(list _ super fieldList) = fieldList ifFalse:		[fieldString _ selectionIndex > 0 ifTrue: [fieldList at: selectionIndex] ifFalse: [nil].		fieldList _ list.		selectionIndex _ fieldList indexOf: fieldString ifAbsent: [0].		self changed: #fieldList.		self changed: #selectionIndex].	list _ msgList.  msgList _ nil.  "force recomputation"		list = self msgList ifFalse:		[msg _ msgListIndex > 0 ifTrue: [list at: msgListIndex] ifFalse: [nil].		msgListIndex _ msgList indexOf: msg ifAbsent: [0].		self changed: #msgList.		self changed: #msgListIndex].	super step! !!InspectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 1/14/1999 09:01'!wantsSteps	^ true! !Object subclass: #InstructionClient	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!InstructionClient commentStamp: 'md 4/8/2003 12:50' prior: 0!My job is to make it easier to implement clients for InstructionStream. See InstVarRefLocatoras an example. !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!blockReturnTop	"Return Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!doDup	"Duplicate Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!doPop	"Remove Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!jump: offset	"Unconditional Jump bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!jump: offset if: condition 	"Conditional Jump bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!methodReturnConstant: value 	"Return Constant bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:02'!methodReturnReceiver	"Return Self bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!methodReturnTop	"Return Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!popIntoLiteralVariable: anAssociation 	"Remove Top Of Stack And Store Into Literal Variable bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!popIntoReceiverVariable: offset 	"Remove Top Of Stack And Store Into Instance Variable bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!popIntoTemporaryVariable: offset 	"Remove Top Of Stack And Store Into Temporary Variable bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!pushActiveContext	"Push Active Context On Top Of Its Own Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!pushConstant: value	"Push Constant, value, on Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!pushLiteralVariable: anAssociation	"Push Contents Of anAssociation On Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!pushReceiver	"Push Active Context's Receiver on Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:03'!pushReceiverVariable: offset	"Push Contents Of the Receiver's Instance Variable Whose Index 	is the argument, offset, On Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:04'!pushTemporaryVariable: offset	"Push Contents Of Temporary Variable Whose Index Is the 	argument, offset, On Top Of Stack bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:04'!send: selector super: supered numArgs: numberArguments	"Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:04'!storeIntoLiteralVariable: anAssociation 	"Store Top Of Stack Into Literal Variable Of Method bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:04'!storeIntoReceiverVariable: offset 	"Store Top Of Stack Into Instance Variable Of Method bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 13:04'!storeIntoTemporaryVariable: offset 	"Store Top Of Stack Into Temporary Variable Of Method bytecode."! !InstructionClient subclass: #InstructionPrinter	instanceVariableNames: 'method scanner stream oldPC indent'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!InstructionPrinter commentStamp: 'md 4/8/2003 12:47' prior: 0!My instances can print the object code of a CompiledMethod in symbolic format. They print into an instance variable, stream, and uses oldPC to determine how many bytes to print in the listing. The variable method  is used to hold the method being printed.!!InstructionPrinter methodsFor: 'accessing' stamp: 'ajh 6/27/2003 22:25'!indent	^ indent ifNil: [0]! !!InstructionPrinter methodsFor: 'accessing' stamp: 'md 4/8/2003 11:20'!method	^method.! !!InstructionPrinter methodsFor: 'accessing' stamp: 'md 4/8/2003 11:20'!method: aMethod	method :=  aMethod.! !!InstructionPrinter methodsFor: 'initialize-release' stamp: 'ajh 2/9/2003 14:16'!indent: numTabs	indent _ numTabs! !!InstructionPrinter methodsFor: 'initialize-release' stamp: 'md 4/8/2003 11:19'!printInstructionsOn: aStream 	"Append to the stream, aStream, a description of each bytecode in the 	instruction stream."		| end |	stream _ aStream.	scanner _ InstructionStream on: method.	end _ method endPC.	oldPC _ scanner pc.	[scanner pc <= end]		whileTrue: [scanner interpretNextInstructionFor: self]! !!InstructionPrinter methodsFor: 'instruction decoding'!blockReturnTop	"Print the Return Top Of Stack bytecode."	self print: 'blockReturn'! !!InstructionPrinter methodsFor: 'instruction decoding'!doDup	"Print the Duplicate Top Of Stack bytecode."	self print: 'dup'! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 12:14'!doPop	"Print the Remove Top Of Stack bytecode."	self print: 'pop'! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 11:13'!jump: offset	"Print the Unconditional Jump bytecode."	self print: 'jumpTo: ' , (scanner pc + offset) printString! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'md 4/8/2003 11:13'!jump: offset if: condition 	"Print the Conditional Jump bytecode."	self print: 		(condition			ifTrue: ['jumpTrue: ']			ifFalse: ['jumpFalse: '])			, (scanner pc + offset) printString! !!InstructionPrinter methodsFor: 'instruction decoding'!methodReturnConstant: value 	"Print the Return Constant bytecode."	self print: 'return: ' , value printString! !!InstructionPrinter methodsFor: 'instruction decoding'!methodReturnReceiver	"Print the Return Self bytecode."	self print: 'returnSelf'! !!InstructionPrinter methodsFor: 'instruction decoding'!methodReturnTop	"Print the Return Top Of Stack bytecode."	self print: 'returnTop'! !!InstructionPrinter methodsFor: 'instruction decoding'!popIntoLiteralVariable: anAssociation 	"Print the Remove Top Of Stack And Store Into Literal Variable bytecode."	self print: 'popIntoLit: ' , anAssociation key! !!InstructionPrinter methodsFor: 'instruction decoding'!popIntoReceiverVariable: offset 	"Print the Remove Top Of Stack And Store Into Instance Variable 	bytecode."	self print: 'popIntoRcvr: ' , offset printString! !!InstructionPrinter methodsFor: 'instruction decoding'!popIntoTemporaryVariable: offset 	"Print the Remove Top Of Stack And Store Into Temporary Variable 	bytecode."	self print: 'popIntoTemp: ' , offset printString! !!InstructionPrinter methodsFor: 'instruction decoding'!pushActiveContext	"Print the Push Active Context On Top Of Its Own Stack bytecode."	self print: 'pushThisContext: '! !!InstructionPrinter methodsFor: 'instruction decoding'!pushLiteralVariable: anAssociation	"Print the Push Contents Of anAssociation On Top Of Stack bytecode."	self print: 'pushLit: ' , anAssociation key! !!InstructionPrinter methodsFor: 'instruction decoding'!pushReceiver	"Print the Push Active Context's Receiver on Top Of Stack bytecode."	self print: 'self'! !!InstructionPrinter methodsFor: 'instruction decoding'!pushReceiverVariable: offset	"Print the Push Contents Of the Receiver's Instance Variable Whose Index 	is the argument, offset, On Top Of Stack bytecode."	self print: 'pushRcvr: ' , offset printString! !!InstructionPrinter methodsFor: 'instruction decoding'!pushTemporaryVariable: offset	"Print the Push Contents Of Temporary Variable Whose Index Is the 	argument, offset, On Top Of Stack bytecode."	self print: 'pushTemp: ' , offset printString! !!InstructionPrinter methodsFor: 'instruction decoding'!send: selector super: supered numArgs: numberArguments	"Print the Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."	self print: (supered ifTrue: ['superSend: '] ifFalse: ['send: ']) , selector! !!InstructionPrinter methodsFor: 'instruction decoding'!storeIntoLiteralVariable: anAssociation 	"Print the Store Top Of Stack Into Literal Variable Of Method bytecode."	self print: 'storeIntoLit: ' , anAssociation key! !!InstructionPrinter methodsFor: 'instruction decoding'!storeIntoReceiverVariable: offset 	"Print the Store Top Of Stack Into Instance Variable Of Method bytecode."	self print: 'storeIntoRcvr: ' , offset printString! !!InstructionPrinter methodsFor: 'instruction decoding'!storeIntoTemporaryVariable: offset 	"Print the Store Top Of Stack Into Temporary Variable Of Method 	bytecode."	self print: 'storeIntoTemp: ' , offset printString! !!InstructionPrinter methodsFor: 'printing' stamp: 'ajh 6/27/2003 22:26'!print: instruction 	"Append to the receiver a description of the bytecode, instruction." 	| code |	stream tab: self indent; print: oldPC; space.	stream nextPut: $<.	oldPC to: scanner pc - 1 do: 		[:i | 		code _ (method at: i) radix: 16.		stream nextPut: 			(code size < 5				ifTrue: [$0]				ifFalse: [code at: 4]).		stream nextPut: code last; space].	stream skip: -1.	stream nextPut: $>.	stream space.	stream nextPutAll: instruction.	stream cr.	oldPC _ scanner pc.	"(InstructionPrinter compiledMethodAt: #print:) symbolic."! !!InstructionPrinter methodsFor: 'printing' stamp: 'ajh 6/27/2003 22:26'!pushConstant: obj	"Print the Push Constant, obj, on Top Of Stack bytecode."	self print: 'pushConstant: ' , (String streamContents: [:s |		(obj isKindOf: LookupKey)			ifFalse: [s withStyleFor: #literal do: [obj printOn: s]]			ifTrue: [obj key				ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]				ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]	]).	(obj isKindOf: CompiledMethod) ifTrue: [		obj longPrintOn: stream indent: self indent + 2. ^ self].	Smalltalk at: #BlockClosure ifPresent:[:aClass|		(obj isKindOf: aClass) ifTrue: [			obj method longPrintOn: stream indent: self indent + 2. ^ self]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InstructionPrinter class	instanceVariableNames: ''!!InstructionPrinter class methodsFor: 'printing' stamp: 'md 4/8/2003 11:19'!on: aMethod	^self new method: aMethod.	! !!InstructionPrinter class methodsFor: 'printing'!printClass: class 	"Create a file whose name is the argument followed by '.bytes'. Store on 	the file the symbolic form of the compiled methods of the class."	| file |	file _ FileStream newFileNamed: class name , '.bytes'.	class selectors do: 		[:sel | 		file cr; nextPutAll: sel; cr.		(self on: (class compiledMethodAt: sel)) printInstructionsOn: file].	file close	"InstructionPrinter printClass: Parser."! !Object subclass: #InstructionStream	instanceVariableNames: 'sender pc'	classVariableNames: 'SpecialConstants'	poolDictionaries: ''	category: 'Kernel-Methods'!!InstructionStream commentStamp: '<historical>' prior: 0!My instances can interpret the byte-encoded Smalltalk instruction set. They maintain a program counter (pc) for streaming through CompiledMethods. My subclasses are Contexts, which inherit this capability. They store the return pointer in the instance variable sender, and the current position in their method in the instance variable pc. For other users, sender can hold a method to be similarly interpreted. The unclean re-use of sender to hold the method was to avoid a trivial subclass for the stand-alone scanning function.!!InstructionStream methodsFor: 'testing'!willJumpIfFalse	"Answer whether the next bytecode is a jump-if-false."	| byte |	byte _ self method at: pc.	^(byte between: 152 and: 159) or: [byte between: 172 and: 175]! !!InstructionStream methodsFor: 'testing' stamp: 'di 1/29/2000 14:42'!willJumpIfTrue 	"Answer whether the next bytecode is a jump-if-true." 	| byte |	byte _ self method at: pc.	^ byte between: 168 and: 171! !!InstructionStream methodsFor: 'testing' stamp: 'sn 8/22/97 21:55'!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte _ self method at: pc.	byte < 128 ifTrue: [^false].	byte == 200 ifTrue: [^false].	byte >= 176 ifTrue: [^true].	"special send or short send"	^byte between: 131 and: 134	"long sends"! !!InstructionStream methodsFor: 'testing'!willReturn	"Answer whether the next bytecode is a return."	^(self method at: pc) between: 120 and: 125! !!InstructionStream methodsFor: 'testing' stamp: 'hmm 7/15/2001 22:00'!willStore	"Answer whether the next bytecode is a store or store-pop"	| byte |	byte _ self method at: pc.	^(byte between: 96 and: 132) and: [		byte <= 111 or: [byte >= 129 and: [			byte <= 130 or: [byte = 132 and: [				(self method at: pc+1) >= 160]]]]]! !!InstructionStream methodsFor: 'testing'!willStorePop	"Answer whether the next bytecode is a store-pop."	| byte |	byte _ self method at: pc.	^byte = 130 or: [byte between: 96 and: 111]! !!InstructionStream methodsFor: 'decoding' stamp: 'ajh 7/29/2001 20:45'!atEnd	^ pc > self method endPC! !!InstructionStream methodsFor: 'decoding'!interpretJump	| byte |	byte _ self method at: pc.	(byte between: 144 and: 151) ifTrue:		[pc _ pc + 1. ^byte - 143].	(byte between: 160 and: 167) ifTrue:		[pc _ pc + 2. ^(byte - 164) * 256 + (self method at: pc - 1)].	^nil! !!InstructionStream methodsFor: 'decoding'!interpretNextInstructionFor: client 	"Send to the argument, client, a message that specifies the type of the 	next instruction."	| byte type offset method |	method _ self method.  	byte _ method at: pc.	type _ byte // 16.  	offset _ byte \\ 16.  	pc _ pc+1.	type=0 ifTrue: [^client pushReceiverVariable: offset].	type=1 ifTrue: [^client pushTemporaryVariable: offset].	type=2 ifTrue: [^client pushConstant: (method literalAt: offset+1)].	type=3 ifTrue: [^client pushConstant: (method literalAt: offset+17)].	type=4 ifTrue: [^client pushLiteralVariable: (method literalAt: offset+1)].	type=5 ifTrue: [^client pushLiteralVariable: (method literalAt: offset+17)].	type=6 		ifTrue: [offset<8					ifTrue: [^client popIntoReceiverVariable: offset]					ifFalse: [^client popIntoTemporaryVariable: offset-8]].	type=7		ifTrue: [offset=0 ifTrue: [^client pushReceiver].				offset<8 ifTrue: [^client pushConstant: (SpecialConstants at: offset)].				offset=8 ifTrue: [^client methodReturnReceiver].				offset<12 ifTrue: [^client methodReturnConstant: 												(SpecialConstants at: offset-8)].				offset=12 ifTrue: [^client methodReturnTop].				offset=13 ifTrue: [^client blockReturnTop].				offset>13 ifTrue: [^self error: 'unusedBytecode']].	type=8 ifTrue: [^self interpretExtension: offset in: method for: client].	type=9		ifTrue:  "short jumps"			[offset<8 ifTrue: [^client jump: offset+1].			^client jump: offset-8+1 if: false].	type=10 		ifTrue:  "long jumps"			[byte_ method at: pc.  pc_ pc+1.			offset<8 ifTrue: [^client jump: offset-4*256 + byte].			^client jump: (offset bitAnd: 3)*256 + byte if: offset<12].	type=11 		ifTrue: 			[^client 				send: (Smalltalk specialSelectorAt: offset+1) 				super: false				numArgs: (Smalltalk specialNargsAt: offset+1)].	type=12 		ifTrue: 			[^client 				send: (Smalltalk specialSelectorAt: offset+17) 				super: false				numArgs: (Smalltalk specialNargsAt: offset+17)].	type>12		ifTrue: 			[^client send: (method literalAt: offset+1) 					super: false					numArgs: type-13]! !!InstructionStream methodsFor: 'scanning'!addSelectorTo: set 	"If this instruction is a send, add its selector to set."	| byte literalNumber byte2 |	byte _ self method at: pc.	byte < 128 ifTrue: [^self].	byte >= 176		ifTrue: 			["special byte or short send"			byte >= 208				ifTrue: [set add: (self method literalAt: (byte bitAnd: 15) + 1)]				ifFalse: [set add: (Smalltalk specialSelectorAt: byte - 176 + 1)]]		ifFalse: 			[(byte between: 131 and: 134)				ifTrue: 					[byte2 _ self method at: pc + 1.					byte = 131 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].					byte = 132 ifTrue: [byte2 < 64 ifTrue: [set add: (self method literalAt: (self method at: pc + 2) + 1)]].					byte = 133 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].					byte = 134 ifTrue: [set add: (self method literalAt: byte2 \\ 64 + 1)]]]! !!InstructionStream methodsFor: 'scanning'!followingByte	"Answer the next bytecode."	^self method at: pc + 1! !!InstructionStream methodsFor: 'scanning'!method	"Answer the compiled method that supplies the receiver's bytecodes."	^sender		"method access when used alone (not as part of a context)"! !!InstructionStream methodsFor: 'scanning'!nextByte	"Answer the next bytecode."	^self method at: pc! !!InstructionStream methodsFor: 'scanning' stamp: 'ajh 7/18/2003 21:32'!nextInstruction	"Return the next bytecode instruction as a message that an InstructionClient would understand.  This advances the pc by one instruction."	^ self interpretNextInstructionFor: MessageCatcher new! !!InstructionStream methodsFor: 'scanning'!pc	"Answer the index of the next bytecode."	^pc! !!InstructionStream methodsFor: 'scanning' stamp: 'ajh 7/18/2003 21:29'!previousPc	| currentPc dummy prevPc |	currentPc _ pc.	pc _ self method initialPC.	dummy _ MessageCatcher new.	[pc = currentPc] whileFalse: [		prevPc _ pc.		self interpretNextInstructionFor: dummy.	].	^ prevPc! !!InstructionStream methodsFor: 'scanning'!scanFor: scanBlock 	"Answer the index of the first bytecode for which scanBlock answer true 	when supplied with that bytecode."	| method end byte type |	method _ self method.	end _ method endPC.	[pc <= end]		whileTrue: 			[(scanBlock value: (byte _ method at: pc)) ifTrue: [^true].			type _ byte // 16.			pc _ 				type = 8					ifTrue: ["extensions"							pc + (#(2 2 2 2 3 2 2 1 1 1 ) at: byte \\ 16 + 1)]					ifFalse: [type = 10								ifTrue: [pc + 2"long jumps"]								ifFalse: [pc + 1]]].	^false! !!InstructionStream methodsFor: 'scanning' stamp: 'hmm 7/29/2001 21:25'!skipBackBeforeJump	"Assuming that the receiver is positioned jast after a jump, skip back one or two bytes, depending on the size of the previous jump instruction."	| strm short |	strm _ InstructionStream on: self method.	(strm scanFor: [:byte |		((short _ byte between: 152 and: 159) or: [byte between: 168 and: 175])			and: [strm pc = (short ifTrue: [pc-1] ifFalse: [pc-2])]]) ifFalse: [self error: 'Where''s the jump??'].	self jump: (short ifTrue: [-1] ifFalse: [-2]).! !!InstructionStream methodsFor: 'scanning'!thirdByte	"Answer the next bytecode."	^self method at: pc + 2! !!InstructionStream methodsFor: 'private'!interpretExtension: offset in: method for: client	| type offset2 byte2 byte3 |	offset <=6 ifTrue: 		["Extended op codes 128-134"		byte2 _ method at: pc.		pc _ pc + 1.		offset <= 2 ifTrue:			["128-130:  extended pushes and pops"			type _ byte2 // 64.			offset2 _ byte2 \\ 64.			offset = 0 ifTrue: 				[type = 0 ifTrue: [^ client pushReceiverVariable: offset2].				type = 1 ifTrue: [^ client pushTemporaryVariable: offset2].				type = 2  ifTrue: [^ client pushConstant: (method literalAt: offset2 + 1)].				type = 3 ifTrue: [^ client pushLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 1 ifTrue: 				[type = 0 ifTrue: [^ client storeIntoReceiverVariable: offset2].				type = 1 ifTrue: [^ client storeIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 2 ifTrue: 				[type = 0 ifTrue: [^ client popIntoReceiverVariable: offset2].				type = 1 ifTrue: [^ client popIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3  ifTrue: [^ client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].		"131-134: extended sends"		offset = 3 ifTrue:  "Single extended send"			[^ client send: (method literalAt: byte2 \\ 32 + 1)					super: false numArgs: byte2 // 32].		offset = 4 ifTrue:    "Double extended do-anything"			[byte3 _ method at: pc.  pc _ pc + 1.			type _ byte2 // 32.			type = 0 ifTrue: [^ client send: (method literalAt: byte3 + 1)									super: false numArgs: byte2 \\ 32].			type = 1 ifTrue: [^ client send: (method literalAt: byte3 + 1)									super: true numArgs: byte2 \\ 32].			type = 2 ifTrue: [^ client pushReceiverVariable: byte3].			type = 3 ifTrue: [^ client pushConstant: (method literalAt: byte3 + 1)].			type = 4 ifTrue: [^ client pushLiteralVariable: (method literalAt: byte3 + 1)].			type = 5 ifTrue: [^ client storeIntoReceiverVariable: byte3].			type = 6 ifTrue: [^ client popIntoReceiverVariable: byte3].			type = 7 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].		offset = 5 ifTrue:  "Single extended send to super"			[^ client send: (method literalAt: byte2 \\ 32 + 1)					super: true numArgs: byte2 // 32].		offset = 6 ifTrue:   "Second extended send"			[^ client send: (method literalAt: byte2 \\ 64 + 1)					super: false numArgs: byte2 // 64]].	offset = 7 ifTrue: [^ client doPop].	offset = 8 ifTrue: [^ client doDup].	offset = 9 ifTrue: [^ client pushActiveContext].	self error: 'unusedBytecode'! !!InstructionStream methodsFor: 'private'!method: method pc: startpc	sender _ method. 	"allows this class to stand alone as a method scanner"	pc _ startpc! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InstructionStream class	instanceVariableNames: ''!!InstructionStream class methodsFor: 'class initialization'!initialize	"Initialize an array of special constants returned by single-bytecode returns."	SpecialConstants _ 		(Array with: true with: false with: nil)			, (Array with: -1 with: 0 with: 1 with: 2)		"InstructionStream initialize."! !!InstructionStream class methodsFor: 'instance creation'!on: method 	"Answer an instance of me on the argument, method."	^self new method: method pc: method initialPC! !Number subclass: #Integer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Integer commentStamp: '<historical>' prior: 0!I am a common abstract superclass for all Integer implementations. My implementation subclasses are SmallInteger, LargePositiveInteger, and LargeNegativeInteger.	Integer division consists of:	/	exact division, answers a fraction if result is not a whole integer	//	answers an Integer, rounded towards negative infinity	\\	is modulo rounded towards negative infinity	quo: truncated division, rounded towards zero!!Integer methodsFor: 'testing'!even 	"Refer to the comment in Number|even."	^((self digitAt: 1) bitAnd: 1) = 0! !!Integer methodsFor: 'testing'!isInteger	"True for all subclasses of Integer."	^ true! !!Integer methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two."	^ (self bitAnd: self-1) = 0! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue:		[^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative].	^ aNumber adaptToInteger: self andSend: #*! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ (self digitAdd: aNumber) normalize]			ifFalse: [^ self digitSubtract: aNumber]].	^ aNumber adaptToInteger: self andSend: #+! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!- aNumber	"Refer to the comment in Number - "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ self digitSubtract: aNumber]			ifFalse: [^ (self digitAdd: aNumber) normalize]].	^ aNumber adaptToInteger: self andSend: #-! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!Integer methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!// aNumber 	| q |	#Numeric.	"Changed 200/01/19 For ANSI support."	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	self = 0 ifTrue: [^ 0].	q := self quo: aNumber.	"Refer to the comment in Number|//."	(q negative		ifTrue: [q * aNumber ~= self]		ifFalse: [q = 0 and: [self negative ~= aNumber negative]])		ifTrue: [^ q - 1"Truncate towards minus infinity."]		ifFalse: [^ q]! !!Integer methodsFor: 'arithmetic'!alignedTo: anInteger	"Answer the smallest number not less than receiver that is a multiple of anInteger."	^(self+anInteger-1//anInteger)*anInteger"5 alignedTo: 2""12 alignedTo: 3"! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng _ self negative == aNumber negative == false.		quo _ (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andSend: #<! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andSend: #=! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andSend: #>! !!Integer methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^(self lastDigit bitShift: 8) + (self digitAt: 1)! !!Integer methodsFor: 'truncation and round off' stamp: 'lr 11/4/2003 12:14'!atRandom	"Answer a random integer from 1 to self.  This implementation uses a	shared generator. Heavy users should their own implementation or use	Interval>atRandom: directly."	self = 0 ifTrue: [ ^0 ].	self < 0 ifTrue: [ ^self negated atRandom negated ].	^Collection mutexForPicking critical: [		self atRandom: Collection randomForPicking ]! !!Integer methodsFor: 'truncation and round off' stamp: 'sma 5/12/2000 12:35'!atRandom: aGenerator	"Answer a random integer from 1 to self picked from aGenerator."	^ aGenerator nextInt: self! !!Integer methodsFor: 'truncation and round off'!ceiling 	"Refer to the comment in Number|ceiling."! !!Integer methodsFor: 'truncation and round off'!floor 	"Refer to the comment in Number|floor."! !!Integer methodsFor: 'truncation and round off'!normalize 	"SmallInts OK; LgInts override"	^ self! !!Integer methodsFor: 'truncation and round off'!rounded 	"Refer to the comment in Number|rounded."! !!Integer methodsFor: 'truncation and round off'!truncated 	"Refer to the comment in Number|truncated."! !!Integer methodsFor: 'enumerating'!timesRepeat: aBlock 	"Evaluate the argument, aBlock, the number of times represented by the 	receiver."	| count |	count _ 1.	[count <= self]		whileTrue: 			[aBlock value.			count _ count + 1]! !!Integer methodsFor: 'mathematical functions' stamp: 'di 4/22/1998 14:45'!factorial	"Answer the factorial of the receiver."	self = 0 ifTrue: [^ 1].	self > 0 ifTrue: [^ self * (self - 1) factorial].	self error: 'Not valid for negative integers'! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'mathematical functions'!lcm: n 	"Answer the least common multiple of the receiver and n."	^self // (self gcd: n) * n! !!Integer methodsFor: 'mathematical functions' stamp: 'tk 7/30/97 13:08'!take: kk	"Return the number of combinations of (self) elements taken kk at a time.  For 6 take 3, this is 6*5*4 / (1*2*3).  Zero outside of Pascal's triangle.  Use a trick to go faster."	" 6 take: 3  "	| num denom |	kk < 0 ifTrue: [^ 0].	kk > self ifTrue: [^ 0].	num _ 1.	self to: (kk max: self-kk) + 1 by: -1 do: [:factor | num _ num * factor].	denom _ 1.	1 to: (kk min: self-kk) do: [:factor | denom _ denom * factor].	^ num // denom! !!Integer methodsFor: 'bit manipulation'!<< shiftAmount  "left shift"	shiftAmount < 0 ifTrue: [self error: 'negative arg'].	^ self bitShift: shiftAmount! !!Integer methodsFor: 'bit manipulation' stamp: 'dwh 8/18/1999 21:57'!>> shiftAmount  "right shift"	shiftAmount < 0 ifTrue: [self error: 'negative arg'].	^ self bitShift: 0 - shiftAmount! !!Integer methodsFor: 'bit manipulation'!allMask: mask 	"Treat the argument as a bit mask. Answer whether all of the bits that 	are 1 in the argument are 1 in the receiver."	^mask = (self bitAnd: mask)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 11/29/2000 14:32'!anyBitOfMagnitudeFrom: start to: stopArg 	"Tests for any magnitude bits in the interval from start to stopArg."	"Primitive fixed in LargeIntegers v1.2. If you have an earlier version 	comment out the primitive call (using this ST method then)."	| magnitude firstDigitIx lastDigitIx rightShift leftShift stop |	<primitive: 'primAnyBitFromTo' module:'LargeIntegers'>	start < 1 | (stopArg < 1)		ifTrue: [^ self error: 'out of range'].	magnitude _ self abs.	stop _ stopArg min: magnitude highBit.	start > stop		ifTrue: [^ false].	firstDigitIx _ start - 1 // 8 + 1.	lastDigitIx _ stop - 1 // 8 + 1.	rightShift _ (start - 1 \\ 8) negated.	leftShift _ 7 - (stop - 1 \\ 8).	firstDigitIx = lastDigitIx		ifTrue: [| digit mask | 			mask _ (255 bitShift: rightShift negated)						bitAnd: (255 bitShift: leftShift negated).			digit _ magnitude digitAt: firstDigitIx.			^ (digit bitAnd: mask)				~= 0].	((magnitude digitAt: firstDigitIx)			bitShift: rightShift)			~= 0		ifTrue: [^ true].	firstDigitIx + 1		to: lastDigitIx - 1		do: [:ix | (magnitude digitAt: ix)					~= 0				ifTrue: [^ true]].	(((magnitude digitAt: lastDigitIx)			bitShift: leftShift)			bitAnd: 255)			~= 0		ifTrue: [^ true].	^ false! !!Integer methodsFor: 'bit manipulation'!anyMask: mask 	"Treat the argument as a bit mask. Answer whether any of the bits that 	are 1 in the argument are 1 in the receiver."	^0 ~= (self bitAnd: mask)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitAnd: n 	"Answer an Integer whose bits are the logical AND of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitAnd' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitAnd:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'di 4/30/1998 10:32'!bitClear: aMask 	"Answer an Integer equal to the receiver, except with all bits cleared that are set in aMask."	^ (self bitOr: aMask) - aMask! !!Integer methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitInvert	"Answer an Integer whose bits are the logical negation of the receiver's bits.	Numbers are interpreted as having 2's-complement representation."	^ -1 - self! !!Integer methodsFor: 'bit manipulation'!bitInvert32	"Answer the 32-bit complement of the receiver."	^ self bitXor: 16rFFFFFFFF! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitOr: n 	"Answer an Integer whose bits are the logical OR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitOr' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitOr:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 10:09'!bitShift: shiftCount 	"Answer an Integer whose value (in twos-complement representation) is  	the receiver's value (in twos-complement representation) shifted left by 	the number of bits indicated by the argument. Negative arguments  	shift right. Zeros are shifted in from the right in left shifts."	| magnitudeShift |	magnitudeShift _ self bitShiftMagnitude: shiftCount.	^ ((self negative and: [shiftCount negative])		and: [self anyBitOfMagnitudeFrom: 1 to: shiftCount negated])		ifTrue: [magnitudeShift - 1]		ifFalse: [magnitudeShift]! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 14:02'!bitShiftMagnitude: shiftCount 	"Answer an Integer whose value (in magnitude representation) is  	the receiver's value (in magnitude representation) shifted left by  	the number of bits indicated by the argument. Negative arguments	shift right. Zeros are shifted in from the right in left shifts."	| rShift |	<primitive: 'primDigitBitShiftMagnitude' module:'LargeIntegers'>	shiftCount >= 0 ifTrue: [^ self digitLshift: shiftCount].	rShift _ 0 - shiftCount.	^ (self		digitRshift: (rShift bitAnd: 7)		bytes: (rShift bitShift: -3)		lookfirst: self digitLength) normalize! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitXor: n 	"Answer an Integer whose bits are the logical XOR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitXor' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitXor:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:13'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self subclassResponsibility! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 01:55'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero."	^ self subclassResponsibility! !!Integer methodsFor: 'bit manipulation' stamp: 'jm 2/19/98 12:11'!lowBit	"Answer the index of the low order bit of this number."	| index |	self = 0 ifTrue: [ ^ 0 ].	index := 1.	[ (self digitAt: index) = 0 ]		whileTrue:			[ index := index + 1 ].	^ (self digitAt: index) lowBit + (8 * (index - 1))! !!Integer methodsFor: 'bit manipulation'!noMask: mask 	"Treat the argument as a bit mask. Answer whether none of the bits that 	are 1 in the argument are 1 in the receiver."	^0 = (self bitAnd: mask)! !!Integer methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ rcvr perform: selector with: self asFraction! !!Integer methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert me to a ScaledDecimal and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal perform: arithmeticOpSelector with: (self asScaledDecimal: 0)! !!Integer methodsFor: 'converting'!asCharacter	"Answer the Character whose value is the receiver."	^Character value: self! !!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!asColorOfDepth: d	"Return a color value representing the receiver as color of the given depth"	^Color colorFromPixelValue: self depth: d! !!Integer methodsFor: 'converting' stamp: 'di 1/13/1999 12:45'!asFloat	"Answer a Float that represents the value of the receiver.	Optimized to process only the significant digits of a LargeInteger.	SqR: 11/30/1998 21:11"	| sum firstByte shift |	shift _ 0.	sum _ 0.0.	firstByte _ self size - 7 max: 1.	firstByte to: self size do:		[:byteIndex | 		sum _ ((self digitAt: byteIndex) asFloat timesTwoPower: shift) + sum.		shift _ shift + 8].	^sum * self sign asFloat timesTwoPower: firstByte - 1 * 8! !!Integer methodsFor: 'converting'!asFraction	"Answer a Fraction that represents value of the the receiver."	^Fraction numerator: self denominator: 1! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!Integer methodsFor: 'converting'!asInteger	"Answer with the receiver itself."	^self! !!Integer methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scaleNotUsed 	"The number of significant digits of the answer is the same as the 	number of decimal digits in the receiver.  The scale of the answer is 0."	#Numeric.	"add 200/01/19 For <integer> protocol."	^ ScaledDecimal newFromNumber: self scale: 0! !!Integer methodsFor: 'converting' stamp: 'brp 5/13/2003 10:12'!asYear
	^ Year year: self 
! !!Integer methodsFor: 'printing' stamp: 'sw 11/24/1998 14:53'!asStringWithCommas	"123456789 asStringWithCommas"	"-123456789 asStringWithCommas"	| digits |	digits _ self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!Integer methodsFor: 'printing' stamp: 'sw 11/13/1999 23:00'!asTwoCharacterString	"Answer a two-character string representing the receiver, with leading zero if required.  Intended for use with integers in the range 0 to 99, but plausible replies given for other values too"	^ (self >= 0 and: [self < 10])		ifTrue:	['0', self printString]		ifFalse:	[self printString copyFrom: 1 to: 2]"2 asTwoCharacterString11 asTwoCharacterString1943 asTwoCharacterString0 asTwoCharacterString-2 asTwoCharacterString-234 asTwoCharacterString"! !!Integer methodsFor: 'printing' stamp: 'tk 4/1/2002 11:30'!asWords	"SmallInteger maxVal asWords"	| mils minus three num answer milCount |	self = 0 ifTrue: [^'zero'].	mils _ #('' ' thousand' ' million' ' billion' ' trillion' ' quadrillion' ' quintillion' ' sextillion' ' septillion' ' octillion' ' nonillion' ' decillion' ' undecillion' ' duodecillion' ' tredecillion' ' quattuordecillion' ' quindecillion' ' sexdecillion' ' septendecillion' ' octodecillion' ' novemdecillion' ' vigintillion').	num _ self.	minus _ ''.	self < 0 ifTrue: [		minus _ 'negative '.		num _ num negated.	].	answer _ String new.	milCount _ 1.	[num > 0] whileTrue: [		three _ (num \\ 1000) threeDigitName.		num _ num // 1000.		three isEmpty ifFalse: [			answer isEmpty ifFalse: [				answer _ ', ',answer			].			answer _ three,(mils at: milCount),answer.		].		milCount _ milCount + 1.	].	^minus,answer! !!Integer methodsFor: 'printing'!hex	^ self printStringBase: 16! !!Integer methodsFor: 'printing'!hex8  "16r3333 hex8"	| hex |	hex _ self hex.  "16rNNN"	hex size < 11		ifTrue: [^ hex copyReplaceFrom: 4 to: 3						 with: ('00000000' copyFrom: 1 to: 11-hex size)]		ifFalse: [^ hex]! !!Integer methodsFor: 'printing'!isLiteral	^true! !!Integer methodsFor: 'printing' stamp: 'gk 11/26/2003 10:26'!printOn: aStream base: base	"Print a representation of the receiver on the stream	<aStream> in base <base> where	2 <= <baseInteger> <= 16. If <base> is other than 10	it is written first separated by $r followed by the number	like for example: 16rFCE2"		| current letters digits quo i |	self < 0 ifTrue: [		aStream nextPut: $-.		^self negated printOn: aStream base: base].	digits _ '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.	base = 10 ifFalse: [aStream print: base; nextPut: $r].	current _ self.	i _ self digitLength * 8.	letters _ String new: i.	[current < base] whileFalse: 		[quo _ current quo: base.		letters at: i put: (digits at: (current - (quo * base)) + 1).		i _ i - 1.		current _ quo].	letters at: i put: (digits at: current + 1).	aStream nextPutAll: (letters copyFrom: i to: letters size)! !!Integer methodsFor: 'printing'!radix: radix 	"Answer a String representing the receiver as a base radix integer."	^ self printStringBase: radix! !!Integer methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:26'!lastDigit	"Answer the last digit of the integer base 256.  LargePositiveInteger uses bytes of base two number, and each is a 'digit'."	^self digitAt: self digitLength! !!Integer methodsFor: 'system primitives'!replaceFrom: start to: stop with: replacement startingAt: repStart	| j |  "Catches failure if LgInt replace primitive fails"	j _ repStart.	start to: stop do:		[:i |		self digitAt: i put: (replacement digitAt: j).		j _ j+1]! !!Integer methodsFor: 'private'!copyto: x	| stop |	stop _ self digitLength min: x digitLength.	^ x replaceFrom: 1 to: stop with: self startingAt: 1! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:41'!digitAdd: arg 	| len arglen accum sum |	<primitive: 'primDigitAdd' module:'LargeIntegers'>	accum _ 0.	(len _ self digitLength) < (arglen _ arg digitLength) ifTrue: [len _ arglen].	"Open code max: for speed"	sum _ Integer new: len neg: self negative.	1 to: len do: 		[:i | 		accum _ (accum bitShift: -8)					+ (self digitAt: i) + (arg digitAt: i).		sum digitAt: i put: (accum bitAnd: 255)].	accum > 255		ifTrue: 			[sum _ sum growby: 1.			sum at: sum digitLength put: (accum bitShift: -8)].	^ sum! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:43'!digitCompare: arg 	"Compare the magnitude of self with that of arg.   	Return a code of 1, 0, -1 for self >, = , < arg"	| len arglen argDigit selfDigit |	<primitive: 'primDigitCompare' module:'LargeIntegers'>	len _ self digitLength.	(arglen _ arg digitLength) ~= len		ifTrue: [arglen > len				ifTrue: [^ -1]				ifFalse: [^ 1]].	[len > 0]		whileTrue: 			[(argDigit _ arg digitAt: len) ~= (selfDigit _ self digitAt: len)				ifTrue: [argDigit < selfDigit						ifTrue: [^ 1]						ifFalse: [^ -1]].			len _ len - 1].	^ 0! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:28'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	"TFEI added this line"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	"shortcut against #highBit"	d _ 8 - arg lastDigit highBitOfPositiveReceiver.	div _ arg digitLshift: d.	div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi _ qlo _ 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13  				bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi _ (hi bitShift: -4)							+ (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i)						* qhi.			lo _ a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a _ lo // 256 - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem _ rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Integer methodsFor: 'private' stamp: 'hmm 1/7/2002 20:55'!digitLogic: arg op: op length: len	| result neg1 neg2 rneg z1 z2 rz b1 b2 b |	neg1 _ self negative.	neg2 _ arg negative.	rneg _ 		((neg1 ifTrue: [-1] ifFalse: [0])			perform: op 			with: (neg2					ifTrue: [-1]					ifFalse: [0])) < 0.	result _ Integer new: len neg: rneg.	rz _ z1 _ z2 _ true.	1 to: result digitLength do: 		[:i | 		b1 _ self digitAt: i.		neg1 			ifTrue: [b1 _ z1						ifTrue: [b1 = 0									ifTrue: [0]									ifFalse: 										[z1 _ false.										256 - b1]]						ifFalse: [255 - b1]].		b2 _ arg digitAt: i.		neg2 			ifTrue: [b2 _ z2						ifTrue: [b2 = 0									ifTrue: [0]									ifFalse: 										[z2 _ false.										256 - b2]]						ifFalse: [255 - b2]].		b _ b1 perform: op with: b2.		result 			digitAt: i 			put: (rneg					ifTrue: [rz ifTrue: [b = 0										ifTrue: [0]										ifFalse:											[rz _ false.											256 - b]]								ifFalse: [255 - b]]				ifFalse: [b])].	^ result normalize! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:30'!digitLshift: shiftCount 	| carry rShift mask len result digit byteShift bitShift highBit |	(highBit _ self highBitOfMagnitude) = 0 ifTrue: [^ 0].	len _ highBit + shiftCount + 7 // 8.	result _ Integer new: len neg: self negative.	byteShift _ shiftCount // 8.	bitShift _ shiftCount \\ 8.	bitShift = 0 ifTrue: ["Fast version for byte-aligned shifts"		^ result			replaceFrom: byteShift + 1			to: len			with: self			startingAt: 1].	carry _ 0.	rShift _ bitShift - 8.	mask _ 255 bitShift: 0 - bitShift.	1 to: byteShift do: [:i | result digitAt: i put: 0].	1 to: len - byteShift do: 		[:i | 		digit _ self digitAt: i.		result digitAt: i + byteShift put: (((digit bitAnd: mask)				bitShift: bitShift)				bitOr: carry).		carry _ digit bitShift: rShift].	^ result! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitMultiply: arg neg: ng 	| prod prodLen carry digit k ab |	<primitive: 'primDigitMultiplyNegative' module:'LargeIntegers'>	(arg digitLength = 1 and: [(arg digitAt: 1)			= 0])		ifTrue: [^ 0].	(self digitLength = 1 and: [(self digitAt: 1)			= 0])		ifTrue: [^ 0].	prodLen _ self digitLength + arg digitLength.	prod _ Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: [:i | (digit _ self digitAt: i) ~= 0			ifTrue: 				[k _ i.				carry _ 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab _ (arg digitAt: j)								* digit + carry + (prod digitAt: k).					carry _ ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k _ k + 1].				prod digitAt: k put: carry]].	^ prod normalize! !!Integer methodsFor: 'private'!digitRshift: anInteger bytes: b lookfirst: a 	 "Shift right 8*b+anInteger bits, 0<=n<8.	Discard all digits beyond a, and all zeroes at or below a."	| n x r f m digit count i |	n _ 0 - anInteger.	x _ 0.	f _ n + 8.	i _ a.	m _ 255 bitShift: 0 - f.	digit _ self digitAt: i.	[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:		[x _ digit bitShift: f "Can't exceed 8 bits".		i _ i - 1.		digit _ self digitAt: i].	i <= b ifTrue: [^Integer new: 0 neg: self negative].  "All bits lost"	r _ Integer new: i - b neg: self negative.	count _ i.	x _ (self digitAt: b + 1) bitShift: n.	b + 1 to: count do:		[:j | digit _ self digitAt: j + 1.		r digitAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x) 			"Avoid values > 8 bits".		x _ digit bitShift: n].	^r! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitSubtract: arg 	| smaller larger z sum sl al ng |	<primitive: 'primDigitSubtract' module:'LargeIntegers'>	sl _ self digitLength.	al _ arg digitLength.	(sl = al		ifTrue: 			[[(self digitAt: sl)				= (arg digitAt: sl) and: [sl > 1]]				whileTrue: [sl _ sl - 1].			al _ sl.			(self digitAt: sl)				< (arg digitAt: sl)]		ifFalse: [sl < al])		ifTrue: 			[larger _ arg.			smaller _ self.			ng _ self negative == false.			sl _ al]		ifFalse: 			[larger _ self.			smaller _ arg.			ng _ self negative].	sum _ Integer new: sl neg: ng.	z _ 0.	"Loop invariant is -1<=z<=1"	1 to: sl do: 		[:i | 		z _ z + (larger digitAt: i) - (smaller digitAt: i).		sum digitAt: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z _ z // 256].	^ sum normalize! !!Integer methodsFor: 'private'!growby: n	^self growto: self digitLength + n! !!Integer methodsFor: 'private'!growto: n	^self copyto: (self species new: n)! !!Integer methodsFor: 'benchmarks' stamp: 'jm 11/20/1998 07:06'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t |	  t _ Time millisecondsToRun: [r _ 26 benchFib].	  (r * 1000) // t"	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Integer methodsFor: 'benchmarks' stamp: 'di 4/11/1999 11:20'!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size _ 8190.    1 to: self do:        [:iter |        count _ 0.        flags _ (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime _ i+1.                k _ i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k _ k + prime].                count _ count + 1]]].    ^ count! !!Integer methodsFor: 'benchmarks' stamp: 'dwh 11/21/1999 16:40'!tinyBenchmarks	"Report the results of running the two tiny Squeak benchmarks.	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"	"0 tinyBenchmarks"	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"	| t1 t2 r n1 n2 |	n1 _ 1.	[t1 _ Time millisecondsToRun: [n1 benchmark].	t1 < 1000] whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"	n2 _ 28.	[t2 _ Time millisecondsToRun: [r _ n2 benchFib].	t2 < 1000] whileTrue:[n2 _ n2 + 1]. 	"Note: #benchFib's runtime is about O(k^n),		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."	^ ((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Integer class	instanceVariableNames: ''!!Integer class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!basicNew	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super basicNew! !!Integer class methodsFor: 'instance creation' stamp: 'sw 5/8/2000 11:05'!initializedInstance	^ 2468! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 22:01'!new	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super new! !!Integer class methodsFor: 'instance creation'!new: length neg: neg	"Answer an instance of a large integer whose size is length. neg is a flag 	determining whether the integer is negative or not."	neg 		ifTrue: [^LargeNegativeInteger new: length]		ifFalse: [^LargePositiveInteger new: length]! !!Integer class methodsFor: 'instance creation'!readFrom: aStream 	"Answer a new Integer as described on the stream, aStream.	Embedded radix specifiers not allowed - use Number readFrom: for that."	^self readFrom: aStream base: 10! !!Integer class methodsFor: 'instance creation' stamp: 'ls 6/23/1999 20:37'!readFrom: aStream base: base 	"Answer an instance of one of my concrete subclasses. Initial minus sign 	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not 	allowed--use Number readFrom: for that. Answer zero (not an error) if 	there are no digits."	| digit value neg startPos |	neg _ aStream peekFor: $-.	neg ifFalse: [aStream peekFor: $+].	value _ 0.	startPos _ aStream position.	[aStream atEnd]		whileFalse: 			[digit _ aStream next digitValue.			(digit < 0 or: [digit >= base])				ifTrue: 					[aStream skip: -1.					aStream position = startPos ifTrue: [self error: 'At least one digit expected here'].					neg ifTrue: [^ value negated].					^ value]				ifFalse: [value _ value * base + digit]].	neg ifTrue: [^ value negated].	^ value! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 02:38'!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require 4 *GIGA*bytes).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit |	limit _ max asInteger - 1.	indexLimit _ max sqrt truncated + 1.	"Create the array of flags."	flags _ ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 _ self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex _ Array new: 2310.	bitIndex _ -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex _ bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex _ bitIndex + 1).	1 to: 5 do:[:i| aBlock value: (primesUpTo2310 at: i)].	index _ 6.	2 to: 2309 do:[:n|		[(primesUpTo2310 at: index) < n] 			whileTrue:[index _ index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex _ bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex _ bitIndex + 1)].		].	].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by 2 for odd numbers only."	13 to: limit by: 2 do:[:n|		(maskBit _ maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex _ n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex _ 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * i to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index _ n * n.					(index bitAnd: 1) = 0 ifTrue:[index _ index + n].					[index <= limit] whileTrue:[						(maskBit _ maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex _ (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit _ 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index _ index + (2 * n)].				].			].		].	].! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!primesUpTo: max	"Return a list of prime integers up to the given integer."	"Integer primesUpTo: 100"	^Array streamContents:[:s| self primesUpTo: max do:[:prime| s nextPut: prime]]! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| limit flags prime k |	limit _ max asInteger - 1.	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 1/154th of the amount we need here and is almost as fast."	limit > 25000 ifTrue:[^self largePrimesUpTo: max do: aBlock].	flags _ (Array new: limit) atAllPut: true.	1 to: limit do: [:i |		(flags at: i) ifTrue: [			prime _ i + 1.			k _ i + prime.			[k <= limit] whileTrue: [				flags at: k put: false.				k _ k + prime].			aBlock value: prime]].! !!Integer class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	#Numeric.	"add 200/01/19 For <number> protocol support."	^ 1! !ArrayedCollection variableWordSubclass: #IntegerArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!IntegerArray commentStamp: '<historical>' prior: 0!IntegerArrays store 32bit signed Integer values.Negative values are stored as 2's complement.!!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index	| word |	<primitive: 165>	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index put: anInteger	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 23:34'!atAllPut: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self primFill: word.! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!IntegerArray methodsFor: 'converting' stamp: 'ar 10/10/1998 16:18'!asIntegerArray	^self! !!IntegerArray methodsFor: 'private' stamp: 'ar 3/3/2001 23:34'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegerArray class	instanceVariableNames: ''!!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:17'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asIntPtrFrom: anInteger on: aStream! !!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/25/1999 15:00'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isWords')! !!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:18'!ccgDeclareCForVar: aSymbolOrString	^'int *', aSymbolOrString! !SequenceableCollection subclass: #Interval	instanceVariableNames: 'start stop step'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!Interval commentStamp: '<historical>' prior: 0!I represent a finite arithmetic progression.!!Interval methodsFor: 'accessing'!at: anInteger 	"Answer the anInteger'th element."	(anInteger >= 1 and: [anInteger <= self size])		ifTrue: [^start + (step * (anInteger - 1))]		ifFalse: [self errorSubscriptBounds: anInteger]! !!Interval methodsFor: 'accessing'!at: anInteger put: anObject 	"Storing into an Interval is not allowed."	self error: 'you can not store into an interval'! !!Interval methodsFor: 'accessing' stamp: 'stp 8/19/2000 23:52'!extent 	"Answer the max - min of the receiver interval."	"(10 to: 50) extent"	^stop - start! !!Interval methodsFor: 'accessing'!first 	"Refer to the comment in SequenceableCollection|first."	^start! !!Interval methodsFor: 'accessing' stamp: 'rpj 11/30/1999 11:04'!includes: aNumber	"Determine if aNumber is an element of this interval."	^ (self rangeIncludes: aNumber) and: [ self valuesInclude: aNumber ]! !!Interval methodsFor: 'accessing'!increment	"Answer the receiver's interval increment."	^step! !!Interval methodsFor: 'accessing'!last 	"Refer to the comment in SequenceableCollection|last."	^stop - (stop - start \\ step)! !!Interval methodsFor: 'accessing' stamp: 'di 12/6/1999 11:00'!rangeIncludes: aNumber	"Return true if the number lies in the interval between start and stop."	step >= 0		ifTrue: [^ aNumber between: start and: stop]		ifFalse: [^ aNumber between: stop and: start]! !!Interval methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:38'!size	"Answer how many elements the receiver contains."	step < 0		ifTrue: [start < stop				ifTrue: [^ 0]				ifFalse: [^ stop - start // step + 1]]		ifFalse: [stop < start				ifTrue: [^ 0]				ifFalse: [^ stop - start // step + 1]]! !!Interval methodsFor: 'comparing' stamp: 'rhi 8/14/2003 10:08'!= anObject	^ self == anObject		ifTrue: [true]		ifFalse: [anObject isInterval			ifTrue: [start = anObject first				and: [step = anObject increment					and: [self last = anObject last]]]			ifFalse: [super = anObject]]! !!Interval methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^(((start hash bitShift: 2)		bitOr: stop hash)		bitShift: 1)		bitOr: self size! !!Interval methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Interval methodsFor: 'adding'!add: newObject 	"Adding to an Interval is not allowed."	self shouldNotImplement! !!Interval methodsFor: 'removing'!remove: newObject 	"Removing from an Interval is not allowed."	self error: 'elements cannot be removed from an Interval'! !!Interval methodsFor: 'copying'!copy	"Return a copy of me. Override the superclass because my species is	Array and copy, as inherited from SequenceableCollection, uses	copyFrom:to:, which creates a new object of my species."	^self shallowCopy! !!Interval methodsFor: 'copying' stamp: 'sma 3/3/2000 13:18'!shallowCopy	"Without this method, #copy would return an array instead of a new interval.	The whole problem is burried in the class hierarchy and every fix will worsen	the problem, so once the whole issue is resolved one should come back to this 	method fix it."	^ self class from: start to: stop by: step! !!Interval methodsFor: 'enumerating'!collect: aBlock	| nextValue result |	result _ self species new: self size.	nextValue _ start.	1 to: result size do:		[:i |		result at: i put: (aBlock value: nextValue).		nextValue _ nextValue + step].	^ result! !!Interval methodsFor: 'enumerating'!do: aBlock	| aValue |	aValue _ start.	step < 0		ifTrue: [[stop <= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue + step]]		ifFalse: [[stop >= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue + step]]! !!Interval methodsFor: 'enumerating' stamp: 'dtl 5/31/2003 16:45'!permutationsDo: aBlock	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy	so that aBlock is presented all (self size factorial) possible permutations."	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"	self asArray permutationsDo: aBlock! !!Interval methodsFor: 'enumerating'!reverseDo: aBlock 	"Evaluate aBlock for each element of my interval, in reverse order."	| aValue |	aValue _ stop.	step < 0		ifTrue: [[start >= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue - step]]		ifFalse: [[start <= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue - step]]! !!Interval methodsFor: 'printing' stamp: 'sma 6/1/2000 09:50'!printOn: aStream	aStream nextPut: $(;	 print: start;	 nextPutAll: ' to: ';	 print: stop.	step ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].	aStream nextPut: $)! !!Interval methodsFor: 'printing'!storeOn: aStream 	"This is possible because we know numbers store and print the same."	self printOn: aStream! !!Interval methodsFor: 'private'!setFrom: startInteger to: stopInteger by: stepInteger	start _ startInteger.	stop _ stopInteger.	step _ stepInteger! !!Interval methodsFor: 'private'!species	^Array! !!Interval methodsFor: 'private' stamp: 'di 4/24/2000 13:56'!valuesInclude: aNumber	"Private - answer whether or not aNumber is one of the enumerated values in this interval."	| val |	val _ (aNumber - self first) asFloat / self increment.	^ val fractionPart abs < (step * 1.0e-10)! !!Interval methodsFor: 'testing' stamp: 'rhi 8/12/2003 09:52'!isInterval	^ true! !!Interval methodsFor: 'arithmetic' stamp: 'ajh 3/13/2003 15:45'!+ number	^ start + number to: stop + number by: step! !!Interval methodsFor: 'arithmetic' stamp: 'ajh 3/13/2003 15:46'!- number	^ start - number to: stop - number by: step! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Interval class	instanceVariableNames: ''!!Interval class methodsFor: 'instance creation'!from: startInteger to: stopInteger 	"Answer an instance of me, starting at startNumber, ending at 	stopNumber, and with an interval increment of 1."	^self new		setFrom: startInteger		to: stopInteger		by: 1! !!Interval class methodsFor: 'instance creation'!from: startInteger to: stopInteger by: stepInteger 	"Answer an instance of me, starting at startNumber, ending at 	stopNumber, and with an interval increment of stepNumber."	^self new		setFrom: startInteger		to: stopInteger		by: stepInteger! !!Interval class methodsFor: 'instance creation'!new	"Primitive. Create and answer with a new instance of the receiver	(a class) with no indexable fields. Fail if the class is indexable. Override	SequenceableCollection new. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self new: 0 ].	"space must be low"	Smalltalk signalLowSpace.	^ self new  "retry if user proceeds"! !!Interval class methodsFor: 'instance creation' stamp: 'md 1/14/2004 11:42'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."    | newInterval n |    (n := aCollection size) <= 1 ifTrue: [		n = 0 ifTrue: [^self from: 1 to: 0].		^self from: aCollection first to: aCollection last].    	newInterval := self from: aCollection first to: aCollection last	by: (aCollection last - aCollection first) // (n - 1).	aCollection ~= newInterval		ifTrue: [self error: 'The argument is not an arithmetic progression'].	^newInterval"	Interval newFrom: {1. 2. 3}	{33. 5. -23} as: Interval	{33. 5. -22} as: Interval    (an error)	(-4 to: -12 by: -1) as: Interval"! !Error subclass: #InvalidDirectoryError	instanceVariableNames: 'pathName'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!InvalidDirectoryError methodsFor: 'accessing' stamp: 'ar 5/30/2001 20:44'!pathName	^pathName! !!InvalidDirectoryError methodsFor: 'accessing' stamp: 'ar 5/30/2001 20:45'!pathName: badPathName	pathName _ badPathName! !!InvalidDirectoryError methodsFor: 'exceptionDescription' stamp: 'ar 5/30/2001 20:49'!defaultAction	"Return an empty list as the default action of signaling the occurance of an invalid directory."	^#()! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InvalidDirectoryError class	instanceVariableNames: ''!!InvalidDirectoryError class methodsFor: 'exceptionInstantiator' stamp: 'ar 5/30/2001 20:49'!pathName: badPathName	^self new pathName: badPathName! !LargePositiveInteger variableByteSubclass: #LargeNegativeInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!LargeNegativeInteger commentStamp: '<historical>' prior: 0!Just like LargePositiveInteger, but represents a negative number.!!LargeNegativeInteger methodsFor: 'arithmetic'!abs	^ self negated! !!LargeNegativeInteger methodsFor: 'arithmetic'!negated	^ self copyto: (LargePositiveInteger new: self digitLength)! !!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:10'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self shouldNotImplement! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:10'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen minVal |	<primitive: 'primNormalizeNegative' module:'LargeIntegers'>	"First establish len = significant length"	len _ oldLen _ self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len _ len - 1].	"Now check if in SmallInteger range"	sLen _ 4  "SmallInteger minVal digitLength".	len <= sLen ifTrue:		[minVal _ SmallInteger minVal.		(len < sLen			or: [(self digitAt: sLen) < minVal lastDigit])			ifTrue: ["If high digit less, then can be small"					val _ 0.					len to: 1 by: -1 do:						[:i | val _ (val *256) - (self digitAt: i)].					^ val].		1 to: sLen do:  "If all digits same, then = minVal"			[:i | (self digitAt: i) = (minVal digitAt: i)					ifFalse: ["Not so; return self shortened"							len < oldLen								ifTrue: [^ self growto: len]								ifFalse: [^ self]]].		^ minVal].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'di 4/23/1998 11:18'!negative	"Answer whether the receiver is mathematically negative."	^ true! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'di 4/23/1998 11:00'!positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ false! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'jm 3/27/98 06:19'!sign	"Optimization. Answer -1 since receiver is less than 0."	^ -1! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'di 4/23/1998 11:03'!strictlyPositive	"Answer whether the receiver is mathematically positive."	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LargeNegativeInteger class	instanceVariableNames: ''!!LargeNegativeInteger class methodsFor: 'as yet unclassified' stamp: 'sw 5/8/2000 12:05'!initializedInstance	^ -9876543210987654321 copy! !Integer variableByteSubclass: #LargePositiveInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!LargePositiveInteger commentStamp: '<historical>' prior: 0!I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!!LargePositiveInteger methodsFor: 'arithmetic'!* anInteger 	"Primitive. Multiply the receiver by the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 29>	^super * anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!+ anInteger 	"Primitive. Add the receiver to the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 21>	^super + anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!- anInteger 	"Primitive. Subtract the argument from the receiver and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 22>	^super - anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!/ anInteger 	"Primitive. Divide the receiver by the argument and answer with the	result if the division is exact. Fail if the result is not a whole integer.	Fail if the argument is 0. Fail if either the argument or the result is not	a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 30>	^super / anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!// anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards negative infinity to make it a whole	integer. Fail if the argument is 0. Fail if either the argument or the	result is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 32>	^super // anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!\\ anInteger 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided	by the argument. Fail if the argument is 0. Fail if either the argument	or the result is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 31>	^super \\ anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!abs! !!LargePositiveInteger methodsFor: 'arithmetic'!negated 	^ (self copyto: (LargeNegativeInteger new: self digitLength))		normalize  "Need to normalize to catch SmallInteger minVal"! !!LargePositiveInteger methodsFor: 'arithmetic'!quo: anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards zero to make it a whole integer. Fail if	the argument is 0. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 33>	^super quo: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation'!bitAnd: anInteger 	"Primitive. Answer an Integer whose bits are the logical AND of the	receiver's bits and those of the argument. Fail if the receiver or argument	is greater than 32 bits. See Object documentation whatIsAPrimitive."	<primitive: 14>	^ super bitAnd: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation'!bitOr: anInteger 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument. Fail if the receiver or argument	is greater than 32 bits. See Object documentation whatIsAPrimitive."	<primitive: 15>	^ super bitOr: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation'!bitShift: anInteger 	"Primitive. Answer an Integer whose value (in twos-complement 	representation) is the receiver's value (in twos-complement	representation) shifted left by the number of bits indicated by the	argument. Negative arguments shift right. Zeros are shifted in from the	right in left shifts. The sign bit is extended in right shifts.	Fail if the receiver or result is greater than 32 bits.	See Object documentation whatIsAPrimitive."	<primitive: 17>	^super bitShift: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation'!bitXor: anInteger 	"Primitive. Answer an Integer whose bits are the logical XOR of the	receiver's bits and those of the argument. Fail if the receiver or argument	is greater than 32 bits. See Object documentation whatIsAPrimitive."	<primitive: 16>	^ super bitXor: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'SqR 9/18/2000 15:17'!hashMultiply	"Truncate to 28 bits and try again"	^(self bitAnd: 16rFFFFFFF) hashMultiply! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:11'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self highBitOfMagnitude! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:15'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	| realLength lastDigit |	realLength _ self digitLength.	[(lastDigit _ self digitAt: realLength) = 0]		whileTrue: [(realLength _ realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))! !!LargePositiveInteger methodsFor: 'testing' stamp: 'di 4/23/1998 11:18'!negative	"Answer whether the receiver is mathematically negative."	^ false! !!LargePositiveInteger methodsFor: 'testing' stamp: 'di 4/23/1998 11:00'!positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ true! !!LargePositiveInteger methodsFor: 'testing' stamp: 'jm 3/27/98 06:19'!sign	"Optimization. Answer 1 since receiver is greater than 0."	^ 1! !!LargePositiveInteger methodsFor: 'testing' stamp: 'di 4/23/1998 11:02'!strictlyPositive	"Answer whether the receiver is mathematically positive."	^ true! !!LargePositiveInteger methodsFor: 'comparing'!< anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive."	<primitive: 23>	^super < anInteger! !!LargePositiveInteger methodsFor: 'comparing'!<= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger or a LargePositiveInteger less	than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 25>	^super <= anInteger! !!LargePositiveInteger methodsFor: 'comparing'!= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	receiver or argument is negative or greater than 32 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 7>	^ super = anInteger! !!LargePositiveInteger methodsFor: 'comparing'!> anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 24>	^super > anInteger! !!LargePositiveInteger methodsFor: 'comparing'!>= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger or a LargePositiveInteger	less than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 26>	^super >= anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'SqR 8/13/2002 10:52'!hash	^ByteArray		hashBytes: self		startingWith: self species hash! !!LargePositiveInteger methodsFor: 'comparing'!~= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	receiver or argument is negative or greater than 32 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 8>	^ super ~= anInteger! !!LargePositiveInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:09'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen |	<primitive: 'primNormalizePositive' module:'LargeIntegers'>	"First establish len = significant length"	len _ oldLen _ self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len _ len - 1].	"Now check if in SmallInteger range"	sLen _ SmallInteger maxVal digitLength.	(len <= sLen		and: [(self digitAt: sLen) <= (SmallInteger maxVal digitAt: sLen)])		ifTrue: ["If so, return its SmallInt value"				val _ 0.				len to: 1 by: -1 do:					[:i | val _ (val *256) + (self digitAt: i)].				^ val].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:28'!digitAt: index 	"Primitive. Answer the value of an indexable field in the receiver.   LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds. Essential.  See Object documentation whatIsAPrimitive."	<primitive: 60>	self digitLength < index		ifTrue: [^0]		ifFalse: [^super at: index]! !!LargePositiveInteger methodsFor: 'system primitives'!digitAt: index put: value 	"Primitive. Store the second argument (value) in the indexable field of 	the receiver indicated by index. Fail if the value is negative or is larger 	than 255. Fail if the index is not an Integer or is out of bounds. Answer 	the value that was stored. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 61>	^super at: index put: value! !!LargePositiveInteger methodsFor: 'system primitives'!digitLength	"Primitive. Answer the number of indexable fields in the receiver. This 	value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self primitiveFailed! !!LargePositiveInteger methodsFor: 'system primitives'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	^ super replaceFrom: start to: stop with: replacement startingAt: repStart! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LargePositiveInteger class	instanceVariableNames: ''!!LargePositiveInteger class methodsFor: 'testing' stamp: 'sw 5/8/2000 12:05'!initializedInstance	^ 12345678901234567 copy! !ParseNode subclass: #LeafNode	instanceVariableNames: 'key code'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!LeafNode commentStamp: '<historical>' prior: 0!I represent a leaf node of the compiler parse tree. I am abstract.	Types (defined in class ParseNode):	1 LdInstType (which uses class VariableNode)	2 LdTempType (which uses class VariableNode)	3 LdLitType (which uses class LiteralNode)	4 LdLitIndType (which uses class VariableNode)	5 SendType (which uses class SelectorNode).Note that Squeak departs slightly from the Blue Book bytecode spec.In order to allow access to more than 63 literals and instance variables,bytecode 132 has been redefined as DoubleExtendedDoAnything:		byte2				byte3			Operation(hi 3 bits)  (lo 5 bits)	0		nargs			lit index			Send Literal Message 0-255	1		nargs			lit index			Super-Send Lit Msg 0-255	2		ignored			rcvr index		Push Receiver Variable 0-255	3		ignored			lit index			Push Literal Constant 0-255	4		ignored			lit index			Push Literal Variable 0-255	5		ignored			rcvr index		Store Receiver Variable 0-255	6		ignored			rcvr index		Store-pop Receiver Variable 0-255	7		ignored			lit index			Store Literal Variable 0-255	This has allowed bytecode 134 also to be redefined as a second extended send	that can access literals up to 64 for nargs up to 3 without needing three bytes.	It is just like 131, except that the extension byte is aallllll instead of aaalllll,	where aaa are bits of argument count, and lll are bits of literal index.!!LeafNode methodsFor: 'initialize-release'!key: object code: byte	key _ object.	code _ byte! !!LeafNode methodsFor: 'initialize-release'!key: object index: i type: type	self key: object code: (self code: i type: type)! !!LeafNode methodsFor: 'initialize-release'!name: ignored key: object code: byte	key _ object.	code _ byte! !!LeafNode methodsFor: 'initialize-release'!name: literal key: object index: i type: type	self key: object		index: i		type: type! !!LeafNode methodsFor: 'accessing'!key	^key! !!LeafNode methodsFor: 'code generation'!code	^code! !!LeafNode methodsFor: 'code generation'!emitForEffect: stack on: strm	^self! !!LeafNode methodsFor: 'code generation'!emitLong: mode on: aStream 	"Emit extended variable access."	| type index |	code < 256		ifTrue:			[code < 16			ifTrue: [type _ 0.					index _ code]			ifFalse: [code < 32					ifTrue: [type _ 1.							index _ code - 16]					ifFalse: [code < 96							ifTrue: [type _ code // 32 + 1.									index _ code \\ 32]							ifFalse: [self error: 									'Sends should be handled in SelectorNode']]]]		ifFalse: 			[index _ code \\ 256.			type _ code // 256 - 1].	index <= 63 ifTrue:		[aStream nextPut: mode.		^ aStream nextPut: type * 64 + index].	"Compile for Double-exetended Do-anything instruction..."	mode = LoadLong ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(64 0 96 128) at: type+1).  "Cant be temp (type=1)"		^ aStream nextPut: index].	mode = Store ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(160 0 0 224) at: type+1).  "Cant be temp or const (type=1 or 2)"		^ aStream nextPut: index].	mode = StorePop ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(192 0 0 0) at: type+1).  "Can only be inst"		^ aStream nextPut: index].! !!LeafNode methodsFor: 'code generation'!reserve: encoder 	"If this is a yet unused literal of type -code, reserve it."	code < 0 ifTrue: [code _ self code: (encoder litIndex: key) type: 0 - code]! !!LeafNode methodsFor: 'code generation'!sizeForEffect: encoder	^0! !!LeafNode methodsFor: 'code generation'!sizeForValue: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 1].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!LeafNode methodsFor: 'private'!code: index type: type	index isNil 		ifTrue: [^type negated].	(CodeLimits at: type) > index 		ifTrue: [^(CodeBases at: type) + index].	^type * 256 + index! !!LeafNode methodsFor: 'copying' stamp: 'tk 10/20/2000 11:45'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.key _ deepCopier references at: key ifAbsent: [key].! !!LeafNode methodsFor: 'copying' stamp: 'tk 10/20/2000 11:41'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."key _ key.		Weakly copied"code _ code veryDeepCopyWith: deepCopier.! !WriteStream subclass: #LimitedWriteStream	instanceVariableNames: 'limit limitBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!LimitedWriteStream commentStamp: '<historical>' prior: 0!A LimitedWriteStream is a specialized WriteStream that has a maximum size of the collection it streams over. When this limit is reached a special limitBlock is executed. This can for example be used to "bail out" of lengthy streaming operations before they have finished.  For a simple example take a look at the universal Object printString.The message SequenceableCollection class streamContents:limitedTo: creates a LimitedWriteStream. In this case it prevents very large (or possibly recursive) object structures to "overdo" their textual representation. !]style[(323 18 15 54 151)f1,f1LObject printString;,f1,f1LSequenceableCollection class streamContents:limitedTo:;,f1!!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'BG 3/13/2004 13:18'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > limit ifTrue: [		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).		^ limitBlock value.	].	newEnd > writeLimit ifTrue: [		self growTo: newEnd + 10	].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position _ newEnd.! !!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'di 10/28/2001 12:49'!pastEndPut: anObject	collection size >= limit ifTrue: [limitBlock value].  "Exceptional return"	^ super pastEndPut: anObject! !!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'di 6/20/97 09:07'!setLimit: sizeLimit limitBlock: aBlock	"Limit the numer of elements this stream will write..."	limit _ sizeLimit.	"Execute this (typically ^ contents) when that limit is exceded"	limitBlock _ aBlock! !!LimitedWriteStream methodsFor: 'accessing' stamp: 'BG 3/13/2004 16:03'!nextPut: anObject 	"Ensure that the limit is not exceeded" position >= limit ifTrue: [limitBlock value]    ifFalse: [super nextPut: anObject].! !Object subclass: #LimitingLineStreamWrapper	instanceVariableNames: 'stream line limitingBlock position'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Collections-Streams'!!LimitingLineStreamWrapper commentStamp: '<historical>' prior: 0!I'm a wrapper for a stream optimized for line-by-line access using #nextLine. My instances can be nested.I read one line ahead. Reading terminates when the stream ends, or if the limitingBlock evaluated with the line answers true. To skip the delimiting line for further reading use #skipThisLine.Character-based reading (#next) is permitted, too. Send #updatePosition when switching from line-based reading.See examples at the class side.--bf 2/19/1999 12:52!!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:25'!delimiter: aString	"Set limitBlock to check for a delimiting string. Be unlimiting if nil"	self limitingBlock: (aString caseOf: {		[nil] -> [[:aLine | false]].		[''] -> [[:aLine | aLine size = 0]]	} otherwise: [[:aLine | aLine beginsWith: aString]])! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 19:16'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock _ aBlock fixTemps.	self updatePosition! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 2/19/1999 11:45'!linesUpToEnd	| elements ln |	elements _ OrderedCollection new.	[(ln _ self nextLine) isNil] whileFalse: [ 		elements add: ln].	^elements! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:37'!next	"Provide character-based access"	position isNil ifTrue: [^nil].	position < line size ifTrue: [^line at: (position _ position + 1)].	line _ stream nextLine.	self updatePosition.	^ Character cr! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:09'!nextLine	| thisLine |	self atEnd ifTrue: [^nil].	thisLine _ line.	line _ stream nextLine.	^thisLine! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 16:53'!skipThisLine	line _ stream nextLine.	self updatePosition.! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 2/19/1999 11:47'!upToEnd	| ln |	^String streamContents: [:strm |		[(ln _ self nextLine) isNil] whileFalse: [ 			strm nextPutAll: ln; cr]]! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:37'!updatePosition	"Call this before doing character-based access"	position _ self atEnd ifFalse: [0]! !!LimitingLineStreamWrapper methodsFor: 'testing' stamp: 'bf 11/13/1998 16:55'!atEnd	^line isNil or: [limitingBlock value: line]! !!LimitingLineStreamWrapper methodsFor: 'stream protocol' stamp: 'bf 11/13/1998 17:00'!close	^stream close! !!LimitingLineStreamWrapper methodsFor: 'printing' stamp: 'bf 11/24/1998 13:39'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on '.	stream printOn: aStream! !!LimitingLineStreamWrapper methodsFor: 'private' stamp: 'bf 11/24/1998 14:30'!setStream: aStream delimiter: aString	stream _ aStream.	line _ stream nextLine.	self delimiter: aString.	"sets position"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LimitingLineStreamWrapper class	instanceVariableNames: ''!!LimitingLineStreamWrapper class methodsFor: 'instance creation' stamp: 'bf 11/24/1998 14:31'!on: aStream delimiter: aString	^self new setStream: aStream delimiter: aString! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 11:48'!example1	"LimitingLineStreamWrapper example1"	"Separate chunks of text delimited by a special string"	| inStream msgStream messages |	inStream _ self exampleStream.	msgStream _ LimitingLineStreamWrapper on: inStream delimiter: 'From '.	messages _ OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine.		messages add: msgStream upToEnd].	^messages			! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 12:46'!example2	"LimitingLineStreamWrapper example2"	"Demo nesting wrappers - get header lines from some messages"	| inStream msgStream headers headerStream |	inStream _ self exampleStream.	msgStream _ LimitingLineStreamWrapper on: inStream delimiter: 'From '.	headers _ OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine. "Skip From"		headerStream _ LimitingLineStreamWrapper on: msgStream delimiter: ''.		headers add: headerStream linesUpToEnd.		[msgStream nextLine isNil] whileFalse. "Skip Body"	].	^headers			! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 12:44'!exampleStream	^ReadStream on:'From me@somewhereFrom: meTo: youSubject: TestTestFrom you@elsewhereFrom: youTo: meSubject: Re: testokay'! !Path subclass: #Line	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!Line commentStamp: '<historical>' prior: 0!I represent the line segment specified by two points.!!Line methodsFor: 'accessing'!beginPoint	"Answer the first end point of the receiver."	^self first! !!Line methodsFor: 'accessing'!beginPoint: aPoint 	"Set the first end point of the receiver to be the argument, aPoint. 	Answer aPoint."	self at: 1 put: aPoint.	^aPoint! !!Line methodsFor: 'accessing'!endPoint	"Answer the last end point of the receiver."	^self last! !!Line methodsFor: 'accessing'!endPoint: aPoint 	"Set the first end point of the receiver to be the argument, aPoint. 	Answer aPoint."	self at: 2 put: aPoint.	^aPoint! !!Line methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"The form associated with this Path will be displayed, according  	to one of the sixteen functions of two logical variables (rule), at  	each point on the Line. Also the source form will be first anded  	with aForm as a mask. Does not effect the state of the Path."	collectionOfPoints size < 2 ifTrue: [self error: 'a line must have two points'].	aDisplayMedium		drawLine: self form		from: self beginPoint + aPoint		to: self endPoint + aPoint		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Line methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newPath newLine |	newPath _ aTransformation applyTo: self.	newLine _ Line new.	newLine beginPoint: newPath firstPoint.	newLine endPoint: newPath secondPoint.	newLine form: self form.	newLine		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Line methodsFor: 'displaying'!displayOnPort: aPort at: aPoint 	aPort sourceForm: self form; combinationRule: Form under; fillColor: nil.	aPort drawFrom: collectionOfPoints first + aPoint		to: collectionOfPoints last + aPoint! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Line class	instanceVariableNames: ''!!Line class methodsFor: 'instance creation'!new	| newSelf | 	newSelf _ super new: 2.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!Line class methodsFor: 'examples'!example	"Designate two places on the screen by clicking any mouse button. A	straight path with a square black form will be displayed connecting the	two selected points."	| aLine aForm |  	aForm _ Form extent: 20@20.		"make a form one quarter of inch square"	aForm fillBlack.							"turn it black"	aLine _ Line new.	aLine form: aForm.						"use the black form for display"	aLine beginPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aLine beginPoint.		aLine endPoint: Sensor waitButton.	aLine displayOn: Display.				"display the line"	"Line example"! !Path subclass: #LinearFit	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!LinearFit commentStamp: '<historical>' prior: 0!I represent a piece-wise linear approximation to a set of points in the plane.!!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 22:16'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anIntegerfillColor: aForm 	| line |	line _ Line new.	line form: self form.	1 to: self size - 1 do: 		[:i | 		line beginPoint: (self at: i).		line endPoint: (self at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 23:00'!displayOn: aDisplayMedium transformation: aTransformation clippingBox:clipRect rule: anInteger fillColor: aForm 	| transformedPath |	"get the scaled and translated Path."	transformedPath _ aTransformation applyTo: self.	transformedPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LinearFit class	instanceVariableNames: ''!!LinearFit class methodsFor: 'examples'!example	"Select points on a Path using the red button. Terminate by selecting	any other button. Creates a Path from the points and displays it as a	piece-wise linear approximation." 	| aLinearFit aForm flag |	aLinearFit _ LinearFit new.	aForm _ Form extent: 1 @ 40.	aForm  fillBlack.	aLinearFit form: aForm.	flag _ true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: [aLinearFit add: Sensor waitButton. Sensor waitNoButton.					aForm displayOn: Display at: aLinearFit last]			ifFalse: [flag_false]].	aLinearFit displayOn: Display	"LinearFit example"! !Object subclass: #Link	instanceVariableNames: 'nextLink'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!Link commentStamp: '<historical>' prior: 0!An instance of me is a simple record of a pointer to another Link. I am an abstract class; my concrete subclasses, for example, Process, can be stored in a LinkedList structure.!!Link methodsFor: 'accessing'!nextLink	"Answer the link to which the receiver points."	^nextLink! !!Link methodsFor: 'accessing'!nextLink: aLink 	"Store the argument, aLink, as the link to which the receiver refers. 	Answer aLink."	^nextLink _ aLink! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Link class	instanceVariableNames: ''!!Link class methodsFor: 'instance creation' stamp: 'apb 10/3/2000 15:55'!nextLink: aLink 	"Answer an instance of me referring to the argument, aLink."	^self new nextLink: aLink; yourself! !SequenceableCollection subclass: #LinkedList	instanceVariableNames: 'firstLink lastLink'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!LinkedList commentStamp: '<historical>' prior: 0!I represent a collection of links, which are containers for other objects. Using the message sequence addFirst:/removeLast causes the receiver to behave as a stack; using addLast:/removeFirst causes the receiver to behave as a queue.!!LinkedList methodsFor: 'accessing' stamp: 'ajh 8/6/2002 15:46'!at: index	| i |	i _ 0.	self do: [:link |		(i _ i + 1) = index ifTrue: [^ link]].	^ self errorSubscriptBounds: index! !!LinkedList methodsFor: 'accessing'!first	"Answer the first link. Create an error notification if the receiver is 	empty."	self emptyCheck.	^firstLink! !!LinkedList methodsFor: 'accessing'!last	"Answer the last link. Create an error notification if the receiver is 	empty."	self emptyCheck.	^lastLink! !!LinkedList methodsFor: 'testing'!isEmpty	^firstLink == nil! !!LinkedList methodsFor: 'adding'!add: aLink 	"Add aLink to the end of the receiver's list. Answer aLink."	^self addLast: aLink! !!LinkedList methodsFor: 'adding' stamp: 'ajh 8/22/2002 14:17'!add: link before: otherLink	| aLink |	firstLink == otherLink ifTrue: [^ self addFirst: link].	aLink _ firstLink.	[aLink == nil] whileFalse: [		aLink nextLink == otherLink ifTrue: [			link nextLink: aLink nextLink.			aLink nextLink: link.			^ link		].		 aLink _ aLink nextLink.	].	^ self errorNotFound: otherLink! !!LinkedList methodsFor: 'adding'!addFirst: aLink 	"Add aLink to the beginning of the receiver's list. Answer aLink."	self isEmpty ifTrue: [lastLink _ aLink].	aLink nextLink: firstLink.	firstLink _ aLink.	^aLink! !!LinkedList methodsFor: 'adding'!addLast: aLink 	"Add aLink to the end of the receiver's list. Answer aLink."	self isEmpty		ifTrue: [firstLink _ aLink]		ifFalse: [lastLink nextLink: aLink].	lastLink _ aLink.	^aLink! !!LinkedList methodsFor: 'removing'!remove: aLink ifAbsent: aBlock  	"Remove aLink from the receiver. If it is not there, answer the result of	evaluating aBlock."	| tempLink |	aLink == firstLink		ifTrue: [firstLink _ aLink nextLink.				aLink == lastLink					ifTrue: [lastLink _ nil]]		ifFalse: [tempLink _ firstLink.				[tempLink == nil ifTrue: [^aBlock value].				 tempLink nextLink == aLink]					whileFalse: [tempLink _ tempLink nextLink].				tempLink nextLink: aLink nextLink.				aLink == lastLink					ifTrue: [lastLink _ tempLink]].	aLink nextLink: nil.	^aLink! !!LinkedList methodsFor: 'removing'!removeFirst	"Remove the first element and answer it. If the receiver is empty, create 	an error notification."	| oldLink |	self emptyCheck.	oldLink _ firstLink.	firstLink == lastLink		ifTrue: [firstLink _ nil. lastLink _ nil]		ifFalse: [firstLink _ oldLink nextLink].	oldLink nextLink: nil.	^oldLink! !!LinkedList methodsFor: 'removing'!removeLast	"Remove the receiver's last element and answer it. If the receiver is 	empty, create an error notification."	| oldLink aLink |	self emptyCheck.	oldLink _ lastLink.	firstLink == lastLink		ifTrue: [firstLink _ nil. lastLink _ nil]		ifFalse: [aLink _ firstLink.				[aLink nextLink == oldLink] whileFalse:					[aLink _ aLink nextLink].				 aLink nextLink: nil.				 lastLink _ aLink].	oldLink nextLink: nil.	^oldLink! !!LinkedList methodsFor: 'enumerating'!do: aBlock	| aLink |	aLink _ firstLink.	[aLink == nil] whileFalse:		[aBlock value: aLink.		 aLink _ aLink nextLink]! !!LinkedList methodsFor: 'enumerating' stamp: 'ajh 8/6/2002 16:39'!species	^ Array! !ScrollController subclass: #ListController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!ListController commentStamp: '<historical>' prior: 0!I am a kind of ScrollController that assumes that the view is a kind of ListView. Therefore, scrolling means moving the items in a textual list (menu) up or down. In addition, I provide the red button activity of determining when the red button is selecting an item in the list.!!ListController methodsFor: 'control defaults' stamp: 'bf 4/14/1999 12:41'!controlActivity	self scrollByKeyboard ifTrue: [^self].	self processKeyboard.	super controlActivity.! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	| viewList |	viewList _ view list.	viewList compositionRectangle height = 0		ifTrue: [^ 0@0 extent: Preferences scrollBarWidth@scrollBar inside height].	^ 0@0 extent: Preferences scrollBarWidth@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !!ListController methodsFor: 'marker adjustment'!markerDelta	| viewList |	viewList _ view list.	viewList compositionRectangle height == 0 ifTrue: [		^ (marker top - scrollBar inside top) - scrollBar inside height	].	^ (marker top - scrollBar inside top) -		((viewList clippingRectangle top -				viewList compositionRectangle top) asFloat /			viewList compositionRectangle height asFloat *			scrollBar inside height asFloat) rounded! !!ListController methodsFor: 'scrolling'!scrollAmount 	"Refer to the comment in ScrollController|scrollAmount."	^sensor cursorPoint y - scrollBar inside top! !!ListController methodsFor: 'scrolling'!scrollView: anInteger 	"Scroll the view and highlight the selection if it just came into view"	| wasClipped |	wasClipped _ view isSelectionBoxClipped.	(view scrollBy: anInteger)		ifTrue: [view isSelectionBoxClipped ifFalse:					[wasClipped ifTrue:  "Selection came into view"						[view displaySelectionBox]].				^ true]		ifFalse: [^ false]! !!ListController methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	| viewList |	viewList _ view list.	^(viewList clippingRectangle top -			viewList compositionRectangle top -			((marker top - scrollBar inside top) asFloat /				scrollBar inside height asFloat *				viewList compositionRectangle height asFloat))		roundTo: viewList lineGrid! !!ListController methodsFor: 'selecting' stamp: 'tk 4/1/98 10:33'!redButtonActivity	| noSelectionMovement oldSelection selection nextSelection pt scrollFlag firstTime |	noSelectionMovement _ true.	scrollFlag _ false.	oldSelection _ view selection.	firstTime _ true.	[sensor redButtonPressed | firstTime]		whileTrue: 			[selection _ view findSelection: (pt _ sensor cursorPoint).			firstTime _ false.			selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"					[pt y < view insetDisplayBox top ifTrue:						[self scrollView: view list lineGrid.						scrollFlag _ true.						selection _ view firstShown].					pt y > view insetDisplayBox bottom ifTrue:						[self scrollView: view list lineGrid negated.						scrollFlag _ true.						selection _ view lastShown]].			selection == nil ifFalse:					[view moveSelectionBox: (nextSelection _ selection).					nextSelection ~= oldSelection						ifTrue: [noSelectionMovement _ false]]].	nextSelection ~~ nil & (nextSelection = oldSelection			ifTrue: [noSelectionMovement]			ifFalse: [true]) ifTrue: [self changeModelSelection: nextSelection].	scrollFlag ifTrue: [self moveMarker]! !!ListController methodsFor: 'private'!changeModelSelection: anInteger	model toggleListIndex: anInteger! !!ListController methodsFor: 'menu messages' stamp: 'acg 9/18/1999 14:09'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !Paragraph subclass: #ListParagraph	instanceVariableNames: ''	classVariableNames: 'ListStyle'	poolDictionaries: ''	category: 'ST80-Support'!!ListParagraph commentStamp: '<historical>' prior: 0!I represent a special type of Paragraph that is used in the list panes of a browser.  I  avoid all the composition done by more general Paragraphs, because I know the structure of my Text.!!ListParagraph methodsFor: 'composition'!composeAll	"No composition is necessary once the ListParagraph is created."		lastLine isNil ifTrue: [lastLine _ 0].			"Because composeAll is called once in the process of creating the ListParagraph."	^compositionRectangle width! !!ListParagraph methodsFor: 'private'!trimLinesTo: lastLineInteger	"Since ListParagraphs are not designed to be changed, we can cut back the		lines field to lastLineInteger."	lastLine _ lastLineInteger.	lines _ lines copyFrom: 1 to: lastLine! !!ListParagraph methodsFor: 'private' stamp: 'di 7/13/97 16:56'!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString |	lines _ Array new: 20.	lastLine _ 0.	startOfLine _ 1.	endOfLine _ 1.	lineIndex _ 0.	anArray do: 		[:item | 		endOfLine _ startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex _ lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine _ endOfLine + 1].	endOfLine _ endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString _ String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item asString			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	anArray with: lines do: 		[:item :interval |  item isText ifTrue:			[text replaceFrom: interval first to: interval last - 1 with: item]].	self updateCompositionHeight! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ListParagraph class	instanceVariableNames: ''!!ListParagraph class methodsFor: 'instance creation' stamp: 'jm 9/20/1998 17:10'!withArray: anArray style: aTextStyleOrNil	"Convert an array of strings into a ListParagraph using the given TextStyle."	aTextStyleOrNil		ifNil: [^ (super withText: Text new style: ListStyle) withArray: anArray]		ifNotNil: [^ (super withText: Text new style: aTextStyleOrNil) withArray: anArray].! !!ListParagraph class methodsFor: 'initialization' stamp: 'sw 12/10/1999 10:37'!initialize 	"ListParagraph initialize"	| aFont |	"Allow different line spacing for lists"	aFont _ Preferences standardListFont.	ListStyle _ aFont textStyle copy consistOnlyOf: aFont.	ListStyle gridForFont: 1 withLead: 1! !!ListParagraph class methodsFor: 'style' stamp: 'sw 12/10/1999 10:43'!standardListStyle	^ ListStyle! !View subclass: #ListView	instanceVariableNames: 'list selection topDelimiter bottomDelimiter isEmpty textStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!ListView commentStamp: '<historical>' prior: 0!I am an abstract View of a list of items. I provide support for storing a selection of one item, as well as formatting the list for presentation on the screen. My instances' default controller is ListController.!!ListView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter _ '------------'.	bottomDelimiter _ '------------'.	isEmpty _ true.	self list: Array new! !!ListView methodsFor: 'font access' stamp: 'sw 12/9/1999 18:07'!font	^ self assuredTextStyle fontNamed: textStyle fontNames first! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle _ nil]		ifNotNil: [			textStyle _ TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'list access' stamp: 'sw 12/10/1999 10:43'!assuredTextStyle	^ textStyle ifNil:		[textStyle _  ListParagraph standardListStyle]! !!ListView methodsFor: 'list access'!list	"Answer the list of items the receiver displays."	^list! !!ListView methodsFor: 'list access' stamp: 'sw 12/9/1999 18:06'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy style: self assuredTextStyle.	selection _ 0.	self positionList.! !!ListView methodsFor: 'list access'!reset	"Set the list of items displayed to be empty."	isEmpty _ true.	self list: Array new! !!ListView methodsFor: 'list access'!resetAndDisplayView	"Set the list of items displayed to be empty and redisplay the receiver."	isEmpty		ifFalse: 			[self reset.			self displayView]! !!ListView methodsFor: 'list access'!selection: selIndex	selection _ selIndex! !!ListView methodsFor: 'delimiters'!bottomDelimiter	"Answer the string used to indicate the bottom of the list."	^bottomDelimiter! !!ListView methodsFor: 'delimiters'!bottomDelimiter: aString 	"Set the string used to indicate the bottom of the list."	bottomDelimiter _ aString! !!ListView methodsFor: 'delimiters'!noBottomDelimiter	"Set the string used to indicate the bottom of the list to be nothing."	bottomDelimiter _ nil! !!ListView methodsFor: 'delimiters'!noTopDelimiter	"Set the string used to indicate the top of the list to be nothing."	topDelimiter _ nil! !!ListView methodsFor: 'delimiters'!topDelimiter	"Answer the string used to indicate the top of the list."	^topDelimiter! !!ListView methodsFor: 'delimiters'!topDelimiter: aString 	"Set the string used to indicate the top of the list."	topDelimiter _ aString! !!ListView methodsFor: 'displaying'!deEmphasizeSelectionBox	self displaySelectionBox! !!ListView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self clippingBox ~= list clippingRectangle])		ifTrue:  "Recompose the list if the window changed"			[selection isNil ifTrue: [selection _ 0].			self positionList].	super display! !!ListView methodsFor: 'displaying'!displaySelectionBox	"If the receiver has a selection and that selection is visible on the display 	screen, then highlight it."	selection ~= 0 ifTrue:		[Display reverse: (self selectionBox intersect: self clippingBox)]! !!ListView methodsFor: 'displaying'!displayView 	"Refer to the comment in View|displayView."	self clearInside.	list foregroundColor: self foregroundColor		backgroundColor: self backgroundColor.	list displayOn: Display! !!ListView methodsFor: 'displaying'!scrollBy: anInteger 	"Scroll up by this amount adjusted by lineSpacing and list limits"	| maximumAmount minimumAmount amount wasClipped |	maximumAmount _ 0 max:		list clippingRectangle top - list compositionRectangle top.	minimumAmount _ 0 min:		list clippingRectangle bottom - list compositionRectangle bottom.	amount _ (anInteger min: maximumAmount) max: minimumAmount.	amount ~= 0		ifTrue: [list scrollBy: amount negated.  ^ true]		ifFalse: [^ false]  "Return false if no scrolling took place"! !!ListView methodsFor: 'displaying'!scrollSelectionIntoView	"Selection is assumed to be on and clipped out of view.	Uses controller scrollView to keep selection right"	| delta |	(delta _ self insetDisplayBox bottom - self selectionBox bottom) < 0		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"	(delta _ self insetDisplayBox top - self selectionBox top) > 0		ifTrue: [^ self controller scrollView: delta + 1] "down"! !!ListView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	^ self deEmphasizeSelectionBox! !!ListView methodsFor: 'deEmphasizing'!emphasizeView 	"List emphasis is its own inverse."	^ self deEmphasizeView! !!ListView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^ListController! !!ListView methodsFor: 'display box access'!boundingBox 	"Refer to the comment in View|boundingBox."	^list boundingBox! !!ListView methodsFor: 'display box access' stamp: 'mkd 11/4/1999 14:31'!isSelectionBoxClipped        "Answer whether there is a selection and whether the selection is visible         on the screen."        ^ selection ~= 0 and:			[(self selectionBox intersects:                        (self clippingBox insetBy: (Rectangle left: 0 right: 0 top: 1 bottom: 0))) not]! !!ListView methodsFor: 'clipping box access'!clippingBox	"Answer the rectangle in which the model can be displayed--this is the 	insetDisplayBox inset by the height of a line for an item."	^self insetDisplayBox insetBy: 		(Rectangle			left: 0			right: 0			top: 0			bottom: self insetDisplayBox height \\ list lineGrid)! !!ListView methodsFor: 'selecting'!deselect	"If the receiver has a selection, then it is highlighted. Remove the 	highlighting."	selection ~= 0 ifTrue: [Display reverse: (self selectionBox intersect: self clippingBox)]! !!ListView methodsFor: 'selecting'!findSelection: aPoint 	"Determine which selection is displayed in an area containing the point, 	aPoint. Answer the selection if one contains the point, answer nil 	otherwise."	| trialSelection |	(self clippingBox containsPoint: aPoint) ifFalse: [^nil].	trialSelection _ aPoint y - list compositionRectangle top // list lineGrid + 1.	topDelimiter == nil ifFalse: [trialSelection _ trialSelection - 1].	(trialSelection < 1) | (trialSelection > self maximumSelection)		ifTrue: [^ nil]		ifFalse: [^ trialSelection]! !!ListView methodsFor: 'selecting'!maximumSelection	"Answer which selection is the last possible one."	^ list numberOfLines		- (topDelimiter == nil ifTrue: [0] ifFalse: [1])		- (bottomDelimiter == nil ifTrue: [0] ifFalse: [1])! !!ListView methodsFor: 'selecting'!minimumSelection	"Answer which selection is the first possible one."	^ 1! !!ListView methodsFor: 'selecting'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[self deselect.			selection _ anInteger.			self displaySelectionBox].	self isSelectionBoxClipped		ifTrue: [self scrollSelectionIntoView]! !!ListView methodsFor: 'selecting' stamp: 'di 5/22/1998 00:25'!numSelectionsInView	^ self clippingBox height // self list lineGrid! !!ListView methodsFor: 'selecting'!selection	"Answer the receiver's current selection."	^selection! !!ListView methodsFor: 'selecting'!selectionBox	"Answer the rectangle in which the current selection is displayed."	^(self insetDisplayBox left @ (list compositionRectangle top + self selectionBoxOffset) 		extent: self insetDisplayBox width @ list lineGrid)		insetBy: (Rectangle left: 1 right: 1 top: 1 bottom: 0)! !!ListView methodsFor: 'selecting'!selectionBoxOffset	"Answer an integer that determines the y position for the display box of 	the current selection."	^ (selection - 1 + (topDelimiter == nil ifTrue: [0] ifFalse: [1]))		* list lineGrid! !!ListView methodsFor: 'updating'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == #list		ifTrue: 			[self list: model list.			self displayView.			^self].	aSymbol == #listIndex		ifTrue: 			[self moveSelectionBox: model listIndex.			^self]! !!ListView methodsFor: 'private'!firstShown	"Return the index of the top item currently visible"	| trial |	trial _ self findSelection: self insetDisplayBox topLeft.	^ trial == nil		ifTrue: [1]		ifFalse: [trial]! !!ListView methodsFor: 'private'!lastShown	"Return the index of the bottom item currently visible"	| trial bottomMargin |	bottomMargin _ self insetDisplayBox height \\ list lineGrid.	trial _ self findSelection: self insetDisplayBox bottomLeft - (0@bottomMargin).	trial == nil		ifTrue: [trial _ self findSelection: self insetDisplayBox bottomLeft					- (0@(list lineGrid+bottomMargin))].	^ trial == nil		ifTrue: [list numberOfLines - 2]		ifFalse: [trial]! !!ListView methodsFor: 'private'!positionList	list wrappingBox: self wrappingBox clippingBox: self clippingBox ! !!ListView methodsFor: 'private'!wrappingBox	| aRectangle |	aRectangle _ self insetDisplayBox. 	selection = 0		ifTrue: [^aRectangle topLeft + (4 @ 0) extent: list compositionRectangle extent]		ifFalse: [^aRectangle left + 4 @ 					(aRectangle top - 						(self selectionBoxOffset 							min: ((list height - aRectangle height 									+ list lineGrid truncateTo: list lineGrid)							max: 0))) 					extent: list compositionRectangle extent]! !!ListView methodsFor: 'lock access'!lock	"Refer to the comment in view|lock.  Must do at least what display would do to lock the view."	(self isUnlocked and: [self clippingBox ~= list clippingRectangle])		ifTrue:  "Recompose the list if the window changed"			[self positionList].	super lock! !Dictionary subclass: #LiteralDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!LiteralDictionary commentStamp: '<historical>' prior: 0!A LiteralDictionary, like an IdentityDictionary, has a special test for equality.  In this case it is simple equality between objects of like class.  This allows equal Float or String literals to be shared without the possibility of erroneously sharing, say, 1 and 1.0!!LiteralDictionary methodsFor: 'as yet unclassified' stamp: 'yo 1/27/2001 05:06'!arrayEquality: x and: y	x size = y size ifFalse: [^ false].	x with: y do: [:e1 :e2 | 		(self literalEquality: e1 and: e2) ifFalse: [^ false]	].	^true.! !!LiteralDictionary methodsFor: 'as yet unclassified' stamp: 'yo 1/27/2001 05:13'!literalEquality: x and: y	^ (x class = Array and: [y class = Array]) ifTrue: [		self arrayEquality: x and: y.	] ifFalse: [		(x class == y class) and: [x = y]	].! !!LiteralDictionary methodsFor: 'as yet unclassified' stamp: 'yo 1/27/2001 05:10'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !LeafNode subclass: #LiteralNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!LiteralNode commentStamp: '<historical>' prior: 0!I am a parse tree leaf representing a literal string or number.!!LiteralNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1! !!LiteralNode methodsFor: 'testing'!isConstantNumber	^ key isNumber! !!LiteralNode methodsFor: 'testing' stamp: 'di 4/5/2000 11:13'!isLiteral	^ true! !!LiteralNode methodsFor: 'testing'!isSpecialConstant	^ code between: LdTrue and: LdMinus1+3! !!LiteralNode methodsFor: 'testing'!literalValue	^key! !!LiteralNode methodsFor: 'printing' stamp: 'ar 8/16/2001 13:27'!printOn: aStream indent: level	(key isVariableBinding)		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###';					 	nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##';						nextPutAll: key key]]		ifFalse:			[aStream withStyleFor: #literal					do: [key storeOn: aStream]]! !VariableNode subclass: #LiteralVariableNode	instanceVariableNames: 'splNode'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:12'!emitLoad: stack on: strm	splNode ifNil:[^super emitLoad: stack on: strm].	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:12'!emitStore: stack on: strm	splNode ifNil:[^super emitStore: stack on: strm].	splNode			emit: stack			args: 1			on: strm			super: false.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:12'!emitStorePop: stack on: strm	splNode ifNil:[^super emitStorePop: stack on: strm].	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/21/2001 13:21'!sizeForStore: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStore: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	splNode _ encoder encodeSelector: #value:.	^(splNode size: encoder args: 1 super: false) + (super sizeForValue: encoder)! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/21/2001 13:21'!sizeForStorePop: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStorePop: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	splNode _ encoder encodeSelector: #value:.	^(splNode size: encoder args: 1 super: false) + (super sizeForValue: encoder) + 1! !Magnitude subclass: #LookupKey	instanceVariableNames: 'key'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!LookupKey commentStamp: '<historical>' prior: 0!I represent a key for looking up entries in a data structure. Subclasses of me, such as Association, typically represent dictionary entries.!!LookupKey methodsFor: 'accessing'!key	"Answer the lookup key of the receiver."	^key! !!LookupKey methodsFor: 'accessing'!key: anObject 	"Store the argument, anObject, as the lookup key of the receiver."	key _ anObject! !!LookupKey methodsFor: 'accessing' stamp: 'ajh 3/24/2003 21:14'!name	^ self key isString		ifTrue: [self key]		ifFalse: [self key printString]! !!LookupKey methodsFor: 'comparing'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^key < aLookupKey key! !!LookupKey methodsFor: 'comparing'!= aLookupKey	self species = aLookupKey species		ifTrue: [^key = aLookupKey key]		ifFalse: [^false]! !!LookupKey methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^key hash! !!LookupKey methodsFor: 'comparing'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^key hashMappedBy: map! !!LookupKey methodsFor: 'comparing' stamp: 'di 9/27/97 20:45'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ key identityHashMappedBy: map! !!LookupKey methodsFor: 'printing'!printOn: aStream	key printOn: aStream! !!LookupKey methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 02:35'!writeOnFilterStream: aStream	aStream write:key.! !!LookupKey methodsFor: 'testing' stamp: 'ar 8/14/2001 22:39'!isVariableBinding	"Return true if I represent a literal variable binding"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LookupKey class	instanceVariableNames: ''!!LookupKey class methodsFor: 'instance creation'!key: aKey 	"Answer an instance of me with the argument as the lookup up."	^self new key: aKey! !FileDirectory subclass: #MacFileDirectory	instanceVariableNames: ''	classVariableNames: 'TypeToMimeMappings'	poolDictionaries: ''	category: 'System-Files'!!MacFileDirectory commentStamp: '<historical>' prior: 0!I represent a Macintosh FileDirectory.!!MacFileDirectory methodsFor: 'file operations' stamp: 'nk 3/13/2003 09:01'!fullPathFor: path	"Return the fully-qualified path name for the given file."	path isEmptyOrNil ifTrue: [^ pathName].	(self class isAbsolute: path) ifTrue: [^ path].	pathName = ''			"Root dir?"		ifTrue: [ ^path].	^(path first = $:)		ifTrue: [ pathName, path ]		ifFalse: [pathName , ':' , path]! !!MacFileDirectory methodsFor: 'as yet unclassified' stamp: 'hmm 3/25/2004 21:57'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	"Details: Note that path relative to a directory, such as '../../foo' are disallowed by this algorithm.  Also note that this method is tolerent of a nil argument -- is simply returns nil in this case."	"Fix by hmm: for a file in the root directory of a volume on MacOS, the filePath (name of the directory) is not  recognizable as an absolute path anymore (it has no delimiters). Therefore, the original fileName is tested for absoluteness, and the filePath is only made absolute if the original fileName was not absolute"	| correctedLocalName prefix |	fileName isEmptyOrNil ifTrue: [^ fileName].	DirectoryClass splitName: fileName to:		[:filePath :localName |			correctedLocalName _ localName isEmpty 				ifFalse: [self checkName: localName fixErrors: true]				ifTrue: [localName].			prefix _ (DirectoryClass isAbsolute: fileName)						ifTrue: [filePath]						ifFalse: [self fullPathFor: filePath]].	prefix isEmpty		ifTrue: [^correctedLocalName].	prefix last = self pathNameDelimiter		ifTrue:[^ prefix, correctedLocalName]		ifFalse:[^ prefix, self slash, correctedLocalName]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MacFileDirectory class	instanceVariableNames: ''!!MacFileDirectory class methodsFor: 'platform specific' stamp: 'md 10/26/2003 13:06'!isActiveDirectoryClass	^ super isActiveDirectoryClass		and: [(SmalltalkImage current getSystemAttribute: 1201) isNil				or: [(SmalltalkImage current getSystemAttribute: 1201) asNumber <= 31]]! !!MacFileDirectory class methodsFor: 'platform specific' stamp: 'di 5/11/1999 08:53'!isCaseSensitive	"Mac OS ignores the case of file names"	^ false! !!MacFileDirectory class methodsFor: 'platform specific' stamp: 'hg 9/28/2001 15:23'!maxFileNameLength	^31! !!MacFileDirectory class methodsFor: 'platform specific' stamp: 'jm 12/4/97 22:57'!pathNameDelimiter	^ $:! !!MacFileDirectory class methodsFor: 'class initialization' stamp: 'nk 12/5/2002 11:17'!isAbsolute: fileName	"Return true if the given fileName is absolute. The rules are:If a path begins with a colon, it is relative.Otherwise,  If it contains a colon anywhere, it is absolute and the first component is the volume name.  Otherwise,    It is relative."	^fileName first ~= $:		and: [ fileName includes: $: ]! !MacFileDirectory subclass: #MacHFSPlusFileDirectory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MacHFSPlusFileDirectory class	instanceVariableNames: ''!!MacHFSPlusFileDirectory class methodsFor: 'platform specific' stamp: 'md 10/26/2003 13:06'!isActiveDirectoryClass	"Ok, lets see if we support HFS Plus file names, the long ones"	^ (self pathNameDelimiter = self primPathNameDelimiter) and: [(SmalltalkImage current  getSystemAttribute: 1201) notNil and: [(SmalltalkImage current getSystemAttribute: 1201) asNumber > 31]]! !!MacHFSPlusFileDirectory class methodsFor: 'platform specific' stamp: 'JMM 11/14/1935 00:02'!maxFileNameLength	^ 255! !Object subclass: #Magnitude	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Magnitudes'!!Magnitude commentStamp: '<historical>' prior: 0!Magnitude has methods for dealing with linearly ordered collections.Subclasses represent dates, times, and numbers.Example for interval-testing (answers a Boolean):	7 between: 5 and: 10 No instance-variables.!!Magnitude methodsFor: 'comparing'!< aMagnitude 	"Answer whether the receiver is less than the argument."	^self subclassResponsibility! !!Magnitude methodsFor: 'comparing'!<= aMagnitude 	"Answer whether the receiver is less than or equal to the argument."	^(self > aMagnitude) not! !!Magnitude methodsFor: 'comparing'!= aMagnitude 	"Compare the receiver with the argument and answer with true if the 	receiver is equal to the argument. Otherwise answer false."	^self subclassResponsibility! !!Magnitude methodsFor: 'comparing'!> aMagnitude 	"Answer whether the receiver is greater than the argument."	^aMagnitude < self! !!Magnitude methodsFor: 'comparing'!>= aMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	^(self < aMagnitude) not! !!Magnitude methodsFor: 'comparing'!between: min and: max 	"Answer whether the receiver is less than or equal to the argument, max, 	and greater than or equal to the argument, min."	^self >= min and: [self <= max]! !!Magnitude methodsFor: 'comparing'!hash	"Hash must be redefined whenever = is redefined."	^self subclassResponsibility! !!Magnitude methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Magnitude methodsFor: 'testing'!max: aMagnitude 	"Answer the receiver or the argument, whichever has the greater 	magnitude."	self > aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]! !!Magnitude methodsFor: 'testing'!min: aMagnitude 	"Answer the receiver or the argument, whichever has the lesser 	magnitude."	self < aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]! !!Magnitude methodsFor: 'testing'!min: aMin max: aMax 	^ (self min: aMin) max: aMax! !Collection subclass: #Matrix	instanceVariableNames: 'nrows ncols contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!Matrix commentStamp: '<historical>' prior: 0!I represent a two-dimensional array, rather like Array2D.There are three main differences between me and Array2D:(1) Array2D inherits from ArrayedCollection, but isn't one.  A lot of things that should work    do not work in consequence of this.(2) Array2D uses "at: column at: row" index order, which means that nothing you write using    it is likely to work either.  I use the almost universal "at: row at: column" order, so it is    much easier to adapt code from other languages without going doolally.(3) Array2D lets you specify the class of the underlying collection, I don't.Structure:  nrows : a non-negative integer saying how many rows there are.  ncols : a non-negative integer saying how many columns there are.  contents : an Array holding the elements in row-major order.  That is, for a 2x3 array    the contents are (11 12 13 21 22 23).  Array2D uses column major order.    You can specify the class of 'contents' when you create a new Array2D,    but Matrix always gives you an Array.    There is a reason for this.  In strongly typed languages like Haskell and Clean,    'unboxed arrays' save you both space AND time.  But in Squeak, while    WordArray and FloatArray and so on do save space, it costs time to use them.    A LOT of time.  I've measured aFloatArray sum running nearly twice as slow as    anArray sum.  The reason is that whenever you fetch an element from an Array,    that's all that happens, but when you fetch an element from aFloatArray, a whole    new Float gets allocated to hold the value.  This takes time and churns memory.    So the paradox is that if you want fast numerical stuff, DON'T use unboxed arrays!!    Another reason for always insisting on an Array is that letting it be something    else would make things like #, and #,, rather more complicated.  Always using Array    is the simplest thing that could possibly work, and it works rather well.I was trying to patch Array2D to make more things work, but just couldn't get my headaround the subscript order.  That's why I made Matrix.Element-wise matrix arithmetic works; you can freely mix matrices and numbers butdon't try to mix matrices and arrays (yet).Matrix multiplication, using the symbol +* (derived from APL's +.x), works between(Matrix or Array) +* (Matrix or Array).  Don't try to use a number as an argument of +*.Matrix * Number and Number * Matrix work fine, so you don't need +* with numbers.Still to come: oodles of stuff.  Gaussian elimination maybe, other stuff probably not.!!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:37'!anyOne	^contents anyOne! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:37'!at: row at: column	^contents at: (self indexForRow: row andColumn: column)! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:40'!at: row at: column put: value	^contents at: (self indexForRow: row andColumn: column) put: value! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:42'!atAllPut: value	contents atAllPut: value! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:43'!atRandom	^contents atRandom! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:43'!atRandom: aGenerator	^contents atRandom: aGenerator! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:44'!columnCount	^ncols! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:48'!identityIndexOf: anElement	^self identityIndexOf: anElement ifAbsent: [0@0]! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:48'!identityIndexOf: anElement ifAbsent: anExceptionBlock	^self rowAndColumnForIndex:		 (contents identityIndexOf: anElement ifAbsent: [^anExceptionBlock value])! !!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 13:13'!indexOf: anElement	"If there are integers r, c such that (self at: r at: c) = anElement,	 answer some such r@c, otherwise answer 0@0.  This kind of perverse	 result is provided by analogy with SequenceableCollection>>indexOf:.	 The order in which the receiver are searched is UNSPECIFIED except	 that it is the same as the order used by #indexOf:ifAbsent: and #readStream."	^self indexOf: anElement ifAbsent: [0@0]! !!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 13:10'!indexOf: anElement ifAbsent: anExceptionBlock	"If there are integers r, c such that (self at: r at: c) = anElement,	 answer some such r@c, otherwise answer the result of anExceptionBlock."	^self rowAndColumnForIndex:		 (contents indexOf: anElement ifAbsent: [^anExceptionBlock value])! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:49'!replaceAll: oldObject with: newObject	contents replaceAll: oldObject with: newObject! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:44'!rowCount	^nrows! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:49'!size	^contents size! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/21/2002 23:32'!atRow: row	(row between: 1 and: nrows)		ifFalse: [self error: '1st subscript out of range'].	^contents copyFrom: (row-1)*ncols+1 to: row*ncols! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:42'!atRow: row put: aCollection	|p|	aCollection size = ncols ifFalse: [self error: 'wrong row size'].	p _ (self indexForRow: row andColumn: 1)-1.	aCollection do: [:each | contents at: (p _ p+1) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/22/2002 00:13'!transposed	self assert: [nrows = ncols].	^self indicesCollect: [:row :column | self at: column at: row]! !!Matrix methodsFor: 'adding' stamp: 'raok 10/21/2002 22:53'!add: newObject	self shouldNotImplement! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:01'!+* aCollection	"Premultiply aCollection by self.  aCollection should be an Array or Matrix.	 The name of this method is APL's +.x squished into Smalltalk syntax."	^aCollection preMultiplyByMatrix: self! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 11/28/2002 14:22'!preMultiplyByArray: a	"Answer a +* self where a is an Array."	nrows = 1 ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: a size columns: ncols tabulate: [:row :col |		(a at: row) * (contents at: col)]! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:02'!preMultiplyByMatrix: m	"Answer m +* self where m is a Matrix."	|s|	nrows = m columnCount ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: m rowCount columns: ncols tabulate: [:row :col |		s _ 0.		1 to: nrows do: [:k | s _ (m at: row at: k) * (self at: k at: col) + s].		s]! !!Matrix methodsFor: 'comparing' stamp: 'raok 11/22/2002 12:58'!= aMatrix	^aMatrix class == self class and: [	 aMatrix rowCount = nrows and: [	 aMatrix columnCount = ncols and: [	 aMatrix privateContents = contents]]]! !!Matrix methodsFor: 'comparing' stamp: 'raok 11/22/2002 13:14'!hash	"I'm really not sure what would be a good hash function here.	 The essential thing is that it must be compatible with #=, and	 this satisfies that requirement."	^contents hash! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:57'!asArray	^contents shallowCopy! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:57'!asBag	^contents asBag! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asByteArray	^contents asByteArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asCharacterSet	^contents asCharacterSet! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!asFloatArray	^contents asFloatArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asIdentitySet	^contents asIdentitySet! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!asIntegerArray	^contents asIntegerArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asOrderedCollection	^contents asOrderedCollection! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asSet	^contents asSet! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asSortedArray	^contents asSortedArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:59'!asSortedCollection	^contents asSortedCollection! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:59'!asSortedCollection: aBlock	^contents asSortedCollection: aBlock! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!asWordArray	^contents asWordArray! !!Matrix methodsFor: 'converting' stamp: 'raok 11/22/2002 13:02'!readStream	"Answer a ReadStream that returns all the elements of the receiver	 in some UNSPECIFIED order."	^ReadStream on: contents! !!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:57'!, aMatrix	"Answer a new matrix having the same number of rows as the receiver and aMatrix,	 its columns being the columns of the receiver followed by the columns of aMatrix."	|newCont newCols anArray oldCols a b c|	self assert: [nrows = aMatrix rowCount].	newCont _ Array new: self size + aMatrix size.	anArray _ aMatrix privateContents.	oldCols _ aMatrix columnCount.	newCols _ ncols + oldCols.	a _ b _ c _ 1.	1 to: nrows do: [:r |		newCont replaceFrom: a to: a+ncols-1 with: contents startingAt: b.		newCont replaceFrom: a+ncols to: a+newCols-1 with: anArray startingAt: c.		a _ a + newCols.		b _ b + ncols.		c _ c + oldCols].	^self class rows: nrows columns: newCols contents: newCont		! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:07'!copy	^self class rows: nrows columns: ncols contents: contents copy! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:07'!shallowCopy	^self class rows: nrows columns: ncols contents: contents shallowCopy! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:27'!shuffled	^self class rows: nrows columns: ncols contents: (contents shuffled)! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:27'!shuffledBy: aRandom	^self class rows: nrows columns: ncols contents: (contents shuffledBy: aRandom)! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:41'!collect: aBlock	"Answer a new matrix with transformed elements; transformations should be independent."	^self class rows: nrows columns: ncols contents: (contents collect: aBlock)! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!difference: aCollection	"Union is in because the result is always a Set.	 Difference and intersection are out because the result is like the receiver,	 and with irregular seleection that cannot be."	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:40'!do: aBlock	"Pass elements to aBlock one at a time in row-major order."	contents do: aBlock! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/23/2002 20:57'!indicesCollect: aBlock	|r i|	r _ Array new: nrows * ncols.	i _ 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			r at: (i _ i+1) put: (aBlock value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!intersection: aCollection	"Union is in because the result is always a Set.	 Difference and intersection are out because the result is like the receiver,	 and with irregular seleection that cannot be."	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!reject: aBlock	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!select: aBlock	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/22/2002 00:15'!with: aCollection collect: aBlock	"aCollection must support #at:at: and be at least as large as the receiver."	^self withIndicesCollect: [:each :row :column |		aBlock value: each value: (aCollection at: row at: column)]! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:53'!with: aCollection do: aBlock	"aCollection must support #at:at: and be at least as large as the receiver."	self withIndicesDo: [:each :row :column |		aBlock value: each value: (aCollection at: row at: column)].! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesCollect: aBlock	|i r|	i _ 0.	r _ contents shallowCopy.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			i _ i+1.			r at: i put: (aBlock value: (r at: i) value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesDo: aBlock	|i|	i _ 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			aBlock value: (contents at: (i _ i+1)) value: row value: column]].! !!Matrix methodsFor: 'printing' stamp: 'raok 10/21/2002 23:22'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name;		nextPutAll: ' rows: '; store: nrows;		nextPutAll: ' columns: '; store: ncols;		nextPutAll: ' contents: '; store: contents;		nextPut: $)! !!Matrix methodsFor: 'removing' stamp: 'raok 10/21/2002 22:54'!remove: anObject ifAbsent: anExceptionBlock	self shouldNotImplement! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!identityIncludes: anObject	^contents identityIncludes: anObject! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:23'!includes: anObject	^contents includes: anObject! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!includesAllOf: aCollection	^contents includesAllOf: aCollection! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!includesAnyOf: aCollection	^contents includesAnyOf: aCollection! !!Matrix methodsFor: 'testing' stamp: 'raok 11/22/2002 13:03'!isSequenceable	"LIE so that arithmetic on matrices will work.	 What matters for arithmetic is not that there should be random indexing	 but that the structure should be stable and independent of the values of	 the elements.  #isSequenceable is simply the wrong question to ask."	^true! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:25'!occurrencesOf: anObject	^contents occurrencesOf: anObject! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:40'!indexForRow: row andColumn: column	(row between: 1 and: nrows)		ifFalse: [self error: '1st subscript out of range'].	(column between: 1 and: ncols)		ifFalse: [self error: '2nd subscript out of range'].	^(row-1) * ncols + column! !!Matrix methodsFor: 'private' stamp: 'raok 11/22/2002 12:56'!privateContents	"Only used in #, #,, and #= so far.	 It used to be called #contents, but that clashes with Collection>>contents."	^contents! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:47'!rowAndColumnForIndex: index	|t|	t _ index - 1.	^(t // ncols + 1)@(t \\ ncols + 1)! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 23:05'!rows: rows columns: columns contents: anArray	self assert: [rows isInteger and: [rows >= 0]].	self assert: [columns isInteger and: [columns >= 0]].	self assert: [rows * columns = anArray size].	nrows _ rows.	ncols _ columns.	contents _ anArray.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Matrix class	instanceVariableNames: ''!!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:06'!new: dim	"Answer a dim*dim matrix.  Is this an abuse of #new:?  The argument is NOT a size."	^self rows: dim columns: dim! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:04'!rows: rows columns: columns	^self rows: rows columns: columns contents: (Array new: rows*columns)! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:51'!rows: rows columns: columns tabulate: aBlock	"Answer a new Matrix of the given dimensions where	 result at: i at: j     is   aBlock value: i value: j"	|a i|	a _ Array new: rows*columns.	i _ 0.	1 to: rows do: [:row |		1 to: columns do: [:column |			a at: (i _ i+1) put: (aBlock value: row value: column)]].	^self rows: rows columns: columns contents: a! !!Matrix class methodsFor: 'private' stamp: 'raok 10/21/2002 23:06'!rows: rows columns: columns contents: contents	^self new rows: rows columns: columns contents: contents! !Object subclass: #Message	instanceVariableNames: 'selector args lookupClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!Message commentStamp: '<historical>' prior: 0!I represent a selector and its argument values.	Generally, the system does not use instances of Message for efficiency reasons. However, when a message is not understood by its receiver, the interpreter will make up an instance of me in order to capture the information involved in an actual message transmission. This instance is sent it as an argument with the message doesNotUnderstand: to the receiver.!!Message methodsFor: 'accessing'!argument	"Answer the first (presumably sole) argument"	^args at: 1! !!Message methodsFor: 'accessing'!argument: newValue	"Change the first argument to newValue and answer self"	args at: 1 put: newValue! !!Message methodsFor: 'accessing'!arguments	"Answer the arguments of the receiver."	^args! !!Message methodsFor: 'accessing' stamp: 'ajh 10/9/2001 16:32'!lookupClass	^ lookupClass! !!Message methodsFor: 'accessing'!selector	"Answer the selector of the receiver."	^selector! !!Message methodsFor: 'accessing'!sends: aSelector	"answer whether this message's selector is aSelector"	^selector == aSelector! !!Message methodsFor: 'printing' stamp: 'ajh 10/9/2001 15:31'!printOn: stream	args isEmpty ifTrue: [^ stream nextPutAll: selector].	args with: selector keywords do: [:arg :word |		stream nextPutAll: word.		stream space.		arg printOn: stream.		stream space.	].	stream skip: -1.! !!Message methodsFor: 'printing' stamp: 'sma 6/1/2000 10:01'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	aStream nextPut: $(;	 nextPutAll: self class name;	 nextPutAll: ' selector: ';	 store: selector;	 nextPutAll: ' arguments: ';	 store: args;	 nextPut: $)! !!Message methodsFor: 'private' stamp: 'ajh 3/9/2003 19:25'!setSelector: aSymbol	selector _ aSymbol.! !!Message methodsFor: 'private'!setSelector: aSymbol arguments: anArray	selector _ aSymbol.	args _ anArray! !!Message methodsFor: 'sending' stamp: 'di 3/25/1999 21:54'!sentTo: receiver	"answer the result of sending this message to receiver"	lookupClass == nil		ifTrue: [^ receiver perform: selector withArguments: args]		ifFalse: [^ receiver perform: selector withArguments: args inSuperclass: lookupClass]! !!Message methodsFor: 'stub creation' stamp: 'ads 7/21/2003 17:33'!createStubMethod	| argNames aOrAn argName arg argClassName |	argNames _ Set new.	^ String streamContents: [ :s |		self selector keywords doWithIndex: [ :key :i |			s nextPutAll: key.			((key last = $:) or: [self selector isInfix]) ifTrue: [				arg _ self arguments at: i.				argClassName _ (arg isKindOf: Class) ifTrue: ['Class'] ifFalse: [arg class name].				aOrAn _ argClassName first isVowel ifTrue: ['an'] ifFalse: ['a'].				argName _ aOrAn, argClassName.				[argNames includes: argName] whileTrue: [argName _ argName, i asString].				argNames add: argName.				s nextPutAll: ' '; nextPutAll: argName; space			].		].		s cr; tab.		s nextPutAll: 'self shouldBeImplemented'	]! !!Message methodsFor: 'as yet unclassified' stamp: 'md 11/14/2003 17:37'!pushReceiver! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Message class	instanceVariableNames: ''!!Message class methodsFor: 'instance creation'!selector: aSymbol	"Answer an instance of me with unary selector, aSymbol."	^self new setSelector: aSymbol arguments: (Array new: 0)! !!Message class methodsFor: 'instance creation'!selector: aSymbol argument: anObject 	"Answer an instance of me whose selector is aSymbol and single 	argument is anObject."	^self new setSelector: aSymbol arguments: (Array with: anObject)! !!Message class methodsFor: 'instance creation'!selector: aSymbol arguments: anArray 	"Answer an instance of me with selector, aSymbol, and arguments, 	anArray."	^self new setSelector: aSymbol arguments: anArray! !MessageNode subclass: #MessageAsTempNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!MessageAsTempNode commentStamp: '<historical>' prior: 0!This node represents accesses to temporary variables for do-its in the debugger.  Since they execute in another context, they must send a message to the original context to access the value of the temporary variable in that context.!!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:38'!asStorableNode: encoder	"This node is a message masquerading as a temporary variable.	It currently has the form {homeContext tempAt: offset}.	We need to generate code for {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack.	This, in turn will get turned into {homeContext tempAt: offset put: expr}	at runtime if nobody disturbs storeAt:inTempFrame: in Object (not clean)"	^ MessageAsTempNode new		receiver: nil  "suppress code generation for reciever already on stack"		selector: #storeAt:inTempFrame:		arguments: (arguments copyWith: receiver)		precedence: precedence		from: encoder! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 10/12/1999 17:29'!code	"Allow synthetic temp nodes to be sorted by code"	^ arguments first literalValue! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!emitStorePop: stack on: codeStream	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self emitForEffect: stack on: codeStream! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:35'!isTemp	"Masquerading for debugger access to temps."	^ true! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!nowHasDef	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!nowHasRef	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!scope	"For compatibility with temp scope protocol"	^ -1! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!scope: ignored	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!sizeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self sizeForEffect: encoder! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:40'!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #tempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ MessageAsTempNode new		receiver: receiver		selector: #tempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !ProtoObject subclass: #MessageCatcher	instanceVariableNames: 'echoToTranscript'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!!MessageCatcher commentStamp: '<historical>' prior: 0!Any message sent to me is returned as a Message object."Message catcher" creates an instance of me.!!MessageCatcher methodsFor: 'as yet unclassified' stamp: 'ajh 9/26/2002 12:24'!doesNotUnderstand: aMessage	echoToTranscript == true ifTrue: [Transcript show: aMessage printString; cr].	^ aMessage! !MessageSet subclass: #MessageNames	instanceVariableNames: 'searchString selectorList selectorListIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!MessageNames methodsFor: 'search' stamp: 'sd 4/20/2003 14:28'!computeSelectorListFromSearchString	"Compute selector list from search string"	| raw sorted |	searchString _ searchString asString copyWithout: $ .	selectorList _ Cursor wait				showWhile: [raw _ Symbol selectorsContaining: searchString.					sorted _ raw as: SortedCollection.					sorted						sortBlock: [:x :y | x asLowercase <= y asLowercase].					sorted asArray].	selectorList size > 19		ifFalse: ["else the following filtering is considered too expensive. This 19  			should be a system-maintained Parameter, someday"			selectorList _ self systemNavigation allSelectorsWithAnyImplementorsIn: selectorList].	^ selectorList! !!MessageNames methodsFor: 'search' stamp: 'sw 7/28/2001 00:32'!doSearchFrom: aPane	"The user hit the Search button -- treat it as a synonym for the user having hit the Return or Enter (or cmd-s) in the type-in pane"	aPane accept.	aPane selectAll! !!MessageNames methodsFor: 'search' stamp: 'sw 7/28/2001 00:43'!searchString	"Answer the current searchString, initializing it if need be"	| pane |	searchString isEmptyOrNil ifTrue:		[searchString _ 'type here, then hit Search'.		pane _ self containingWindow findDeepSubmorphThat:			[:m | m knownName = 'Search'] ifAbsent: ["this happens during window creation" ^ searchString].			pane setText: searchString.			pane setTextMorphToSelectAllOnMouseEnter.			pane selectAll].	^ searchString! !!MessageNames methodsFor: 'search' stamp: 'sw 7/28/2001 02:18'!searchString: aString notifying: aController	"Take what the user typed and find all selectors containing it"	searchString _ aString asString copyWithout: $ .	self containingWindow setLabel: 'Message names containing "', searchString asLowercase, '"'.	selectorList _ nil.	self changed: #selectorList.	self changed: #messageList.	^ true! !!MessageNames methodsFor: 'search' stamp: 'sd 4/20/2003 14:28'!showOnlyImplementedSelectors	"Caution -- can be slow!! Filter my selector list down such that it only  	shows selectors that are actually implemented somewhere in the system."	self okToChange		ifTrue: [Cursor wait				showWhile: [selectorList _ self systemNavigation allSelectorsWithAnyImplementorsIn: selectorList.					self changed: #selectorList.					self changed: #messageList]]! !!MessageNames methodsFor: 'selection' stamp: 'sw 7/24/2001 01:46'!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ self messageList at: messageListIndex ifAbsent: [nil]! !!MessageNames methodsFor: 'selector list' stamp: 'sd 4/19/2003 12:12'!messageList	"Answer the receiver's message list, computing it if necessary. The way 	to force a recomputation is to set the messageList to nil"	messageList		ifNil: [messageList _ selectorListIndex == 0						ifTrue: [#()]						ifFalse: [self systemNavigation								allImplementorsOf: (selectorList at: selectorListIndex)].			self				messageListIndex: (messageList size > 0						ifTrue: [1]						ifFalse: [0])].	^ messageList! !!MessageNames methodsFor: 'selector list' stamp: 'sw 7/24/2001 01:46'!selectorList	"Answer the selectorList"	selectorList ifNil:		[self computeSelectorListFromSearchString.		selectorListIndex _  selectorList size > 0			ifTrue:	[1]			ifFalse: [0].		messageList _ nil].	^ selectorList! !!MessageNames methodsFor: 'selector list' stamp: 'sw 7/24/2001 01:55'!selectorListIndex	"Answer the selectorListIndex"	^ selectorListIndex! !!MessageNames methodsFor: 'selector list' stamp: 'sw 7/24/2001 01:59'!selectorListIndex: anInteger 	"Set the selectorListIndex as specified, and propagate consequences"	selectorListIndex _ anInteger.	selectorListIndex = 0		ifTrue: [^ self].	messageList _ nil.	self changed: #selectorListIndex.	self changed: #messageList! !!MessageNames methodsFor: 'selector list' stamp: 'sw 7/24/2001 01:58'!selectorListMenu: aMenu	"Answer the menu associated with the selectorList"	aMenu addList: #(		('senders (n)'				browseSenders		'browse senders of the chosen selector')		('copy selector to clipboard'	copyName			'copy the chosen selector to the clipboard, for subsequent pasting elsewhere')		-		('show only implemented selectors'	showOnlyImplementedSelectors		'remove from the selector-list all symbols that do not represent implemented methods')).	^ aMenu! !!MessageNames methodsFor: 'selector list' stamp: 'sw 7/24/2001 01:47'!selectorListMenuTitle	"Answer the title to supply for the menu belonging to the selector-list pane"	^ 'Click on any item in the listto see all implementors of it'! !!MessageNames methodsFor: 'initialization' stamp: 'sw 7/24/2001 01:35'!selectorListKey: aChar from: view	"Respond to a Command key in the message-list pane."	aChar == $n ifTrue: [^ self browseSenders].	aChar == $c ifTrue: [^ self copyName].	aChar == $b ifTrue: [^ self browseMethodFull].! !!MessageNames methodsFor: 'message list menu' stamp: 'sw 8/15/2002 17:24'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectorList at: selectorListIndex ifAbsent: [nil]) ifNotNil:		[Clipboard clipboardText: selector asString asText]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageNames class	instanceVariableNames: ''!!MessageNames class methodsFor: 'instance creation' stamp: 'sw 7/28/2001 00:56'!prototypicalToolWindow	"Answer an example of myself seen in a tool window, for the benefit of parts-launching tools"	^ self methodBrowserSearchingFor: nil! !!MessageNames class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:53'!initialize	self registerInFlapsRegistry.	! !!MessageNames class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:53'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(MessageNames			prototypicalToolWindow		'Message Names'		'A tool for finding, viewing, and editing all methods whose names contain a given character sequence.')						forFlapNamed: 'Tools']! !!MessageNames class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:37'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !ParseNode subclass: #MessageNode	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode'	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers StdTypers ThenFlag'	poolDictionaries: ''	category: 'System-Compiler'!!MessageNode commentStamp: '<historical>' prior: 0!I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MessageNode methodsFor: 'initialize-release' stamp: 'di 6/6/2000 23:24'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selNode key.	selector _ selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'initialize-release' stamp: 'di 6/6/2000 23:27'!receiver: rcvr selector: aSelector arguments: args precedence: p from: encoder 	"Compile."	| theSelector |	self receiver: rcvr		arguments: args		precedence: p.	aSelector = #:Repeat:do:		ifTrue: [theSelector _ #do:]		ifFalse: [theSelector _ aSelector].	self noteSpecialSelector: theSelector.	(self transform: encoder)		ifTrue: 			[selector isNil				ifTrue: [selector _ SelectorNode new 							key: (MacroSelectors at: special)							code: #macro]]		ifFalse: 			[selector _ encoder encodeSelector: theSelector.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!MessageNode methodsFor: 'initialize-release'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder sourceRange: range 	"Compile."	encoder noteSourceRange: range forNode: self.	^self		receiver: rcvr		selector: selName		arguments: args		precedence: p		from: encoder! !!MessageNode methodsFor: 'initialize-release' stamp: 'tk 10/26/2000 15:37'!selector: sel	selector _ sel! !!MessageNode methodsFor: 'testing'!canCascade	^(receiver == NodeSuper or: [special > 0]) not! !!MessageNode methodsFor: 'testing'!isComplex		^(special between: 1 and: 10) or: [arguments size > 2 or: [receiver isComplex]]! !!MessageNode methodsFor: 'testing'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs	 arguments.  All block arguments are ParseNodes."	^(selSymbol isNil or: [selSymbol==selector key]) and:		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !!MessageNode methodsFor: 'testing'!isReturningIf	^(special between: 3 and: 4)		and: [arguments first returns and: [arguments last returns]]! !!MessageNode methodsFor: 'testing'!toDoIncrement: variable	(receiver = variable and: [selector key = #+]) 		ifFalse: [^ nil].	arguments first isConstantNumber		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'testing'!toDoLimit: variable	(receiver = variable and: [selector key = #<= or: [selector key = #>=]]) 		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'cascading'!cascadeReceiver	"Nil out rcvr (to indicate cascade) and return what it had been."	| rcvr |	rcvr _ receiver.	receiver _ nil.	^rcvr! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 6/11/2000 16:09'!noteSpecialSelector: selectorSymbol	" special > 0 denotes specially treated messages. "	"Deconvert initial keywords from SQ2K"	special _ #(:Test:Yes: :Test:No: :Test:Yes:No: :Test:No:Yes:				and: or:				:Until:do: :While:do: whileFalse whileTrue				:Repeat:to:do: :Repeat:to:by:do:				) indexOf: selectorSymbol.	special > 0 ifTrue: [^ self].	special _ MacroSelectors indexOf: selectorSymbol.! !!MessageNode methodsFor: 'macro transformations' stamp: 'sma 3/3/2000 13:37'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:		and: [(initStmt isMemberOf: AssignmentNode) and:				[initStmt variable isTemp]])		ifFalse: [^ nil].	body _ arguments last statements.	variable _ initStmt variable.	increment _ body last toDoIncrement: variable.	(increment == nil or: [receiver statements size ~= 1])		ifTrue: [^ nil].	test _ receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	((test isMemberOf: MessageNode)		and: [(limit _ test toDoLimit: variable) notNil])		ifFalse: [^ nil].	toDoBlock _ BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	^ MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'macro transformations'!transform: encoder	special = 0 ifTrue: [^false].	(self perform: (MacroTransformers at: special) with: encoder)		ifTrue: 			[^true]		ifFalse: 			[special _ 0. ^false]! !!MessageNode methodsFor: 'macro transformations'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (arguments at: 1)					with: (BlockNode withJust: NodeFalse).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformBoolean: encoder	^self		checkBlock: (arguments at: 1)		as: 'argument'		from: encoder! !!MessageNode methodsFor: 'macro transformations'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (BlockNode withJust: NodeNil)					with: (arguments at: 1).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/28/2000 00:48'!transformIfFalseIfTrue: encoder	((self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'True arg' from: encoder])		ifTrue: 			[selector _ #ifTrue:ifFalse:.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 4/24/2000 13:32'!transformIfNil: encoder	(self transformBoolean: encoder) ifFalse: [^ false].	(MacroSelectors at: special) = #ifNotNil:	ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder) ifFalse: [^ false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector _ SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments _ {BlockNode withJust: NodeNil. arguments first}.		(self transform: encoder) ifFalse: [self error: 'compiler logic error'].		^ true]	ifFalse:		[^ self checkBlock: arguments first as: 'ifNil arg' from: encoder]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/28/2000 21:49'!transformIfNilIfNotNil: encoder	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'NotNil arg' from: encoder])		ifTrue: 			[selector _ SelectorNode new key: #ifTrue:ifFalse: code: #macro.			receiver _ MessageNode new				receiver: receiver				selector: #==				arguments: (Array with: NodeNil)				precedence: 2				from: encoder.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/28/2000 21:50'!transformIfNotNilIfNil: encoder	((self checkBlock: (arguments at: 1) as: 'NotNil arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder])		ifTrue: 			[selector _ SelectorNode new key: #ifTrue:ifFalse: code: #macro.			receiver _ MessageNode new				receiver: receiver				selector: #==				arguments: (Array with: NodeNil)				precedence: 2				from: encoder.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (arguments at: 1)					with: (BlockNode withJust: NodeNil).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/27/2000 22:29'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'False arg' from: encoder]! !!MessageNode methodsFor: 'macro transformations'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (BlockNode withJust: NodeTrue)					with: (arguments at: 1).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'hmm 7/15/2001 22:22'!transformToDo: encoder	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)			and: [arguments last numberOfArguments = 1])		ifFalse: [^ false].	arguments last firstArgument isVariableReference		ifFalse: [^ false]. "As with debugger remote vars"	arguments size = 3		ifTrue: [increment _ arguments at: 2.				(increment isConstantNumber and:					[increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment _ encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector _ SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange _ encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block _ arguments last.	blockRange _ encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar _ block firstArgument.	initStmt _ AssignmentNode new variable: blockVar value: receiver.	limit _ arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit _ nil]		ifFalse:  "Need to store limit in a var"			[limit _ encoder autoBind: blockVar key , 'LimiT'.			limit scope: -2.  "Already done parsing block"			limitInit _ AssignmentNode new					variable: limit					value: (arguments at: 1)].	test _ MessageNode new receiver: blockVar			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])			arguments: (Array with: limit)			precedence: precedence from: encoder			sourceRange: (myRange first to: blockRange first).	incStmt _ AssignmentNode new			variable: blockVar			value: (MessageNode new				receiver: blockVar selector: #+				arguments: (Array with: increment)				precedence: precedence from: encoder)			from: encoder			sourceRange: (myRange last to: myRange last).	arguments _ (Array with: limit with: increment with: block)		, (Array with: initStmt with: test with: incStmt with: limitInit).	^ true! !!MessageNode methodsFor: 'macro transformations'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder)		ifFalse: [^ false].	arguments size = 0   "transform bodyless form to body form"		ifTrue: [selector _ SelectorNode new					key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])					code: #macro.				arguments _ Array with: (BlockNode withJust: NodeNil).				^ true]		ifFalse: [^ self transformBoolean: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:24'!emitCase: stack on: strm value: forValue	| braceNode sizeStream thenSize elseSize |	forValue not		ifTrue: [^super emitForEffect: stack on: strm].	braceNode _ arguments first.	sizeStream _ ReadStream on: sizes.	receiver emitForValue: stack on: strm.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		thenSize _ sizeStream next.		elseSize _ sizeStream next.		last ifFalse: [strm nextPut: Dup. stack push: 1].		keyNode emitForEvaluatedValue: stack on: strm.		equalNode emit: stack args: 1 on: strm.		self emitBranchOn: false dist: thenSize pop: stack on: strm.		last ifFalse: [strm nextPut: Pop. stack pop: 1].		valueNode emitForEvaluatedValue: stack on: strm.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse: [self emitJump: elseSize on: strm]].	arguments size = 2		ifTrue:			[arguments last emitForEvaluatedValue: stack on: strm] "otherwise: [...]"		ifFalse:			[NodeSelf emitForValue: stack on: strm.			caseErrorNode emit: stack args: 0 on: strm]! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:39'!emitForEffect: stack on: strm	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc _ 0.			self perform: (MacroEmitters at: special) with: stack with: strm with: false]		ifFalse: 			[super emitForEffect: stack on: strm]! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:40'!emitForValue: stack on: strm	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc _ 0.			self perform: (MacroEmitters at: special) with: stack with: strm with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].			arguments do: [:argument | argument emitForValue: stack on: strm].			selector				emit: stack				args: arguments size				on: strm				super: receiver == NodeSuper.			pc _ strm position]! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:23'!emitIf: stack on: strm value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize _ sizes at: 1.	elseSize _ sizes at: 2.	(forValue not and: [(elseSize*thenSize) > 0])		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super emitForEffect: stack on: strm].	thenExpr _ arguments at: 1.	elseExpr _ arguments at: 2.	receiver emitForValue: stack on: strm.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitBranchOn: false dist: thenSize pop: stack on: strm.			pc _ strm position.			thenExpr emitForEvaluatedValue: stack on: strm.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not				ifTrue:  "Elide jump over else after a return"					[self emitJump: elseSize on: strm].			elseExpr emitForEvaluatedValue: stack on: strm]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitBranchOn: false dist: thenSize pop: stack on: strm.					pc _ strm position.					thenExpr emitForEvaluatedEffect: stack on: strm]				ifFalse:					[self emitBranchOn: true dist: elseSize pop: stack on: strm.					pc _ strm position.					elseExpr emitForEvaluatedEffect: stack on: strm]]! !!MessageNode methodsFor: 'code generation' stamp: 'ajh 7/31/2003 11:26'!emitIfNil: stack on: strm value: forValue	| theNode theSize theSelector |	theNode _ arguments first.	theSize _ sizes at: 1.	theSelector _ #ifNotNil:.	receiver emitForValue: stack on: strm.	forValue ifTrue: [strm nextPut: Dup. stack push: 1].	strm nextPut: LdNil. stack push: 1.	equalNode emit: stack args: 1 on: strm.	self 		emitBranchOn: (selector key == theSelector)		dist: theSize 		pop: stack 		on: strm.	pc _ strm position.	forValue 		ifTrue: 			[strm nextPut: Pop. stack pop: 1.			theNode emitForEvaluatedValue: stack on: strm]			ifFalse: [theNode emitForEvaluatedEffect: stack on: strm].! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:42'!emitToDo: stack on: strm value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt _ arguments at: 4.	limitInit _ arguments at: 7.	test _ arguments at: 5.	block _ arguments at: 3.	incStmt _ arguments at: 6.	blockSize _ sizes at: 1.	loopSize _ sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitForEffect: stack on: strm].	initStmt emitForEffect: stack on: strm.	test emitForValue: stack on: strm.	self emitBranchOn: false dist: blockSize pop: stack on: strm.	pc _ strm position.	block emitForEvaluatedEffect: stack on: strm.	incStmt emitForEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:36'!emitWhile: stack on: strm value: forValue 	" L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond _ receiver.	stmt _ arguments at: 1.	stmtSize _ sizes at: 1.	loopSize _ sizes at: 2.	cond emitForEvaluatedValue: stack on: strm.	self emitBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack on: strm.   "Btp for whileFalse"	pc _ strm position.	stmt emitForEvaluatedEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!MessageNode methodsFor: 'code generation'!pc	"Used by encoder source mapping."	pc==nil ifTrue: [^0] ifFalse: [^pc]! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:25'!sizeCase: encoder value: forValue	| braceNode sizeIndex thenSize elseSize |	forValue not		ifTrue: [^super sizeForEffect: encoder].	equalNode _ encoder encodeSelector: #=.	braceNode _ arguments first.	sizes _ Array new: 2 * braceNode numElements.	sizeIndex _ sizes size.	elseSize _ arguments size = 2		ifTrue:			[arguments last sizeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode _ encoder encodeSelector: #caseError.			 1 + (caseErrorNode size: encoder args: 0 super: false)]. "self caseError"	braceNode casesReverseDo:		[:keyNode :valueNode :last |		sizes at: sizeIndex put: elseSize.		thenSize _ valueNode sizeForEvaluatedValue: encoder.		last ifFalse: [thenSize _ thenSize + 1]. "Pop"		valueNode returns ifFalse: [thenSize _ thenSize + (self sizeJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize _ elseSize + 1]. "Dup"		elseSize _ elseSize + (keyNode sizeForEvaluatedValue: encoder) +			(equalNode size: encoder args: 1 super: false) +			(self sizeBranchOn: false dist: thenSize) + thenSize.		sizeIndex _ sizeIndex - 2].	^(receiver sizeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation'!sizeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeForEffect: encoder! !!MessageNode methodsFor: 'code generation'!sizeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector _ selector copy "only necess for splOops"].	total _ selector size: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total _ total + (receiver sizeForValue: encoder)].	sizes _ arguments collect: 					[:arg | 					argSize _ arg sizeForValue: encoder.					total _ total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation'!sizeIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr _ arguments at: 1.	elseExpr _ arguments at: 2.	(forValue		or: [(thenExpr isJust: NodeNil)		or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super sizeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize _ elseExpr sizeForEvaluatedValue: encoder.			thenSize _ (thenExpr sizeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeJump: elseSize]).			branchSize _ self sizeBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize _ 0.					thenSize _ thenExpr sizeForEvaluatedEffect: encoder.					branchSize _ self sizeBranchOn: false dist: thenSize]				ifFalse:					[thenSize _ 0.					elseSize _ elseExpr sizeForEvaluatedEffect: encoder.					branchSize _ self sizeBranchOn: true dist: elseSize]].	sizes _ Array with: thenSize with: elseSize.	^ (receiver sizeForValue: encoder) + branchSize			+ thenSize + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'acg 1/28/2000 22:00'!sizeIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode _ encoder encodeSelector: #==.	sizes _ Array new: 1.	theNode _ arguments first.	theSelector _ #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize _ (1 "pop" + (theNode sizeForEvaluatedValue: encoder))).			 ^(receiver sizeForValue: encoder) +				2 "Dup. LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]		ifFalse:			[sizes at: 1 put: (theSize _ (theNode sizeForEvaluatedEffect: encoder)).			 ^(receiver sizeForValue: encoder) +				1 "LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]! !!MessageNode methodsFor: 'code generation'!sizeToDo: encoder value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize blockVar initSize limitInit |	block _ arguments at: 3.	blockVar _ block firstArgument.	initStmt _ arguments at: 4.	test _ arguments at: 5.	incStmt _ arguments at: 6.	limitInit _ arguments at: 7.	initSize _ initStmt sizeForEffect: encoder.	limitInit == nil		ifFalse: [initSize _ initSize + (limitInit sizeForEffect: encoder)].	blockSize _ (block sizeForEvaluatedEffect: encoder)			+ (incStmt sizeForEffect: encoder) + 2.  "+2 for Jmp backward"	loopSize _ (test sizeForValue: encoder)			+ (self sizeBranchOn: false dist: blockSize)			+ blockSize.	sizes _ Array with: blockSize with: loopSize.	^ initSize + loopSize			+ (forValue ifTrue: [1] ifFalse: [0])    " +1 for value (push nil) "! !!MessageNode methodsFor: 'code generation'!sizeWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond _ receiver.	stmt _ arguments at: 1.	stmtSize _ (stmt sizeForEvaluatedEffect: encoder) + 2.	branchSize _ self sizeBranchOn: (selector key == #whileFalse:)  "Btp for whileFalse"					dist: stmtSize.	loopSize _ (cond sizeForEvaluatedValue: encoder)			+ branchSize + stmtSize.	sizes _ Array with: stmtSize with: loopSize.	^ loopSize    " +1 for value (push nil) "		+ (forValue ifTrue: [1] ifFalse: [0])! !!MessageNode methodsFor: 'printing' stamp: 'RAA 2/15/2001 19:25'!macroPrinter	special > 0 ifTrue: [^MacroPrinters at: special].	^nil! !!MessageNode methodsFor: 'printing'!precedence	^precedence! !!MessageNode methodsFor: 'printing' stamp: 'di 4/24/2000 10:32'!printCaseOn: aStream indent: level 	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode _ arguments first.	otherwise _ arguments last.	(arguments size = 1 or: [otherwise isJustCaseError])		ifTrue: [otherwise _ nil].	receiver		printOn: aStream		indent: level		precedence: 3.	aStream dialect = #SQ00 ifTrue: [aStream nextPutAll: ' caseOf (']		ifFalse: [aStream nextPutAll: ' caseOf: '].	braceNode isVariableReference ifTrue: [braceNode printOn: aStream indent: level]		ifFalse: 			[aStream nextPutAll: '{';				 crtab: level + 1.			braceNode				casesForwardDo: 					[:keyNode :valueNode :last | 					keyNode printOn: aStream indent: level + 1.					aStream nextPutAll: ' -> '.					valueNode isComplex						ifTrue: 							[aStream crtab: level + 2.							extra _ 1]						ifFalse: [extra _ 0].					valueNode printOn: aStream indent: level + 1 + extra.					last ifTrue: [aStream nextPut: $}]						ifFalse: [aStream nextPut: $.;								 crtab: level + 1]]].	aStream dialect = #SQ00 ifTrue: [aStream nextPutAll: ')'].	otherwise isNil		ifFalse: 			[aStream dialect = #SQ00 ifTrue: [aStream crtab: level + 1;					 nextPutAll: ' otherwise (']				ifFalse: [aStream crtab: level + 1;						 nextPutAll: ' otherwise: '].			otherwise isComplex				ifTrue: 					[aStream crtab: level + 2.					extra _ 1]				ifFalse: [extra _ 0].			otherwise printOn: aStream indent: level + 1 + extra.			aStream dialect = #SQ00 ifTrue: [aStream nextPutAll: ')']]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:20'!printIfNil: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:20'!printIfNilNotNil: aStream indent: level	self printReceiver: receiver ifNilReceiver on: aStream indent: level.	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^ self printKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'RAA 2/16/2001 15:12'!printIfOn: aStream indent: level	aStream dialect = #SQ00 ifTrue:		["Convert to if-then-else"		(arguments last isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #Yes: arguments: (Array with: arguments first)						on: aStream indent: level prefix: true].		(arguments last isJust: NodeFalse) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #and: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments first isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #No: arguments: (Array with: arguments last)						on: aStream indent: level prefix: true].		(arguments first isJust: NodeTrue) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #or: arguments: (Array with: arguments last)						on: aStream indent: level].		aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].		self printParenReceiver: receiver on: aStream indent: level + 1.		^ self printKeywords: #Yes:No: arguments: arguments						on: aStream indent: level prefix: true].	receiver ifNotNil: [		receiver printOn: aStream indent: level + 1 precedence: precedence.	].	(arguments last isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^ self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^ self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:08'!printKeywords: key arguments: args on: aStream indent: level	^ self printKeywords: key arguments: args on: aStream indent: level prefix: false! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:07'!printKeywords: key arguments: args on: aStream indent: level prefix: isPrefix	| keywords indent noColons arg kwd hasBrackets doCrTab |	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	noColons _ aStream dialect = #SQ00 and: [keywords first endsWith: ':'].	doCrTab _ args size > 2 or:		[{receiver} , args			inject: false			into: [:was :thisArg |				was or: [(thisArg isKindOf: BlockNode)					or: [(thisArg isKindOf: MessageNode) and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do:		[:i | arg _ args at: i.  kwd _ keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		noColons			ifTrue: [aStream withStyleFor: (isPrefix ifTrue: [#prefixKeyword] ifFalse: [#keyword])						do: [aStream nextPutAll: kwd allButLast; space].					hasBrackets _ (arg isKindOf: BlockNode) or: [arg isKindOf: BlockNode].					hasBrackets ifFalse: [aStream nextPutAll: '(']]			ifFalse: [aStream nextPutAll: kwd; space].		arg printOn: aStream indent: level + 1 + indent			 	precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		noColons			ifTrue: [hasBrackets ifFalse: [aStream nextPutAll: ')']]]! !!MessageNode methodsFor: 'printing' stamp: 'RAA 2/16/2001 15:12'!printOn: aStream indent: level	| leadingKeyword |"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	(special > 0)		ifTrue: [self perform: self macroPrinter with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [leadingKeyword _ selector key keywords first.						aStream nextPutAll: leadingKeyword; space.						self printReceiver: receiver on: aStream indent: level.						self printKeywords: (selector key allButFirst: leadingKeyword size + 1) arguments: arguments							on: aStream indent: level]				ifFalse: [(aStream dialect = #SQ00 and: [selector key == #do:])						ifTrue: ["Add prefix keyword"								aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].								self printParenReceiver: receiver on: aStream indent: level + 1.								self printKeywords: selector key arguments: arguments									on: aStream indent: level prefix: true]						ifFalse: [self printReceiver: receiver on: aStream indent: level.								self printKeywords: selector key arguments: arguments									on: aStream indent: level]]]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/30/2000 23:17'!printOn: strm indent: level precedence: outerPrecedence	| parenthesize |	parenthesize _ precedence > outerPrecedence		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].	parenthesize		ifTrue: [strm nextPutAll: '('.				self printOn: strm indent: level.				strm nextPutAll: ')']		ifFalse: [self printOn: strm indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 08:28'!printParenReceiver: rcvr on: aStream indent: level						(rcvr isKindOf: BlockNode) ifTrue:		[^ rcvr printOn: aStream indent: level].	aStream nextPutAll: '('.	rcvr printOn: aStream indent: level.	aStream nextPutAll: ')'! !!MessageNode methodsFor: 'printing' stamp: 'di 5/30/2000 23:06'!printReceiver: rcvr on: aStream indent: level						rcvr ifNil: [^ self].	"Force parens around keyword receiver of kwd message"	(precedence = 3 and: [aStream dialect = #SQ00])		ifTrue: [rcvr printOn: aStream indent: level precedence: precedence - 1]		ifFalse: [rcvr printOn: aStream indent: level precedence: precedence]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:12'!printToDoOn: aStream indent: level	| limitNode |	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].				self printParenReceiver: receiver on: aStream indent: level + 1]		ifFalse: [self printReceiver: receiver on: aStream indent: level].	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level prefix: true]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level prefix: true]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:12'!printWhileOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #prefixKeyword						do: [aStream nextPutAll: (selector key == #whileTrue:									ifTrue: ['While '] ifFalse: ['Until '])].				self printParenReceiver: receiver on: aStream indent: level + 1.				self printKeywords: #do: arguments: arguments					on: aStream indent: level prefix: true]		ifFalse: [self printReceiver: receiver on: aStream indent: level.				(arguments first isJust: NodeNil) ifTrue:						[selector _ SelectorNode new								key: (selector key == #whileTrue:									ifTrue: [#whileTrue] ifFalse: [#whileFalse])								code: #macro.						arguments _ Array new].				self printKeywords: selector key arguments: arguments					on: aStream indent: level]! !!MessageNode methodsFor: 'private' stamp: 'hg 10/2/2001 21:08'!checkBlock: node as: nodeName from: encoder	node canBeSpecialArgument ifTrue: [^node isMemberOf: BlockNode].	((node isKindOf: BlockNode) and: [node numberOfArguments > 0])		ifTrue:	[^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a 0-argument block']		ifFalse: [^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a block or variable']! !!MessageNode methodsFor: 'private' stamp: 'acg 1/28/2000 00:57'!ifNilReceiver	^receiver! !!MessageNode methodsFor: 'private' stamp: 'tk 8/2/1999 18:40'!pvtCheckForPvtSelector: encoder	"If the code being compiled is trying to send a private message (e.g. 'pvtCheckForPvtSelector:') to anyone other than self, then complain to encoder."	selector isPvtSelector ifTrue:		[receiver isSelfPseudoVariable ifFalse:			[encoder notify: 'Private messages may only be sent to self']].! !!MessageNode methodsFor: 'private'!receiver: rcvr arguments: args precedence: p	receiver _ rcvr.	arguments _ args.	sizes _ Array new: arguments size.	precedence _ p! !!MessageNode methodsFor: 'private'!transformCase: encoder	| caseNode |	caseNode _ arguments first.	(caseNode isKindOf: BraceNode)		ifTrue:			[^(caseNode blockAssociationCheck: encoder) and:			 	[arguments size = 1 or:					[self checkBlock: arguments last as: 'otherwise arg' from: encoder]]].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not])		ifTrue:			[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'equation translation'!arguments	^arguments! !!MessageNode methodsFor: 'equation translation' stamp: 'tk 10/27/2000 15:11'!arguments: list	arguments _ list! !!MessageNode methodsFor: 'equation translation'!receiver	^receiver! !!MessageNode methodsFor: 'equation translation' stamp: 'RAA 2/14/2001 14:07'!receiver: val	"14 feb 2001 - removed return arrow"	receiver _ val! !!MessageNode methodsFor: 'equation translation'!selector	^selector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageNode class	instanceVariableNames: ''!!MessageNode class methodsFor: 'class initialization' stamp: 'acg 1/28/2000 21:58'!initialize		"MessageNode initialize"	MacroSelectors _ 		#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers _ 		#(transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters _ 		#(emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:			emitIf:on:value: emitIf:on:value:			emitWhile:on:value: emitWhile:on:value: emitWhile:on:value: emitWhile:on:value:			emitToDo:on:value: emitToDo:on:value:			emitCase:on:value: emitCase:on:value:			emitIfNil:on:value: emitIfNil:on:value: emitIf:on:value: emitIf:on:value:).	MacroSizers _ 		#(sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:			sizeIf:value: sizeIf:value:			sizeWhile:value: sizeWhile:value: sizeWhile:value: sizeWhile:value:			sizeToDo:value: sizeToDo:value:			sizeCase:value: sizeCase:value:			sizeIfNil:value: sizeIfNil:value: sizeIf:value: sizeIf:value: ).	MacroPrinters _ 		#(printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !Error subclass: #MessageNotUnderstood	instanceVariableNames: 'message receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!MessageNotUnderstood commentStamp: '<historical>' prior: 0!This exception is provided to support Object>>doesNotUnderstand:.!!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'pnm 8/16/2000 15:03'!message: aMessage	message := aMessage! !!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'ab 8/22/2003 11:56'!messageText	"Return an exception's message text."	^messageText == nil		ifTrue:			[message == nil				ifTrue: [super messageText]				ifFalse: [message lookupClass printString, '>>', message selector asString]]		ifFalse: [messageText]! !!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'ajh 10/9/2001 16:38'!receiver: obj	receiver _ obj! !!MessageNotUnderstood methodsFor: 'exceptionDescription' stamp: 'tfei 6/4/1999 18:30'!isResumable	"Determine whether an exception is resumable."	^true! !!MessageNotUnderstood methodsFor: 'exceptionDescription' stamp: 'ajh 10/9/2001 16:39'!receiver	"Answer the receiver that did not understand the message"	^ receiver! !Browser subclass: #MessageSet	instanceVariableNames: 'messageList autoSelectString growable'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!MessageSet commentStamp: '<historical>' prior: 0!I represent a query path of the retrieval result of making a query about methods in the system. The result is a set of methods, denoted by a message selector and the class in which the method was found. As a StringHolder, the string I represent is the source code of the currently selected method. I am typically viewed in a Message Set Browser consisting of a MessageListView and a BrowserCodeView.!!MessageSet methodsFor: 'message list' stamp: 'BG 11/1/2003 14:51'!addExtraShiftedItemsTo: aMenu	"The shifted selector-list menu is being built.  Add items specific to MessageSet"	self growable ifTrue:		[aMenu addList: #(			-			('remove from this browser'		removeMessageFromBrowser)			)].	aMenu add: 'sort by date' action: #sortByDate! !!MessageSet methodsFor: 'message list' stamp: 'tk 5/1/2001 18:14'!addItem: classAndMethod	"Append a classAndMethod string to the list.  Select the new item."	"Do some checks on the input?"	self okToChange ifFalse: [^ self].	messageList add: classAndMethod.	self changed: #messageList.	self messageListIndex: messageList size.! !!MessageSet methodsFor: 'message list' stamp: 'sw 1/28/2001 20:56'!growable	"Answer whether the receiver is capable of growing/shrinking dynamically"	^ growable ~~ false! !!MessageSet methodsFor: 'message list' stamp: 'sw 12/6/2000 07:12'!growable: aBoolean	"Give or take away the growable trait; when a message set is growable, methods submitted within it will be added to its message list"	growable _ aBoolean! !!MessageSet methodsFor: 'message list'!messageList	"Answer the current list of messages."	^messageList! !!MessageSet methodsFor: 'message list' stamp: 'nk 2/14/2004 15:10'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex _ anInteger.	contents _ 		messageListIndex ~= 0			ifTrue: [self selectedMessage]			ifFalse: [''].	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self contentsChanged.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].	self decorateButtons! !!MessageSet methodsFor: 'message list' stamp: 'sbw 12/30/1999 17:19'!optionalButtonHeight	^ 15! !!MessageSet methodsFor: 'message list' stamp: 'sma 3/3/2000 11:17'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^ nil].	^ self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'message list' stamp: 'sw 8/1/2002 18:18'!sortByDate	"Sort the message-list by date of time-stamp"	| assocs aCompiledMethod aDate inOrder |	assocs _ messageList collect:		[:aRef |			aDate _ aRef methodSymbol == #Comment				ifTrue:					[aRef actualClass organization dateCommentLastSubmitted]				ifFalse:					[aCompiledMethod _ aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: [nil].					aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].			aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"	inOrder _ assocs asSortedCollection:		[:a :b | a value < b value].	messageList _ inOrder asArray collect: [:assoc | assoc key].	self changed: #messageList! !!MessageSet methodsFor: 'message functions' stamp: 'sw 12/11/2000 15:51'!deleteFromMessageList: aMessage	"Delete the given message from the receiver's message list"	messageList _ messageList copyWithout: aMessage! !!MessageSet methodsFor: 'message functions' stamp: 'sw 2/24/1999 18:31'!methodCategoryChanged	self changed: #annotation! !!MessageSet methodsFor: 'message functions' stamp: 'sw 12/1/2000 11:54'!reformulateList	"The receiver's messageList has been changed; rebuild it"	super reformulateList.	self initializeMessageList: messageList.	self changed: #messageList.	self changed: #messageListIndex.	self contentsChanged! !!MessageSet methodsFor: 'message functions' stamp: 'nk 6/26/2003 21:44'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self systemNavigation  confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation == 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self deleteFromMessageList: self selection.	self reformulateList.	confirmation == 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/12/2001 00:19'!removeMessageFromBrowser	"Remove the selected message from the browser."	messageListIndex = 0 ifTrue: [^ self].	self deleteFromMessageList: self selection.	self reformulateList.	self adjustWindowTitleAfterFiltering! !!MessageSet methodsFor: 'class list'!metaClassIndicated	"Answer the boolean flag that indicates whether	this is a class method."	^ self selectedClassOrMetaClass isMeta! !!MessageSet methodsFor: 'class list'!selectedClass 	"Return the base class for the current selection.  1/17/96 sw fixed up so that it doesn't fall into a debugger in a msg browser that has no message selected"	| aClass |	^ (aClass _ self selectedClassOrMetaClass) == nil		ifTrue:			[nil]		ifFalse:			[aClass theNonMetaClass]! !!MessageSet methodsFor: 'class list' stamp: 'tk 4/4/98 18:50'!selectedClassName	"Answer the name of class of the currently selected message. Answer nil if no selection 	exists."	| cls |	(cls _ self selectedClass) ifNil: [^ nil].	^ cls name! !!MessageSet methodsFor: 'class list'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	messageListIndex = 0 ifTrue: [^nil].	self setClassAndSelectorIn: [:c :s | ^c]! !!MessageSet methodsFor: 'class list'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	messageListIndex = 0 ifTrue: [^ nil].	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !!MessageSet methodsFor: 'contents' stamp: 'di 10/1/2001 22:26'!contents	"Answer the contents of the receiver"	^ contents == nil		ifTrue: [currentCompiledMethod _ nil. '']		ifFalse: [messageListIndex = 0 			ifTrue: [currentCompiledMethod _ nil. contents]			ifFalse: [self showingByteCodes				ifTrue: [self selectedBytecodes]				ifFalse: [self selectedMessage]]]! !!MessageSet methodsFor: 'contents' stamp: 'nk 6/19/2004 16:47'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'Class vanished'].		selector first isUppercase ifTrue:			[selector == #Comment ifTrue:				[currentCompiledMethod _ class organization commentRemoteStr.				^ class comment].			selector == #Definition ifTrue:				[^ class definitionST80: Preferences printAlternateSyntax not].			selector == #Hierarchy ifTrue: [^ class printHierarchy]].		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		self showingDecompile ifTrue:			[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		self showingDocumentation ifTrue:			[^ self commentContents].	source _ self sourceStringPrettifiedAndDiffed.	^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'contents' stamp: 'sw 2/14/2001 15:25'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	contents _ ''! !!MessageSet methodsFor: 'private' stamp: 'sw 1/11/2001 09:16'!adjustWindowTitleAfterFiltering	"Set the title of the receiver's window, if any, to reflect the just-completed filtering"	| aWindow existingLabel newLabel |	(aWindow _ self containingWindow) ifNil: [^ self].	(existingLabel _ aWindow label) isEmptyOrNil ifTrue: [^ self].	(((existingLabel size < 3) or: [existingLabel last ~~ $]]) or: [(existingLabel at: (existingLabel size - 1)) isDigit not]) ifTrue: [^ self].	existingLabel size to: 1 by: -1 do:		[:anIndex | ((existingLabel at: anIndex) == $[) ifTrue:			[newLabel _ (existingLabel copyFrom: 1 to: anIndex),				'Filtered: ',				messageList size printString,				']'.			^ aWindow setLabel: newLabel]]			! !!MessageSet methodsFor: 'private'!autoSelectString	"Return the string to be highlighted when making new selections"	^ autoSelectString! !!MessageSet methodsFor: 'private'!autoSelectString: aString	"Set the string to be highlighted when making new selections"	autoSelectString _ aString! !!MessageSet methodsFor: 'private' stamp: 'sw 7/31/2002 12:58'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector ~~ nil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector = #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self clearUserEditFlag.			^ false].		oldSelector = #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self clearUserEditFlag. 			^ false].		oldSelector = #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^ false].	self noteAcceptanceOfCodeFor: selector.	selector == oldSelector ifFalse:		[self reformulateListNoting: selector].	contents _ aString copy.	self changed: #annotation.	^ true! !!MessageSet methodsFor: 'private' stamp: 'ff 12/13/2003 02:38'!initializeMessageList: anArray	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil: [					s _ class name , ' ' , sel , ' {' , 						((class organization categoryOfElement: sel) ifNil: ['']) , '}'.					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s					)				]			]	].	messageListIndex _ messageList isEmpty ifTrue: [0 ] ifFalse: [1].	contents _ ''! !!MessageSet methodsFor: 'private' stamp: 'sw 6/13/2001 00:59'!openAsMorphNamed: labelString inWorld: aWorld	"Open the receiver in a morphic window in the given world"	(self inMorphicWindowLabeled: labelString) openInWorld: aWorld! !!MessageSet methodsFor: 'private' stamp: 'sw 12/28/2000 14:28'!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ messageList at: messageListIndex ifAbsent: [nil]! !!MessageSet methodsFor: 'private' stamp: 'RAA 5/29/2001 10:12'!setClassAndSelectorIn: csBlock	| sel |	"Decode strings of the form <className> [class] <selectorName>."	self flag: #mref.	"compatibility with pre-MethodReference lists"	sel _ self selection.	^(sel isKindOf: MethodReference) ifTrue: [		sel setClassAndSelectorIn: csBlock	] ifFalse: [		MessageSet parse: sel toClassAndSelector: csBlock	]! !!MessageSet methodsFor: 'private' stamp: 'sw 1/11/2001 09:18'!setFilteredList: newList	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"	newList size == 0		ifTrue:			[^ self inform: 'Nothing would be left in the list if you did that'].	newList size == messageList size		ifTrue:			[^ self inform: 'That leaves the list unchanged'].	self initializeMessageList: newList.	self adjustWindowTitleAfterFiltering! !!MessageSet methodsFor: 'filtering' stamp: 'sw 1/19/2001 16:47'!augmentMessageList	"Allow the user to add to the list of messages."	self notYetImplemented! !!MessageSet methodsFor: 'filtering' stamp: 'sw 1/11/2001 09:33'!filterFrom: aBlock	"Filter the receiver's list down to only those items that satisfy aBlock, which takes a class an a selector as its arguments."	| newList |	newList _ messageList select:		[:anElement |			self class parse: anElement toClassAndSelector: aBlock].	self setFilteredList: newList! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 12:55'!filterToAnyChangeSet	"Filter down only to messages present in ANY change set"	self filterFrom:		[:aClass :aSelector |			ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector: aSelector]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 8/10/2001 14:45'!filterToCommentedMethods	"Filter the receiver's list down to only those items which have comments"	self filterFrom:		[:aClass :aSelector |			(aClass selectors includes: aSelector) and:						[(aClass firstPrecodeCommentFor: aSelector) isEmptyOrNil not]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 2/14/2001 18:30'!filterToCurrentAuthor	"Filter down only to messages with my initials as most recent author"	| myInitials aMethod aTimeStamp |	(myInitials _ Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:							[aMethod _ aClass compiledMethodAt: aSelector ifAbsent: [nil].				aMethod notNil and:					[(aTimeStamp _ Utilities timeStampForMethod: aMethod) notNil and:						[aTimeStamp beginsWith: myInitials]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sd 5/23/2003 14:38'!filterToCurrentChangeSet	"Filter the receiver's list down to only those items in the current change set"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(ChangeSet current atSelector: aSelector class: aClass) ~~ #none]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 8/10/2001 14:33'!filterToImplementorsOf	"Filter the receiver's list down to only those items with a given selector"	| aFragment inputWithBlanksTrimmed |	aFragment _ FillInTheBlank request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector |					aSelector == aSymbol]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:14'!filterToMessagesInChangesFile	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."	| cm |	self filterFrom:		[:aClass :aSelector |			aClass notNil and: [aSelector notNil and:				[(self class isPseudoSelector: aSelector) not and:					[(cm _ aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex ~~ 1]]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:15'!filterToMessagesInSourcesFile	"Filter down only to messages whose source code resides in the .sources file."	| cm |	self filterFrom: [:aClass :aSelector |		(aClass notNil and: [aSelector notNil]) and:			[(self class isPseudoSelector: aSelector) not and:				[(cm _ aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex == 1]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 14:10'!filterToMessagesThat	"Allow the user to type in a block which will be"	| reply |	reply _ FillInTheBlank		multiLineRequest: 'Type your block here'		centerAt: Sensor cursorPoint		initialAnswer: '[:aClass :aSelector |		]'		answerHeight: 200.	reply isEmptyOrNil ifTrue: [^ self].	self filterFrom: (Compiler evaluate: reply)! !!MessageSet methodsFor: 'filtering' stamp: 'sw 2/13/2001 12:02'!filterToMessagesWithHardenedClasses	"Filter the receiver's list down to only those items representing methods of hardened classes, as opposed to uniclasses"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[aClass isUniClass not]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 8/12/2001 22:25'!filterToMessagesWithPriorVersions	"Filter down only to messages which have at least one prior version"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(self class isPseudoSelector: aSelector) not and:					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:12'!filterToMessagesWithoutPriorVersions	"Filter down only to messages which have no prior version stored"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(self class isPseudoSelector: aSelector) not and:					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) <= 1]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 13:07'!filterToNotAnyChangeSet	"Filter down only to messages present in NO change set"	self filterFrom:		[:aClass :aSelector |			(ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 2/14/2001 18:24'!filterToNotCurrentAuthor	"Filter down only to messages not stamped with my initials"	| myInitials aMethod aTimeStamp |	(myInitials _ Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:							[aMethod _ aClass compiledMethodAt: aSelector ifAbsent: [nil].				aMethod notNil and:					[(aTimeStamp _ Utilities timeStampForMethod: aMethod) isNil or:						[(aTimeStamp beginsWith: myInitials) not]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sd 5/23/2003 14:38'!filterToNotCurrentChangeSet	"Filter the receiver's list down to only those items not in the current change set"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(ChangeSet current atSelector: aSelector class: aClass) == #none]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 8/10/2001 14:34'!filterToNotImplementorsOf	"Filter the receiver's list down to only those items whose selector is NOT one solicited from the user."	| aFragment inputWithBlanksTrimmed |	aFragment _ FillInTheBlank request: 'type selector: ' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector |					aSelector ~~ aSymbol]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 8/12/2001 13:11'!filterToNotSendersOf	"Filter the receiver's list down to only those items which do not send a given selector"	| aFragment inputWithBlanksTrimmed aMethod |	aFragment _ FillInTheBlank request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector |					(aMethod _ aClass compiledMethodAt: aSelector) isNil or:						[(aMethod hasLiteralThorough: aSymbol) not]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 1/19/2001 15:58'!filterToSendersOf	"Filter the receiver's list down to only those items which send a given selector"	| aFragment inputWithBlanksTrimmed aMethod |	aFragment _ FillInTheBlank request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector |					(aMethod _ aClass compiledMethodAt: aSelector) notNil and:						[aMethod hasLiteralThorough: aSymbol]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 8/10/2001 14:43'!filterToUncommentedMethods	"Filter the receiver's list down to only those items which lack comments"	self filterFrom:		[:aClass :aSelector |			(aClass selectors includes: aSelector) and:						[(aClass firstPrecodeCommentFor: aSelector) isEmptyOrNil]]! !!MessageSet methodsFor: 'filtering' stamp: 'sd 4/29/2003 12:24'!filterToUnsentMessages	"Filter the receiver's list down to only those items which have no  	senders"	self		filterFrom: [:aClass :aSelector | (self systemNavigation allCallsOn: aSelector) isEmpty]! !!MessageSet methodsFor: 'message category functions' stamp: 'sw 10/8/2001 14:10'!canShowMultipleMessageCategories	"Answer whether the receiver is capable of showing multiple message categories"	^ false! !!MessageSet methodsFor: 'metaclass' stamp: 'sw 8/15/2002 22:23'!classCommentIndicated	"Answer true iff we're viewing the class comment."	^ self selectedMessageName == #Comment! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageSet class	instanceVariableNames: ''!!MessageSet class methodsFor: 'instance creation'!messageList: anArray 	"Answer an instance of me with message list anArray."	^self new initializeMessageList: anArray! !!MessageSet class methodsFor: 'instance creation' stamp: 'BG 10/29/2003 08:40'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView aTextView underPane y buttonsView winWidth |	winWidth _ 200.	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: winWidth @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView  menuTitleSelector: #messageListSelectorTitle.	aListView window: (0 @ 0 extent: winWidth @ 100).	topView addSubView: aListView.	aMessageSet  wantsAnnotationPane		ifTrue:			[aTextView _ PluggableTextView on: aMessageSet 			text: #annotation accept: nil			readSelection: nil menu: nil.			aTextView window: (0 @ 0 extent: winWidth @ 24).			topView addSubView: aTextView below: aListView.			underPane _ aTextView.			y _ 300 - 24.			aTextView askBeforeDiscardingEdits: false]		ifFalse:			[underPane _ aListView.			y _ 300].	aMessageSet wantsOptionalButtons ifTrue:		[buttonsView _ aMessageSet buildOptionalButtonsView.		topView addSubView: buttonsView below: underPane.		underPane _ buttonsView.		y _ y - aMessageSet optionalButtonHeight].	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: winWidth @ y).	topView addSubView: aBrowserCodeView below: underPane.	topView setUpdatablePanesFrom: #(messageList).	topView controller open! !!MessageSet class methodsFor: 'instance creation'!openMessageList: anArray name: aString 	"Create a standard system view for the message set on the list, anArray. 	The label of the view is aString."	self open: (self messageList: anArray) name: aString! !!MessageSet class methodsFor: 'instance creation' stamp: 'ssa 9/3/2008 11:07'!openMessageList: messageList name: labelString autoSelect: autoSelectString	"Open a system view for a MessageSet on messageList. 	 1/24/96 sw: the there-are-no msg now supplied by my sender"	| messageSet |	messageSet _ self messageList: messageList.	messageSet autoSelectString: autoSelectString.	ScheduledControllers scheduleActive: (self open: messageSet name: labelString)! !!MessageSet class methodsFor: 'utilities' stamp: 'RAA 5/29/2001 10:19'!extantMethodsIn: aListOfMethodRefs	"Answer the subset of the incoming list consisting only of those message markers that refer to methods actually in the current image"	self flag: #mref.	"may be removed in second round"	^ aListOfMethodRefs select: [:aToken |		self 			parse: aToken 			toClassAndSelector: [ :aClass :aSelector |				aClass notNil and: [aClass includesSelector: aSelector]			]	]! !!MessageSet class methodsFor: 'utilities' stamp: 'sw 6/6/2001 15:09'!isPseudoSelector: aSelector	"Answer whether the given selector is a special marker"	^ #(Comment Definition Hierarchy) includes: aSelector! !!MessageSet class methodsFor: 'utilities' stamp: 'bkv 4/2/2003 11:33'!parse: methodRef toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	self flag: #mref.	"compatibility with pre-MethodReference lists"	methodRef ifNil: [^ csBlock value: nil value: nil].	(methodRef isKindOf: MethodReference) ifTrue: [		^methodRef setClassAndSelectorIn: csBlock	].	methodRef isEmpty ifTrue: [^ csBlock value: nil value: nil].	tuple _ methodRef asString findTokens: ' .'.	cl _ Smalltalk atOrBelow: tuple first asSymbol ifAbsent: [^ csBlock value: nil value: nil].	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !Magnitude subclass: #MessageTally	instanceVariableNames: 'class method tally receivers senders time gcStats maxClassNameSize maxClassPlusSelectorSize maxTabs'	classVariableNames: 'DefaultPollPeriod ObservedProcess Timer'	poolDictionaries: ''	category: 'Tools-Debugger'!!MessageTally commentStamp: 'nk 3/8/2004 12:43' prior: 0!My instances observe and report the amount of time spent in methods.NOTE: a higher-level user interface (combining the MessageTally result tree with a method browser) is available from TimeProfileBrowser.MessageTally provides two different strategies available for profiling:* spyOn: and friends use a high-priority Process to interrupt the block or process being spied on at periodic intervals. The interrupted call stack is then examined for caller information.* tallySends: and friends use the interpreter simulator to run the block, recording every method call.The two give you different results:* spyOn: gives you a view of where the time is being spent in your program, at least on a rough statistical level (assuming you've run the block for long enough and have a high enough poll rate). If you're trying to optimize your code, start here and optimize the methods where most of the time is being spent first.* tallySends: gives you accurate counts of how many times methods get called, and by exactly which route. If you're debugging, or trying to figure out if a given method is getting called too many times, this is your tool.You can change the printing format (that is, the whitespace and string compression) by using these instance methods: 	maxClassNameSize:	maxClassPlusSelectorSize:	maxTabs:You can change the default polling period (initially set to 1) by calling	MessageTally defaultPollPeriod: numberOfMillisecondsQ: How do you interpret MessageTally>>tallySendsA: The methods #tallySends and #spyOn: measure two very different quantities, but broken down in the same who-called-who format.  #spyOn: is approximate, but more indicative of real time spent, whereas #tallySends is exact and a precise record of how many times each method got executed.!!MessageTally methodsFor: 'comparing'!< aMessageTally 	"Refer to the comment in Magnitude|<."	^tally > aMessageTally tally! !!MessageTally methodsFor: 'comparing' stamp: 'tk 7/5/2001 22:05'!= aMessageTally	self species == aMessageTally species ifFalse: [^ false].	^ aMessageTally method == method! !!MessageTally methodsFor: 'comparing'!> aMessageTally 	"Refer to the comment in Magnitude|>."	^tally < aMessageTally tally! !!MessageTally methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^method asOop! !!MessageTally methodsFor: 'comparing' stamp: 'tk 7/5/2001 22:04'!species	^MessageTally! !!MessageTally methodsFor: 'initialize-release'!close	(Timer isMemberOf: Process) ifTrue: [Timer terminate].	Timer _ ObservedProcess _ nil.	class _ method _ tally _ receivers _ nil! !!MessageTally methodsFor: 'initialize-release' stamp: 'nk 3/8/2004 12:29'!initialize	maxClassNameSize _ self class defaultMaxClassNameSize.	maxClassPlusSelectorSize _ self class defaultMaxClassPlusSelectorSize.	maxTabs _ self class defaultMaxTabs.! !!MessageTally methodsFor: 'printing' stamp: 'nk 3/8/2004 12:14'!printOn: aStream 	| aSelector className aClass |	(class isNil or: [method isNil]) ifTrue: [^super printOn: aStream].	aSelector := class selectorAtMethod: method setClass: [:c | aClass := c].	className := aClass name contractTo: self maxClassNameSize.	aStream		nextPutAll: className;		nextPutAll: ' >> ';		nextPutAll: (aSelector 					contractTo: self maxClassPlusSelectorSize - className size)! !!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:29'!maxClassNameSize	^maxClassNameSize! !!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:29'!maxClassPlusSelectorSize	^maxClassPlusSelectorSize! !!MessageTally methodsFor: 'reporting' stamp: 'stp 05/08/1999 12:06'!tally	"Answer the receiver's number of tally."	^tally! !!MessageTally methodsFor: 'reporting' stamp: 'stp 05/08/1999 11:47'!time	"Answer the receiver's run time."	^time! !!MessageTally methodsFor: 'private'!method	^method! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageTally class	instanceVariableNames: ''!!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:27'!defaultMaxClassNameSize	"Return the default maximum width of the class name alone"	^30! !!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:27'!defaultMaxClassPlusSelectorSize	"Return the default maximum width of the class plus selector together (not counting the '>>')"	^60! !!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:26'!defaultMaxTabs	"Return the default number of tabs after which leading white space is compressed"	^18! !ClassDescription subclass: #Metaclass	instanceVariableNames: 'thisClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!Metaclass commentStamp: '<historical>' prior: 0!My instances add instance-specific behavior to various class-describing objects in the system. This typically includes messages for initializing class variables and instance creation messages particular to a class. There is only one instance of a particular Metaclass, namely the class which is being described. A Metaclass shares the class variables of its instance.	[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes. Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object. Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class. Thus,	Object superclass == nil, and	Object class superclass == Class.[Subtle detail] A class is know by name to an environment.  Typically this is the SystemDictionary named Smalltalk.  If we ever make lightweight classes that are not in Smalltalk, they must be in some environment.  Specifically, the code that sets 'wasPresent' in name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed: must continue to work.!!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/13/1999 04:52'!adoptInstance: oldInstance from: oldMetaClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	thisClass class == self ifTrue:[^self error:'Metaclasses have only one instance'].	oldMetaClass isMeta ifFalse:[^self error:'Argument must be Metaclass'].	oldInstance class == oldMetaClass ifFalse:[^self error:'Not the class of argument'].	^thisClass _ self 		newInstanceFrom: oldInstance 		variable: self isVariable 		size: self instSize 		map: (self instVarMappingFrom: oldMetaClass)! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 18:56'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	^(ClassBuilder new)		class: self		instanceVariableNames: instVarString! !!Metaclass methodsFor: 'accessing' stamp: 'ar 7/11/1999 08:14'!allInstances	thisClass class == self ifTrue:[^Array with: thisClass].	^super allInstances! !!Metaclass methodsFor: 'accessing' stamp: 'ar 7/11/1999 05:19'!environment	^thisClass environment! !!Metaclass methodsFor: 'accessing'!isMeta	^ true! !!Metaclass methodsFor: 'accessing' stamp: 'tk 6/17/1998 09:48'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!Metaclass methodsFor: 'accessing'!name	"Answer a String that is the name of the receiver, either 'Metaclass' or 	the name of the receiver's class followed by ' class'."	thisClass == nil		ifTrue: [^'a Metaclass']		ifFalse: [^thisClass name , ' class']! !!Metaclass methodsFor: 'accessing'!soleInstance	"The receiver has only one instance. Answer it."	^thisClass! !!Metaclass methodsFor: 'accessing'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^thisClass! !!Metaclass methodsFor: 'copying'!copy	"Make a copy of the receiver without a list of subclasses. Share the 	reference to the sole instance."	| copy t |	t _ thisClass.	thisClass _ nil.	copy _ super copy.	thisClass _ t.	^copy! !!Metaclass methodsFor: 'copying' stamp: 'tk 8/19/1998 16:16'!veryDeepCopyWith: deepCopier	"Return self.  Must be created, not copied.  Do not record me."! !!Metaclass methodsFor: 'instance creation' stamp: 'nk 11/9/2003 10:00'!new	"The receiver can only have one instance. Create it or complain that	one already exists."	thisClass class ~~ self		ifTrue: [^thisClass _ self basicNew]		ifFalse: [self error: 'A Metaclass should only have one instance!!']! !!Metaclass methodsFor: 'instance variables'!addInstVarName: aString 	"Add the argument, aString, as one of the receiver's instance variables."	| fullString |	fullString _ aString.	self instVarNames do: [:aString2 | fullString _ aString2 , ' ' , fullString].	self instanceVariableNames: fullString! !!Metaclass methodsFor: 'pool variables'!classPool	"Answer the dictionary of class variables."	^thisClass classPool! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/11/1999 15:43'!addSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!obsoleteSubclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass obsoleteSubclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses_nil' for: m logged: false]"! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!removeObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/11/1999 15:43'!removeSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/14/1999 11:19'!subclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass subclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses_nil' for: m logged: false]"! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/9/1999 14:11'!subclassesDo: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	thisClass subclassesDo:[:aSubclass|		"The following test is for Class class which has to exclude		the Metaclasses being subclasses of Class."		aSubclass isMeta ifFalse:[aBlock value: aSubclass class]].! !!Metaclass methodsFor: 'class hierarchy' stamp: 'tk 8/18/1999 17:37'!subclassesDoGently: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	thisClass subclassesDo: [:aSubclass |		"The following test is for Class class which has to exclude			the Metaclasses being subclasses of Class."		aSubclass isInMemory ifTrue: [			aSubclass isMeta ifFalse: [aBlock value: aSubclass class]]].! !!Metaclass methodsFor: 'compiling'!acceptsLoggingOfCompilation	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself.  6/18/96 sw"	^ thisClass acceptsLoggingOfCompilation! !!Metaclass methodsFor: 'compiling' stamp: 'ar 5/18/2003 18:13'!bindingOf: varName	^thisClass classBindingOf: varName! !!Metaclass methodsFor: 'compiling'!possibleVariablesFor: misspelled continuedFrom: oldResults	^ thisClass possibleVariablesFor: misspelled continuedFrom: oldResults! !!Metaclass methodsFor: 'compiling'!wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.The metaclass follows the rule of the class itself.  7/12/96 sw"	^ thisClass wantsChangeSetLogging! !!Metaclass methodsFor: 'compiling' stamp: 'sw 7/31/2000 14:29'!wantsRecompilationProgressReported	"The metaclass follows the rule of the class itself."	^ thisClass wantsRecompilationProgressReported! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'sma 6/25/2000 16:30'!definitionST80	"Refer to the comment in ClassDescription|definition."	^ String streamContents: 		[:strm |		strm print: self;			crtab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:50'!definitionST80: isST80	"Refer to the comment in ClassDescription|definition."	isST80 ifTrue: [^ self definitionST80].	^ String streamContents: 		[:strm |		strm print: self;			nextPutKeyword: ' instanceVariableNames: '				withArg: self instanceVariablesString]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!fileOutInitializerOn: aStream	(self methodDict includesKey: #initialize) ifTrue: 		[aStream cr.		aStream nextChunkPut: thisClass name , ' initialize'].! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:31'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: true! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool	super fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	(aBool and:[moveSource not and: [self methodDict includesKey: #initialize]]) ifTrue: 		[aFileStream cr.		aFileStream cr.		aFileStream nextChunkPut: thisClass name , ' initialize'.		aFileStream cr]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!nonTrivial 	"Answer whether the receiver has any methods or instance variables."	^ self instVarNames size > 0 or: [self methodDict size > 0]! !!Metaclass methodsFor: 'testing' stamp: 'ar 9/10/1999 17:41'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'testing' stamp: 'ar 7/11/1999 07:27'!isObsolete	"Return true if the receiver is obsolete"	^thisClass == nil "Either no thisClass"		or:[thisClass class ~~ self "or I am not the class of thisClass"			or:[thisClass isObsolete]] "or my instance is obsolete"! !!Metaclass methodsFor: 'enumerating' stamp: 'ar 7/15/1999 16:43'!allInstancesDo: aBlock	"There should be only one"	thisClass class == self ifTrue:[^aBlock value: thisClass].	^super allInstancesDo: aBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Metaclass class	instanceVariableNames: ''!!Metaclass class methodsFor: 'anti-corruption' stamp: 'di 11/24/1999 13:30'!isScarySelector: newbieSelector	"Return true if newbieSelector is already a part of Metaclass protocol."	(Metaclass includesSelector: newbieSelector) ifTrue: [^ true].	(ClassDescription includesSelector: newbieSelector) ifTrue: [^ true].	(Behavior includesSelector: newbieSelector) ifTrue: [^ true].	^ false! !Object subclass: #MethodChangeRecord	instanceVariableNames: 'changeType currentMethod infoFromRemoval'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!MethodChangeRecord commentStamp: '<historical>' prior: 0!MethodChangeRecords are used to record method changes.  Here is a simple summary of the relationship between the changeType symbol and the recording of prior state			|	prior == nil			|	prior not nil		---------	|----------------------------	|--------------------	add		|	add					|	change	---------	|----------------------------	|--------------------	remove	|	addedThenRemoved	|	removeStructure:changeType			symbol -- as summarized abovecurrentMethod	method				This is the current version of the method.				It can be used to assert this change upon entry to a layer. infoFromRemoval -- an array of size 2.				The first element is the source index of the last version of the method.				The second element is the category in which it was defined, so it				can be put back there if re-accepted from a version browser.Note that the above states each have an associated revoke action:	add --> remove	change --> change back	remove --> add back	addedThenRemoved --> no changeHowever all of these are accomplished trivially by restoring the original method dictionary.!!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!changeType	^ changeType! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 3/28/2000 23:34'!currentMethod	^ currentMethod! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!methodInfoFromRemoval	"Return an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	(changeType == #remove or: [changeType == #addedThenRemoved])		ifTrue: [^ infoFromRemoval]		ifFalse: [^ nil]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/4/2000 11:05'!noteChangeType: newChangeType	(changeType == #addedThenRemoved and: [newChangeType == #change])		ifTrue: [changeType _ #add]		ifFalse: [changeType _ newChangeType]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 11:05'!noteMethodInfoFromRemoval: info	"Store an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	infoFromRemoval _ info! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 3/28/2000 23:32'!noteNewMethod: newMethod	currentMethod _ newMethod! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!printOn: strm	super printOn: strm.	strm nextPutAll: ' ('; print: changeType; nextPutAll: ')'! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 10:47'!priorMethod: ignored	"We do not save original versions of changed methods because we only	revoke changes at the level of entire classes, and that is done by	restoration of the entire methodDictionary."! !ContextPart variableSubclass: #MethodContext	instanceVariableNames: 'method receiverMap receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodContext commentStamp: '<historical>' prior: 0!My instances hold all the dynamic state associated with the execution of a CompiledMethod. In addition to their inherited state, this includes the receiver, a method, and temporary space in the variable part of the context.	MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.MethodContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a MethodContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.!!MethodContext methodsFor: 'initialize-release' stamp: 'ajh 1/23/2003 20:27'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ method initialPC.	self stackp: method numTemps.	method numArgs+1 to: method numTemps		do: [:i | self tempAt: i put: nil]! !!MethodContext methodsFor: 'initialize-release' stamp: 'ajh 5/22/2003 16:28'!privRefreshWith: aCompiledMethod 	"Reinitialize the receiver as though it had been for a different method. 	Used by a Debugger when one of the methods to which it refers is 	recompiled."	method _ aCompiledMethod.	receiverMap _ nil.	self privRefresh! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 16:55'!blockHome	"If executing closure, search senders for method containing my closure method.  If not found return nil."	| m |	self isExecutingBlock ifFalse: [^ self].	self sender ifNil: [^ nil].	m _ self method.	^ self sender findContextSuchThat: [:c | c method hasLiteralThorough: m]! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 23:29'!finalBlockHome	"If executing closure, search senders for original method containing my closure method.  If not found return nil."	| h |	self isExecutingBlock ifFalse: [^ self].	^ (h _ self blockHome) ifNotNil: [h finalBlockHome]! !!MethodContext methodsFor: 'accessing'!home 	"Refer to the comment in ContextPart|home."	^self! !!MethodContext methodsFor: 'accessing' stamp: 'ar 6/28/2003 00:04'!isExecutingBlock	"Is this executing a block versus a method"	| r |	Smalltalk at: #BlockClosure ifPresent:[:aClass|		^((r _ self receiver) isKindOf: aClass) and: [r method == self method]	].	^false! !!MethodContext methodsFor: 'accessing'!method	^method! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 2/9/2003 00:08'!methodNode	| h |	^ self isExecutingBlock		ifTrue: [self method blockNodeIn: ((h _ self blockHome) ifNotNil: [h methodNode])]		ifFalse: [super methodNode]! !!MethodContext methodsFor: 'accessing'!receiver 	"Refer to the comment in ContextPart|receiver."	^receiver! !!MethodContext methodsFor: 'accessing'!tempAt: index 	"Refer to the comment in ContextPart|tempAt:."	^self at: index! !!MethodContext methodsFor: 'accessing'!tempAt: index put: value 	"Refer to the comment in ContextPart|tempAt:put:."	^self at: index put: value! !!MethodContext methodsFor: 'private' stamp: 'di 1/14/1999 22:30'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!MethodContext methodsFor: 'private' stamp: 'ikp 12/23/1999 15:56'!setSender: s receiver: r method: m arguments: args 	"Create the receiver's initial state."	sender _ s.	receiver _ r.	method _ m.	receiverMap _ nil.	pc _ method initialPC.	self stackp: method numTemps.	1 to: args size do: [:i | self at: i put: (args at: i)]! !!MethodContext methodsFor: 'private' stamp: 'ajh 8/13/2002 13:34'!startpc	^ self method initialPC! !!MethodContext methodsFor: 'private-exceptions' stamp: 'hg 10/2/2001 20:43'!cannotReturn: result	Debugger		openContext: thisContext		label: 'computation has been terminated'		contents: nil! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 22:05'!isHandlerContext"is this context for  method that is marked?"	^method primitive = 199! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 22:05'!isUnwindContext"is this context for  method that is marked?"	^method primitive = 198! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tfei 3/23/1999 13:00'!receiver: r	receiver := r! !!MethodContext methodsFor: 'private-debugger' stamp: 'tfei 3/19/2000 23:55'!cachedStackTop	"WARNING - this method depends on a very dirty trick, viz. snitching information off the variable stack of a particular CompiledMethod.  So if you add/remove a temp in BlockContext>>valueUninterruptably, this method will fail, probably with some horrible consequences I'd rather not think through just now ... assumption is that the variable declaration in that method looks like:		| sendingContext result homeSender |"	^self tempAt: 3! !!MethodContext methodsFor: 'private-debugger' stamp: 'ajh 1/24/2003 23:38'!cachesStack	^ false	"^self selector == #valueUninterruptably		and: [self receiver class == BlockContext]"! !!MethodContext methodsFor: 'private-debugger' stamp: 'tfei 3/20/2000 00:24'!hideFromDebugger	| sndr sndrHome |	^self cachesStack		or: [(sndr := self sender) ~~ nil			and: [(sndrHome := sndr home) ~~ nil				and: [sndrHome cachesStack]]]! !!MethodContext methodsFor: 'printing' stamp: 'ajh 1/31/2003 20:34'!printOn: aStream	| h |	self isExecutingBlock ifFalse: [^ super printOn: aStream].	h _ self blockHome.	h ifNil: [^ aStream nextPutAll: '[]'].	aStream nextPutAll: '[] from '.	h printOn: aStream! !!MethodContext methodsFor: 'printing' stamp: 'emm 5/30/2002 14:07'!printString	"Answer an emphasized string in case of a breakpoint method"	^self method hasBreakpoint		ifTrue:[(super printString , ' [break]') asText allBold]		ifFalse:[super printString]! !!MethodContext methodsFor: 'printing' stamp: 'LC 1/6/2002 11:13'!who	| sel mcls |	self method ifNil: [^ Array with: #unknown with: #unknown].	sel _ self receiver class			selectorAtMethod: self method 			setClass: [:c | mcls _ c].	sel == #? ifTrue: [^ self method who].	^ Array with: mcls with: sel! !!MethodContext methodsFor: 'closure support' stamp: 'ar 6/28/2003 00:15'!contextTag	"Context tags may be used for referring to contexts instead of contexts themselves as they can be copied and will continue to work in other processes (continuations). By default, we use the context itself to as its tag."	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodContext class	instanceVariableNames: ''!!MethodContext class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:06'!sender: s receiver: r method: m arguments: args 	"Answer an instance of me with attributes set to the arguments."	^(self newForMethod: m) setSender: s receiver: r method: m arguments: args! !Dictionary variableSubclass: #MethodDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodDictionary commentStamp: '<historical>' prior: 0!I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instances of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.!!MethodDictionary methodsFor: 'accessing'!add: anAssociation	^ self at: anAssociation key put: anAssociation value! !!MethodDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock	| index |	index _ self findElementOrNil: key.	(self basicAt: index) == nil ifTrue: [ ^ aBlock value ].	^ array at: index! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 10/12/2000 17:25'!at: key put: value	"Set the value at key to be value."	| index |	index _ self findElementOrNil: key.	(self basicAt: index) == nil		ifTrue: 			[tally _ tally + 1.			self basicAt: index put: key]		ifFalse:			[(array at: index) flushCache].	array at: index put: value.	self fullCheck.	^ value! !!MethodDictionary methodsFor: 'accessing' stamp: 'tk 6/30/2000 00:14'!includesKey: aSymbol	"This override assumes that pointsTo is a fast primitive"	aSymbol ifNil: [^ false].	^ super pointsTo: aSymbol! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:17'!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value == (array at: index)			ifTrue:				[(theKey _ self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:00'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value = (array at: index)			ifTrue:				[(theKey _ self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!MethodDictionary methodsFor: 'removing'!removeKey: key ifAbsent: errorBlock 	"The interpreter might be using this MethodDict while	this method is running!!  Therefore we perform the removal	in a copy, and then atomically become that copy"	| copy |	copy _ self copy.	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].	self become: copy! !!MethodDictionary methodsFor: 'enumeration'!associationsDo: aBlock 	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil ifFalse:			[aBlock value: (Association key: key									value: (array at: i))]]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'to 1/14/98 10:13'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (self basicAt: i) == nil ifFalse:			[aBlock value: (array at: i)]]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 08:05'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys and values passed to the block"	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil ifFalse:			[aBlock value: key value: (array at: i)]		]! !!MethodDictionary methodsFor: 'enumeration'!keysDo: aBlock 	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil			ifFalse: [aBlock value: key]]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 07:29'!valuesDo: aBlock 	| value |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (value _ array at: i) == nil			ifFalse: [aBlock value: value]]! !!MethodDictionary methodsFor: 'private' stamp: 'tk 8/21/97 16:26'!copy	^ self shallowCopy withArray: array shallowCopy! !!MethodDictionary methodsFor: 'private' stamp: 'di 11/4/97 20:11'!grow 	| newSelf key |	newSelf _ self species new: self basicSize.  "This will double the size"	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private'!keyAt: index	^ self basicAt: index! !!MethodDictionary methodsFor: 'private'!rehash 	| newSelf key |	newSelf _ self species new: self size.	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private' stamp: 'RAA 12/17/2000 11:11'!rehashWithoutBecome	| newSelf key |	newSelf _ self species new: self size.	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	^newSelf! !!MethodDictionary methodsFor: 'private'!removeDangerouslyKey: key ifAbsent: aBlock	"This is not really dangerous.  But if normal removal	were done WHILE a MethodDict were being used, the	system might crash.  So instead we make a copy, then do	this operation (which is NOT dangerous in a copy that is	not being used), and then use the copy after the removal."	| index element |	index _ self findElementOrNil: key.	(self basicAt: index) == nil ifTrue: [ ^ aBlock value ].	element _ array at: index.	array at: index put: nil.	self basicAt: index put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^ element! !!MethodDictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!MethodDictionary methodsFor: 'private'!swap: oneIndex with: otherIndex	| element |	element _ self basicAt: oneIndex.	self basicAt: oneIndex put: (self basicAt: otherIndex).	self basicAt: otherIndex put: element.	super swap: oneIndex with: otherIndex.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodDictionary class	instanceVariableNames: ''!!MethodDictionary class methodsFor: 'instance creation' stamp: 'RAA 5/29/2001 09:53'!new	"change the default size to be a bit bigger to help reduce the number of #grows while filing in"	^self new: 16! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'di 11/4/97 20:11'!new: nElements	"Create a Dictionary large enough to hold nElements without growing.	Note that the basic size must be a power of 2.	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"	| size |	size _ 1 bitShift: nElements highBit.	^ (self basicNew: size) init: size! !Object subclass: #MethodFinder	instanceVariableNames: 'data answers selector argMap thisData mapStage mapList expressions cachedClass cachedArgNum cachedSelectorLists'	classVariableNames: 'AddAndRemove Approved Blocks Dangerous'	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodFinder commentStamp: '<historical>' prior: 0!Find a method in the system from a set of examples.  Done by brute force, trying every possible selector.  Errors are skipped over using ( [3 + 'xyz'] ifError: [^ false] ).Submit an array of the form ((data1 data2) answer  (data1 data2) answer).	MethodFinder methodFor: #( (4 3) 7  (0 5) 5  (5 5) 10).answer:  'data1 + data2'More generally, use the brace notation to construct live examples.The program tries data1 as the receiver, and	tries all other permutations of the data for the receiver and args, and	tries leaving out one argument, and	uses all selectors data understands, and	uses all selectors in all od data's superclasses.Floating point values must be precise to 0.01 percent, or (X * 0.0001).If you get an error, you have probably discovered a selector that needs to be removed from the Approved list.  See MethodFinder.initialize.  Please email the Squeak Team.Only considers 0, 1, 2, and 3 argument messages.  The argument data may have 1 to 5 entries, but only a max of 4 used at a time.  For now, we only test messages that use given number of args or one fewer.  For example, this data (100 true 0.6) would test the receiver plus two args, and the receiver plus one arg, but not any other patterns.Three sets of selectors:  Approved, AddAndRemove, and Blocks selectors.  When testing a selector in AddAndRemove, deepCopy the receiver.  We do not handle selectors that modify an argument (printOn: etc.).  Blocks is a set of (selector argNumber) where that argument must be a block.For perform, the selector is tested.  It must be in the Approved list.do: is not on the Approved list.  It does not produce a result that can be tested.  Type 'do' into the upper pane of the Selector Finder to find messages list that.[Later, allow the user to supply a block that tests the answer, not just the literal answer.]	MethodFinder methodFor: { { true. [3]. [4]}. 3}. Later allow this to work without the blocks around 3 and 4.!!MethodFinder methodsFor: 'initialize' stamp: 'tk 7/1/2000 23:11'!cleanInputs: dataAndAnswerString	"Find an remove common mistakes.  Complain when ill formed."| fixed ddd rs places |ddd _ dataAndAnswerString.fixed _ false.rs _ ReadStream on: ddd, ' '.places _ OrderedCollection new.[rs upToAll: '#true'.  rs atEnd] whileFalse: [places addFirst: rs position-4]. places do: [:pos | ddd _ ddd copyReplaceFrom: pos to: pos with: ''.	fixed _ true]. 	"remove #"rs _ ReadStream on: ddd.places _ OrderedCollection new.[rs upToAll: '#false'.  rs atEnd] whileFalse: [places addFirst: rs position-5]. places do: [:pos | ddd _ ddd copyReplaceFrom: pos to: pos with: ''.	fixed _ true]. 	"remove #"fixed ifTrue: [self inform: '#(true false) are Symbols, not Booleans.  Next time use { true. false }.'].fixed _ false.rs _ ReadStream on: ddd.places _ OrderedCollection new.[rs upToAll: '#nil'.  rs atEnd] whileFalse: [places addFirst: rs position-3]. places do: [:pos | ddd _ ddd copyReplaceFrom: pos to: pos with: ''.	fixed _ true]. 	"remove #"fixed ifTrue: [self inform: '#nil is a Symbol, not the authentic UndefinedObject.  Next time use nil instead of #nil'].^ ddd! !!MethodFinder methodsFor: 'initialize' stamp: 'md 11/14/2003 16:47'!copy: mthFinder addArg: aConstant	| more |	"Copy inputs and answers, add an additional data argument to the inputs.  The same constant for every example"	more _ Array with: aConstant.	data _ mthFinder data collect: [:argList | argList, more].	answers _ mthFinder answers.	self load: nil.! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 5/18/2001 19:23'!initialize	"The methods we are allowed to use.  (MethodFinder new initialize) "	Approved _ Set new.	AddAndRemove _ Set new.	Blocks _ Set new.	"These modify an argument and are not used by the MethodFinder: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom: printOn:format:""Object"  	#("in class, instance creation" categoryForUniclasses chooseUniqueClassName initialInstance isSystemDefined newFrom: officialClass readCarefullyFrom:"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself "testing" basicType ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps "comparing" = == closeTo: hash hashMappedBy: identityHash identityHashMappedBy: identityHashPrintString ~= ~~ "copying" clone copy shallowCopy "dependents access" canDiscardEdits dependents hasUnacceptedEdits "updating" changed changed: okToChange update: windowIsClosing "printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation "class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass "error handling" "user interface" addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor defaultLabelForInspector fullScreenSize initialExtent modelWakeUp mouseUpBalk: newTileMorphRepresentative windowActiveOnFirstClick windowReqNewLabel: "system primitives" asOop instVarAt: instVarNamed: "private" "associating" -> "converting" as: asOrderedCollection asString "casing" caseOf: caseOf:otherwise: "binding" bindingOf: "macpal" contentsChanged currentEvent currentHand currentWorld flash ifKindOf:thenDo: instanceVariableValues scriptPerformer "flagging" flag: "translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:""message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: ) do: [:sel | AddAndRemove add: sel]."Boolean, True, False, UndefinedObject"  	#("logical operations" & eqv: not xor: |"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:"copying" "testing" isEmptyOrNil) do: [:sel | Approved add: sel]."Behavior" 	#("initialize-release""accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords"copying""printing" defaultNameStemForInstances printHierarchy"creating class hierarchy""creating method dictionary""instance creation" basicNew basicNew: new new:"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames"testing class hierarchy" inheritsFrom: kindOfSubclass"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: scopeHas:ifTrue: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:"enumerating""user interface""private" indexIfCompact) do: [:sel | Approved add: sel]."ClassDescription"	#("initialize-release" "accessing" classVersion isMeta name theNonMetaClass"copying" "printing" classVariablesString instanceVariablesString sharedPoolsString"instance variables" checkForInstVarsOK: "method dictionary" "organization" category organization whichCategoryIncludesSelector:"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging"fileIn/Out" definition"private" ) do: [:sel | Approved add: sel]."Class"	#("initialize-release" "accessing" classPool"testing""copying" "class name" "instance variables" "class variables" classVarAt: classVariableAssociationAt:"pool variables" "compiling" "subclass creation" "fileIn/Out" ) do: [:sel | Approved add: sel]. "Metaclass"	#("initialize-release" "accessing" isSystemDefined soleInstance"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling""fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel]."Context, BlockContext"	#(receiver client method receiver tempAt: "debugger access" mclass pc selector sender shortStack sourceCode tempNames tempsAndValues"controlling"  "printing" "system simulation" "initialize-release" "accessing" hasMethodReturn home numArgs"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel]."Message"	#("inclass, instance creation" selector: selector:argument: selector:arguments:"accessing" argument argument: arguments sends:"printing" "sending" ) do: [:sel | Approved add: sel].	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel]."Magnitude"	#("comparing" < <= > >= between:and:"testing" max: min: min:max: ) do: [:sel | Approved add: sel]."Date, Time"	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:"accessing" day leap monthIndex monthName weekday year"arithmetic" addDays: subtractDate: subtractDays:"comparing""inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:"converting" asSeconds"printing" mmddyy mmddyyyy printFormat: "private" firstDayOfMonthIndex: weekdayIndex 	"in class, instance creation" fromSeconds: now 	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds"accessing" hours minutes seconds"arithmetic" addTime: subtractTime:"comparing""printing" intervalString print24 "converting") do: [:sel | Approved add: sel].	#("private" hours: hours:minutes:seconds: day:year: 		 ) do: [:sel | AddAndRemove add: sel]."Number"	#("in class" readFrom:base: "arithmetic" * + - / // \\ abs negated quo: reciprocal rem:"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated"comparing""testing" even isDivisibleBy: isInf isInfinite isNaN isZero negative odd positive sign strictlyPositive"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees"intervals" to: to:by: "printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel]."Integer"	#("in class" primesUpTo:"testing" isPowerOfTwo"arithmetic" alignedTo:"comparing""truncation and round off" atRandom normalize"enumerating" timesRepeat:"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit"printing" asStringWithCommas hex hex8 radix:"system primitives" lastDigit replaceFrom:to:with:startingAt:"private" "benchmarks" ) do: [:sel | Approved add: sel]."SmallInteger, LargeNegativeInteger, LargePositiveInteger"	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" "system primitives" digitAt: digitLength "private" fromString:radix: ) do: [:sel | Approved add: sel].	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel]."Float"	#("arithmetic""mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:"comparing" "testing""truncation and round off" exponent fractionPart integerPart significand significandAsInteger"converting" asApproximateFraction asIEEE32BitWord asTrueFraction"copying") do: [:sel | Approved add: sel]."Fraction, Random"	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel]."Collection"	#("accessing" anyOne"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:"enumerating" collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect:"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:"printing""private" maxSize"arithmetic""math functions" average max median min range sum) do: [:sel | Approved add: sel].	#("adding" add: addAll: addIfNotPresent:"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel]."SequenceableCollection"	#("comparing" hasEqualElements:"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third"removing""copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: polynomialEval:"converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].	#( swap:with:) do: [:sel | AddAndRemove add: sel]."ArrayedCollection, Bag"	#("private" defaultElement "sorting" isSorted"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 	) do: [:sel | Approved add: sel].	#( mergeSortFrom:to:by: sort sort: add: add:withOccurrences:"private" setDictionary ) do: [:sel | AddAndRemove add: sel]."Other messages that modify the receiver"	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].	self initialize2."MethodFinder new initialize.MethodFinder new organizationFiltered: Set"! !!MethodFinder methodsFor: 'initialize' stamp: 'ads 3/29/2003 17:12'!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) ""Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"adding"  growSize"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asIRCLowercase asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf fromPacked:	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet" valueOfHtmlEntity:"accessing" byteAt: endsWithDigit findAnySubStr:startingAt: findBetweenSubStrs: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: includesSubString: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: skipAnySubStr:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: crc16 endsWith: endsWithAnyOf: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padded:to:with:"converting" asByteArray asDate asDisplayText asFileName asHtml asLegalSelector asPacked asParagraph asText asTime asUnHtml asUrl asUrlRelativeTo: capitalized compressWithTable: contractTo: correctAgainst: encodeForHTTP initialIntegerOrNil keywords quoted sansPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes truncateWithElipsisTo: withBlanksTrimmed withFirstCharacterDownshifted withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits withoutTrailingBlanks"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable unescapePercents withInternetLineEndings withSqueakLineEndings withoutQuoting"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: translateToLowercase match:) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "testing" isInfix isKeyword isPvtSelector isUnary) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" evalStrings "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce addLast:times: repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print: printHtml:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo: upToAll: ) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" key nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: dist: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: fromRgbTriplet: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other" colorNames indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter alphaMixed:with:"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses _ #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls _ Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1 ) (at:modify: 2 ) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 ) (ifKindOf:thenDo: 2 ) (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sortBy: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (scopeHas:ifTrue: 2 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (bindWithTemp: 1 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray].self initialize3."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/1/2002 11:33'!initialize3	"additional selectors to consider"#(asWords threeDigitName ) do: [:sel | Approved add: sel].! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 12/29/2000 13:22'!load: dataWithAnswers	"Find a function that takes the data and gives the answers.  Odd list entries are data for it, even ones are the answers.  nil input means data and answers were supplied already.""  (MethodFinder new) load: #( (4 3) 7  (-10 5) -5  (-3 11) 8);		findMessage  "dataWithAnswers ifNotNil: [	data _ Array new: dataWithAnswers size // 2.	1 to: data size do: [:ii | data at: ii put: (dataWithAnswers at: ii*2-1)].	answers _ Array new: data size.	1 to: answers size do: [:ii | answers at: ii put: (dataWithAnswers at: ii*2)]].data do: [:list | 	(list isKindOf: SequenceableCollection) ifFalse: [		^ self inform: 'first and third items are not Arrays'].	].argMap _ (1 to: data first size) asArray.data do: [:list | list size = argMap size ifFalse: [		self inform: 'data arrays must all be the same size']].argMap size > 4 ifTrue: [self inform: 'No more than a receiver and three arguments allowed'].	"Really only test receiver and three args." thisData _ data copy.mapStage _ mapList _ nil.! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/24/1999 19:34'!test3	"find the modification of the caracter table"	(#x at: 1) asciiValue = 120 ifFalse: [self error: 'Character table mod'].! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 5/18/1999 14:46'!makeAllMaps 	"Make a giant list of all permutations of the args.  To find the function, we will try these permutations of the input data.  receiver, args."	| ii |	mapList _ Array new: argMap size factorial.	ii _ 1.	argMap permutationsDo: [:perm |		mapList at: ii put: perm copy.		ii _ ii + 1].	mapStage _ 1.	"about to be bumped"! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!mapData 	"Force the data through the map (permutation) to create the data to test."	thisData _ data collect: [:realData |					argMap collect: [:ind | realData at: ind]].		! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 5/24/1999 16:31'!permuteArgs 	"Run through ALL the permutations.  First one was as presented."	data first size <= 1 ifTrue: [^ false].	"no other way"	mapList ifNil: [self makeAllMaps].	mapStage _ mapStage + 1.	mapStage > mapList size ifTrue: [^ false].	argMap _ mapList at: mapStage.	self mapData.	^ true	! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:18'!exceptions	"Handle some very slippery selectors.	asSymbol -- want to be able to produce it, but do not want to make every string submitted into a Symbol!!" 	| aSel |	answers first class == Symbol ifFalse: [^ self].	thisData first first class == String ifFalse: [^ self].	aSel _ #asSymbol.	(self testPerfect: aSel) ifTrue: [		selector add: aSel.		expressions add: (String streamContents: [:strm | 			strm nextPutAll: 'data', argMap first printString.			aSel keywords doWithIndex: [:key :ind |				strm nextPutAll: ' ',key.				(key last == $:) | (key first isLetter not)					ifTrue: [strm nextPutAll: ' data', 						(argMap at: ind+1) printString]]])].! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:35'!findMessage	"Control the search."	data do: [:alist |		(alist isKindOf: SequenceableCollection) ifFalse: [			^ OrderedCollection with: 'first and third items are not Arrays']].	Approved ifNil: [self initialize].	"Sets of allowed selectors"	expressions _ OrderedCollection new.	self search: true.	"multi"	expressions isEmpty ifTrue: [^ OrderedCollection with: 'no single method does that function'].	expressions class = String ifTrue: [^ OrderedCollection with: expressions]. 	^ expressions! !!MethodFinder methodsFor: 'search' stamp: 'tk 4/12/2001 10:47'!insertConstants	"see if one of several known expressions will do it. C is the constant we discover here."	"C  data1+C  data1*C  data1//C  (data1*C1 + C2) (data1 = C) (data1 ~= C) (data1 <= C) (data1 >= C)  (data1 mod C)"	thisData size >= 2 ifFalse: [^ false].	"need 2 examples"	(thisData at: 1) size = 1 ifFalse: [^ false].	"only one arg, data1"	self const ifTrue: [^ true].	self constUsingData1Value ifTrue: [^ true].		"(data1 ?? const), where const is one of the values of data1"		" == ~~ ~= = <= >= "	self allNumbers ifFalse: [^ false].	self constMod ifTrue: [^ true].	self constPlus ifTrue: [^ true].	self constMult ifTrue: [^ true].	self constDiv ifTrue: [^ true].	self constLinear ifTrue: [^ true].	^ false! !!MethodFinder methodsFor: 'search' stamp: 'tk 12/29/2000 12:54'!search: multi	"if Multi is true, collect all selectors that work."	| old |	selector _ OrderedCollection new.	"list of them"	old _ Preferences autoAccessors.	Preferences disableGently: #autoAccessors.	self simpleSearch.	multi not & (selector isEmpty not) ifTrue:		[old ifTrue: [Preferences enableGently: #autoAccessors].		^ selector].	[self permuteArgs] whileTrue:		[self simpleSearch.		multi not & (selector isEmpty not) ifTrue:			[old ifTrue: [Preferences enableGently: #autoAccessors].			^ selector]].	self insertConstants.	old ifTrue: [Preferences enableGently: #autoAccessors].	"(selector isEmpty not) ifTrue: [^ selector]].    expression is the answer, not a selector"	^ #()! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 17:53'!searchForOne	"Look for and return just one answer"	expressions _ OrderedCollection new.	self search: false.	"non-multi"	^ expressions			! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:17'!simpleSearch	"Run through first arg's class' selectors, looking for one that works."| class supers listOfLists |self exceptions.class _ thisData first first class."Cache the selectors for the receiver class"(class == cachedClass and: [cachedArgNum = ((argMap size) - 1)]) 	ifTrue: [listOfLists _ cachedSelectorLists]	ifFalse: [supers _ class withAllSuperclasses.		listOfLists _ OrderedCollection new.		supers do: [:cls |			listOfLists add: (cls selectorsWithArgs: (argMap size) - 1)].		cachedClass _ class.		cachedArgNum _ (argMap size) - 1.		cachedSelectorLists _ listOfLists].listOfLists do: [:selectorList |	selectorList do: [:aSel |		(selector includes: aSel) ifFalse: [			((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [				(self testPerfect: aSel) ifTrue: [					selector add: aSel.					expressions add: (String streamContents: [:strm | 						strm nextPutAll: 'data', argMap first printString.						aSel keywords doWithIndex: [:key :ind |							strm nextPutAll: ' ',key.							(key last == $:) | (key first isLetter not)								ifTrue: [strm nextPutAll: ' data', 									(argMap at: ind+1) printString]]])					]]]]].! !!MethodFinder methodsFor: 'search' stamp: 'tk 4/30/1999 14:22'!testPerfect: aSelector	"Try this selector!! Return true if it answers every example perfectly.  Take the args in the order they are.  Do not permute them.  Survive errors.  later cache arg lists."| sz argList val rec activeSel perform |	"Transcript cr; show: aSelector.		debug"perform _ aSelector beginsWith: 'perform:'.sz _ argMap size.1 to: thisData size do: [:ii | "each example set of args"	argList _ (thisData at: ii) copyFrom: 2 to: sz.	perform		ifFalse: [activeSel _ aSelector]		ifTrue: [activeSel _ argList first.	"what will be performed"			((Approved includes: activeSel) or: [AddAndRemove includes: activeSel])				ifFalse: [^ false].	"not approved"			aSelector == #perform:withArguments: 				ifTrue: [activeSel numArgs = (argList at: 2) basicSize "avoid error" 							ifFalse: [^ false]]				ifFalse: [activeSel numArgs = (aSelector numArgs - 1) 							ifFalse: [^ false]]].	1 to: sz do: [:num | 		(Blocks includes: (Array with: activeSel with: num)) ifTrue: [			(argList at: num) class == BlockContext ifFalse: [^ false]]].	rec _ (AddAndRemove includes: activeSel) 			ifTrue: [(thisData at: ii) first class == Symbol ifTrue: [^ false].						"vulnerable to modification"				(thisData at: ii) first copyTwoLevel] 	"protect from damage"			ifFalse: [(thisData at: ii) first].	val _ [rec perform: aSelector withArguments: argList] 				ifError: [:aString :aReceiver | 							"self test3."							"self test2: (thisData at: ii)."							^ false].	"self test3."	"self test2: (thisData at: ii)."	((answers at: ii) closeTo: val) ifFalse: [^ false].	].^ true! !!MethodFinder methodsFor: 'access' stamp: 'tk 12/29/2000 13:39'!answers	^ answers! !!MethodFinder methodsFor: 'access' stamp: 'tk 12/29/2000 13:39'!data	^ data! !!MethodFinder methodsFor: 'access' stamp: 'tk 12/29/2000 13:20'!expressions	^ expressions! !!MethodFinder methodsFor: 'access' stamp: 'tk 1/4/2001 17:18'!selectors	"Note the inst var does not have an S on the end"	^ selector! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 12/29/2000 22:34'!allNumbers	"Return true if all answers and all data are numbers."	answers do: [:aa | aa isNumber ifFalse: [^ false]].	thisData do: [:vec |			vec do: [:nn | nn isNumber ifFalse: [^ false]]].	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/18/2001 22:45'!const	| const |	"See if (^ constant) is the answer"	"quick test"	((const _ answers at: 1) closeTo: (answers at: 2)) ifFalse: [^ false].	3 to: answers size do: [:ii | (const closeTo: (answers at: ii)) ifFalse: [^ false]].	expressions add: '^ ', const printString.	selector add: #yourself.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:49'!constDiv	| const subTest got |	"See if (data1 // C) is the answer"	const _ ((thisData at: 1) at: 1) // (answers at: 1).  "May not be right!!"	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:47'!constLinear	| const subTest got denom num slope offset |	"See if (data1 * C1) + C2 is the answer.  In the form  #(C2 C1) polynomialEval: data1 "	denom _ ((thisData at: 2) at: 1) - ((thisData at: 1) at: 1).	denom = 0 ifTrue: [^ false].   "will divide by it"	num _ (answers at: 2) - (answers at: 1).    slope := (num asFloat / denom) reduce.    offset := ((answers at: 2) - (((thisData at: 2) at: 1) * slope)) reduce.	const _ Array with: offset with: slope.	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/18/2001 22:46'!constMod	| subTest low |	"See if mod, (data1 \\ C) is the answer"	low _ answers max.	low+1 to: low+20 do: [:const |		subTest _ MethodFinder new copy: self addArg: const.		(subTest testPerfect: #\\) ifTrue: [			expressions add: 'data1 \\ ', const printString.			selector add: #\\.			^ true]].	^ false! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:49'!constMult	| const subTest got |	"See if (data1 * C) is the answer"	((thisData at: 1) at: 1) = 0 ifTrue: [^ false].	const _ ((answers at: 1) asFloat / ((thisData at: 1) at: 1)) reduce.	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:48'!constPlus	| const subTest got |	"See if (data1 + C) is the answer"	const _ (answers at: 1) - ((thisData at: 1) at: 1).	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 4/9/2001 17:59'!constUsingData1Value	| const subTest got |	"See if (data1 <= C) or (data1 >= C) is the answer"	"quick test"	((answers at: 1) class superclass == Boolean) ifFalse: [^ false].	2 to: answers size do: [:ii | 		((answers at: ii) class superclass == Boolean) ifFalse: [^ false]].	thisData do: [:datums | 		const _ datums first.	"use data as a constant!!"		got _ (subTest _ MethodFinder new copy: self addArg: const) 					searchForOne isEmpty not.		got ifTrue: [			"replace data2 with const in expressions"			subTest expressions do: [:exp |				expressions add: (exp copyReplaceAll: 'data2' with: const printString)].			selector addAll: subTest selectors.			^ true]].	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodFinder class	instanceVariableNames: ''!!MethodFinder class methodsFor: 'as yet unclassified' stamp: 'BG 10/29/2003 09:52'!methodFor: dataAndAnswers	"Return a Squeak expression that computes these answers.  (This method is called by the comment in the bottom pane of a MethodFinder.  Do not delete this method.)"	| resultOC resultString |	resultOC _ (self new) load: dataAndAnswers; findMessage.	resultString _ String streamContents: [:strm |		resultOC do: [:exp | strm nextPut: $(; nextPutAll: exp; nextPut: $); space]].		^ resultString! !CodeHolder subclass: #MethodHolder	instanceVariableNames: 'methodClass methodSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!MethodHolder methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:54'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph	aCustomMenu addLine.	aCustomMenu add: 'whose script is this?' translated target: self action: #identifyScript	! !!MethodHolder methodsFor: 'menu' stamp: 'ssa 9/4/2008 15:23'!doItReceiver	"If there is an instance associated with me, answer it, for true mapping of self.  If not, then do what other code-bearing tools do, viz. give access to the class vars."	^ self selectedClass ifNil: [FakeClassPool new]! !!MethodHolder methodsFor: 'miscellaneous' stamp: 'sw 3/28/2002 00:36'!changeMethodSelectorTo: aSelector	"Change my method selector as noted.  Reset currentCompiledMethod"	methodSelector _ aSelector.	currentCompiledMethod _ methodClass compiledMethodAt: aSelector ifAbsent: [nil]! !!MethodHolder methodsFor: 'miscellaneous' stamp: 'tk 8/30/2000 13:07'!compiledMethod	^ methodClass compiledMethodAt: methodSelector! !!MethodHolder methodsFor: 'miscellaneous' stamp: 'sw 10/23/1999 23:01'!identifyScript	| msg aPlayer |	msg _ methodClass isUniClass		ifTrue:			[aPlayer _ methodClass someInstance.			aPlayer costume				ifNotNil:					['This holds code for a scriptnamed ', methodSelector, ' belongingto an object named ', aPlayer externalName]				ifNil:					['This formerly held code for a scriptnamed ', methodSelector, ' for a Playerwho once existed but now is moribund.']]		ifFalse:			['This holds code for the methodnamed ', methodSelector, 'for class ', methodClass name].	self inform: msg! !!MethodHolder methodsFor: 'miscellaneous' stamp: 'sw 10/21/1999 13:05'!methodClass: aClass methodSelector: aSelector	methodClass _ aClass.	methodSelector _ aSelector.	currentCompiledMethod _ aClass compiledMethodAt: aSelector ifAbsent: [nil]! !!MethodHolder methodsFor: 'miscellaneous' stamp: 'tk 8/30/2000 13:08'!versions	"Return a VersionsBrowser (containing a list of ChangeRecords) of older versions of this method."	^ VersionsBrowser new scanVersionsOf: self compiledMethod			class: self selectedClass 			meta: methodClass isMeta 			category: self selectedMessageCategoryName				"(classOfMethod whichCategoryIncludesSelector: selectorOfMethod)"			selector: methodSelector! !!MethodHolder methodsFor: 'contents' stamp: 'nk 6/19/2004 16:47'!contents	"Answer the contents, with due respect for my contentsSymbol"	contents _ methodClass sourceCodeAt: methodSelector ifAbsent: [''].	currentCompiledMethod _ methodClass compiledMethodAt: methodSelector ifAbsent: [nil].	self showingDecompile ifTrue:			[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].	self showingDocumentation ifTrue:		[^ self commentContents].	^ contents _ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: methodClass! !!MethodHolder methodsFor: 'contents' stamp: 'sw 10/21/1999 13:06'!contents: input notifying: aController 	| selector |	(selector _ Parser new parseSelector: input asText) ifNil:		[self inform: 'Sorry - invalid format for the method name and arguments -- cannot accept.'.		^ false].	selector == methodSelector ifFalse:		[self inform:'You cannot change the name ofthe method here -- it must continueto be ', methodSelector.		^ false].	selector _ methodClass				compile: input asText				classified: self selectedMessageCategoryName				notifying: aController.	selector == nil ifTrue: [^ false].	contents _ input asString copy.	currentCompiledMethod _ methodClass compiledMethodAt: methodSelector.	^ true! !!MethodHolder methodsFor: 'selection' stamp: 'sw 10/21/1999 09:40'!selectedClass	^ methodClass theNonMetaClass! !!MethodHolder methodsFor: 'selection' stamp: 'sw 10/27/1999 14:30'!selectedClassOrMetaClass	^ methodClass! !!MethodHolder methodsFor: 'selection' stamp: 'sw 10/21/1999 10:16'!selectedMessageCategoryName	^ methodClass organization categoryOfElement: methodSelector! !!MethodHolder methodsFor: 'selection' stamp: 'sw 10/21/1999 09:39'!selectedMessageName	^ methodSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodHolder class	instanceVariableNames: ''!!MethodHolder class methodsFor: 'instance creation' stamp: 'sw 10/23/2000 18:55'!makeIsolatedCodePaneForClass: aClass selector: aSelector	"Create, and place in the morphic Hand, an isolated code pane bearing source code for the given class and selector"	(self isolatedCodePaneForClass: aClass selector: aSelector) openInHand! !ObjectWithDocumentation subclass: #MethodInterface	instanceVariableNames: 'selector argumentVariables resultSpecification receiverType attributeKeywords defaultStatus'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Kernel'!!MethodInterface commentStamp: '<historical>' prior: 0!A MethodInterface describes the interface for a single method.  The most generic form is not bound to any particular class or object but rather describes an idealized interface.	selector					A symbol - the selector being described	argumentSpecifications	A list of specifications for the formal arguments of the method	resultSpecification 		A characterization of the return value of the method	userLevel					attributeKeywords		A list of symbols, comprising keywords that the user wishes to								see on the screen for this method	defaultStatus			The status to apply to new instances of the class by default							(#ticking, #paused, #normal, etc.)!!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/10/2001 00:38'!argumentVariables	"Answer the list of argumentVariables of the interface"	^ argumentVariables ifNil: [argumentVariables _ OrderedCollection new]! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/9/2001 17:00'!initialize	"Initialize the receiver"	super initialize.	attributeKeywords _ OrderedCollection new.	defaultStatus _ #normal.	argumentVariables _ OrderedCollection new! !!MethodInterface methodsFor: 'access' stamp: 'sw 3/8/2001 16:29'!companionSetterSelector	"If there is a companion setter selector, anwer it, else answer nil"	^ resultSpecification ifNotNil:		[resultSpecification companionSetterSelector]! !!MethodInterface methodsFor: 'access' stamp: 'sw 9/13/2001 16:42'!elementSymbol	"Answer the element symbol, for the purposes of translation"	^ selector! !!MethodInterface methodsFor: 'access' stamp: 'sw 9/12/2001 14:05'!elementWording	"Answer the wording to be shown on friendly tiles representing the receiver; by default, it is just the same as the method selector itself, but anything special-cased via #wordingForOperator:, and all getters/setters of slots, are transformed into somethingfriendlier here"	^ self translatedToPrevailingLanguage wording! !!MethodInterface methodsFor: 'access' stamp: 'sw 4/5/2001 22:21'!printOn: aStream	"print the receiver on a stream.  Overridden to provide details about wording, selector, result type, and companion setter."	super printOn: aStream.	aStream nextPutAll: ' - wording: ''', self elementWording asString, ''' selector: #', selector asString.	self argumentVariables size > 0 ifTrue:		[aStream nextPutAll: 'Arguments: '.		argumentVariables doWithIndex:			[:aVariable :anIndex | 				aStream nextPutAll: 'argument #', anIndex printString, ' name = ', aVariable variableName asString, ', type = ', aVariable variableType]].	resultSpecification ifNotNil:		[aStream nextPutAll: ' result type = ', resultSpecification resultType asString.		resultSpecification companionSetterSelector ifNotNil:			[aStream nextPutAll: ' setter = ', resultSpecification companionSetterSelector asString]]	! !!MethodInterface methodsFor: 'access' stamp: 'sw 3/10/2001 00:38'!resultType	"Answer the result type"	^ resultSpecification		ifNotNil:			[resultSpecification type]		ifNil:			[#unknown]! !!MethodInterface methodsFor: 'access' stamp: 'sw 1/23/2001 18:37'!selector	"Answer the receiver's selector"	^ selector! !!MethodInterface methodsFor: 'initialize-release' stamp: 'ar 3/3/2001 19:38'!releaseCachedState	"Sent by player"! !ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries sourceText'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!MethodNode commentStamp: '<historical>' prior: 0!I am the root of the parse tree.!!MethodNode methodsFor: 'initialize-release' stamp: 'tk 8/3/1999 12:47'!block	^ block! !!MethodNode methodsFor: 'initialize-release' stamp: 'ajh 1/24/2003 17:37'!selector: symbol	selectorOrFalse _ symbol! !!MethodNode methodsFor: 'initialize-release'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 	"Initialize the receiver with respect to the arguments given."	encoder _ anEncoder.	selectorOrFalse _ selOrFalse.	precedence _ p.	arguments _ args.	temporaries _ temps.	block _ blk.	primitive _ prim! !!MethodNode methodsFor: 'initialize-release' stamp: 'ajh 1/22/2003 17:53'!sourceText: stringOrText	sourceText _ stringOrText! !!MethodNode methodsFor: 'code generation'!encoder	^ encoder! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:48'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:45'!generate: trailer ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])		ifFalse: [^ self].	v _ block code.	v < 0		ifTrue: [^ self].	v = LdSelf		ifTrue: [^ methodBlock value: (CompiledMethod toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3)		ifTrue: [^ methodBlock value: (CompiledMethod toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v trailerBytes: trailer)].	v // 256 = 1		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v \\ 256 trailerBytes: trailer)]! !!MethodNode methodsFor: 'code generation' stamp: 'ajh 3/24/2003 14:51'!generateNative: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'code generation' stamp: 'ajh 7/6/2003 15:25'!parserClass	"Which parser produces this class of parse node"	^ Parser! !!MethodNode methodsFor: 'code generation'!selector 	"Answer the message selector for the method represented by the receiver."	(selectorOrFalse isMemberOf: Symbol)		ifTrue: [^selectorOrFalse].	^selectorOrFalse key! !!MethodNode methodsFor: 'code generation' stamp: 'ajh 7/6/2003 15:26'!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in me) -> sourceRange (an Interval) in source text."	| methNode |	methNode _ self.	sourceText ifNil: [		"No source, use decompile string as source to map from"		methNode _ self parserClass new			parse: self decompileString			class: self methodClass	].	methNode generateNative: #(0 0 0 0).  "set bytecodes to map to"	^ methNode encoder sourceMap! !!MethodNode methodsFor: 'converting' stamp: 'sw 5/20/2001 10:01'!asAltSyntaxText 	"Answer a string description of the parse tree whose root is the receiver, using the alternative syntax"	^ DialectStream		dialect: #SQ00		contents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'converting' stamp: 'sw 5/20/2001 10:00'!asColorizedSmalltalk80Text	"Answer a colorized Smalltalk-80-syntax string description of the parse tree whose root is the receiver."	^ DialectStream		dialect: #ST80		contents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'converting' stamp: 'di 4/13/2000 21:09'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ (DialectStream dialect: #ST80 contents: [:strm | self printOn: strm])		asString! !!MethodNode methodsFor: 'converting' stamp: 'di 4/5/2000 10:07'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ DialectStream		dialect: (Preferences printAlternateSyntax ifTrue: [#SQ00] ifFalse: [#ST80])		contents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'printing' stamp: 'ajh 1/22/2003 17:39'!methodClass	^ encoder classEncoding! !!MethodNode methodsFor: 'printing' stamp: 'di 6/13/2000 00:46'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream dialect = #SQ00					ifTrue: [(kwd endsWith: ':')							ifTrue: [aStream withStyleFor: #methodSelector									do: [aStream nextPutAll: kwd allButLast].									aStream nextPutAll: ' (']							ifFalse: [aStream withStyleFor: #methodSelector									do: [aStream nextPutAll: kwd].									aStream space]]					ifFalse: [aStream nextPutAll: kwd; space].				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream nextPutAll: ') ']					ifFalse: [aStream space]]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream dialect = #SQ00				ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Use']]				ifFalse: [aStream nextPutAll: '|'].			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].			aStream dialect = #SQ00				ifTrue: [aStream nextPutAll: '.']				ifFalse: [aStream nextPutAll: ' |']].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'printing' stamp: 'ar 2/13/2001 21:15'!printPrimitiveOn: aStream 	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ primitive.	primIndex = 0		ifTrue: [^ self].	primIndex = 120		ifTrue: ["External call spec"			^ aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primIndex = 117		ifTrue: [primDecl _ encoder literals at: 1.			aStream nextPut: $';								nextPutAll: (primDecl at: 2);				 nextPut: $'.			(primDecl at: 1) notNil				ifTrue: [aStream nextPutAll: ' module:';						 nextPut: $';												nextPutAll: (primDecl at: 1);						 nextPut: $']]		ifFalse: [aStream print: primIndex].	aStream nextPut: $>.	Smalltalk at: #Interpreter ifPresent:[:cls|		aStream nextPutAll: ' "'				, ((cls classPool at: #PrimitiveTable)						at: primIndex + 1) , '" '].! !!MethodNode methodsFor: 'printing' stamp: 'ajh 1/24/2003 17:41'!sourceText	^ sourceText ifNil: [self printString]! !!MethodNode methodsFor: 'printing'!tempNames	^ encoder tempNames! !!MethodNode methodsFor: 'tiles' stamp: 'RAA 8/20/1999 19:56'!rawSourceRanges	self generate: #(0 0 0 0).	^encoder rawSourceRanges! !Object subclass: #MethodReference	instanceVariableNames: 'classSymbol classIsMeta methodSymbol stringVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!MethodReference methodsFor: 'queries' stamp: 'RAA 5/28/2001 07:42'!actualClass 	| actualClass |	actualClass _ Smalltalk atOrBelow: classSymbol ifAbsent: [^nil].	classIsMeta ifTrue: [^actualClass class].	^actualClass! !!MethodReference methodsFor: 'queries' stamp: 'RAA 5/28/2001 06:19'!asStringOrText	^stringVersion! !!MethodReference methodsFor: 'queries' stamp: 'RAA 5/28/2001 08:11'!classIsMeta	^classIsMeta! !!MethodReference methodsFor: 'queries' stamp: 'RAA 5/28/2001 08:10'!classSymbol	^classSymbol! !!MethodReference methodsFor: 'queries' stamp: 'cwp 7/7/2003 17:44'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	(#(DoIt DoItIn:) includes: methodSymbol) ifTrue: [^ false].	(aClass _ self actualClass) ifNil: [^ false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!MethodReference methodsFor: 'queries' stamp: 'RAA 5/28/2001 08:10'!methodSymbol	^methodSymbol! !!MethodReference methodsFor: 'queries' stamp: 'sw 11/5/2001 00:53'!printOn: aStream	"Print the receiver on a stream"	super printOn: aStream.	aStream nextPutAll: ' ', self actualClass name, ' >> ', methodSymbol! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 08:06'!setClass: aClass methodSymbol: methodSym stringVersion: aString 	classSymbol _ aClass theNonMetaClass name.	classIsMeta _ aClass isMeta.	methodSymbol _ methodSym.	stringVersion _ aString.! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 07:34'!setClassAndSelectorIn: csBlock	^csBlock value: self actualClass value: methodSymbol! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 06:04'!setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 	classSymbol _ classSym.	classIsMeta _ isMeta.	methodSymbol _ methodSym.	stringVersion _ aString.! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 11:34'!setStandardClass: aClass methodSymbol: methodSym	classSymbol _ aClass theNonMetaClass name.	classIsMeta _ aClass isMeta.	methodSymbol _ methodSym.	stringVersion _ aClass name , ' ' , methodSym.! !!MethodReference methodsFor: 'string version' stamp: 'RAA 5/29/2001 14:44'!stringVersion	^stringVersion! !!MethodReference methodsFor: 'string version' stamp: 'RAA 5/29/2001 14:44'!stringVersion: aString	stringVersion _ aString! !!MethodReference methodsFor: 'comparisons' stamp: 'RAA 5/28/2001 11:56'!<= anotherMethodReference	classSymbol < anotherMethodReference classSymbol ifTrue: [^true].	classSymbol > anotherMethodReference classSymbol ifTrue: [^false].	classIsMeta = anotherMethodReference classIsMeta ifFalse: [^classIsMeta not].	^methodSymbol <= anotherMethodReference methodSymbol! !!MethodReference methodsFor: 'comparisons' stamp: 'dgd 3/7/2003 13:18'!= anotherMethodReference 	"Answer whether the receiver and the argument represent the 	same object."	^ self species == anotherMethodReference species		and: [self classSymbol = anotherMethodReference classSymbol]		and: [self classIsMeta = anotherMethodReference classIsMeta]		and: [self methodSymbol = anotherMethodReference methodSymbol]! !!MethodReference methodsFor: 'comparisons' stamp: 'dgd 3/8/2003 11:54'!hash	"Answer a SmallInteger whose value is related to the receiver's  	identity."	^ (self species hash bitXor: self classSymbol hash)		bitXor: self methodSymbol hash! !!MethodReference methodsFor: '*packageinfo-base' stamp: 'ab 5/23/2003 22:58'!category
	^ self actualClass organization categoryOfElement: methodSymbol! !!MethodReference methodsFor: '*packageinfo-base' stamp: 'ab 5/23/2003 22:58'!sourceCode	^ self actualClass sourceCodeAt: methodSymbol! !Controller subclass: #ModalController	instanceVariableNames: 'modeActive'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Framework'!!ModalController commentStamp: '<historical>' prior: 0!I am a controller that puts the poor user into a mode by not relinquishing control. However, I do pass control onto my underlings. Some underling is expected to end the mode by sending me 'close'. Watch out Larry Tesler, the mode lives on...!!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:05'!close	"This is how we leave the mode." 	modeActive _ false.! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:02'!controlInitialize	modeActive _ true.	^ super controlInitialize! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:00'!isControlActive	^ modeActive! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:00'!isControlWanted	^ modeActive! !StandardSystemView subclass: #ModalSystemWindowView	instanceVariableNames: 'modalBorder'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!ModalSystemWindowView commentStamp: '<historical>' prior: 0!I am a view for a Modal System Window.  I vary from StandardSystemView, of which I am a subclass in a few ways:	(1) I use ModalController as my default controller;	(2) When asked to update with the symbol #close, I direct the controller to close;	(3) I display a slightly different title bar with no control boxes.!!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/18/2000 20:41'!borderWidth: anObject	modalBorder _ false.	^super borderWidth: anObject! !!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 00:50'!initialize 	"Refer to the comment in View|initialize."	super initialize.	self borderWidth: 5.	self noLabel.	modalBorder _ true.! !!ModalSystemWindowView methodsFor: 'modal dialog' stamp: 'BG 12/13/2002 11:33'!doModalDialog	| savedArea |	self resizeInitially.	self resizeTo: 		((self windowBox)			align: self windowBox center			with: Display boundingBox aboveCenter).	savedArea _ Form fromDisplay: self windowBox.	self displayEmphasized.	self controller startUp.	self release.	savedArea displayOn: Display at: self windowOrigin.! !!ModalSystemWindowView methodsFor: 'controller access' stamp: 'acg 2/9/2000 00:58'!defaultControllerClass	^ModalController! !!ModalSystemWindowView methodsFor: 'label access' stamp: 'acg 2/9/2000 08:35'!backgroundColor	^Color lightYellow! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/18/2000 20:24'!display	super display.	self displayLabelBackground: false.	self displayLabelText.! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/19/2000 00:59'!displayBorder	"Display the receiver's border (using the receiver's borderColor)."	modalBorder ifFalse: [^super displayBorder].	Display		border: self displayBox		widthRectangle: (1@1 corner: 2@2)		rule: Form over		fillColor: Color black.	Display		border: (self displayBox insetBy: (1@1 corner: 2@2))		widthRectangle: (4@4 corner: 3@3)		rule: Form over		fillColor: (Color r: 16rEA g: 16rEA b: 16rEA).! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/9/2000 07:21'!displayLabelBoxes	"Modal dialogs don't have closeBox or growBox."! !!ModalSystemWindowView methodsFor: 'model access' stamp: 'acg 2/9/2000 00:57'!update: aSymbol	aSymbol = #close		ifTrue: [^self controller close].	^super update: aSymbol! !Object subclass: #Model	instanceVariableNames: 'dependents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!Model commentStamp: '<historical>' prior: 0!Provides a superclass for classes that function as models.  The only behavior provided is fast dependents maintenance, which bypasses the generic DependentsFields mechanism.  1/23/96 sw!!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:26'!canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	dependents ifNil: [^ true].	^ super canDiscardEdits! !!Model methodsFor: 'dependents' stamp: 'BG 10/29/2003 08:37'!containingWindow	"Answer the window that holds the receiver.  The dependents technique is odious and may not be airtight, if multiple windows have the same model."	^ self dependents detect:		[:d | (d isKindOf: StandardSystemView) and: [d model == self]] ifNone: [nil]! !!Model methodsFor: 'dependents' stamp: 'jm 3/24/98 15:12'!hasUnacceptedEdits	"Answer true if any of the views on this model has unaccepted edits."	dependents == nil ifTrue: [^ false].	^ super hasUnacceptedEdits! !!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:54'!myDependents	^ dependents! !!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:54'!myDependents: aCollectionOrNil	dependents _ aCollectionOrNil! !!Model methodsFor: 'dependents' stamp: 'BG 10/28/2003 21:00'!topView	"Find the first top view on me. Is there any danger of their being two with the same model?  Any danger from ungarbage collected old views?  Ask if schedulled?"	dependents ifNil: [^ nil].		dependents do: [:v | v superView ifNil: [v model == self ifTrue: [^ v]]].	^ nil! !!Model methodsFor: 'text links' stamp: 'RAA 5/29/2001 11:14'!addItem: classAndMethod	"Make a linked message list and put this method in it"	| list |	self flag: #mref.	"classAndMethod is a String"	MessageSet 		parse: classAndMethod  		toClassAndSelector: [ :class :sel |			class ifNil: [^self].			list _ OrderedCollection with: (				MethodReference new					setClass: class  					methodSymbol: sel 					stringVersion: classAndMethod			).			MessageSet 				openMessageList: list 				name: 'Linked by HyperText'.		]! !!Model methodsFor: 'menus' stamp: 'di 4/11/98 11:34'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	"default is that the editor does all"	^ otherTarget perform: selector.! !!Model methodsFor: 'menus' stamp: 'tk 4/17/1998 17:28'!selectedClass	"All owners of TextViews are asked this during a doIt"	^ nil! !!Model methodsFor: 'menus' stamp: 'zz 3/2/2004 23:49'!step	"Default for morphic models is no-op"! !!Model methodsFor: 'menus' stamp: 'sw 12/15/2000 13:21'!trash	"What should be displayed if a trash pane is restored to initial state"	^ ''! !!Model methodsFor: 'menus' stamp: 'sw 12/15/2000 13:21'!trash: ignored	"Whatever the user submits to the trash, it need not be saved."	^ true! !!Model methodsFor: 'keyboard' stamp: 'BG 10/29/2003 08:54'!arrowKey: aChar from: view	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	(#(1 4 11 12 30 31) includes: (keyEvent _ aChar asciiValue)) ifFalse:		[			^ self].     oldSelection := view getCurrentSelectionIndex.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[self okToChange			ifTrue:				[view changeModelSelection: nextSelection.				"view controller moveMarker"]]			! !!Model methodsFor: 'copying' stamp: 'tk 10/21/2002 12:59'!veryDeepFixupWith: deepCopier 	"See if the dependents are being copied also.  If so, point at the new copies.  (The dependent has self as its model.)	Dependents handled in class Object, when the model is not a Model, are fixed up in Object veryDeepCopy."	| originalDependents refs newDependent |	super veryDeepFixupWith: deepCopier.	originalDependents _ dependents.	originalDependents ifNil: [		^self.		].	dependents _ nil.	refs _ deepCopier references.	originalDependents		do: [:originalDependent | 			newDependent _ refs						at: originalDependent						ifAbsent: [].			newDependent				ifNotNil: [self addDependent: newDependent]]!]style[(29 206 19 395)f1b,f1,f1LObject veryDeepCopy;,f1! !!Model methodsFor: 'copying' stamp: 'RB 9/20/2001 16:25'!veryDeepInner: deepCopier	"Shallow copy dependents and fix them later"! !ModifiedEvent subclass: #ModifiedClassDefinitionEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:30'!classVarNames	^ item classVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:29'!instVarNames	^ item instVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:30'!oldClassVarNames	^ oldItem classVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:29'!oldInstVarNames	^ oldItem instVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:31'!oldSharedPools	^ oldItem sharedPools! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:31'!sharedPools	^ item sharedPools! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:28'!superclass	^ item superclass! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/26/2004 09:33'!anyChanges	^ self isSuperclassModified or: [self areInstVarsModified or: [self areClassVarsModified or: [self areSharedPoolsModified]]]! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:31'!areClassVarsModified	^ self classVarNames ~= self oldClassVarNames! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:30'!areInstVarsModified	^ self instVarNames ~= self oldInstVarNames! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:32'!areSharedPoolsModified	^ self sharedPools ~= self oldSharedPools! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:29'!isSuperclassModified	^ item superclass ~~ oldItem superclass! !!ModifiedClassDefinitionEvent methodsFor: 'printing' stamp: 'NS 1/21/2004 09:25'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' Super: ';		print: self isSuperclassModified;		nextPutAll: ' InstVars: ';		print: self areInstVarsModified;		nextPutAll: ' ClassVars: ';		print: self areClassVarsModified;		nextPutAll: ' SharedPools: ';		print: self areSharedPoolsModified.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ModifiedClassDefinitionEvent class	instanceVariableNames: ''!!ModifiedClassDefinitionEvent class methodsFor: 'instance creation' stamp: 'NS 1/20/2004 11:52'!classDefinitionChangedFrom: oldClass to: newClass	| instance |	instance := self item: newClass kind: self classKind.	instance oldItem: oldClass.	^instance! !!ModifiedClassDefinitionEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:26'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind! !AbstractEvent subclass: #ModifiedEvent	instanceVariableNames: 'oldItem'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!ModifiedEvent methodsFor: 'testing' stamp: 'NS 1/19/2004 15:09'!isModified	^true! !!ModifiedEvent methodsFor: 'printing' stamp: 'NS 1/19/2004 15:10'!printEventKindOn: aStream	aStream nextPutAll: 'Modified'! !!ModifiedEvent methodsFor: 'printing' stamp: 'NS 1/19/2004 17:57'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' oldItem: ';		print: oldItem.! !!ModifiedEvent methodsFor: 'accessing' stamp: 'NS 1/19/2004 15:08'!oldItem	^ oldItem! !!ModifiedEvent methodsFor: 'private-accessing' stamp: 'NS 1/19/2004 15:08'!oldItem: anItem	oldItem _ anItem! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ModifiedEvent class	instanceVariableNames: ''!!ModifiedEvent class methodsFor: 'accessing' stamp: 'NS 1/19/2004 15:10'!changeKind	^#Modified! !!ModifiedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:25'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self methodKind with: self categoryKind with: self protocolKind! !!ModifiedEvent class methodsFor: 'instance creation' stamp: 'NS 1/20/2004 19:37'!classDefinitionChangedFrom: oldClass to: newClass	^ ModifiedClassDefinitionEvent classDefinitionChangedFrom: oldClass to: newClass! !!ModifiedEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 11:40'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor	| instance |	instance := self method: newMethod selector: aSymbol class: aClass requestor: requestor.	instance oldItem: oldMethod.	^ instance! !Timespan subclass: #Month	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!Month commentStamp: 'brp 5/13/2003 09:48' prior: 0!I represent a month.!!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:04'!asMonth	^ self
! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!daysInMonth	^ self duration days.! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!index	^ self monthIndex
! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!name
	^ self monthName
! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!printOn: aStream
	aStream nextPutAll: self monthName, ' ', self year printString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Month class	instanceVariableNames: ''!!Month class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:22'!month: month year: year	"Create a Month for the given <year> and <month>.	<month> may be a number or a String with the	name of the month. <year> should be with 4 digits."	^ self starting: (DateAndTime year: year month: month day: 1)! !!Month class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:21'!readFrom: aStream	| m y c |
	m _ (ReadWriteStream with: '') reset.
	[(c _ aStream next) isSeparator] whileFalse: [m nextPut: c].
	[(c _ aStream next) isSeparator] whileTrue.
	y _ (ReadWriteStream with: '') reset.
	y nextPut: c.
	[aStream atEnd] whileFalse: [y nextPut: aStream next].
	^ self 		month: m contents		year: y contents"Month readFrom: 'July 1998' readStream"! !!Month class methodsFor: 'squeak protocol' stamp: 'brp 7/1/2003 13:59'!starting: aDateAndTime duration: aDuration 	"Override - a each month has a defined duration"	| start adjusted days |	start _ aDateAndTime asDateAndTime.	adjusted _ DateAndTime				year: start year				month: start month				day: 1.	days _ self daysInMonth: adjusted month forYear: adjusted year.	^ super		starting: adjusted		duration: (Duration days: days)! !!Month class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:27'!daysInMonth: indexOrName forYear: yearInteger 	| index |	index _ indexOrName isInteger 				ifTrue: [indexOrName]				ifFalse: [self indexOfMonth: indexOrName].	^ (DaysInMonth at: index)			+ ((index = 2					and: [Year isLeapYear: yearInteger])						ifTrue: [1] ifFalse: [0])! !!Month class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 09:29'!indexOfMonth: aMonthName
	1 to: 12 do: [ :i |  (aMonthName, '*' match: (MonthNames at: i)) ifTrue: [^i] ].
	self error: aMonthName , ' is not a recognized month name'.! !!Month class methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 09:02'!nameOfMonth: anIndex	^ MonthNames at: anIndex.! !Controller subclass: #MouseMenuController	instanceVariableNames: 'redButtonMenu redButtonMessages'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!MouseMenuController commentStamp: '<historical>' prior: 0!I am a Controller that modifies the scheduling of user activities so that the three mouse buttons can be used to make selections or display menus. The menu items are unary messages to the value of sending my instance the message menuMessageReceiver.!!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!release	super release.	redButtonMenu release! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!reset	"Eliminate references to all mouse button menus."	redButtonMenu _ nil.	redButtonMessages _ nil! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:28'!controlActivity	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint _ sensor cursorPoint.	super controlActivity.	(cursorPoint = sensor cursorPoint and: [self viewHasCursor])		ifTrue: 			[sensor redButtonPressed ifTrue: [^ self redButtonActivity].			sensor yellowButtonPressed ifTrue: [^ self yellowButtonActivity].			sensor blueButtonPressed ifTrue: [^ self blueButtonActivity]]! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 11:24'!isControlActive 	"In contrast to class Controller, only blue button but not yellow button	events will end the receiver's control loop."	^ self viewHasCursor and: [sensor blueButtonPressed not]! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu _ aSystemMenu.	redButtonMessages _ anArray! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 15:01'!blueButtonActivity	"This normally opens the window menu. It is a no-op here	as only the StandardSystemController deals with that kind	of menus."! !!MouseMenuController methodsFor: 'menu messages'!performMenuMessage: aSelector	"Perform a menu command by sending self the message aSelector.	 Default does nothing special."	^self perform: aSelector! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:56'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self perform: (redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:59'!yellowButtonActivity	"This normally opens a popup menu. Determine the selected	item and, if one is selected, then send the corresponding message	to either the model or the receiver."	^ self pluggableYellowButtonActivity: sensor leftShiftDown! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:36'!getPluggableYellowButtonMenu: shiftKeyState	^ view getMenu: shiftKeyState! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sw 2/17/2002 04:35'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu |	(menu _ self getPluggableYellowButtonMenu: shiftKeyState)		ifNil:			[sensor waitNoButton]		ifNotNil:			[self terminateAndInitializeAround:				[menu invokeOn: model orSendTo: self]]! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sw 3/22/2001 12:03'!shiftedTextPaneMenuRequest	"The user chose the more... branch from the text-pane menu."	^ self pluggableYellowButtonActivity: true! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!shiftedYellowButtonActivity	"Invoke the model's special popup menu."	^ self pluggableYellowButtonActivity: true! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!unshiftedYellowButtonActivity	"Invoke the model's normal popup menu."	^ self pluggableYellowButtonActivity: false! !Controller subclass: #NoController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Framework'!!NoController commentStamp: '<historical>' prior: 0!I represent a controller that never wants control. I am the controller for views that are non-interactive.!!NoController methodsFor: 'basic control sequence'!startUp	"I do nothing."	^self! !!NoController methodsFor: 'control defaults'!isControlActive 	"Refer to the comment in Controller|isControlActive."	^false! !!NoController methodsFor: 'control defaults'!isControlWanted 	"Refer to the comment in Controller|isControlWanted."	^false! !Error subclass: #NonBooleanReceiver	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!NonBooleanReceiver methodsFor: 'accessing' stamp: 'hmm 7/29/2001 21:30'!object	^object! !!NonBooleanReceiver methodsFor: 'accessing' stamp: 'hmm 7/29/2001 21:30'!object: anObject	object _ anObject! !!NonBooleanReceiver methodsFor: 'signaledException' stamp: 'hmm 7/29/2001 21:37'!isResumable	^true! !Exception subclass: #Notification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!Notification commentStamp: '<historical>' prior: 0!A Notification is an indication that something interesting has occurred.  If it is not handled, it will pass by without effect.!!Notification methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 15:04'!defaultAction	"No action is taken. The value nil is returned as the value of the message that signaled the exception."	^nil! !!Notification methodsFor: 'exceptionDescription' stamp: 'tfei 6/4/1999 18:17'!isResumable	"Answer true. Notification exceptions by default are specified to be resumable."	^true! !Magnitude subclass: #Number	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Number commentStamp: '<historical>' prior: 0!Class Number holds the most general methods for dealing with numbers. Subclasses Float, Fraction, and Integer, and their subclasses, provide concrete representations of a numeric quantity.All of Number's subclasses participate in a simple type coercion mechanism that supports mixed-mode arithmetic and comparisons.  It works as follows:  If	self<typeA> op: arg<typeB>fails because of incompatible types, then it is retried in the following guise:	(arg adaptTypeA: self) op: arg adaptToTypeA.This gives the arg of typeB an opportunity to resolve the incompatibility, knowing exactly what two types are involved.  If self is more general, then arg will be converted, and viceVersa.  This mechanism is extensible to any new number classes that one might wish to add to Squeak.  The only requirement is that every subclass of Number must support a pair of conversion methods specific to each of the other subclasses of Number.!!Number methodsFor: 'arithmetic'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!+ aNumber 	"Answer the sum of the receiver and aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!- aNumber 	"Answer the difference between the receiver and aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!/ aNumber 	"Answer the result of dividing the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!// aNumber 	"Integer quotient defined by division with truncation toward negative 	infinity. 9//4 = 2, -9//4 = -3. -0.9//0.4 = -3. \\ answers the remainder 	from this division."	^(self / aNumber) floor! !!Number methodsFor: 'arithmetic'!\\ aNumber 	"modulo. Remainder defined in terms of //. Answer a Number with the 	same sign as aNumber. e.g. 9\\4 = 1, -9\\4 = 3, 9\\-4 = -3, 0.9\\0.4 = 0.1."	^self - (self // aNumber * aNumber)! !!Number methodsFor: 'arithmetic'!abs	"Answer a Number that is the absolute value (positive magnitude) of the 	receiver."	self < 0		ifTrue: [^self negated]		ifFalse: [^self]! !!Number methodsFor: 'arithmetic'!negated	"Answer a Number that is the negation of the receiver."	^0 - self! !!Number methodsFor: 'arithmetic'!quo: aNumber 	"Integer quotient defined by division with truncation toward zero. -9 quo: 	4 = -2, -0.9 quo: 0.4 = -2. rem: answers the remainder from this division."	^(self / aNumber) truncated! !!Number methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	"Answer 1 divided by the receiver. Create an error notification if the 	receiver is 0."	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	self = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	^ 1 / self! !!Number methodsFor: 'arithmetic'!rem: aNumber 	"Remainder defined in terms of quo:. Answer a Number with the same 	sign as self. e.g. 9 rem: 4 = 1, -9 rem: 4 = -1. 0.9 rem: 0.4 = 0.1."	^self - ((self quo: aNumber) * aNumber)! !!Number methodsFor: 'mathematical functions'!arcCos 	"The receiver is the cosine of an angle. Answer the angle measured in 	radians."	^self asFloat arcCos! !!Number methodsFor: 'mathematical functions'!arcSin	"The receiver is the sine of an angle. Answer the angle measured in 	radians."	^self asFloat arcSin! !!Number methodsFor: 'mathematical functions'!arcTan	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^self asFloat arcTan! !!Number methodsFor: 'mathematical functions' stamp: 'jsp 2/24/1999 15:20'!arcTan: denominator	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^(self asFloat) arcTan: denominator.! !!Number methodsFor: 'mathematical functions'!cos	"The receiver represents an angle measured in radians. Answer its cosine."	^self asFloat cos! !!Number methodsFor: 'mathematical functions' stamp: 'sd 3/5/2004 10:04'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."		^ (90 + self) degreeSin! !!Number methodsFor: 'mathematical functions' stamp: 'sd 3/5/2004 10:04'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."		^ self asFloat degreesToRadians sin! !!Number methodsFor: 'mathematical functions'!exp	"Answer the exponential of the receiver as a floating point number."	^self asFloat exp! !!Number methodsFor: 'mathematical functions' stamp: 'jm 3/27/98 06:16'!floorLog: radix	"Answer the floor of the log base radix of the receiver."	^ self asFloat floorLog: radix! !!Number methodsFor: 'mathematical functions' stamp: 'ar 8/31/2000 20:05'!interpolateTo: aNumber at: param	^self + (aNumber - self * param)! !!Number methodsFor: 'mathematical functions'!ln	"Answer the natural log of the receiver."	^self asFloat ln! !!Number methodsFor: 'mathematical functions' stamp: 'di 9/8/1998 17:10'!log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'mathematical functions'!log: aNumber 	"Answer the log base aNumber of the receiver."	^self ln / aNumber ln! !!Number methodsFor: 'mathematical functions' stamp: 'RJ 3/15/1999 19:35'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].	self < 0 ifTrue:		[ self error: self printString, ' raised to a non-integer power' ].	aNumber = 0 ifTrue: [^ 1].		"Special case of exponent=0"	(self = 0) | (aNumber = 1) ifTrue:		[^ self].						"Special case of exponent=1"	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Number methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49'!raisedToInteger: operand 	"Answer the receiver raised to the power operand, an Integer."	| count result |	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	operand isInteger ifFalse: [^ ArithmeticError signal: 'parameter is not an Integer'"<- Chg"].	operand = 0 ifTrue: [^ self class one].	operand = 1 ifTrue: [^ self].	operand < 0 ifTrue: [^ (self raisedToInteger: operand negated) reciprocal].	count := 1.	[(count := count + count) < operand] whileTrue.	result := self class one.	[count > 0]		whileTrue: 			[result := result * result.			(operand bitAnd: count)				= 0 ifFalse: [result := result * self].			count := count bitShift: -1].	^ result! !!Number methodsFor: 'mathematical functions'!sin	"The receiver represents an angle measured in radians. Answer its sine."	^self asFloat sin! !!Number methodsFor: 'mathematical functions'!sqrt	"Answer the square root of the receiver."	^self asFloat sqrt! !!Number methodsFor: 'mathematical functions'!squared	"Answer the receiver multipled by itself."	^self * self! !!Number methodsFor: 'mathematical functions'!tan	"The receiver represents an angle measured in radians. Answer its 	tangent."	^self asFloat tan! !!Number methodsFor: 'truncation and round off'!ceiling	"Answer the integer nearest the receiver toward positive infinity."	self <= 0.0		ifTrue: [^self truncated]		ifFalse: [^self negated floor negated]! !!Number methodsFor: 'truncation and round off' stamp: 'di 2/19/98 21:58'!detentBy: detent atMultiplesOf: grid snap: snap	"Map all values that are within detent/2 of any multiple of grid to that multiple.  Otherwise, if snap is true, return self, meaning that the values in the dead zone will never be returned.  If snap is false, then expand the range between dead zones so that it covers the range between multiples of the grid, and scale the value by that factor."	| r1 r2 |	r1 _ self roundTo: grid.  "Nearest multiple of grid"	(self roundTo: detent) = r1 ifTrue: [^ r1].  "Snap to that multiple..."	snap ifTrue: [^ self].  "...or return self"	r2 _ self < r1  "Nearest end of dead zone"		ifTrue: [r1 - (detent asFloat/2)]		ifFalse: [r1 + (detent asFloat/2)].	"Scale values between dead zones to fill range between multiples"	^ r1 + ((self - r2) * grid asFloat / (grid - detent))"	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: true] 	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: false]	(3.9 to: 4.1 by: 0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: true] 	(-3.9 to: -4.1 by: -0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: false]"! !!Number methodsFor: 'truncation and round off'!floor	"Answer the integer nearest the receiver toward negative infinity."	| truncation |	truncation _ self truncated.	self >= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation - 1]! !!Number methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!fractionPart	"Answer the fractional part of the receiver."	#Numeric.	"2000/03/04  Harmon R. Added ANSI <number> protocol"	^ self - self truncated! !!Number methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!integerPart	"Answer the integer part of the receiver."	#Numeric.	"2000/03/04  Harmon R. Added ANSI <number> protocol"	^ self truncated! !!Number methodsFor: 'truncation and round off'!reduce    "If self is close to an integer, return that integer"    ^ self! !!Number methodsFor: 'truncation and round off' stamp: 'di 10/4/1999 08:08'!roundTo: quantum 	"Answer the nearest number that is a multiple of quantum."	^(self / quantum) rounded * quantum! !!Number methodsFor: 'truncation and round off'!roundUpTo: aNumber 	"Answer the next multiple of aNumber toward infinity that is nearest the 	receiver."	^(self/aNumber) ceiling * aNumber! !!Number methodsFor: 'truncation and round off'!rounded	"Answer the integer nearest the receiver."	^(self + (self sign / 2)) truncated! !!Number methodsFor: 'truncation and round off'!truncateTo: aNumber 	"Answer the next multiple of aNumber toward zero that is nearest the 	receiver."	^(self quo: aNumber)		* aNumber! !!Number methodsFor: 'truncation and round off'!truncated	"Answer an integer nearest the receiver toward zero."	^self quo: 1! !!Number methodsFor: 'testing' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Number! !!Number methodsFor: 'testing'!even	"Answer whether the receiver is an even number."	^self \\ 2 = 0! !!Number methodsFor: 'testing' stamp: 'sw 12/30/1998 13:21'!isDivisibleBy: aNumber	aNumber = 0 ifTrue: [^ false].	aNumber isInteger ifFalse: [^ false].	^ (self \\ aNumber) = 0! !!Number methodsFor: 'testing' stamp: 'tao 10/10/97 16:36'!isInf	^ false! !!Number methodsFor: 'testing' stamp: 'tao 4/19/98 23:33'!isInfinite	^ false! !!Number methodsFor: 'testing' stamp: 'tao 10/10/97 16:36'!isNaN	^ false! !!Number methodsFor: 'testing'!isNumber	^ true! !!Number methodsFor: 'testing'!isZero	^self = 0! !!Number methodsFor: 'testing' stamp: 'di 4/23/1998 11:18'!negative	"Answer whether the receiver is mathematically negative."	^ self < 0! !!Number methodsFor: 'testing'!odd	"Answer whether the receiver is an odd number."	^self even == false! !!Number methodsFor: 'testing' stamp: 'di 4/23/1998 11:17'!positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ self >= 0! !!Number methodsFor: 'testing'!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self > 0 ifTrue: [^1].	self < 0 ifTrue: [^-1].	^0! !!Number methodsFor: 'testing' stamp: 'di 4/23/1998 11:02'!strictlyPositive	"Answer whether the receiver is mathematically positive."	^ self > 0! !!Number methodsFor: 'converting'!@ y 	"Primitive. Answer a Point whose x value is the receiver and whose y 	value is the argument. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 18>	^Point x: self y: y! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:21'!adaptToFloat: rcvr andSend: selector 	"If I am involved in arithmetic with a Float, convert me to a Float."	^ rcvr perform: selector with: self asFloat! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: self@self! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Do any required conversion and then the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Number methodsFor: 'converting' stamp: 'brp 5/13/2003 10:13'!asDuration

	^ Duration nanoSeconds: self asInteger
! !!Number methodsFor: 'converting'!asInteger	"Answer an Integer nearest the receiver toward zero."	^self truncated! !!Number methodsFor: 'converting' stamp: 'sw 2/16/1999 18:15'!asNumber	^ self! !!Number methodsFor: 'converting'!asPoint	"Answer a Point with the receiver as both coordinates; often used to 	supply the same value in two dimensions, as with symmetrical gridding 	or scaling."	^self @ self! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scale 	"Answer a scaled decimal number, with a fractional precision of scale, 	approximating the receiver."	#Numeric.	"add 200/01/19 For number protocol."	^ ScaledDecimal newFromNumber: self scale: scale! !!Number methodsFor: 'converting' stamp: 'sw 9/8/97 16:30'!asSmallAngleDegrees	"Return the receiver normalized to lie within the range (-180, 180)"	| pos |	pos _ self \\ 360.	pos > 180 ifTrue: [pos _ pos - 360].	^ pos"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]"! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:12'!day

	^ self sign days! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!days

	^ Duration days: self! !!Number methodsFor: 'converting'!degreesToRadians	"The receiver is assumed to represent degrees. Answer the conversion to 	radians."	^self asFloat degreesToRadians! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:28'!hour

	^ self sign hours
! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!hours

	^ Duration hours: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:16'!minute

	^ self sign minutes
! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!minutes

	^ Duration minutes: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:27'!nanoSecond

	^ self sign nanoSeconds
! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 08:52'!nanoSeconds

	^ Duration nanoSeconds: self.! !!Number methodsFor: 'converting'!radiansToDegrees	"The receiver is assumed to represent radians. Answer the conversion to 	degrees."	^self asFloat radiansToDegrees! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:17'!second

	^ self sign seconds
! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:57'!seconds

	^ Duration seconds: self! !!Number methodsFor: 'converting' stamp: 'brp 5/21/2003 08:20'!sign: aNumber
	"Return a Number with the same sign as aNumber"

	^ aNumber positive ifTrue: [self abs] ifFalse: [self abs negated].! !!Number methodsFor: 'intervals'!to: stop	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by 1."	^Interval from: self to: stop by: 1! !!Number methodsFor: 'intervals'!to: stop by: step	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by step."	^Interval from: self to: stop by: step! !!Number methodsFor: 'intervals' stamp: 'tao 1/30/1999 08:58'!to: stop by: step do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: step)."	| nextValue |	nextValue _ self.	step = 0 ifTrue: [self error: 'step must be non-zero'].	step < 0		ifTrue: [[stop <= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue _ nextValue + step]]		ifFalse: [[stop >= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue _ nextValue + step]]! !!Number methodsFor: 'intervals'!to: stop do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: 1)."	| nextValue |	nextValue _ self.	[nextValue <= stop]		whileTrue: 			[aBlock value: nextValue.			nextValue _ nextValue + 1]! !!Number methodsFor: 'printing'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ super defaultLabelForInspector, ': ', self printString! !!Number methodsFor: 'printing' stamp: 'sw 6/29/1999 21:10'!isOrAreStringWith: aNoun	| result |	result _ self = 1		ifTrue:			[' is one ']		ifFalse:			[self = 0				ifTrue:					[' are no ']				ifFalse:					[' are ', self printString, ' ']].	result _ result, aNoun.	self = 1 ifFalse: [result _ result, 's'].	^ result"#(0 1 2 98.6) do:	[:num | Transcript cr; show: 'There', (num isOrAreStringWith: 'way'), ' to skin a cat']"! !!Number methodsFor: 'printing'!printOn: aStream	"Default print radix is 10"	self printOn: aStream base: 10! !!Number methodsFor: 'printing'!printStringBase: base	^ String streamContents:		[:strm | self printOn: strm base: base]! !!Number methodsFor: 'printing'!storeOn: aStream 	"Normal printing is OK for storing"	self printOn: aStream! !!Number methodsFor: 'printing'!storeOn: aStream base: base	"Append my printed representation to aStream, incuding the base."	self printOn: aStream base: base! !!Number methodsFor: 'printing'!storeStringBase: base	^ String streamContents: [:strm | self storeOn: strm base: base]! !!Number methodsFor: 'printing' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!Number methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:26'!closeTo: num	"are these two numbers close?"	| ans |	num isFloat ifTrue: [^ num closeTo: self asFloat].	[ans _ self = num] ifError: [:aString :aReceiver | ^ false].	^ ans! !!Number methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:07'!byteEncode:aStream	^aStream writeNumber:self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Number class	instanceVariableNames: ''!!Number class methodsFor: 'instance creation' stamp: 'bf 12/9/1998 19:21'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base _ 10.	value _ Integer readFrom: aStream base: base.	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base _ value) < 2 ifTrue: [^self error: 'Invalid radix'].			(aStream peekFor: $-) ifTrue: [sign _ sign negated].			value _ Integer readFrom: aStream base: base].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !!Number class methodsFor: 'instance creation' stamp: 'tao 4/23/98 12:24'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base."	| aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	^ self readRemainderOf: (Integer readFrom: aStream base: base)			from: aStream base: base withSign: sign! !!Number class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!readRemainderOf: integerPart from: aStream base: base withSign: sign 	"Read optional fractional part and exponent, and return the final result"	| value fraction fractionDigits fracpos peekChar scale |	#Numeric.	"Changed 200/01/19 For ANSI Numeric Literals support."	value := integerPart.	fractionDigits := 0.	(aStream peekFor: $.)		ifTrue: ["<integer>.<fraction>"			(aStream atEnd not and: [aStream peek digitValue between: 0 and: base - 1])				ifTrue: 					[fracpos := aStream position.					fraction := Integer readFrom: aStream base: base.					fraction := fraction asFloat / (base raisedTo: aStream position - fracpos).					fractionDigits := aStream position - fracpos.					value := value asFloat + fraction]				ifFalse: 					["oops - just <integer>."					aStream skip: -1.					"un-gobble the period"					^ value * sign"Number readFrom: '3r-22.2'"]].	peekChar := aStream peek.	"<number>(e|d|q)<exponent>>"	peekChar = $e | (peekChar = $d) | (peekChar = $q)		ifTrue: 			[aStream next.			value := value * (base raisedTo: (Integer readFrom: aStream))]		ifFalse: [peekChar = $s				ifTrue: 					["<number>s[<scale>]"					aStream next.					(aStream atEnd not and: ["<number>s<scale>"						aStream peek digitValue between: 0 and: 10])						ifTrue: [scale := Integer readFrom: aStream].					scale isNil						ifTrue: ["<number>s"							fractionDigits = 0								ifTrue: ["<integer>s"									scale := 0]								ifFalse: ["<integer>.<fraction>s"									scale := fractionDigits]].					value := ScaledDecimal newFromNumber: value scale: scale]].	(value isFloat		and: [value = 0.0 and: [sign = -1]])		ifTrue: [^ Float negativeZero]		ifFalse: [^ value * sign]! !ProtoObject subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields'	poolDictionaries: ''	category: 'Kernel-Objects'!!Object commentStamp: '<historical>' prior: 0!Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.Class Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.Class Variables:	DependentsFields		an IdentityDictionary		Provides a virtual 'dependents' field so that any object may have one		or more dependent views, synchronized by the changed:/update: protocol.		Note that class Model has a real slot for its dependents, and overrides		the associated protocol with more efficient implementations.	EventsFields			an IdentityDictionary that maps each object to its dependents.		Registers a message send (consisting of a selector and a receiver object)		which should be performed when anEventSymbol is triggered by the receiver.		Part of a new event notification framework which could eventually replace		the existing changed/update mechanism.  It is intended to be compatible		with Dolphin Smalltalk and VSE as much as possible.Because Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.!!Object methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:18'!addInstanceVarNamed: aName withValue: aValue	"Add an instance variable named aName and give it value aValue"	self class addInstVarName: aName asString.	self instVarAt: self class instSize put: aValue! !!Object methodsFor: 'accessing' stamp: 'yo 6/29/2004 11:39'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!at: index modify: aBlock	"Replace the element of the collection with itself transformed by the block"	^ self at: index put: (aBlock value: (self at: index))! !!Object methodsFor: 'accessing' stamp: 'yo 6/29/2004 13:08'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicAt: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicAt: index put: value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0	! !!Object methodsFor: 'accessing'!bindWithTemp: aBlock	^ aBlock value: self value: nil! !!Object methodsFor: 'accessing' stamp: 'md 12/12/2003 16:25'!doIfNotNil: aBlock	self deprecated: 'use ifNotNilDo:'.	^ self ifNotNilDo: aBlock! !!Object methodsFor: 'accessing' stamp: 'di 11/8/2000 21:04'!ifNotNilDo: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'ajh 1/21/2003 12:59'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'sw 10/17/2000 11:15'!presenter	"Answer the presenter object associated with the receiver.  For morphs, there is in effect a clear containment hierarchy of presenters (accessed via their association with PasteUpMorphs); for arbitrary objects the hook is simply via the current world, at least at present."	^ self currentWorld presenter! !!Object methodsFor: 'accessing'!readFromString: aString	"Create an object based on the contents of aString."	^self readFrom: (ReadStream on: aString)! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 13:10'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self class isVariable ifFalse: [self errorNotIndexable].	^ 0! !!Object methodsFor: 'accessing'!yourself	"Answer self."! !!Object methodsFor: 'associating'!-> anObject	"Answer an Association between self and anObject"	^Association new key: self value: anObject! !!Object methodsFor: 'binding'!bindingOf: aString	^nil! !!Object methodsFor: 'casing'!caseOf: aBlockAssociationCollection	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, report an error."	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]"| z | z _ {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""| z | z _ {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"! !!Object methodsFor: 'casing'!caseOf: aBlockAssociationCollection otherwise: aBlock	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z _ {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z _ {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: 'class membership'!class	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!Object methodsFor: 'class membership' stamp: 'sw 9/27/2001 15:51'!inheritsFromAnyIn: aList	"Answer whether the receiver inherits from any class represented by any element in the list.  The elements of the list can be classes, class name symbols, or strings representing possible class names.  This allows speculative membership tests to be made even when some of the classes may not be known to the current image, and even when their names are not interned symbols."	| aClass |	aList do:		[:elem | Symbol hasInterned: elem asString ifTrue: 			[:elemSymbol | (((aClass _ Smalltalk at: elemSymbol ifAbsent: [nil]) isKindOf: Class)						and: [self isKindOf: aClass])				ifTrue:					[^ true]]].	^ false"{3.  true. 'olive'} do:	[:token |		 {{#Number. #Boolean}. {Number.  Boolean }.  {'Number'. 'Boolean'}} do:			[:list |				Transcript cr; show: token asString, ' list element provided as a ', list first class name, ' - ', (token inheritsFromAnyIn: list) asString]]"! !!Object methodsFor: 'class membership'!isKindOf: aClass 	"Answer whether the class, aClass, is a superclass or class of the receiver."	self class == aClass		ifTrue: [^true]		ifFalse: [^self class inheritsFrom: aClass]! !!Object methodsFor: 'class membership' stamp: 'sw 2/16/98 02:08'!isKindOf: aClass orOf: anotherClass	"Answer whether either of the classes, aClass or anotherClass,, is a superclass or class of the receiver.  A convenience; could be somewhat optimized"	^ (self isKindOf: aClass) or: [self isKindOf: anotherClass]! !!Object methodsFor: 'class membership'!isMemberOf: aClass 	"Answer whether the receiver is an instance of the class, aClass."	^self class == aClass! !!Object methodsFor: 'class membership'!respondsTo: aSymbol 	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector."	^self class canUnderstand: aSymbol! !!Object methodsFor: 'class membership' stamp: 'tk 10/21/1998 12:38'!xxxClass	"For subclasses of nil, such as ObjectOut"	^ self class! !!Object methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^self == anObject! !!Object methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:26'!closeTo: anObject	"Answer whether the receiver and the argument represent the same	object. If = is redefined in any subclass, consider also redefining the	message hash."	| ans |	[ans _ self = anObject] ifError: [:aString :aReceiver | ^ false].	^ ans! !!Object methodsFor: 'comparing'!hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash! !!Object methodsFor: 'comparing' stamp: 'pm 9/23/97 09:36'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Object methodsFor: 'comparing' stamp: 'di 9/27/97 20:23'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Object methodsFor: 'comparing' stamp: 'sw 8/20/1998 12:34'!identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'comparing' stamp: 'ajh 2/2/2002 15:02'!literalEqual: other	^ self class == other class and: [self = other]! !!Object methodsFor: 'comparing'!~= anObject 	"Answer whether the receiver and the argument do not represent the 	same object."	^self = anObject == false! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToFloat: rcvr andSend: selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:14'!adaptToFraction: rcvr andSend: selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToInteger: rcvr andSend: selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting'!as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self! !!Object methodsFor: 'converting' stamp: 'rw 4/27/2002 07:48'!asActionSequence	^WeakActionSequence with: self! !!Object methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors with: self! !!Object methodsFor: 'converting' stamp: 'sma 5/12/2000 17:39'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!Object methodsFor: 'converting'!asString	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'ajh 3/11/2003 10:27'!asStringOrText	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'RAA 8/2/1999 12:41'!complexContents	^self! !!Object methodsFor: 'converting' stamp: 'ajh 7/6/2003 20:37'!mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM.  The sending context is rewound to just before the jump causing this exception."	^ self mustBeBooleanIn: thisContext sender! !!Object methodsFor: 'converting' stamp: 'ajh 7/6/2003 20:40'!mustBeBooleanIn: context	"context is the where the non-boolean error occurred. Rewind context to before jump then raise error."	| proceedValue |	context skipBackBeforeJump.	proceedValue _ NonBooleanReceiver new		object: self;		signal: 'proceed for truth.'.	^ proceedValue ~~ false! !!Object methodsFor: 'converting' stamp: 'sw 3/26/2001 12:12'!printDirectlyToDisplay	"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism."	self asString displayAt: 0@100"StringMorph someInstance printDirectlyToDisplay"! !!Object methodsFor: 'converting' stamp: 'RAA 3/31/1999 12:13'!withoutListWrapper	^self! !!Object methodsFor: 'copying'!clone	<primitive: 148>	self primitiveFailed! !!Object methodsFor: 'copying' stamp: 'ajh 8/18/2001 21:25'!copy	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy."	^self shallowCopy postCopy! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:01'!copyAddedStateFrom: anotherObject	"Copy over the values of instance variables added by the receiver's class from anotherObject to the receiver.  These will be remapped in mapUniClasses, if needed."	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Object methodsFor: 'copying' stamp: 'tpr 2/14/2004 21:53'!copyFrom: anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| mine his |	<primitive: 168>	mine _ self class allInstVarNames.	his _ anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: 'copying' stamp: 'ajh 5/23/2002 00:38'!copySameFrom: otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	| myInstVars otherInstVars match |	myInstVars _ self class allInstVarNames.	otherInstVars _ otherObject class allInstVarNames.	myInstVars doWithIndex: [:each :index |		(match _ otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]].	1 to: (self basicSize min: otherObject basicSize) do: [:i |		self basicAt: i put: (otherObject basicAt: i)].! !!Object methodsFor: 'copying' stamp: 'tk 4/20/1999 14:44'!copyTwoLevel	"one more level than a shallowCopy"	| newObject class index |	class _ self class.	newObject _ self clone.	newObject == self ifTrue: [^ self].	class isVariable		ifTrue: 			[index _ self basicSize.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) shallowCopy.					index _ index - 1]].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) shallowCopy.			index _ index - 1].	^newObject! !!Object methodsFor: 'copying'!deepCopy	"Answer a copy of the receiver with its own copy of each instance 	variable."	| newObject class index |	class _ self class.	(class == Object) ifTrue: [^self].	class isVariable		ifTrue: 			[index _ self basicSize.			newObject _ class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) deepCopy.					index _ index - 1]]		ifFalse: [newObject _ class basicNew].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.			index _ index - 1].	^newObject! !!Object methodsFor: 'copying' stamp: 'hg 11/23/1999 13:43'!initialDeepCopierSize	"default value is 4096; other classes may override this, esp. for smaller (=faster) sizes"	^4096! !!Object methodsFor: 'copying' stamp: 'ajh 1/27/2003 18:45'!postCopy	"self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"	^ self! !!Object methodsFor: 'copying' stamp: 'jm 11/14/97 11:08'!shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables."	| class newObject index |	<primitive: 148>	class _ self class.	class isVariable		ifTrue: 			[index _ self basicSize.			newObject _ class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index _ index - 1]]		ifFalse: [newObject _ class basicNew].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index _ index - 1].	^ newObject! !!Object methodsFor: 'copying' stamp: 'tk 5/13/2003 19:39'!veryDeepCopyUsing: copier	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy.	Same as veryDeepCopy except copier (with dictionary) is supplied.	** do not delete this method, even if it has no callers **"	| new refs newDep newModel |	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	"Fix dependents"	refs _ copier references.	DependentsFields associationsDo: [:pair |		pair value do: [:dep | 			(newDep _ refs at: dep ifAbsent: [nil]) ifNotNil: [				newModel _ refs at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].	^ new! !!Object methodsFor: 'copying' stamp: 'tk 3/11/2003 14:12'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new uc sup has mine |	deepCopier references at: self ifPresent: [:newer | ^ newer]. 	"already did him"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	(class isSystemDefined not and: [deepCopier newUniClasses "allowed"]) ifTrue: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [			deepCopier uniClasses at: class put: (uc _ self copyUniClassWith: deepCopier).			deepCopier references at: class put: uc].	"remember"		new _ uc new.		new copyFrom: self].	"copy inst vars in case any are weak"	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index _ self basicSize.		[index > 0] whileTrue: 			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index _ index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup _ class.  index _ class instSize.	[has _ sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	has _ has ifNil: [class isSystemDefined not "is a uniClass"] ifNotNil: [true].	mine _ sup instVarNames.	has ifTrue: [index _ index - mine size]	"skip inst vars"		ifFalse: [1 to: mine size do: [:xx |				sub _ self instVarAt: index.				(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [new instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: index put: subAss value].				index _ index - 1]].	(sup _ sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'copying' stamp: 'tk 1/6/1999 17:39'!veryDeepFixupWith: deepCopier	"I have no fields and no superclass.  Catch the super call."! !!Object methodsFor: 'copying' stamp: 'tk 9/4/2001 10:30'!veryDeepInner: deepCopier	"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:"! !!Object methodsFor: 'creation' stamp: 'sw 1/29/2002 21:43'!asMorph	"Open a morph, as best one can, on the receiver"	^ self asString asMorph	"234 asMorph(ScriptingSystem formAtKey: #TinyMenu) asMorph'fred' asMorph"! !!Object methodsFor: 'creation' stamp: 'sw 1/29/2002 21:45'!openAsMorph	"Open a morph, as best one can, on the receiver"	^ self asMorph openInHand"234 openAsMorph(ScriptingSystem formAtKey: #TinyMenu) openAsMorph'fred' openAsMorph"! !!Object methodsFor: 'dependents access' stamp: 'ar 2/11/2001 01:55'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents _ self dependents.	(dependents includes: anObject) ifFalse:		[self myDependents: (dependents copyWithDependent: anObject)].	^ anObject! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:53'!breakDependents	"Remove all of the receiver's dependents."	self myDependents: nil! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:26'!canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	self dependents		do: [:each | each canDiscardEdits ifFalse: [^ false]]		without: self.	^ true! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:58'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	^ self myDependents ifNil: [#()]! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:59'!hasUnacceptedEdits	"Answer true if any of the views on this object has unaccepted edits."	self dependents		do: [:each | each hasUnacceptedEdits ifTrue: [^ true]]		without: self.	^ false! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:55'!myDependents	"Private. Answer a list of all the receiver's dependents."	^ DependentsFields at: self ifAbsent: []! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:52'!myDependents: aCollectionOrNil	"Private. Set (or remove) the receiver's dependents list."	aCollectionOrNil		ifNil: [DependentsFields removeKey: self ifAbsent: []]		ifNotNil: [DependentsFields at: self put: aCollectionOrNil]! !!Object methodsFor: 'dependents access' stamp: 'reThink 2/18/2001 17:06'!release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self releaseActionMap! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 20:23'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents |	dependents _ self dependents reject: [:each | each == anObject].	self myDependents: (dependents isEmpty ifFalse: [dependents]).	^ anObject! !!Object methodsFor: 'deprecated' stamp: 'md 12/12/2003 17:02'!beep: soundName	"Make the given sound, unless the making of sound is disabled in Preferences."	self deprecated: 'Use SampledSound>>playSoundNamed: instead.'.	Preferences soundsEnabled		ifTrue: [self playSoundNamed: soundName]! !!Object methodsFor: 'deprecated' stamp: 'gk 2/24/2004 08:50'!beepPrimitive	"Deprecated. Beep in the absence of sound support."		self deprecated: 'Use Beeper class>>beep or Beeper class>>beepPrimitive instead.'.	Beeper beepPrimitive! !!Object methodsFor: 'drag and drop' stamp: 'bh 9/16/2001 18:10'!acceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph 		^false.! !!Object methodsFor: 'drag and drop' stamp: 'mir 5/16/2000 11:35'!dragAnimationFor: item transferMorph: transferMorph 	"Default do nothing"! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:20'!dragPassengerFor: item inMorph: dragSource 	^item! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:11'!dragTransferType	^nil! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:05'!dragTransferTypeForMorph: dragSource 	^nil! !!Object methodsFor: 'drag and drop' stamp: 'mir 5/8/2000 17:19'!wantsDroppedMorph: aMorph event: anEvent inMorph: destinationLM 	^false! !!Object methodsFor: 'error handling' stamp: 'sma 5/6/2000 19:35'!assert: aBlock	"Throw an assertion error if aBlock does not evaluates to true."	aBlock value ifFalse: [AssertionFailure signal: 'Assertion failed']! !!Object methodsFor: 'error handling'!caseError	"Report an error from an in-line or explicit case statement."	self error: 'Case not found, and no otherwise clause'! !!Object methodsFor: 'error handling' stamp: 'sma 5/28/2000 15:48'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ PopUpMenu confirm: queryString! !!Object methodsFor: 'error handling' stamp: 'sma 5/28/2000 15:55'!confirm: aString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	^ PopUpMenu confirm: aString orCancel: cancelBlock! !!Object methodsFor: 'error handling' stamp: 'dew 10/6/2003 18:20'!deprecated: anExplanationString	"Warn that the sending method has been deprecated."	Preferences showDeprecationWarnings ifTrue:		[Deprecation signal: thisContext sender printString, ' has been deprecated. ', anExplanationString]! !!Object methodsFor: 'error handling' stamp: 'dew 10/7/2003 00:26'!deprecated: anExplanationString block: aBlock 	 "Warn that the sender has been deprecated.  Answer the value of aBlock on resumption.  (Note that #deprecated: is usually the preferred method.)"	Preferences showDeprecationWarnings ifTrue:		[Deprecation			signal: thisContext sender printString, ' has been deprecated. ', anExplanationString].	^ aBlock value.! !!Object methodsFor: 'error handling' stamp: 'sd 11/13/2003 21:11'!deprecated: aBlock explanation: aString 	 "This method is OBSOLETE.  Use #deprecated:block: instead."	self deprecated: 'Use Object>>deprecated:block: instead of deprecated:explanation:.'.	Preferences showDeprecationWarnings ifTrue:		[Deprecation			signal: ('{1} has been deprecated. {2}' translated format: {thisContext sender printString. aString})].	^ aBlock value.! !!Object methodsFor: 'error handling' stamp: 'sd 11/13/2003 21:10'!deprecatedExplanation: aString     "This method is OBSOLETE.  Use #deprecated: instead."	self deprecated: 'Use Object>>deprecated: instead of deprecatedExplanation:.'.	Preferences showDeprecationWarnings ifTrue:		[Deprecation signal: ('{1} has been deprecated. {2}' translated format: {thisContext sender printString. aString})]! !!Object methodsFor: 'error handling' stamp: 'ajh 10/9/2001 17:21'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])		ifTrue: [^ aMessage sentTo: self].	^ MessageNotUnderstood new 		message: aMessage;		receiver: self;		signal! !!Object methodsFor: 'error handling' stamp: 'tfei 4/12/1999 12:55'!error: aString 	"Throw a generic Error exception."	^Error new signal: aString! !!Object methodsFor: 'error handling' stamp: 'ar 2/13/2001 20:49'!externalCallFailed	"A call to an external function has failed."	^(Smalltalk at: #ExternalFunction ifAbsent:[^self error: 'FFI not installed'])		externalCallFailed! !!Object methodsFor: 'error handling' stamp: 'tfei 4/12/1999 12:54'!halt	"This is the typical message to use for inserting breakpoints during 	debugging. It behaves like halt:, but does not call on halt: in order to 	avoid putting this message on the stack. Halt is especially useful when 	the breakpoint message is an arbitrary one."	Halt signal! !!Object methodsFor: 'error handling' stamp: 'tfei 4/12/1999 12:59'!halt: aString 	"This is the typical message to use for inserting breakpoints during 	debugging. It creates and schedules a Notifier with the argument, 	aString, as the label."		Halt new signal: aString! !!Object methodsFor: 'error handling' stamp: 'bf 9/27/1999 17:14'!handles: exception	"This method exists to break an endless loop in Exception>>findHandlerFrom: if the exceptionis invalid"	^false! !!Object methodsFor: 'error handling' stamp: 'hg 10/2/2001 20:49'!notify: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	Warning signal: aString	"nil notify: 'confirmation message'"! !!Object methodsFor: 'error handling'!notify: aString at: location	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed. Subclasses can	override this and insert an error message at location within aString."	self notify: aString	"nil notify: 'confirmation message' at: 12"! !!Object methodsFor: 'error handling' stamp: 'sw 5/23/2001 13:43'!notifyWithLabel: aString 	"Create and schedule a Notifier with aString as the window label as well as the contents of the window, in  order to request confirmation before a process can proceed."	Debugger		openContext: thisContext		label: aString		contents: aString	"nil notifyWithLabel: 'let us see if this works'"! !!Object methodsFor: 'error handling'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self error: 'a primitive has failed'! !!Object methodsFor: 'error handling' stamp: 'AFi 2/8/2003 22:52'!shouldBeImplemented	"Announce that this message should be implemented"	self error: 'This message should be implemented'! !!Object methodsFor: 'error handling'!shouldNotImplement	"Announce that, although the receiver inherits this message, it should 	not implement it."	self error: 'This message is not appropriate for this object'! !!Object methodsFor: 'error handling' stamp: 'ajh 9/7/2002 21:20'!subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	self error: 'My subclass should have overridden ', thisContext sender methodSelector printString! !!Object methodsFor: 'error handling' stamp: 'tk 6/18/2001 15:04'!tryToDefineVariableAccess: aMessage	"See if the message just wants to get at an instance variable of this class.  Ask the user if its OK.  If so, define the message to read or write that instance or class variable and retry."	| ask newMessage sel canDo classOrSuper |	aMessage arguments size > 1 ifTrue: [^ false].	sel _ aMessage selector asString.	"works for 0 args"	aMessage arguments size = 1 ifTrue: [		sel last = $: ifFalse: [^ false].		sel _ sel copyWithout: $:].	canDo _ false.  classOrSuper _ self class.	[((classOrSuper instVarNames includes: sel) 			ifTrue: [canDo _ true. nil]		ifFalse: [classOrSuper _ classOrSuper superclass]) == nil] whileFalse.	canDo ifFalse: [classOrSuper _ self class.		[((classOrSuper classVarNames includes: sel) 				ifTrue: [canDo _ true. nil]			ifFalse: [classOrSuper _ classOrSuper superclass]) == nil] whileFalse].	canDo ifFalse: [^ false].	ask _ self confirm: 'A ', thisContext sender sender receiver 		class printString, ' wants to ', 		(aMessage arguments size = 1 ifTrue: ['write into'] ifFalse: ['read from']), '', sel ,' in class ', classOrSuper printString, '.Define a this access message?'.	ask ifTrue: [		aMessage arguments size = 1 			ifTrue: [newMessage _ aMessage selector, ' anObject	', sel, ' _ anObject']			ifFalse: [newMessage _ aMessage selector, '	^', aMessage selector].		classOrSuper compile: newMessage classified: 'accessing' notifying: nil].	^ ask! !!Object methodsFor: 'evaluating' stamp: 'reThink 3/12/2001 18:14'!value	^self! !!Object methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 15:23'!valueWithArguments: aSequenceOfArguments	^self! !!Object methodsFor: 'events-accessing' stamp: 'nk 12/20/2002 17:48'!actionForEvent: anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^nil].	^ actions asMinimalRepresentation! !!Object methodsFor: 'events-accessing' stamp: 'nk 12/20/2002 17:48'!actionForEvent: anEventSelectorifAbsent: anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^anExceptionBlock value].	^ actions asMinimalRepresentation! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 14:43'!actionMap	^EventManager actionMapFor: self! !!Object methodsFor: 'events-accessing' stamp: 'rw 4/27/2002 08:35'!actionSequenceForEvent: anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequence new])            asActionSequence! !!Object methodsFor: 'events-accessing' stamp: 'SqR 6/28/2001 13:19'!actionsDo: aBlock	self actionMap do: aBlock! !!Object methodsFor: 'events-accessing' stamp: 'rw 2/10/2002 13:05'!createActionMap	^IdentityDictionary new! !!Object methodsFor: 'events-accessing' stamp: 'SqR 2/19/2001 14:04'!hasActionForEvent: anEventSelector    "Answer true if there is an action associated with anEventSelector"    ^(self actionForEvent: anEventSelector) notNil! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 15:29'!setActionSequence: actionSequenceforEvent: anEventSelector    | action |    action := actionSequence asMinimalRepresentation.    action == nil        ifTrue:            [self removeActionsForEvent: anEventSelector]        ifFalse:            [self updateableActionMap                at: anEventSelector asSymbol                put: action]! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/25/2001 08:50'!updateableActionMap	^EventManager updateableActionMapFor: self! !!Object methodsFor: 'events-registering' stamp: 'reThink 2/18/2001 15:04'!when: anEventSelector evaluate: anAction 	| actions |	actions := self actionSequenceForEvent: anEventSelector.	(actions includes: anAction)		ifTrue: [^ self].	self 		setActionSequence: (actions copyWith: anAction)		forEvent: anEventSelector! !!Object methodsFor: 'events-registering' stamp: 'rww 12/30/2002 10:37'!when: anEventSelectorsend: aMessageSelectorto: anObject     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: 'events-registering' stamp: 'rww 12/30/2002 10:37'!when: anEventSelectorsend: aMessageSelectorto: anObjectwith: anArg     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: 'events-registering' stamp: 'rww 12/30/2002 10:37'!when: anEventSelectorsend: aMessageSelectorto: anObjectwithArguments: anArgArray     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:33'!releaseActionMap	EventManager releaseActionMapFor: self! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:31'!removeAction: anActionforEvent: anEventSelector    self        removeActionsSatisfying: [:action | action = anAction]        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:33'!removeActionsForEvent: anEventSelector    | map |    map := self actionMap.    map removeKey: anEventSelector asSymbol ifAbsent: [].    map isEmpty        ifTrue: [self releaseActionMap]! !!Object methodsFor: 'events-removing' stamp: 'nk 8/25/2003 21:46'!removeActionsSatisfying: aBlock	self actionMap keys do:		[:eachEventSelector |			self   				removeActionsSatisfying: aBlock				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:31'!removeActionsSatisfying: aOneArgBlock forEvent: anEventSelector    self        setActionSequence:            ((self actionSequenceForEvent: anEventSelector)                reject: [:anAction | aOneArgBlock value: anAction])        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'rw 7/29/2003 17:18'!removeActionsWithReceiver: anObject	self actionMap copy keysDo:		[:eachEventSelector |			self   				removeActionsSatisfying: [:anAction | anAction receiver == anObject]				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:36'!removeActionsWithReceiver: anObjectforEvent: anEventSelector    self        removeActionsSatisfying:            [:anAction |            anAction receiver == anObject]        forEvent: anEventSelector! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 15:22'!triggerEvent: anEventSelector	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self actionForEvent: anEventSelector) value! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 17:09'!triggerEvent: anEventSelectorifNotHandled: anExceptionBlock	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value]) value! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 14:59'!triggerEvent: anEventSelectorwith: anObject    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 14:59'!triggerEvent: anEventSelectorwith: anObjectifNotHandled: anExceptionBlock    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)		ifNotHandled: anExceptionBlock! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 15:21'!triggerEvent: anEventSelectorwithArguments: anArgumentList    ^(self actionForEvent: anEventSelector)        valueWithArguments: anArgumentList! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 15:21'!triggerEvent: anEventSelectorwithArguments: anArgumentListifNotHandled: anExceptionBlock    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value])        valueWithArguments: anArgumentList! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:42'!byteEncode:aStream	self flattenOnStream:aStream.! !!Object methodsFor: 'filter streaming'!drawOnCanvas:aStream	self flattenOnStream:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:31'!elementSeparator	^nil.! !!Object methodsFor: 'filter streaming'!encodePostscriptOn:aStream	self byteEncode:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:07'!flattenOnStream:aStream	self writeOnFilterStream:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'mpw 6/22/1930 22:56'!fullDrawPostscriptOn:aStream	^aStream fullDraw:self.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:51'!printOnStream:aStream	self byteEncode:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:49'!putOn:aStream	^aStream nextPut:self.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:53'!storeOnStream:aStream	self printOnStream:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:06'!writeOnFilterStream:aStream	aStream writeObject:self.! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:26'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 5/19/2003 20:10'!finalizationRegistry	"Answer the finalization registry associated with the receiver."	^WeakRegistry default! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Object methodsFor: 'finalization' stamp: 'ar 5/19/2003 20:14'!toFinalizeSend: aSelector to: aFinalizer with: aResourceHandle	"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).	WARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].	self == aResourceHandle ifTrue:[self error: 'I cannot finalize myself'].	^self finalizationRegistry add: self executor:		(ObjectFinalizer new			receiver: aFinalizer			selector: aSelector			argument: aResourceHandle)! !!Object methodsFor: 'flagging' stamp: 'sw 8/4/97 16:49'!isThisEverCalled	^ self isThisEverCalled: thisContext sender printString! !!Object methodsFor: 'flagging'!isThisEverCalled: msg	"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached.  2/5/96 sw"	self halt: 'This is indeed called: ', msg printString! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:23'!logEntry	Transcript show: 'Entered ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:23'!logExecution	Transcript show: 'Executing ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:22'!logExit	Transcript show:  'Exited ', thisContext sender printString; cr.! !!Object methodsFor: 'macpal' stamp: 'sw 5/7/1998 23:00'!codeStrippedOut: messageString	"When a method is stripped out for external release, it is replaced by a method that calls this"	self halt: 'Code stripped out -- ', messageString, '-- do not proceed.'! !!Object methodsFor: 'macpal' stamp: 'sw 1/28/1999 17:31'!contentsChanged	self changed: #contents! !!Object methodsFor: 'macpal' stamp: 'ar 3/18/2001 00:03'!currentEvent	"Answer the current Morphic event.  This method never returns nil."	^ActiveEvent ifNil:[self currentHand lastEvent]! !!Object methodsFor: 'macpal' stamp: 'ar 3/18/2001 00:03'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ActiveHand! !!Object methodsFor: 'macpal' stamp: 'BG 10/29/2003 08:43'!currentWorld	"Answer a morphic world that is the current UI focus.		If in an embedded world, it's that world.		If in a morphic project, it's that project's world.  		If in an mvc project, it is the topmost morphic-mvc-window's worldMorph. 		If in an mvc project that has no morphic-mvc-windows, then it's just some existing worldmorph instance.		If in an mvc project in a Squeak that has NO WorldMorph instances, one is created.	This method will never return nil, it will always return its best effort at returning a relevant world morph, but if need be -- if there are no worlds anywhere, it will create a new one."	| aView aSubview |	ActiveWorld ifNotNil:[^ActiveWorld].	World ifNotNil:[^World].	aView _ ScheduledControllers controllerSatisfying:		[:ctrl | (aSubview _ ctrl view firstSubView) notNil and:			[aSubview model isMorph and: [aSubview model isWorldMorph]]].	^aView		ifNotNil:			[aSubview model]		ifNil:			[].! !!Object methodsFor: 'macpal' stamp: 'jm 5/6/1998 22:35'!flash	"Do nothing."! !!Object methodsFor: 'macpal' stamp: 'sw 10/13/97 16:38'!ifKindOf: aClass thenDo: aBlock	^ (self isKindOf: aClass) ifTrue: [aBlock value: self]! !!Object methodsFor: 'macpal' stamp: 'sw 6/16/1998 15:07'!instanceVariableValues	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!Object methodsFor: 'macpal' stamp: 'sw 3/20/2001 13:29'!isUniversalTiles	"Return true if I (my world) uses universal tiles.  This message can be called in places where the current World is not known, such as when writing out a project.  For more information about the project-writing subtlety addressed by this protocol, kindly contact Ted Kaehler."	^ Preferences universalTiles! !!Object methodsFor: 'macpal' stamp: 'sw 10/24/2000 07:04'!objectRepresented	"most objects represent themselves; this provides a hook for aliases to grab on to"	^ self! !!Object methodsFor: 'macpal' stamp: 'gk 2/23/2004 20:51'!playSoundNamed: soundName	"Deprecated.	Play the sound with the given name."	self deprecated: 'Use "SoundService default playSoundNamed: aName" instead.'.	SoundService default playSoundNamed: soundName! !!Object methodsFor: 'macpal' stamp: 'sw 5/22/2001 18:31'!refusesToAcceptCode	"Answer whether the receiver is a code-bearing instrument which at the moment refuses to allow its contents to be submitted"	^ false	! !!Object methodsFor: 'macpal' stamp: 'jm 2/24/1999 12:40'!scriptPerformer	^ self! !!Object methodsFor: 'macpal' stamp: 'sw 3/20/2001 13:40'!slotInfo	"Answer a list of slot-information objects.  Initally only provides useful info for players"	^ Dictionary new! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:52'!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Object methodsFor: 'message handling' stamp: 'sw 10/30/1998 18:27'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ otherTarget perform: selector! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:52'!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:52'!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:51'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject)! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:55'!perform: selector withArguments: argArray 	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Fail if the number of arguments expected by the selector 	does not match the size of argArray.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 84>	^ self perform: selector withArguments: argArray inSuperclass: self class! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 08:00'!perform: selector withArguments: argArray inSuperclass: lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."	<primitive: 100>	(selector isMemberOf: Symbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	(selector numArgs = argArray size)		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == lookupClass or: [self class inheritsFrom: lookupClass])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!Object methodsFor: 'message handling' stamp: 'NS 1/28/2004 11:19'!withArgs: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 12:46'!comeFullyUpOnReload: smartRefStream	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"	^ self! !!Object methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 16:51'!convertToCurrentVersion: varDict refStream: smartRefStrm	"subclasses should implement if they wish to convert old instances to modern ones"! !!Object methodsFor: 'objects from disk' stamp: 'RAA 1/10/2001 14:02'!indexIfCompact	^0		"helps avoid a #respondsTo: in publishing"! !!Object methodsFor: 'objects from disk' stamp: 'tk 2/24/1999 11:08'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    ^ self! !!Object methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 12:05'!readDataFrom: aDataStream size: varsOnDisk	"Fill in the fields of self based on the contents of aDataStream.  Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	self class isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars _ 0.				cntInstVars _ varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self	"If we ever return something other than self, fix calls 			on (super readDataFrom: aDataStream size: anInteger)"! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 08:57'!fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:s | self printOn: s]! !!Object methodsFor: 'printing'!isLiteral	"Answer whether the receiver has a literal text form recognized by the 	compiler."	^false! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:28'!longPrintOn: aStream	"Append to the argument, aStream, the names and values of all 	of the receiver's instance variables."	self class allInstVarNames doWithIndex:		[:title :index |		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 print: (self instVarAt: index);		 cr]! !!Object methodsFor: 'printing' stamp: 'tk 10/19/2001 11:18'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var."	self class allInstVarNames doWithIndex:		[:title :index |		indent timesRepeat: [aStream tab].		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 nextPutAll: 			((self instVarAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1));		 cr]! !!Object methodsFor: 'printing' stamp: 'tk 10/16/2001 19:41'!longPrintString	"Answer a String whose characters are a description of the receiver."		| str |	str _ String streamContents: [:aStream | self longPrintOn: aStream].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing' stamp: 'sw 3/7/2001 13:14'!nominallyUnsent: aSelectorSymbol	"From within the body of a method which is not formally sent within the system, but which you intend to have remain in the system (for potential manual invocation, or for documentation, or perhaps because it's sent by commented-out-code that you anticipate uncommenting out someday, send this message, with the selector itself as the argument.This will serve two purposes:	(1)  The method will not be returned by searches for unsent selectors (because it, in a manner of speaking, sends itself).	(2)	You can locate all such methods by browsing senders of #nominallyUnsent:"	false ifTrue: [self flag: #nominallyUnsent:]    "So that this method itself will appear to be sent"! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:31'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title _ self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:22'!printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!Object methodsFor: 'printing' stamp: 'tk 5/7/1999 16:20'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString _ String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: 'printing' stamp: 'sw 10/17/2000 11:16'!reportableSize	"Answer a string that reports the size of the receiver -- useful for showing in a list view, for example"	^ (self basicSize + self class instSize) printString! !!Object methodsFor: 'printing'!storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream nextPutAll: self class name, ' basicNew'].	1 to: self class instSize do:		[:i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 09:12'!storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [:s | self storeOn: s]! !!Object methodsFor: 'printing' stamp: 'sw 5/2/1998 13:55'!stringForReadout	^ self stringRepresentation! !!Object methodsFor: 'printing'!stringRepresentation	"Answer a string that represents the receiver.  For most objects this is simply its printString, but for strings themselves, it's themselves.  6/12/96 sw"	^ self printString ! !!Object methodsFor: 'scripting' stamp: 'ar 3/17/2001 20:11'!adaptedToWorld: aWorld	"If I refer to a world or a hand, return the corresponding items in the new world."	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 3/5/2001 18:13'!contentsGetz: x	self contents: x! !!Object methodsFor: 'scripting' stamp: 'sw 3/10/2000 13:57'!defaultFloatPrecisionFor: aGetSelector	"Answer a number indicating the default float precision to be used in a numeric readout for which the receiver is the model."	^ 1! !!Object methodsFor: 'scripting' stamp: 'RAA 3/9/2001 17:08'!evaluateUnloggedForSelf: aCodeString	^Compiler evaluate:		aCodeString		for: self		logged: false! !!Object methodsFor: 'scripting' stamp: 'sw 2/6/2003 18:05'!methodInterfacesForCategory: aCategorySymbol inVocabulary: aVocabulary limitClass: aLimitClass
	"Return a list of methodInterfaces for the receiver in the given category, given a vocabulary.  aCategorySymbol is the inherent category symbol, not necessarily the wording as expressed in the vocabulary."

	| categorySymbol |
	categorySymbol _ aCategorySymbol asSymbol.

	(categorySymbol == ScriptingSystem nameForInstanceVariablesCategory) ifTrue:		"user-defined instance variables"
		[^ self methodInterfacesForInstanceVariablesCategoryIn: aVocabulary].

	(categorySymbol == ScriptingSystem nameForScriptsCategory) ifTrue:						"user-defined scripts"
		[^ self methodInterfacesForScriptsCategoryIn: aVocabulary].

	^ (self usableMethodInterfacesIn: (aVocabulary methodInterfacesInCategory: (aVocabulary translatedWordingFor: categorySymbol) forInstance: self ofClass: self class limitClass: aLimitClass))   "all others"! !!Object methodsFor: 'scripting' stamp: 'sw 8/3/2001 13:54'!methodInterfacesForInstanceVariablesCategoryIn: aVocabulary	"Return a collection of methodInterfaces for the instance-variables category.  The vocabulary parameter, at present anyway, is not used.  And for non-players, the method is at present vacuous in any case"	^  OrderedCollection new! !!Object methodsFor: 'scripting' stamp: 'sw 8/3/2001 13:53'!methodInterfacesForScriptsCategoryIn: aVocabulary	"Answer a list of method interfaces for the category #scripts, as seen in a viewer or other tool.  The vocabulary argument is not presently used.  Also, at present, only Players really do anyting interesting here."	^ OrderedCollection new! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:37'!selfWrittenAsIll	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:38'!selfWrittenAsIm	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:37'!selfWrittenAsMe	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:37'!selfWrittenAsMy	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:38'!selfWrittenAsThis	^self! !!Object methodsFor: 'system primitives'!asOop	"Primitive. Answer a SmallInteger whose value is half of the receiver's 	object pointer (interpreting object pointers as 16-bit signed quantities). 	Fail if the receiver is a SmallInteger. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 75>	self primitiveFailed! !!Object methodsFor: 'system primitives' stamp: 'di 1/9/1999 15:19'!becomeForward: otherObject 	"Primitive. All variables in the entire system that used to point	to the receiver now point to the argument.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)! !!Object methodsFor: 'system primitives' stamp: 'zz 3/3/2004 23:53'!becomeForward: otherObject copyHash: copyHash	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)				copyHash: copyHash! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 10:59'!className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 11:04'!creationStamp	"Answer a string which reports the creation particulars of the receiver.  Intended perhaps for list views, but this is presently a feature not easily accessible"	^ '<no creation stamp>'! !!Object methodsFor: 'system primitives'!instVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize		! !!Object methodsFor: 'system primitives'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 11:09'!instVarNamed: aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class allInstVarNames indexOf: aString asString)! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 11:10'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class allInstVarNames indexOf: aString asString) put: aValue! !!Object methodsFor: 'system primitives' stamp: 'sw 10/17/2000 11:12'!oopString	"Answer a string that represents the oop of the receiver"	^ self asOop printString! !!Object methodsFor: 'system primitives' stamp: 'ar 3/2/2001 01:34'!primitiveChangeClassTo: anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115>	self primitiveFailed! !!Object methodsFor: 'system primitives'!someObject	"Primitive. Answer the first object in the enumeration of all	 objects."	<primitive: 138>	self primitiveFailed.! !!Object methodsFor: 'testing' stamp: 'sw 9/26/2001 11:58'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Object! !!Object methodsFor: 'testing' stamp: 'sw 5/3/2001 16:19'!beViewed	"Open up a viewer on the receiver.  The Presenter is invited to decide just how to present this viewer"	self uniqueNameForReference.  "So the viewer will have something nice to refer to"	self presenter viewObject: self! !!Object methodsFor: 'testing' stamp: 'sw 10/16/2000 11:01'!costumes	"Answer a list of costumes associated with the receiver.  The appearance of this method in class Object serves only as a backstop, probably only transitionally"	^ nil! !!Object methodsFor: 'testing' stamp: 'sw 1/12/98 18:09'!haltIfNil! !!Object methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior.	Note: Do not override in any class except behavior."	^false! !!Object methodsFor: 'testing' stamp: 'ajh 1/21/2003 13:15'!isBlock	^ false! !!Object methodsFor: 'testing' stamp: 'md 11/21/2003 12:14'!isBlockClosure	^ false! !!Object methodsFor: 'testing' stamp: 'ar 8/17/1999 19:43'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^false! !!Object methodsFor: 'testing'!isColor	"Answer true if receiver is a Color. False by default."	^ false! !!Object methodsFor: 'testing' stamp: 'nk 4/17/2004 19:43'!isColorForm	^false! !!Object methodsFor: 'testing' stamp: 'md 11/21/2003 12:14'!isCompiledMethod	^ false! !!Object methodsFor: 'testing' stamp: 'di 11/9/1998 09:38'!isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'ar 10/30/2000 23:22'!isForm	^false! !!Object methodsFor: 'testing' stamp: 'len 1/13/98 21:18'!isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'testing' stamp: 'rhi 8/14/2003 08:51'!isHeap	^ false! !!Object methodsFor: 'testing'!isInteger	"Overridden to return true in Integer."	^ false! !!Object methodsFor: 'testing' stamp: 'rhi 8/12/2003 09:52'!isInterval	^ false! !!Object methodsFor: 'testing' stamp: 'nk 4/25/2002 08:04'!isMessageSend	^false! !!Object methodsFor: 'testing'!isMorph	^ false! !!Object methodsFor: 'testing' stamp: 'ar 9/13/2000 15:37'!isMorphicEvent	^false! !!Object methodsFor: 'testing' stamp: 'gm 2/22/2003 12:56'!isMorphicModel	"Return true if the receiver is a morphic model"	^false! !!Object methodsFor: 'testing'!isNumber	"Overridden to return true in Number, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'di 11/6/1998 08:04'!isPoint	"Overridden to return true in Point."	^ false! !!Object methodsFor: 'testing' stamp: 'ikp 9/26/97 14:45'!isPseudoContext	^false! !!Object methodsFor: 'testing' stamp: 'ar 12/23/1999 15:43'!isStream	"Return true if the receiver responds to the stream protocol"	^false! !!Object methodsFor: 'testing' stamp: 'sma 6/15/2000 15:48'!isString	"Overridden to return true in String, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'md 4/30/2003 15:30'!isSymbol	^ false ! !!Object methodsFor: 'testing' stamp: 'jam 3/9/2003 15:10'!isSystemWindow"answer whatever the receiver is a SystemWindow"	^ false! !!Object methodsFor: 'testing'!isText	^ false! !!Object methodsFor: 'testing' stamp: 'tk 10/21/97 12:45'!isTransparent	^ false! !!Object methodsFor: 'testing' stamp: 'ar 8/14/2001 23:19'!isVariableBinding	"Return true if I represent a literal variable binding"	^false	! !!Object methodsFor: 'testing' stamp: 'ls 7/14/1998 21:45'!isWebBrowser	"whether this object is a web browser.  See class: Scamper"	^false! !!Object methodsFor: 'testing' stamp: 'sw 10/27/2000 06:58'!knownName	"If a formal name has been handed out for this object, answer it, else nil"		^ Preferences capitalizedReferences		ifTrue:			[References keyAtValue: self ifAbsent: [nil]]		ifFalse:			[nil]! !!Object methodsFor: 'testing' stamp: 'sw 9/27/96'!name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "	^ self printString! !!Object methodsFor: 'testing' stamp: 'sw 11/19/2001 13:28'!nameForViewer	"Answer a name to be shown in a Viewer that is viewing the receiver"	| aName |	(aName _ self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(aName _ self knownName) ifNotNil: [^ aName].	^ [(self asString copyWithout: Character cr) truncateTo:  27] ifError:		[:msg :rcvr | ^ self class name printString]! !!Object methodsFor: 'testing'!notNil	"Coerces nil to false and everything else to true."	^true! !!Object methodsFor: 'testing' stamp: 'sw 2/27/2002 14:55'!renameTo: newName	"If the receiver has an inherent idea about its own name, it should take action here.  Any object that might be pointed to in the References dictionary might get this message sent to it upon reload"! !!Object methodsFor: 'testing' stamp: 'sw 1/18/2001 13:43'!showDiffs	"Answer whether the receiver, serving as the model of a text-bearing entity, is 'showing differences' -- if it is, the editor may wish to show special feedback"	^ false! !!Object methodsFor: 'testing' stamp: 'sw 10/20/1999 14:52'!stepAt: millisecondClockValue in: aWindow	^ self stepIn: aWindow! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:16'!stepIn: aWindow	^ self step! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:21'!stepTime		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:22'!stepTimeIn: aSystemWindow		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'sw 5/3/2001 18:22'!vocabularyDemanded	"Answer a vocabulary that the receiver insists be used when it is looked at in a Viewer.  This allows specific classes to insist on specific custom vocabularies"	^ nil! !!Object methodsFor: 'testing' stamp: 'sw 11/13/2001 07:26'!wantsDiffFeedback	"Answer whether the receiver, serving as the model of a text-bearing entity, would like for 'diffs' green pane-border feedback to be shown"	^ false! !!Object methodsFor: 'testing' stamp: 'di 1/8/1999 15:04'!wantsSteps	"Overridden by morphic classes whose instances want to be stepped,	or by model classes who want their morphic views to be stepped."	^ false! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:26'!wantsStepsIn: aSystemWindow		^ self wantsSteps! !!Object methodsFor: 'translation support'!inline: inlineFlag	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'undo' stamp: 'di 9/11/2000 20:32'!capturedState	"May be overridden in subclasses."	^ self shallowCopy! !!Object methodsFor: 'undo' stamp: 'di 9/12/2000 08:15'!redoFromCapturedState: st 	"May be overridden in subclasses.  See also capturedState"	self undoFromCapturedState: st  "Simple cases are symmetric"! !!Object methodsFor: 'undo' stamp: 'sw 11/16/2000 14:42'!refineRedoTarget: target selector: aSymbol arguments: arguments in: refineBlock 	"Any object can override this method to refine its redo specification"	^ refineBlock		value: target		value: aSymbol		value: arguments! !!Object methodsFor: 'undo' stamp: 'sw 11/16/2000 14:42'!refineUndoTarget: target selector: aSymbol arguments: arguments in: refineBlock 	"Any object can override this method to refine its undo specification"	^ refineBlock		value: target		value: aSymbol		value: arguments! !!Object methodsFor: 'undo' stamp: 'di 9/11/2000 20:32'!undoFromCapturedState: st 	"May be overridden in subclasses.  See also capturedState"	self copyFrom: st! !!Object methodsFor: 'updating'!changed	"Receiver changed in a general way; inform all the dependents by 	sending each dependent an update: message."	self changed: self! !!Object methodsFor: 'updating'!changed: aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self dependents do: [:aDependent | aDependent update: aParameter]! !!Object methodsFor: 'updating' stamp: 'nk 2/17/2004 11:12'!changed: anAspect with: anObject	"Receiver changed. The change is denoted by the argument anAspect. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents. Also pass anObject for additional information."	self dependents do: [:aDependent | aDependent update: anAspect with: anObject]! !!Object methodsFor: 'updating' stamp: 'sw 10/12/1999 18:15'!handledListVerification	"When a self-updating PluggableListMorph lazily checks to see the state of affairs, it first gives its model an opportunity to handle the list verification itself (this is appropriate for some models, such as VersionsBrowser); if a list's model has indeed handled things itself, it returns true here"	^ false! !!Object methodsFor: 'updating' stamp: 'sw 10/31/1999 00:15'!noteSelectionIndex: anInteger for: aSymbol	"backstop"! !!Object methodsFor: 'updating'!okToChange	"Allows a controller to ask this of any model"	^ true! !!Object methodsFor: 'updating' stamp: 'sma 2/29/2000 20:05'!update: aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to do nothing; a subclass might want 	to change itself in some way."	^ self! !!Object methodsFor: 'updating' stamp: 'nk 2/17/2004 11:13'!update: anAspect with: anObject	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to call update:,	which by default does nothing; a subclass might want 	to change itself in some way."	^ self update: anAspect! !!Object methodsFor: 'updating' stamp: 'sw 10/19/1999 14:39'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Object methodsFor: 'updating' stamp: 'jm 8/20/1998 18:26'!windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'user interface' stamp: 'sw 10/4/1999 08:13'!addModelItemsToWindowMenu: aMenu	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."! !!Object methodsFor: 'user interface' stamp: 'sw 10/5/1998 14:39'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"! !!Object methodsFor: 'user interface' stamp: 'sma 11/12/2000 11:43'!asExplorerString	^ self printString! !!Object methodsFor: 'user interface' stamp: 'gk 2/24/2004 08:49'!beep	"Deprecated."		self deprecated: 'Use Beeper class>>beep instead.'.	Beeper beep! !!Object methodsFor: 'user interface' stamp: 'sw 7/13/1999 15:53'!defaultBackgroundColor	"Answer the color to be used as the base window color for a window whose model is an object of the receiver's class"		^ Preferences windowColorFor: self class name! !!Object methodsFor: 'user interface'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self class name! !!Object methodsFor: 'user interface' stamp: 'sw 8/15/97 17:25'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	| adj |	adj _ (3 * Preferences scrollBarWidth) @ 0.	^ Rectangle origin: adj extent: (DisplayScreen actualScreenSize - adj)! !!Object methodsFor: 'user interface' stamp: 'RAA 6/21/1999 11:27'!hasContentsInExplorer	^self basicSize > 0 or: [self class allInstVarNames isEmpty not]! !!Object methodsFor: 'user interface' stamp: 'sma 5/28/2000 15:59'!inform: aString	"Display a message for the user to read and then dismiss. 6/9/96 sw"	aString isEmptyOrNil ifFalse: [PopUpMenu inform: aString]! !!Object methodsFor: 'user interface'!initialExtent	"Answer the desired extent for the receiver when a view on it is first opened on the screen. 	5/22/96 sw: in the absence of any override, obtain from RealEstateAgent"	^ RealEstateAgent standardWindowExtent! !!Object methodsFor: 'user interface'!inspectWithLabel: aLabel	Inspector openOn: self withEvalPane: true withLabel: aLabel! !!Object methodsFor: 'user interface' stamp: 'sw 6/12/2001 11:09'!launchPartVia: aSelector	"Obtain a morph by sending aSelector to self, and attach it to the morphic hand.  This provides a general protocol for parts bins"	| aMorph |	aMorph _ self perform: aSelector.	aMorph setProperty: #beFullyVisibleAfterDrop toValue: true.	aMorph openInHand! !!Object methodsFor: 'user interface' stamp: 'ar 12/14/2001 20:08'!launchPartVia: aSelector label: aString	"Obtain a morph by sending aSelector to self, and attach it to the morphic hand.  This provides a general protocol for parts bins"	| aMorph |	aMorph _ self perform: aSelector.	aMorph setNameTo: aString.	aMorph setProperty: #beFullyVisibleAfterDrop toValue: true.	aMorph openInHand! !!Object methodsFor: 'user interface' stamp: 'di 5/11/1999 22:26'!modelSleep	"A window with me as model is being exited or collapsed or closed.	Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'di 5/11/1999 22:01'!modelWakeUp	"A window with me as model is being entered or expanded.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'sw 10/16/1999 22:45'!modelWakeUpIn: aWindow	"A window with me as model is being entered or expanded.  Default response is no-op" 	self modelWakeUp! !!Object methodsFor: 'user interface' stamp: 'sw 3/8/1999 15:27'!mouseUpBalk: evt	"A button I own got a mouseDown, but the user moved out before letting up.  Certain kinds of objects (so-called 'radio buttons', for example, and other structures that must always have some selection, e.g. PaintBoxMorph) wish to take special action in this case; this default does nothing."! !!Object methodsFor: 'user interface' stamp: 'jcg 11/1/2001 13:13'!notYetImplemented	self inform: 'Not yet implemented (', thisContext sender printString, ')'! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowActiveOnFirstClick	"Return true if my window should be active on first click."	^ false! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowReqNewLabel: labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'viewer' stamp: 'sw 10/16/2000 10:35'!assureUniClass	"If the receiver is not yet an instance of a uniclass, create a uniclass for it and make the receiver become an instance of that class."	| anInstance |	self belongsToUniClass ifTrue: [^ self].	anInstance _ self class instanceOfUniqueClass.	self become: (self as: anInstance class).	^ anInstance! !!Object methodsFor: 'viewer' stamp: 'sw 10/16/2000 10:41'!belongsToUniClass	"Answer whether the receiver belongs to a uniclass.  For the moment (this is not entirely satisfactory) this is precisely equated with the classname ending in a digit"	^ self class name endsWithDigit! !!Object methodsFor: 'viewer' stamp: 'sw 12/11/2000 15:37'!browseOwnClassSubProtocol	"Open up a ProtocolBrowser on the subprotocol of the receiver"	ProtocolBrowser openSubProtocolForClass: self class! !!Object methodsFor: 'viewer' stamp: 'sw 8/3/2001 22:08'!categoriesForVocabulary: aVocabulary limitClass: aLimitClass	"Answer a list of categories of methods for the receiver when using the given vocabulary, given that one considers only methods that are implemented not further away than aLimitClass"	^ aVocabulary categoryListForInstance: self ofClass: self class limitClass: aLimitClass! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 07:20'!chooseNewNameForReference	"Offer an opportunity for the receiver, presumed already to be known in the References registry, to be renamed"	|  nameSym current newName |	current _ References keyAtValue: self ifAbsent: [^ self error: 'not found in References'].	newName _ FillInTheBlank request: 'Please enter new name' initialAnswer: current.	"Want to user some better way of determining the validity of the chosen identifier, and also want to give more precise diagnostic if the string the user types in is not acceptable.  Work to be done here."	newName isEmpty ifTrue: [^ nil].	((Scanner isLiteralSymbol: newName) and: [(newName includes: $:) not])		ifTrue:			[nameSym _ newName capitalized asSymbol.			(((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(ScriptingSystem allKnownClassVariableNames includes: nameSym) not])					ifTrue:						[(References associationAt: current) key: nameSym.						References rehash.						^ nameSym]].	self inform: 'Sorry, that name is not available.'.	^ nil! !!Object methodsFor: 'viewer' stamp: 'sw 2/14/2000 14:24'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver.  The default is to let the class specify, but certain instances will want to override.  (PasteUpMorphs serving as Worlds come to mind"	^ self class defaultNameStemForInstances! !!Object methodsFor: 'viewer' stamp: 'sw 5/22/2001 16:53'!elementTypeFor: aStringOrSymbol vocabulary: aVocabulary	"Answer a symbol characterizing what kind of element aStringOrSymbol represents.  Realistically, at present, this always just returns #systemScript; a prototyped but not-incorporated architecture supported use of a leading colon to characterize an inst var of a system class, and for the moment we still see its remnant here."	self flag: #deferred.  "a loose end in the non-player case"	^ #systemScript! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:04'!externalName	"Answer an external name by which the receiver is known.  Generic implementation here is a transitional backstop. probably"	^ self nameForViewer! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:06'!graphicForViewerTab	"When a Viewer is open on the receiver, its tab needs some graphic to show to the user.  Answer a form or a morph to serve that purpose.  A generic image is used for arbitrary objects, but note my reimplementors"		^ ScriptingSystem formAtKey: 'Image'! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:08'!hasUserDefinedSlots	"Answer whether the receiver has any user-defined slots, in the omniuser sense of the term.  This is needed to allow Viewers to look at any object, not just at Players."	^ false! !!Object methodsFor: 'viewer' stamp: 'sw 9/26/2001 11:58'!initialTypeForSlotNamed: aName	"Answer the initial type to be ascribed to the given instance variable"	^ #Object! !!Object methodsFor: 'viewer' stamp: 'ar 5/26/2001 16:13'!isPlayerLike	"Return true if the receiver is a player-like object"	^false! !!Object methodsFor: 'viewer' stamp: 'sw 10/24/2000 11:36'!newScriptorAround: aPhraseTileMorph	"Sprout a scriptor around aPhraseTileMorph, thus making a new script.  This is where generalized scriptors will be threaded in"	^ nil! !!Object methodsFor: 'viewer' stamp: 'sw 1/22/2001 15:20'!renameScript: oldSelector	"prompt the user for a new selector and apply it.  Presently only works for players"	self notYetImplemented! !!Object methodsFor: 'viewer' stamp: 'sw 10/17/2000 11:27'!uniqueInstanceVariableNameLike: aString excluding: takenNames	"Answer a nice instance-variable name to be added to the receiver which resembles aString, making sure it does not coincide with any element in takenNames"	| okBase uniqueName usedNames |	usedNames _ self class allInstVarNamesEverywhere.	usedNames removeAllFoundIn: self class instVarNames.	usedNames addAll: takenNames.	okBase _ Utilities wellFormedInstanceVariableNameFrom: aString.	uniqueName _ Utilities keyLike: okBase satisfying: 		[:aKey | (usedNames includes: aKey) not].	^ uniqueName! !!Object methodsFor: 'viewer' stamp: 'sw 11/21/2001 15:16'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.  At present this uses a global References dictionary to hold the database of references, but in due course this will need to acquire some locality"	| aName nameSym stem knownClassVars |	(aName _ self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(stem _ self knownName) ifNil:		[stem _ self defaultNameStemForInstances asString].	stem _ stem select: [:ch | ch isLetter or: [ch isDigit]].	stem size == 0 ifTrue: [stem _ 'A'].	stem first isLetter ifFalse:		[stem _ 'A', stem].	stem _ stem capitalized.	knownClassVars _ ScriptingSystem allKnownClassVariableNames.	aName _ Utilities keyLike:  stem satisfying:		[:jinaLake |			nameSym _ jinaLake asSymbol.			 ((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(knownClassVars includes: nameSym) not]].	References at: (aName _ aName asSymbol) put: self.	^ aName! !!Object methodsFor: 'viewer' stamp: 'sw 3/15/2004 23:53'!uniqueNameForReferenceFrom: proposedName	"Answer a satisfactory symbol, similar to the proposedName but obeying the rules, to represent the receiver"	| aName nameSym stem okay |	proposedName = self uniqueNameForReferenceOrNil 		ifTrue: [^ proposedName].  "No change"	stem _ proposedName select: [:ch | ch isLetter or: [ch isDigit]].	stem size == 0 ifTrue: [stem _ 'A'].	stem first isLetter ifFalse:		[stem _ 'A', stem].	stem _ stem capitalized.	aName _ Utilities keyLike: stem satisfying:		[:jinaLake |			nameSym _ jinaLake asSymbol.			okay _ true.			self class scopeHas: nameSym ifTrue: [:x | okay _ false "don't use it"].			okay].	^ aName asSymbol! !!Object methodsFor: 'viewer' stamp: 'sw 3/15/2004 23:01'!uniqueNameForReferenceOrNil	"If the receiver has a unique name for reference, return it here, else return nil"	^ References keyAtValue: self ifAbsent: [nil]! !!Object methodsFor: 'viewer' stamp: 'ar 5/16/2001 01:40'!updateThresholdForGraphicInViewerTab	"When a Viewer is open on the receiver, its tab needs some graphic to show to the user. Computing this graphic can take quite some time so we want to make the update frequency depending on how long it takes to compute the thumbnail. The threshold returned by this method defines that the viewer will update at most every 'threshold * timeItTakesToDraw' milliseconds. Thus, if the time for computing the receiver's thumbnail is 200 msecs and the the threshold is 10, the viewer will update at most every two seconds."	^20 "seems to be a pretty good general choice"! !!Object methodsFor: 'viewer' stamp: 'sw 3/9/2001 13:48'!usableMethodInterfacesIn: aListOfMethodInterfaces	"Filter aList, returning a subset list of apt phrases"	^ aListOfMethodInterfaces! !!Object methodsFor: 'private'!errorImproperStore	"Create an error notification that an improper store was attempted."	self error: 'Improper store into indexable object'! !!Object methodsFor: 'private'!errorNonIntegerIndex	"Create an error notification that an improper object was used as an index."	self error: 'only integers should be used as indices'! !!Object methodsFor: 'private' stamp: 'yo 6/29/2004 11:37'!errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: ('Instances of {1} are not indexable' translated format: {self class name})! !!Object methodsFor: 'private'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'private' stamp: 'BG 10/28/2003 21:01'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	| context |	Sensor eventQueue: nil. "Or else we won't get keyboard and possibly run out of memory"	(String		streamContents: 			[:s |			s nextPutAll: '***System error handling failed***'.			s cr; nextPutAll: aString.			context _ thisContext sender sender.			20 timesRepeat: [context == nil ifFalse: [s cr; print: (context _ context sender)]].			s cr; nextPutAll: '-------------------------------'.			s cr; nextPutAll: 'Type CR to enter an emergency evaluator.'.			s cr; nextPutAll: 'Type any other character to restart.'])		displayAt: 0 @ 0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard = Character cr ifTrue: [Transcripter emergencyEvaluator].	Smalltalk isMorphic		ifFalse: [ScheduledControllers searchForActiveController]! !!Object methodsFor: 'private'!species	"Answer the preferred class for reconstructing the receiver.  For example, 	collections create new collections whenever enumeration messages such as 	collect: or select: are invoked.  The new kind of collection is determined by 	the species of the original collection.  Species and class are not always the 	same.  For example, the species of Interval is Array."	^self class! !!Object methodsFor: 'private'!storeAt: offset inTempFrame: aContext	"This message had to get sent to an expression already on the stack	as a Block argument being accessed by the debugger.	Just re-route it to the temp frame."	^ aContext tempAt: offset put: self! !!Object methodsFor: '*system-support' stamp: 'dvf 8/23/2003 12:27'!systemNavigation	^ SystemNavigation default! !!Object methodsFor: 'Breakpoint' stamp: 'bkv 7/1/2003 12:33'!break
	"This is a simple message to use for inserting breakpoints during debugging.
	The debugger is opened by sending a signal. This gives a chance to restore
	invariants related to multiple processes."

	BreakPoint signal.

	"nil break."! !!Object methodsFor: 'inspecting' stamp: 'ajh 1/31/2003 15:49'!basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	BasicInspector openOn: self withEvalPane: false! !!Object methodsFor: 'inspecting' stamp: 'ajh 2/3/2003 19:19'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	self inspectorClass openOn: self withEvalPane: true! !!Object methodsFor: 'inspecting' stamp: 'ajh 2/3/2003 19:18'!inspectorClass	^ Inspector! !!Object methodsFor: '*sunit-preload' stamp: 'jp 3/17/2003 09:58'!sunitAddDependent: anObject         self addDependent: anObject! !!Object methodsFor: '*sunit-preload' stamp: 'jp 3/17/2003 09:58'!sunitChanged: anAspect         self changed: anAspect! !!Object methodsFor: '*sunit-preload' stamp: 'jp 3/17/2003 09:58'!sunitRemoveDependent: anObject         self removeDependent: anObject! !!Object methodsFor: '*tools-browser' stamp: 'mu 3/6/2004 15:13'!browse	self systemNavigation browseClass: self class! !!Object methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 16:00'!browseHierarchy	self systemNavigation browseHierarchy: self class! !!Object methodsFor: 'debugging' stamp: 'ssa 8/8/2008 17:25'!print	Transcript cr;show: self printString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Object class	instanceVariableNames: ''!!Object class methodsFor: 'instance creation' stamp: 'sw 1/23/2003 09:45'!categoryForUniclasses
	"Answer the default system category into which to place unique-class instances"

	^ 'UserObjects'! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!chooseUniqueClassName	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ className! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:22'!initialInstance	"Answer the first instance of the receiver, generate an error if there is one already"	"self instanceCount > 0 ifTrue: [self error: 'instance(s) already exist.']."		"Debugging test that is very slow"	^ self new! !!Object class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 09:30'!initializedInstance	^ self new! !!Object class methodsFor: 'instance creation' stamp: 'sw 10/16/2000 10:58'!instanceOfUniqueClass	"Answer an instance of a unique subclass of the receiver"	^ self instanceOfUniqueClassWithInstVarString: '' andClassInstVarString: ''! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:27'!instanceOfUniqueClassWithInstVarString: instVarString andClassInstVarString: classInstVarString	"Create a unique class for the receiver, and answer an instance of it"	^ (self newUniqueClassInstVars: instVarString 		classInstVars: classInstVarString) initialInstance! !!Object class methodsFor: 'instance creation' stamp: 'sw 10/23/1999 22:51'!isUniClass	^ false! !!Object class methodsFor: 'instance creation' stamp: 'ajh 5/23/2002 00:35'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject.	If the classes have any instance varaibles with the same names, copy them across.	If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]	  ) copySameFrom: aSimilarObject! !!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy"	^ self instanceOfUniqueClass! !!Object class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 15:46'!readCarefullyFrom: textOrString	"Create an object based on the contents of textOrString.  Return an error instead of putting up a SyntaxError window."	| object ok |	ok _ (textOrString isKindOf: Stream) or: [textOrString isKindOf: String].	(ok or: [textOrString isKindOf: Text]) ifFalse: [^ self error: 'expected String or Text'].	object _ Compiler evaluate: textOrString for: nil 				notifying: #error: "signal we want errors" logged: false.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 07:05'!readFrom: aStream	"Create an object based on the contents of aStream."	| object ok |	ok _ (aStream isKindOf: Stream) or: [aStream isKindOf: String].	(ok or: [aStream isKindOf: Text]) ifFalse: [^ self error: 'expected String or Text'].	object _ Compiler evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: 'documentation'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!Object class methodsFor: 'documentation'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !!Object class methodsFor: 'private' stamp: 'mir 8/22/2001 15:20'!releaseExternalSettings	"Do nothing as a default"! !!Object class methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!createFrom: aSmartRefStream size: varsOnDisk version: instVarList	"Create an instance of me so objects on the disk can be read in.  Tricky part is computing the size if variable.  Inst vars will be filled in later.  "	^ self isVariable		ifFalse: [self basicNew]		ifTrue: ["instVarList is names of old class's inst vars plus a version number" 				self basicNew: (varsOnDisk - (instVarList size - 1))]! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:05'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asNakedOopFrom: anInteger on: aStream! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 13:01'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream! !!Object class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:10'!ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 16:09'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asKindOf: self from: anInteger! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:12'!ccgCanConvertFrom: anObject	^anObject isKindOf: self! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 00:19'!ccgDeclareCForVar: aSymbolOrString	^'int ', aSymbolOrString! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 02:00'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!Object class methodsFor: 'class initialization' stamp: 'rw 2/10/2002 13:09'!flushEvents	"Object flushEvents"	EventManager flushEvents. ! !!Object class methodsFor: 'class initialization' stamp: 'rww 10/2/2001 07:35'!initialize	"Object initialize"	DependentsFields ifNil:[self initializeDependentsFields].! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:41'!initializeDependentsFields	"Object initialize"	DependentsFields _ WeakIdentityKeyDictionary new.! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:45'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields _ DependentsFields.	DependentsFields _ WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !Object subclass: #ObjectFinalizer	instanceVariableNames: 'receiver selector arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Finalization'!!ObjectFinalizer methodsFor: 'initialize' stamp: 'ar 5/19/2003 20:12'!receiver: aReceiver selector: aSelector argument: anObject	receiver := aReceiver.	selector := aSelector.	arguments := Array with: anObject! !!ObjectFinalizer methodsFor: 'finalization' stamp: 'ar 5/19/2003 20:13'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."	[receiver perform: selector withArguments: arguments] 		on: Error do:[:ex| ex return].! !Object subclass: #ObjectWithDocumentation	instanceVariableNames: 'authoringStamp properties elementSymbol naturalLanguageTranslations'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Kernel'!!ObjectWithDocumentation commentStamp: '<historical>' prior: 0!ObjectWithDocumentation - an abstract superclass for objects that allows maintenance of an authoring stamp, a body of documentation, and a properties dictionary.The Properties implementation has not happened yet -- it would closely mirror the implemenation of properties in the MorphExtension, for example.!!ObjectWithDocumentation methodsFor: 'initialization' stamp: 'sw 1/29/2001 09:28'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	authoringStamp _ Utilities changeStampPerSe! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'sw 11/5/2001 15:36'!documentation: maneno	"Set the receiver's documentation, in the current langauge"	| wording |	wording _ self wording.	self absorbTranslation: (ElementTranslation new wording: wording  helpMessage: maneno language: #English) ! !!ObjectWithDocumentation methodsFor: 'queries' stamp: 'sw 9/12/2001 14:36'!documentation	"Answer the receiver's documentation"	^ self translatedToPrevailingLanguage helpMessage! !!ObjectWithDocumentation methodsFor: 'queries' stamp: 'sw 9/12/2001 15:13'!wording	"Answer the receiver's wording"	^ self translatedToPrevailingLanguage wording! !!ObjectWithDocumentation methodsFor: 'translation' stamp: 'sw 9/12/2001 23:03'!absorbTranslation: anElementTranslation	"Absorb the given translation, which could overlay a prior version"	naturalLanguageTranslations ifNil:		[naturalLanguageTranslations _ OrderedCollection new].	naturalLanguageTranslations removeAllSuchThat:		[:tr | tr language == anElementTranslation language].	naturalLanguageTranslations add: anElementTranslation! !!ObjectWithDocumentation methodsFor: 'translation' stamp: 'dgd 2/24/2004 20:02'!translatedToLanguage: languageSymbol 	"Answer an ElementTranslation object in the prevailing natural  	language, or, if none found, in English"	| fallback elSym el wrd doc |	elSym := self elementSymbol.	^ naturalLanguageTranslations isEmptyOrNil		ifTrue: [(el := self elementSymbol)				ifNotNil: [((el beginsWith: 'get')							and: [elSym size > 3])						ifTrue: [wrd := (elSym copyFrom: 4 to: elSym size) withFirstCharacterDownshifted.							doc := 'get value of ' , elSym]						ifFalse: [((elSym beginsWith: 'set')									and: [elSym size > 4])								ifTrue: [wrd := (elSym copyFrom: 4 to: elSym size - 1) withFirstCharacterDownshifted.									doc := 'set value of ' , elSym]								ifFalse: [wrd := ScriptingSystem wordingForOperator: elSym.									doc := nil]]].			^ ElementTranslation new				wording: wrd				helpMessage: doc				language: #English]		ifFalse: [naturalLanguageTranslations				do: [:aTranslation | 					aTranslation language == languageSymbol						ifTrue: [^ aTranslation].					aTranslation language == #English						ifTrue: [fallback := aTranslation]].			fallback				ifNil: [ElementCategory new categoryName: elSym]]! !!ObjectWithDocumentation methodsFor: 'translation' stamp: 'dgd 12/4/2003 19:09'!translatedToPrevailingLanguage	"Answer an ElementTranslation object in the prevailing natural language, or, if none found, in English"	^ Preferences translationWithBabel			ifTrue:[ self translatedToPrevailingLanguageUsingBabel ]			ifFalse:[ self translatedToLanguage:self currentWorld currentNaturalLanguage]! !!ObjectWithDocumentation methodsFor: 'translation' stamp: 'dgd 12/4/2003 19:14'!translatedToPrevailingLanguageUsingBabel	"Answer an ElementTranslation object in the prevailing natural  	language using the Babel mechanism"	| elSym |	elSym := self elementSymbol.	""	elSym isNil		ifFalse: [""			((elSym beginsWith: 'get')					and: [elSym size > 3])				ifTrue: [""					^ ElementTranslation new						wording: (elSym allButFirst: 3) withFirstCharacterDownshifted translated						helpMessage: ('get value of {1}' translated format: {elSym})						language: self currentWorld currentNaturalLanguage].			""			((elSym beginsWith: 'set')					and: [elSym size > 4])				ifTrue: [""					^ ElementTranslation new						wording: (elSym allButFirst: 3) withFirstCharacterDownshifted translated						helpMessage: ('set value of {1}' translated format: {elSym})						language: self currentWorld currentNaturalLanguage]].	""	^ (self translatedToLanguage: #English) translated! !!ObjectWithDocumentation methodsFor: 'miscellaneous' stamp: 'sw 9/12/2001 23:03'!elementSymbol	"Answer the receiver's element symbol"	^ elementSymbol! !Switch subclass: #OneOnSwitch	instanceVariableNames: 'connection'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!OneOnSwitch commentStamp: '<historical>' prior: 0!I am a kind of Switch that can be connected to some related object, typically to a collection of my instances. When my instance is created, its connection is set to a particular object. When the object changes because an Switch it refers to is turned on, an update message is broadcasted. All the connected OneOnSwitches, except the changed one, turn off. This allows OneOnSwitches to maintain the constraint that at most one of them will be on at any time. OneOnSwitches can thus be made to act like "car radio" switches.!!OneOnSwitch methodsFor: 'initialize-release'!release	super release.	self isConnectionSet ifTrue: [connection removeDependent: self]! !!OneOnSwitch methodsFor: 'state'!turnOn	"Does nothing if it is already on. If it is not, it is set to 'on', its	dependents are 	notified of the change, its connection is notified, and	its action is executed."	self isOff		ifTrue: 			[on _ true.			self changed.			self notifyConnection.			self doAction: onAction]! !!OneOnSwitch methodsFor: 'connection'!connection	"Answer the object that connects the receiver to other Switches."	^connection! !!OneOnSwitch methodsFor: 'connection'!isConnectionSet	"Answer whether the receiver is connected to an object that coordinates 	updates among switches."	connection == nil		ifTrue: [^false]		ifFalse: [^true]! !!OneOnSwitch methodsFor: 'connection'!notifyConnection	"Send the receiver's connection (if it exists) the message 'changed: self' in 	order for the connection to broadcast the change to other objects 	connected by the connection."		self isConnectionSet ifTrue: [self connection changed: self]! !!OneOnSwitch methodsFor: 'updating'!update: aOneOnSwitch 	"Does nothing if aOneOnSwitch is identical to this object. If it is not, this 	object is turned off. This message is sent by the connection (an Object)	when some related OneOnSwitch (possibly this one) has changed. This	allows a group of related OneOnSwitches to maintain the constraint that	at most one will be on at any time."	self ~~ aOneOnSwitch ifTrue: [self turnOff]! !SequenceableCollection subclass: #OrderedCollection	instanceVariableNames: 'array firstIndex lastIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!OrderedCollection commentStamp: '<historical>' prior: 0!I represent a collection of objects ordered by the collector.!!OrderedCollection methodsFor: 'accessing'!at: anInteger 	"Answer my element at index anInteger. at: is used by a knowledgeable	client to access an existing element"	(anInteger < 1 or: [anInteger + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^ array at: anInteger + firstIndex - 1]! !!OrderedCollection methodsFor: 'accessing'!at: anInteger put: anObject 	"Put anObject at element index anInteger. at:put: cannot be used to	append, front or back, to an ordered collection; it is used by a	knowledgeable client to replace an element."	| index |	index _ anInteger asInteger.	(index < 1 or: [index + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^array at: index + firstIndex - 1 put: anObject]! !!OrderedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:42'!capacity	"Answer the current capacity of the receiver."	^ array size! !!OrderedCollection methodsFor: 'accessing'!inspect	"Open an OrderedCollectionInspector on the receiver.	Use basicInspect to get a normal type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!OrderedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:39'!size	"Answer how many elements the receiver contains."	^ lastIndex - firstIndex + 1! !!OrderedCollection methodsFor: 'copying'!copyEmpty	"Answer a copy of the receiver that contains no elements."	^self species new! !!OrderedCollection methodsFor: 'copying' stamp: 'di 12/12/2000 10:15'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection _ self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection addLast: (self at: index)].	^ targetCollection! !!OrderedCollection methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver with replacementCollection's elements in	place of the receiver's start'th to stop'th elements. This does not expect	a 1-1 map from replacementCollection to the start to stop elements, so it	will do an insert or append."	| newOrderedCollection delta startIndex stopIndex |	"if start is less than 1, ignore stop and assume this is inserting at the front. 	if start greater than self size, ignore stop and assume this is appending. 	otherwise, it is replacing part of me and start and stop have to be within my 	bounds. "	delta _ 0.	startIndex _ start.	stopIndex _ stop.	start < 1		ifTrue: [startIndex _ stopIndex _ 0]		ifFalse: [startIndex > self size				ifTrue: [startIndex _ stopIndex _ self size + 1]				ifFalse: 					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])						ifTrue: [self errorOutOfBounds].					delta _ stopIndex - startIndex + 1]].	newOrderedCollection _ 		self species new: self size + replacementCollection size - delta.	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].	1 to: replacementCollection size do: 		[:index | newOrderedCollection add: (replacementCollection at: index)].	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].	^newOrderedCollection! !!OrderedCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection _ self copy.	newCollection add: newElement.	^newCollection! !!OrderedCollection methodsFor: 'copying' stamp: 'sw 1/26/96'!reversed	"Answer a copy of the receiver with element order reversed.  "	| newCol |	newCol _ self species new.	self reverseDo:		[:elem | newCol addLast: elem].	^ newCol"#(2 3 4 'fred') reversed"! !!OrderedCollection methodsFor: 'adding'!add: newObject	^self addLast: newObject! !!OrderedCollection methodsFor: 'adding'!add: newObject after: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just succeeding oldObject. Answer newObject."		| index |	index _ self find: oldObject.	self insert: newObject before: index + 1.	^newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'di 3/15/1999 14:01'!add: newObject afterIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just after index. Answer newObject."	self insert: newObject before: firstIndex + index.	^ newObject! !!OrderedCollection methodsFor: 'adding'!add: newObject before: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding oldObject. Answer newObject."		| index |	index _ self find: oldObject.	self insert: newObject before: index.	^newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'BG 1/9/2004 12:30'!add: newObject beforeIndex: index  "Add the argument, newObject, as an element of the receiver. Put it in  the sequence just before index. Answer newObject." self add: newObject afterIndex: index - 1. ^ newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'sma 5/12/2000 11:26'!addAll: aCollection 	"Add each element of aCollection at my end. Answer	aCollection."	^ self addAllLast: aCollection! !!OrderedCollection methodsFor: 'adding'!addAllFirst: anOrderedCollection 	"Add each element of anOrderedCollection at the beginning of the 	receiver. Answer anOrderedCollection."	anOrderedCollection reverseDo: [:each | self addFirst: each].	^anOrderedCollection! !!OrderedCollection methodsFor: 'adding' stamp: 'sw 3/1/2001 11:03'!addAllFirstUnlessAlreadyPresent: anOrderedCollection 	"Add each element of anOrderedCollection at the beginning of the receiver, preserving the order, but do not add any items that are already in the receiver.  Answer anOrderedCollection."	anOrderedCollection reverseDo:		[:each | (self includes: each) ifFalse: [self addFirst: each]].	^ anOrderedCollection! !!OrderedCollection methodsFor: 'adding'!addAllLast: anOrderedCollection 	"Add each element of anOrderedCollection at the end of the receiver. 	Answer anOrderedCollection."	anOrderedCollection do: [:each | self addLast: each].	^anOrderedCollection! !!OrderedCollection methodsFor: 'adding'!addFirst: newObject 	"Add newObject to the beginning of the receiver. Answer newObject."	firstIndex = 1 ifTrue: [self makeRoomAtFirst].	firstIndex _ firstIndex - 1.	array at: firstIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding'!addLast: newObject 	"Add newObject to the end of the receiver. Answer newObject."	lastIndex = array size ifTrue: [self makeRoomAtLast].	lastIndex _ lastIndex + 1.	array at: lastIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'ajh 5/22/2003 12:03'!at: index ifAbsentPut: block	"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)"	| v |	index <= self size ifTrue: [		^ (v _ self at: index)			ifNotNil: [v]			ifNil: [self at: index put: block value]	].	[self size < index] whileTrue: [self add: nil].	^ self at: index put: block value! !!OrderedCollection methodsFor: 'adding'!grow	"Become larger. Typically, a subclass has to override this if the subclass	adds instance variables."	| newArray |	newArray _ Array new: self size + self growSize.	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array _ newArray! !!OrderedCollection methodsFor: 'adding'!growSize	^ array size max: 2! !!OrderedCollection methodsFor: 'removing'!remove: oldObject ifAbsent: absentBlock	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[oldObject = (array at: index)				ifTrue: 					[self removeIndex: index.					^ oldObject]				ifFalse: [index _ index + 1]].	^ absentBlock value! !!OrderedCollection methodsFor: 'removing' stamp: 'raok 4/27/2001 15:35'!removeAllSuchThat: aBlock 	"Remove each element of the receiver for which aBlock evaluates to true.	The method in Collection is O(N^2), this is O(N)."	| n |	n _ firstIndex.	firstIndex to: lastIndex do: [:index |	    (aBlock value: (array at: index)) ifFalse: [			array at: n put: (array at: index).			n _ n + 1]].	n to: lastIndex do: [:index | array at: index put: nil].	lastIndex _ n - 1! !!OrderedCollection methodsFor: 'removing' stamp: 'ar 5/22/2000 12:19'!removeAt: index	| removed |	removed _ self at: index.	self removeIndex: index + firstIndex - 1.	^removed! !!OrderedCollection methodsFor: 'removing'!removeFirst	"Remove the first element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| firstObject |	self emptyCheck.	firstObject _ array at: firstIndex.	array at: firstIndex put: nil.	firstIndex _ firstIndex + 1.	^ firstObject! !!OrderedCollection methodsFor: 'removing' stamp: 'ajh 6/22/2003 14:37'!removeFirst: n	"Remove first n object into an array"	| list |	list _ Array new: n.	1 to: n do: [:i |		list at: i put: self removeFirst].	^ list! !!OrderedCollection methodsFor: 'removing'!removeLast	"Remove the last element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| lastObject |	self emptyCheck.	lastObject _ array at: lastIndex.	array at: lastIndex put: nil.	lastIndex _ lastIndex - 1.	^ lastObject! !!OrderedCollection methodsFor: 'removing' stamp: 'ajh 6/22/2003 14:36'!removeLast: n	"Remove last n object into an array with last in last position"	| list |	list _ Array new: n.	n to: 1 by: -1 do: [:i |		list at: i put: self removeLast].	^ list! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into a collection that is like me. Answer the new 	collection. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection _ self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (aBlock value: (array at: index))].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'bf 5/18/2000 17:34'!collect: aBlock from: fromIndex to: toIndex	"Override superclass in order to use addLast:, not at:put:."	| result |	(fromIndex < 1 or:[toIndex + firstIndex - 1 > lastIndex])		ifTrue: [^self errorNoSuchElement].	result _ self species new: toIndex - fromIndex + 1.	firstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:		[:index | result addLast: (aBlock value: (array at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating'!do: aBlock 	"Override the superclass for performance reasons."	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[aBlock value: (array at: index).			index _ index + 1]! !!OrderedCollection methodsFor: 'enumerating'!reverseDo: aBlock 	"Override the superclass for performance reasons."	| index |	index _ lastIndex.	[index >= firstIndex]		whileTrue: 			[aBlock value: (array at: index).			index _ index - 1]! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:13'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection element |	newCollection _ self copyEmpty.	firstIndex to: lastIndex do:		[:index |		(aBlock value: (element _ array at: index))			ifTrue: [newCollection addLast: element]].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result _ self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating' stamp: 'bf 5/16/2000 16:30'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection _ self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (elementAndIndexBlock			value: (array at: index)			value: index - firstIndex + 1)].	^ newCollection! !!OrderedCollection methodsFor: 'private'!collector  "Private"	^ array! !!OrderedCollection methodsFor: 'private'!errorConditionNotSatisfied	self error: 'no element satisfies condition'! !!OrderedCollection methodsFor: 'private'!errorNoSuchElement	self error: 'attempt to index non-existent element in an ordered collection'! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:26'!find: oldObject  "  This method answers an index in the range firstIndex .. lastIndex, which is meant for internal use only.     Never use this method in your code, the methods for public use are:        #indexOf:        #indexOf:ifAbsent: "	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue:			[(array at: index) = oldObject ifTrue: [^ index].			index _ index + 1].	self errorNotFound: oldObject! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:29'!insert: anObject before: spot  "  spot is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.      Never use this method in your code, it is meant for private use by OrderedCollection only.     The methods for use are:        #add:before:   to insert an object before another object        #add:beforeIndex:   to insert an object before a given position. "	| "index" delta spotIndex|	spotIndex _ spot.	delta _ spotIndex - firstIndex.	firstIndex = 1		ifTrue: 			[self makeRoomAtFirst.			spotIndex _ firstIndex + delta].	firstIndex _ firstIndex - 1.	array		replaceFrom: firstIndex		to: spotIndex - 2		with: array		startingAt: firstIndex + 1.	array at: spotIndex - 1 put: anObject."	index _ firstIndex _ firstIndex - 1.	[index < (spotIndex - 1)]		whileTrue: 			[array at: index put: (array at: index + 1).			index _ index + 1].	array at: index put: anObject."	^ anObject! !!OrderedCollection methodsFor: 'private'!makeRoomAtFirst	| delta index |	delta _ array size - self size.	delta = 0 ifTrue: 			[self grow.			delta _ array size - self size].	lastIndex = array size ifTrue: [^ self]. "just in case we got lucky"	index _ array size.	[index > delta]		whileTrue: 			[array at: index put: (array at: index - delta + firstIndex - 1).			array at: index - delta + firstIndex - 1 put: nil.			index _ index - 1].	firstIndex _ delta + 1.	lastIndex _ array size! !!OrderedCollection methodsFor: 'private'!makeRoomAtLast	| newLast delta |	newLast _ self size.	array size - self size = 0 ifTrue: [self grow].	(delta _ firstIndex - 1) = 0 ifTrue: [^ self].	"we might be here under false premises or grow did the job for us"	1 to: newLast do:		[:index |		array at: index put: (array at: index + delta).		array at: index + delta put: nil].	firstIndex _ 1.	lastIndex _ newLast! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:28'!removeIndex: removedIndex  "  removedIndex is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.    Never use this method in your code, it is meant for private use by OrderedCollection only.     The method for public use is:        #removeAt: "	array 		replaceFrom: removedIndex 		to: lastIndex - 1 		with: array 		startingAt: removedIndex+1.	array at: lastIndex put: nil.	lastIndex _ lastIndex - 1.! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!reset	firstIndex _ array size // 3 max: 1.	lastIndex _ firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'ar 4/16/1999 07:59'!resetTo: index	firstIndex _ index.	lastIndex _ firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!setCollection: anArray	array _ anArray.	self reset! !!OrderedCollection methodsFor: 'private' stamp: 'apb 10/15/2000 18:10'!setContents: anArray	array _ anArray.	firstIndex _ 1.	lastIndex _ array size.! !!OrderedCollection methodsFor: 'testing' stamp: 'bf 8/20/1999 15:08'!hasContentsInExplorer	^self isEmpty not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderedCollection class	instanceVariableNames: ''!!OrderedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:41'!new	^ self new: 10! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:42'!new: anInteger 	^ super new setCollection: (Array new: anInteger)! !!OrderedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection _ self new: aCollection size.	newCollection addAll: aCollection.	^newCollection"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'apb 10/15/2000 22:02'!ofSize: n	"Create a new collection of size n with nil as its elements.	This method exists because OrderedCollection new: n creates an	empty collection,  not one of size n."	| collection |	collection _ self new: n.	collection setContents: (collection collector).	^ collection! !Inspector subclass: #OrderedCollectionInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'dew 9/19/2001 03:27'!fieldList	object ifNil: [ ^ OrderedCollection new].	^ self baseFieldList ,		(object size <= (self i1 + self i2)			ifTrue: [(1 to: object size)						collect: [:i | i printString]]			ifFalse: [(1 to: self i1) , (object size-(self i2-1) to: object size)						collect: [:i | i printString]])"OrderedCollection new inspect(OrderedCollection newFrom: #(3 5 7 123)) inspect(OrderedCollection newFrom: (1 to: 1000)) inspect"! !!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'sw 9/16/97 22:38'!replaceSelectionValue: anObject 	"The receiver has a list of variables of its inspected object. One of these 	is selected. The value of the selected variable is set to the value, anObject."	(selectionIndex - 2) <= object class instSize		ifTrue: [^ super replaceSelectionValue: anObject].	object at: self selectedObjectIndex put: anObject! !!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'sw 9/16/97 22:28'!selectedObjectIndex	"Answer the index of the inspectee's collection that the current selection refers to."	| basicIndex |	basicIndex _ selectionIndex - 2 - object class instSize.	^ (object size <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [basicIndex]		ifFalse: [object size - (self i1 + self i2) + basicIndex]! !!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'sw 9/16/97 22:39'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	(selectionIndex - 2) <= object class instSize		ifTrue: [^ super selection].	^ object at: self selectedObjectIndex! !Notification subclass: #OutOfScopeNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!OutOfScopeNotification methodsFor: 'as yet unclassified' stamp: 'RAA 2/5/2001 10:41'!defaultAction	self resume: false! !Browser subclass: #PackagePaneBrowser	instanceVariableNames: 'package packageListIndex packageList'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!PackagePaneBrowser commentStamp: '<historical>' prior: 0!A package browser represents a hierarchical query path through an organization of class and method information.   It parses class categories into a two-level hierarchy on the first '-' character, giving "packages" (e.g.,  Magnitude, Collections, Graphics, etc.), and "categories" (e.g., Magnitude-General and Magnitude-Number).Instance Variables:	package  <Symbol> the "category header," e.g., #Magnitudes or #Collections	packageListIndex <Integer> The index in the package list	packageList  <OrderedCollection of String> the list of package names!!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'sw 1/13/2000 16:45'!defaultBrowserTitle	^ 'Package Browser'! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'stp 10/06/1998 22:02'!systemOrganizer: aSystemOrganizer 	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."	super systemOrganizer: aSystemOrganizer .	packageListIndex := 0! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'JF 7/30/2003 12:35'!categoryExistsForPackage	^ self hasPackageSelected		and: [(systemOrganizer categories indexOf: self package asSymbol) ~= 0]! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'JF 7/30/2003 12:24'!hasPackageSelected	^ packageListIndex ~= 0! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'BG 10/30/2003 21:09'!openEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"PackageBrowser openBrowser"	| packageListView systemCategoryListView classListView messageCategoryListView	  messageListView browserCodeView topView switchView annotationPane underPane y optionalButtonsView |	topView := StandardSystemView new model: self.	topView borderWidth: 1.  "label and minSize taken care of by caller"	packageListView := PluggableListView on: self		list: #packageList		selected: #packageListIndex		changeSelected: #packageListIndex:		menu: #packageMenu:.	packageListView window: (0 @ 0 extent: 20 @ 70).	topView addSubView: packageListView.	systemCategoryListView := PluggableListView on: self		list: #systemCategoryList		selected: #systemCategoryListIndex		changeSelected: #systemCategoryListIndex:		menu: #systemCategoryMenu:.	systemCategoryListView window: (20 @ 0 extent: 30 @ 70).	topView addSubView: systemCategoryListView.	classListView := PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:shifted:.	classListView window: (0 @ 0 extent: 50 @ 62).	topView addSubView: classListView toRightOf: systemCategoryListView.	switchView := self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView := PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView := PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	self wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: packageListView.			underPane _ annotationPane.			y _ 110 - self optionalAnnotationHeight]		ifFalse:			[underPane _ packageListView.			y _ 110].	self wantsOptionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView := PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'JF 7/30/2003 12:25'!package	"Answer the receiver's 'package'."	^ self hasPackageSelected		ifFalse: [nil]		ifTrue: [self packageList at: packageListIndex]! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'stp 10/05/1998 20:36'!packageList	"Answer a list of the packages in the current system organization."	| str cats stream |	str := Set new: 100.	stream := WriteStream on: (Array new: 100).	systemOrganizer categories do:		[ :categ | 		cats := categ asString copyUpTo: $-.		(str includes: cats) ifFalse: 			[str add: cats.			stream nextPut: cats]].	^stream contents! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'stp 10/05/1998 19:48'!packageListIndex	"Answer the index of the current package selection."	^packageListIndex! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'stp 12/01/1998 02:46'!packageListIndex: anInteger 	"Set anInteger to be the index of the current package selection."	packageListIndex := anInteger.	anInteger = 0		ifFalse: [package := self packageList at: packageListIndex].	messageCategoryListIndex := 0.	systemCategoryListIndex := 0.	messageListIndex := 0.	classListIndex := 0.	self setClassOrganizer.	self changed: #packageSelectionChanged.	self changed: #packageListIndex.	"update my selection"	self changed: #systemCategoryList.	"update the category list"	self systemCategoryListIndex: 0.	"update category list selection"! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'stp 10/06/1998 19:59'!packageMenu: aMenu	"Answer a Menu of operations on class packages to be 	displayed when the operate menu button is pressed."	^aMenu			labels: 'find class...\recent classes...\reorganize\update' withCRs			lines: #(2)			selections: #(#findClass #recent #editSystemCategories #updatePackages)! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'nk 2/14/2004 15:09'!updatePackages	"Update the contents of the package list."	self editSelection: #none.	self changed: #packageList.	self changed: #package.	self packageListIndex: 0 ! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'JF 7/30/2003 12:23'!hasSystemCategorySelected	^ systemCategoryListIndex ~= 0! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'stp 01/13/2000 12:59'!selectCategoryForClass: theClass	"Set the package and category lists to display the given class."	| cat |	cat := theClass category.	self packageListIndex: (self packageList indexOf: (cat copyUpTo: $-)).		self systemCategoryListIndex: (self systemCategoryList indexOf: 			(cat copyFrom: ((cat indexOf: $- ifAbsent: [0]) + 1) to: cat size)).! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'di 12/20/1999 20:16'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	systemCategoryListIndex = 0		ifTrue: [^nil].	packageListIndex = 0		ifTrue: [^ self systemCategoryList at: systemCategoryListIndex].	^ self package , '-' , (self systemCategoryList at: systemCategoryListIndex)! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'di 12/16/1999 16:14'!systemCategoryList	"Answer the sequenceable collection containing the class categories that 	the receiver accesses."	| prefix |	packageListIndex = 0 ifTrue: [^ systemOrganizer categories].	prefix := self package, '-'.	^ Array streamContents:		[:strm |		systemOrganizer categories do: 			[ :cat | (cat beginsWith: prefix) ifTrue:				[strm nextPut: (cat copyFrom: prefix size + 1 to: cat size)]]]! !!PackagePaneBrowser methodsFor: 'class list' stamp: 'JF 7/30/2003 12:26'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	^ self hasSystemCategorySelected 		ifFalse:			[self packageClasses]		ifTrue: [systemOrganizer listAtCategoryNumber:			(systemOrganizer categories indexOf: self selectedSystemCategoryName asSymbol)]! !!PackagePaneBrowser methodsFor: 'class list' stamp: 'JF 7/30/2003 12:36'!packageClasses	^ self categoryExistsForPackage		ifFalse: [Array new]		ifTrue:			[systemOrganizer listAtCategoryNumber:				(systemOrganizer categories indexOf: self package asSymbol)]! !!PackagePaneBrowser methodsFor: 'class list' stamp: 'ak 6/4/2000 09:07'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	| name envt |	(name _ self selectedClassName) ifNil: [^ nil].	"(envt _ self selectedEnvironment) ifNil: [^ nil]."	envt_(Smalltalk environmentForCategory: self selectedSystemCategoryName).	^ envt at: name! !!PackagePaneBrowser methodsFor: 'dragNDrop util' stamp: 'ls 6/22/2001 23:21'!dstCategoryDstListMorph: dstListMorph internal: internal 	| dropItem |	^ internal & (dstListMorph getListSelector == #systemCategoryList)		ifTrue: [(dropItem _ dstListMorph potentialDropItem) ifNotNil: [(self package , '-' , dropItem) asSymbol]]		ifFalse: [self selectedSystemCategoryName]! !!PackagePaneBrowser methodsFor: 'dragNDrop' stamp: 'mir 5/29/2000 11:54'!changeCategoryForClass: class srcSystemCategory: srcSystemCategorySel atListMorph: dstListMorph internal: internal copy: copyFlag 	"only move semantic"	| newClassCategory success |	self flag: #stringSymbolProblem.	success _ copyFlag not ifFalse: [^ false].	newClassCategory _ self dstCategoryDstListMorph: dstListMorph internal: internal.	(success _ newClassCategory notNil & (newClassCategory ~= class category))		ifTrue: 			[class category: newClassCategory.			self changed: #classList.			internal ifFalse: [self selectClass: class]].	^ success! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PackagePaneBrowser class	instanceVariableNames: ''!!PackagePaneBrowser class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 13:15'!initialize	self registerInFlapsRegistry.! !!PackagePaneBrowser class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 13:15'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(PackagePaneBrowser	prototypicalToolWindow		'Packages'			'Package Browser:  like a System Browser, except that if has extra level of categorization in the top-left pane, such that class-categories are further organized into groups called "packages"') 						forFlapNamed: 'Tools']! !!PackagePaneBrowser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:38'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !DisplayText subclass: #Paragraph	instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'ST80-Support'!!Paragraph commentStamp: '<historical>' prior: 0!I represent displayable text that has been decoraged with margin alignment, line leading, and tab settings.!!Paragraph methodsFor: 'accessing'!backgroundColor	backColor == nil ifTrue: [^ Color white].	^ backColor! !!Paragraph methodsFor: 'accessing'!clippingRectangle 	"Answer the rectangle, defined in absolute coordinates, whose 	intersection with the destinationForm is the area in which the characters 	are constrained to display."	^clippingRectangle! !!Paragraph methodsFor: 'accessing' stamp: 'di 10/5/97 15:33'!clippingRectangle: clipRect 	clippingRectangle _ clipRect! !!Paragraph methodsFor: 'accessing'!compositionRectangle	"Answer the rectangle whose width is the dimension, modified by 	indents and tabsLevels, against which line wraparound is measured. The 	height of the compositionRectangle is reset each time recomposition is 	required."	^compositionRectangle! !!Paragraph methodsFor: 'accessing'!compositionRectangle: compRectangle 	"Set the rectangle whose width is the dimension, modified by indents and 	tabsLevels, against which line wraparound is measured."	compositionRectangle _ compRectangle.	self composeAll! !!Paragraph methodsFor: 'accessing'!destinationForm 	 "Answer the Form into which the characters are scanned."	^destinationForm! !!Paragraph methodsFor: 'accessing'!fillColor 	"Answer the Form with which each character is combined by the scanner 	before applying the rule for display."	^mask! !!Paragraph methodsFor: 'accessing'!fillColor: maskForm 	"Set the argument, maskForm, to be the form with which each character 	is combined by the scanner before applying the rule for display."	mask _ maskForm! !!Paragraph methodsFor: 'accessing'!height 	"Answer the height of the composition rectangle."	^compositionRectangle height! !!Paragraph methodsFor: 'accessing'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	arrayIndex _ lineIndex.	[first _ (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex _ arrayIndex - 1].	last _ (lines at: lastLine) last.	reader _ ReadStream on: text string from: first to: last.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ first - 1 + leadingTabs.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = last | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!Paragraph methodsFor: 'accessing'!mask 	"Answer the Form with which each character is combined by the scanner 	before applying the rule for display."	^mask! !!Paragraph methodsFor: 'accessing'!numberOfLines 	"Answer the number of lines of text in the receiver."	^lastLine! !!Paragraph methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'accessing'!rule 	"Answer the rule according to which character display behaves. For 	example, rule may equal over, under, reverse."	^rule! !!Paragraph methodsFor: 'accessing'!rule: ruleInteger 	"Set the rule according to which character display behaves."	rule _ ruleInteger! !!Paragraph methodsFor: 'accessing' stamp: 'sw 10/29/1999 18:11'!stringAtLineNumber: aNumber	(aNumber > lastLine or: [aNumber < 1]) ifTrue: [^ nil].	^ (text string copyFrom: (lines at: aNumber) first to: (lines at: aNumber) last) copyWithout: Character cr! !!Paragraph methodsFor: 'accessing'!text: aText 	"Set the argument, aText, to be the text for the receiver."	text _ aText.	self composeAll! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium	"Because Paragraphs cache so much information, computation is avoided	and displayAt: 0@0 is not appropriate here."	self displayOn: aDisplayMedium		at: compositionRectangle topLeft		clippingBox: clippingRectangle		rule: rule		fillColor: mask! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint	"Use internal clippingRect; destination cliping is done during actual display."	self displayOn: aDisplayMedium at: aPoint		clippingBox: (clippingRectangle translateBy: aPoint - compositionRectangle topLeft)		rule: rule fillColor: mask! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Default display message when aDisplayPoint is in absolute screen	coordinates."	rule _ ruleInteger.	mask _ aForm.	clippingRectangle _ clipRectangle.	compositionRectangle _ aDisplayPoint extent: compositionRectangle extent.	(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].	self displayOn: aDisplayMedium lines: (1 to: lastLine)! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	self				"Assumes offset has been set!!!!!!!!!!"	  displayOn: aDisplayMedium	  at: (offset 			+ (displayTransformation applyTo: relativePoint) 			- alignmentPoint) rounded	  clippingBox: clipRectangle	  rule: ruleInteger	  fillColor: aForm.	! !!Paragraph methodsFor: 'display box access'!boundingBox	^offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'display box access'!computeBoundingBox	^offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'composition' stamp: 'ar 5/18/2000 18:34'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'composition'!wrappingBox: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap 	within the rectangle, compositionRect, and the display of the text is 	clipped by the rectangle, clippingRect."	self compositionRectangle: compositionRect copy				text: text				style: textStyle				offset: offset.	clippingRectangle _ clippingRect copy! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/18/2000 18:33'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for characters in the text at point aPoint. It is 	assumed that aPoint has been transformed into coordinates appropriate to 	the receiver's destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockAtPoint: aPoint in: self! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/18/2000 18:33'!characterBlockForIndex: targetIndex 	"Answer a CharacterBlock for character in the text at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockForIndex: targetIndex in: self! !!Paragraph methodsFor: 'character location' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'selecting' stamp: 'ar 5/28/2000 12:10'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box _ CaretForm boundingBox.	f _ Form extent: box extent depth: depth.	map _ (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb _ BitBlt current toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'dvf 10/1/2003 13:28'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model in: self at: clickPoint editor: aController) ifTrue: [action _ true]]]]].	^ action! !!Paragraph methodsFor: 'selecting'!extendSelectionAt: beginBlock endBlock: endBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."		(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock		ifTrue: [^self mouseMovedFrom: beginBlock 					pivotBlock: endBlock					showingCaret: (beginBlock = endBlock)]		ifFalse: [^self mouseMovedFrom: endBlock 					pivotBlock: beginBlock					showingCaret: (beginBlock = endBlock)]! !!Paragraph methodsFor: 'selecting' stamp: 'th 9/19/2002 17:27'!extendSelectionMark: markBlock pointBlock: pointBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."	true 		ifTrue:[^self mouseMovedFrom: pointBlock					pivotBlock: markBlock					showingCaret:(pointBlock = markBlock)]		ifFalse:		[	| beginBlock endBlock |			beginBlock _ markBlock min: pointBlock.			endBlock _ markBlock max: endBlock.				(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock				ifTrue: [^self mouseMovedFrom: beginBlock 							pivotBlock: endBlock							showingCaret: (beginBlock = endBlock)]				ifFalse: [^self mouseMovedFrom: endBlock 							pivotBlock: beginBlock							showingCaret: (beginBlock = endBlock)]		]! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/1/1999 12:31'!hiliteRect: rect	| highlightColor |	highlightColor _ Color quickHighLight: destinationForm depth.	rect ifNotNil: [		destinationForm			fill: rect			rule: Form reverse			fillColor: highlightColor.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: highlightColor" ].! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/8/97 12:25'!mouseMovedFrom: beginBlock pivotBlock: pivotBlock showingCaret: caretOn 	| startBlock stopBlock showingCaret |	stopBlock _ startBlock _ beginBlock.	showingCaret _ caretOn.	[Sensor redButtonPressed]		whileTrue: 			[stopBlock _ self characterBlockAtPoint: Sensor cursorPoint.			stopBlock = startBlock				ifFalse: 					[showingCaret						ifTrue: 							[showingCaret _ false.							self reverseFrom: pivotBlock to: pivotBlock].			((startBlock >= pivotBlock and: [stopBlock >= pivotBlock])				or: [startBlock <= pivotBlock and: [stopBlock <= pivotBlock]])				ifTrue: 					[self reverseFrom: startBlock to: stopBlock.					startBlock _ stopBlock]				ifFalse: 					[self reverseFrom: startBlock to: pivotBlock.					self reverseFrom: pivotBlock to: stopBlock.					startBlock _ stopBlock].			(clippingRectangle containsRect: stopBlock) ifFalse:				[stopBlock top < clippingRectangle top				ifTrue: [self scrollBy: stopBlock top - clippingRectangle top						withSelectionFrom: pivotBlock to: stopBlock]				ifFalse: [self scrollBy: stopBlock bottom + textStyle lineGrid - clippingRectangle bottom						withSelectionFrom: pivotBlock to: stopBlock]]]].	pivotBlock = stopBlock ifTrue:		[showingCaret ifFalse:  "restore caret"			[self reverseFrom: pivotBlock to: pivotBlock]].	^ Array with: pivotBlock with: stopBlock! !!Paragraph methodsFor: 'selecting'!mouseSelect	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes.  Return quickly if the button is noticed up	to make double-click more responsive."	| pivotBlock startBlock stopBlock origPoint stillDown |	stillDown _ Sensor redButtonPressed.	pivotBlock _ startBlock _ stopBlock _		self characterBlockAtPoint: (origPoint _ Sensor cursorPoint).	stillDown _ stillDown and: [Sensor redButtonPressed].	self reverseFrom: startBlock to: startBlock.	[stillDown and: [Sensor cursorPoint = origPoint]] whileTrue:		[stillDown _ Sensor redButtonPressed].	(stillDown and: [clippingRectangle containsPoint: Sensor cursorPoint])		ifFalse: [^Array with: pivotBlock with: stopBlock].	^ self mouseMovedFrom: startBlock 		pivotBlock: pivotBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!mouseSelect: clickPoint 	"Track text selection and answer with an Array of two CharacterBlocks."	| startBlock |	startBlock _ self characterBlockAtPoint: clickPoint.	self reverseFrom: startBlock to: startBlock.	^ self mouseMovedFrom: startBlock 		pivotBlock: startBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline caret |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		caret _ self caretFormForDepth: Display depth.		^ caret  "Use a caret to indicate null selection"				displayOn: destinationForm				at: characterBlock1 topLeft + (-3 @ baseline)				clippingBox: clippingRectangle				rule: (false "Display depth>8" ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle _ 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'selecting' stamp: 'di 12/1/97 04:43'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ Array with: (characterBlock1 topLeft extent: 1 @ baseline)].	visibleRectangle _ clippingRectangle intersect: compositionRectangle.	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	^ (Array with: initialRectangle with: interiorRectangle with: finalRectangle)			select: [:rect | rect notNil]! !!Paragraph methodsFor: 'scrolling'!scrollBy: heightToMove 	^ self scrollBy: heightToMove withSelectionFrom: nil to: nil! !!Paragraph methodsFor: 'scrolling' stamp: 'hmm 9/16/2000 21:30'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max _ 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min _ 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount _ ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [destinationForm deferUpdatesIn: clippingRectangle while: [					self scrollUncheckedBy: amount						withSelectionFrom: startBlock to: stopBlock].				^ true]		ifFalse: [^ false]! !!Paragraph methodsFor: 'scrolling'!scrollDelta	"By comparing this before and after, you know if scrolling happened"	^ clippingRectangle top - compositionRectangle top! !!Paragraph methodsFor: 'scrolling'!scrollUncheckedBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Scroll by the given amount.  Copy bits where possible, display the rest.	If selection blocks are not nil, then select the newly visible text as well."	| savedClippingRectangle delta |	delta _ 0 @ (0 - heightToMove).	compositionRectangle _ compositionRectangle translateBy: delta.	startBlock == nil ifFalse:		[startBlock moveBy: delta.		stopBlock moveBy: delta].	savedClippingRectangle _ clippingRectangle.	clippingRectangle _ clippingRectangle intersect: Display boundingBox.	heightToMove abs >= clippingRectangle height	  ifTrue: 		["Entire visible region must be repainted"		self displayLines: (1 to: lastLine) affectedRectangle: clippingRectangle]	  ifFalse:		["Copy bits where possible / display the rest"		destinationForm			copyBits: clippingRectangle from: destinationForm			at: clippingRectangle topLeft + delta			clippingBox: clippingRectangle			rule: Form over fillColor: nil.		"Set clippingRectangle to 'vacated' area for lines 'pulled' into view."		clippingRectangle _ heightToMove < 0			ifTrue:  "On the top"				[clippingRectangle topLeft corner: clippingRectangle topRight + delta]			ifFalse:  "At the bottom"				[clippingRectangle bottomLeft + delta corner: clippingRectangle bottomRight].		self displayLines: (1 to: lastLine)   "Refresh vacated region"			affectedRectangle: clippingRectangle].	startBlock == nil ifFalse:		[self reverseFrom: startBlock to: stopBlock].	"And restore the clippingRectangle to its original value. "	clippingRectangle _ savedClippingRectangle! !!Paragraph methodsFor: 'alignment'!centered 	"Set the alignment for the style with which the receiver displays its text 	so that text is centered in the composition rectangle."	textStyle alignment: Centered! !!Paragraph methodsFor: 'alignment'!justified 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text end on an even border in the 	composition rectangle."	textStyle alignment: Justified! !!Paragraph methodsFor: 'alignment'!leftFlush 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text begin on an even border in the 	composition rectangle. This is also known as ragged-right."	textStyle alignment: LeftFlush! !!Paragraph methodsFor: 'alignment'!rightFlush 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text end on an even border in the 	composition rectangle but the beginning of each line does not. This is 	also known as ragged-left."	textStyle alignment: RightFlush! !!Paragraph methodsFor: 'alignment'!toggleAlignment 	"Set the alignment for the style with which the receiver displays its text 	so that it moves from centered to justified to leftFlush to rightFlush and 	back to centered again."	textStyle alignment: textStyle alignment + 1! !!Paragraph methodsFor: 'indicating'!flash 	"Complement twice the visible area in which the receiver displays."	Display flash: clippingRectangle! !!Paragraph methodsFor: 'indicating'!outline 	"Display a border around the visible area in which the receiver presents 	its text."	clippingRectangle bottom <= compositionRectangle bottom	  ifTrue: [Display 				border: (clippingRectangle intersect: compositionRectangle) 				width: 2]	  ifFalse: [Display 				border: (clippingRectangle intersect: destinationForm boundingBox)				width: 2].	! !!Paragraph methodsFor: 'utilities'!clearVisibleRectangle 	"Display the area in which the receiver presents its text so that the area 	is all one tone--in this case, all white."	destinationForm	  fill: clippingRectangle	  rule: rule	  fillColor: self backgroundColor! !!Paragraph methodsFor: 'utilities'!deepCopy	"Don't want to copy the destForm (Display) or fonts in the TextStyle.  9/13/96 tk"	| new |	new _ self copy.	new textStyle: textStyle copy.	new destinationForm: destinationForm.	new lines: lines copy.	new text: text deepCopy.	^ new! !!Paragraph methodsFor: 'utilities'!destinationForm: destForm	destinationForm _ destForm! !!Paragraph methodsFor: 'utilities'!fit	"Make the bounding rectangle of the receiver contain all the text without 	changing the width of the receiver's composition rectangle."	[(self lineIndexOfTop: clippingRectangle top) = 1]		whileFalse: [self scrollBy: (0-1)*textStyle lineGrid].	self updateCompositionHeight.	clippingRectangle _ clippingRectangle withBottom: compositionRectangle bottom! !!Paragraph methodsFor: 'utilities'!lines: lineArray	lines _ lineArray! !!Paragraph methodsFor: 'utilities'!visibleRectangle 	"May be less than the clippingRectangle if text ends part way down.	Also some fearful history includes Display intersection;	it shouldn't be necessary"	^ (clippingRectangle intersect: compositionRectangle)		intersect: destinationForm boundingBox! !!Paragraph methodsFor: 'converting' stamp: 'yo 6/23/2003 19:05'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	textStyle isTTCStyle ifTrue: [		theForm _  (Form extent: compositionRectangle extent depth: 32)		offset: offset.	] ifFalse: [		theForm _ (ColorForm extent: compositionRectangle extent)			offset: offset;			colors: (Array				with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])				with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	].	oldBackColor _ backColor.	oldForeColor _ foreColor.	backColor _ Color white.	foreColor _ Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor _ oldBackColor.	foreColor _ oldForeColor.	^ theForm"Example:| p |p _ 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!Paragraph methodsFor: 'converting'!asString	"Answer the string of characters of the receiver's text."	^text string! !!Paragraph methodsFor: 'converting'!asText	"Answer the receiver's text."	^text! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' stamp: 'tk 9/30/96'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	rule _ DefaultRule.	mask _ nil.		"was DefaultMask "	marginTabsLevel _ 0.	destinationForm _ Display.	offset _ aPoint.	^self composeAll! !!Paragraph methodsFor: 'private'!compositionRectangleDelta	"A handy number -- mostly for scrolling."	^compositionRectangle top - clippingRectangle top! !!Paragraph methodsFor: 'private'!displayLines: linesInterval 	^ self displayLines: linesInterval		affectedRectangle: self visibleRectangle! !!Paragraph methodsFor: 'private' stamp: 'ar 5/18/2000 18:34'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				DisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private'!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	saveDestinationForm _ destinationForm.	destinationForm _ aDisplayMedium.	self displayLines: lineInterval.	destinationForm _ saveDestinationForm! !!Paragraph methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex 	"Build the left margin for composition of a line. Depends upon	marginTabsLevel and the indent."	| indent |	lineIndex = 1		ifTrue: [indent _ textStyle firstIndent]		ifFalse: [indent _ textStyle restIndent].	^indent + (textStyle leftMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private' stamp: 'ar 12/15/2001 23:29'!leftMarginForDisplayForLine: lineIndex alignment: alignment	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(alignment = LeftFlush or: [alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad _ (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad _ 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']! !!Paragraph methodsFor: 'private'!lineAt: indexInteger put: aTextLineInterval 	"Store a line, track last, and grow lines if necessary."	indexInteger > lastLine ifTrue: [lastLine _ indexInteger].	lastLine > lines size ifTrue: [lines _ lines , (Array new: lines size)].	^lines at: indexInteger put: aTextLineInterval! !!Paragraph methodsFor: 'private'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	1 to: lastLine do: 		[:lineIndex | 		(lines at: lineIndex) last >= characterIndex ifTrue: [^lineIndex]].	^lastLine! !!Paragraph methodsFor: 'private'!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y _ compositionRectangle top.	1 to: lastLine do:		[:i | line _ lines at: i.		(y _ y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private'!lines	^lines! !!Paragraph methodsFor: 'private'!moveBy: delta	compositionRectangle _ compositionRectangle translateBy: delta.	clippingRectangle _ clippingRectangle translateBy: delta.! !!Paragraph methodsFor: 'private'!rightMarginForComposition	"Build the right margin for a line. Depends upon compositionRectangle	width, marginTabsLevel, and right indent."	^compositionRectangle width 		- (textStyle rightMarginTabAt: marginTabsLevel) 		- textStyle rightIndent! !!Paragraph methodsFor: 'private'!rightMarginForDisplay 	"Build the right margin for a line. Depends upon compositionRectangle	rightSide, marginTabsLevel, and right indent."	^compositionRectangle right - 		textStyle rightIndent - (textStyle rightMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded _ Rectangle origin: 0 @ 0 extent: 9999@9999.	compositionWidth _ self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle _ compositionRectangle withWidth: compositionWidth.	clippingRectangle _ compositionRectangle copy.	shrink _ unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect 	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle _ clipRect copy.	^self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: cf backColor: cb	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle _ clipRect copy.	self foregroundColor: cf backgroundColor: cb.	^ self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y _ y + (otherLines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!trimLinesTo: lastLineInteger	(lastLineInteger + 1 to: lastLine) do: [:i | lines at: i put: nil].	(lastLine _ lastLineInteger) < (lines size // 2) 		ifTrue: [lines _ lines copyFrom: 1 to: lines size - (lines size // 2)]! !!Paragraph methodsFor: 'private'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle _ compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle _ compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' stamp: 'di 8/30/97 11:14'!withClippingRectangle: clipRect do: aBlock	| saveClip |	saveClip _ clippingRectangle.	clippingRectangle _ clipRect.		aBlock value.	clippingRectangle _ saveClip! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Paragraph class	instanceVariableNames: ''!!Paragraph class methodsFor: 'instance creation'!new	"Do not allow an uninitialized view. Create with text that has no	characters."	^self withText: '' asText! !!Paragraph class methodsFor: 'instance creation'!withText: aText 	"Answer an instance of me with text set to aText and style set to the 	system's default text style."	^self withText: aText style: DefaultTextStyle copy! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle 	"Answer an instance of me with text set to aText and style set to 	aTextStyle."	^super new setWithText: aText style: aTextStyle! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: c1 backColor: c2	"Answer an instance of me with text set to aText and style set to 	aTextStyle, composition rectangle is compRect and the clipping rectangle 	is clipRect."	| para |	para _ super new.	para setWithText: aText		style: aTextStyle		compositionRectangle: compRect		clippingRectangle: clipRect		foreColor: c1 backColor: c2.	^para! !!Paragraph class methodsFor: 'examples' stamp: 'tk 9/30/96'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. "	| para point |	point _ Sensor waitButton.	para _ 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval lastParenLocation'	classVariableNames: 'ChangeText CmdActions FindText Keyboard ShiftCmdActions TextEditorYellowButtonMenu UndoInterval UndoMessage UndoParagraph UndoSelection Undone'	poolDictionaries: 'TextConstants'	category: 'Kernel-ST80 Remnants'!!ParagraphEditor commentStamp: '<historical>' prior: 0!I am a Controller for editing a Paragraph. I am a kind of ScrollController, so that more text can be created for the Paragraph than can be viewed on the screen. Editing messages are sent by issuing commands from a yellow button menu or from keys on the keyboard. My instances keep control as long as the cursor is within the view when the red or yellow mouse button is pressed; they give up control if the blue button is pressed.!!ParagraphEditor methodsFor: 'initialize-release'!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph _ nil].	paragraph _ aParagraph.	self resetState! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'th 10/21/2003 15:49'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	stopBlock _ paragraph defaultCharacterBlock.	self pointBlock: stopBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 5/15/2000 13:51'!stateArray	^ {ChangeText.		FindText.		UndoInterval.		UndoMessage.		UndoParagraph.		UndoSelection.		Undone.		self selectionInterval.		self startOfTyping.		emphasisHere}! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText _ stateArray at: 1.	FindText _ stateArray at: 2.	UndoInterval _ stateArray at: 3.	UndoMessage _ stateArray at: 4.	UndoParagraph _ stateArray at: 5.	UndoSelection _ stateArray at: 6.	Undone _ stateArray at: 7.	sel _ stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock _ stateArray at: 9.	emphasisHere _ stateArray at: 10.! !!ParagraphEditor methodsFor: 'accessing' stamp: 'tk 4/21/1998 09:55'!initialText	^ initialText! !!ParagraphEditor methodsFor: 'accessing'!replace: oldInterval with: newText and: selectingBlock 	"Replace the text in oldInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval _ self selectionInterval.	undoInterval = oldInterval ifFalse: [self selectInterval: oldInterval].	UndoSelection _ self selection.	self zapSelectionWith: newText.	selectingBlock value.	otherInterval _ self selectionInterval.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: otherInterval! !!ParagraphEditor methodsFor: 'accessing'!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ~~ nil ifTrue: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection _ self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!ParagraphEditor methodsFor: 'accessing'!setSearch: aString	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText string = aString		ifFalse: [FindText _ ChangeText _ aString asText]! !!ParagraphEditor methodsFor: 'accessing'!text	"Answer the text of the paragraph being edited."	^paragraph text! !!ParagraphEditor methodsFor: 'accessing' stamp: 'jm 3/18/98 20:38'!userHasEdited	"Note that the user has edited my text. Here it is just a noop so that the Character Recognizer won't fail when used with a vanilla ParagrahEditor."! !!ParagraphEditor methodsFor: 'controlling'!controlInitialize	super controlInitialize.	self recomputeInterval.	self initializeSelection.	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'controlling'!controlTerminate	self closeTypeIn.  "Must call to establish UndoInterval"	super controlTerminate.	self deselect! !!ParagraphEditor methodsFor: 'controlling' stamp: 'sma 3/11/2000 15:17'!normalActivity	self processKeyboard.	self processMouseButtons! !!ParagraphEditor methodsFor: 'scrolling'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: Preferences scrollBarWidth @ scrollBar inside height]		ifFalse:	[^0@0 extent:					Preferences scrollBarWidth 						@ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor methodsFor: 'scrolling'!markerDelta	^marker top - scrollBar top - ((paragraph clippingRectangle top -		paragraph compositionRectangle top) asFloat /			(self scrollRectangleHeight max: 1) asFloat *				scrollBar height asFloat) rounded! !!ParagraphEditor methodsFor: 'scrolling'!scrollAmount 	"Refer to the comment in ScrollController|scrollAmount."	^sensor cursorPoint y - scrollBar top! !!ParagraphEditor methodsFor: 'scrolling'!scrollBar	^ scrollBar! !!ParagraphEditor methodsFor: 'scrolling' stamp: 'BG 12/12/2003 15:31'!scrollBy: heightToMove	"Move the paragraph by heightToMove, and reset the text selection."	^ paragraph scrollBy: heightToMove withSelectionFrom: self pointBlock to: self markBlock! !!ParagraphEditor methodsFor: 'scrolling'!scrollRectangleHeight	^paragraph compositionRectangle height 		+ paragraph lineGrid! !!ParagraphEditor methodsFor: 'scrolling'!scrollToBottom	"Scroll so that the tail end of the text is visible in the view.  5/6/96 sw"	self scrollView: (paragraph clippingRectangle bottom 		- paragraph compositionRectangle bottom)! !!ParagraphEditor methodsFor: 'scrolling'!scrollToTop	"Scroll so that the paragraph is at the top of the view."	self scrollView: (paragraph clippingRectangle top 		- paragraph compositionRectangle top)! !!ParagraphEditor methodsFor: 'scrolling'!scrollView: anInteger 	"Paragraph scrolling uses opposite polarity"	^ self scrollBy: anInteger negated! !!ParagraphEditor methodsFor: 'scrolling'!updateMarker	"A variation of computeMarkerRegion--only redisplay the marker in the scrollbar if an actual change has occurred in the positioning of the paragraph."	self moveMarkerTo: self computeMarkerRegion! !!ParagraphEditor methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	^paragraph clippingRectangle top 		- paragraph compositionRectangle top 		- ((marker top - scrollBar inside top) asFloat 				/ scrollBar inside height asFloat * self scrollRectangleHeight asFloat)			roundTo: paragraph lineGrid! !!ParagraphEditor methodsFor: 'sensor access'!processBlueButton	"The user pressed the blue button on the mouse. Determine what action 	to take."	^self! !!ParagraphEditor methodsFor: 'sensor access'!processKeyboard	"Determine whether the user pressed the keyboard. If so, read the keys."	sensor keyboardPressed ifTrue: [self readKeyboard]! !!ParagraphEditor methodsFor: 'sensor access'!processMouseButtons	"Determine whether the user pressed any mouse button. For each possible 	button, determine what actions to take."	sensor redButtonPressed ifTrue: [self processRedButton].	sensor yellowButtonPressed ifTrue: [self processYellowButton].	sensor blueButtonPressed ifTrue: [self processBlueButton]! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'th 9/19/2002 18:24'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	|  selectionBlocks clickPoint oldDelta oldInterval previousMarkBlock previousPointBlock |	clickPoint _ sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval _ self selectionInterval.	previousMarkBlock _ self markBlock.	previousPointBlock _ self pointBlock.	oldDelta _ paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks _ paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks _ paragraph extendSelectionMark: self markBlock pointBlock: self pointBlock.			self closeTypeIn].	selectionShowing _ true.	self markBlock: (selectionBlocks at: 1).	self pointBlock: (selectionBlocks at: 2).	(self hasCaret		and: [previousMarkBlock = self markBlock and: [previousPointBlock = self pointBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval]! !!ParagraphEditor methodsFor: 'sensor access'!processYellowButton	"User pressed the yellow button on the mouse. Determine what actions to 	take."	self yellowButtonActivity! !!ParagraphEditor methodsFor: 'displaying'!display	"Redisplay the paragraph."	| selectionState |	selectionState _ selectionShowing.	self deselect.	paragraph foregroundColor: view foregroundColor			backgroundColor: view backgroundColor;			displayOn: Display.	selectionState ifTrue: [self select]! !!ParagraphEditor methodsFor: 'displaying'!flash	"Causes the view of the paragraph to complement twice in succession."	paragraph flash! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'jm 5/3/1998 19:19'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling."	initialText _ paragraph text copy.! !!ParagraphEditor methodsFor: 'menu messages'!again	"Text substitution. If the left shift key is down, the substitution is made 	throughout the entire Paragraph. Otherwise, only the next possible 	substitution is made.	Undoer & Redoer: #undoAgain:andReselect:typedKey:."	"If last command was also 'again', use same keys as before"	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:)! !!ParagraphEditor methodsFor: 'menu messages'!align	"Align text according to the next greater alignment value--cycling among 	left flush, right flush, center, justified.  No effect on the undoability of the pre	preceding command."	paragraph toggleAlignment.	paragraph displayOn: Display.	self recomputeInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/24/2001 12:22'!browseChangeSetsWithSelector	"Determine which, if any, change sets have at least one change for the selected selector, independent of class"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [ChangeSorter browseChangeSetsWithSelector: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 1/16/2004 21:14'!browseClassFromIt	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self lineSelectAndEmptyCheck: [^ self].	aClass _ Utilities classFromPattern: (self selection string copyWithout: Character cr) withCaption: 'choose a class to browse...'.	aClass ifNil: [^ view flash].	self terminateAndInitializeAround:		[self systemNavigation spawnHierarchyForClass: aClass selector: nil]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 09:42'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isKindOf: Class)					ifFalse:	[anEntry _ anEntry class].				brow _ Preferences browseToolClass new.				brow setClass: anEntry selector: nil.				brow class					openBrowserView: (brow openEditString: nil)					label: 'System Browser']			ifFalse:				[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/23/1998 11:08'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!cancel 	"Restore the text of the paragraph to be the text saved since initialization 	or the last accept.  Undoer & Redoer: undoAndReselect:redoAndReselect:.	This used to call controlTerminate and controlInitialize but this seemed illogical.	Sure enough, nobody overrode them who had cancel in the menu, and if	anybody really cared they could override cancel."	UndoSelection _ paragraph text.	self undoer: #undoAndReselect:redoAndReselect: with: self selectionInterval with: (1 to: 0).	view ifNotNil: [view clearInside].	self changeParagraph: (paragraph text: initialText).	UndoParagraph _ paragraph.	otherInterval _ UndoInterval _ 1 to: initialText size. "so undo will replace all"	paragraph displayOn: Display.	self selectAt: 1.	self scrollToTop! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 12/17/2001 12:54'!changeAlignment	| aList reply  |	aList _ #(leftFlush centered justified rightFlush).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ifNil:[^self].	self setAlignment: reply.	paragraph composeAll.	self recomputeSelection.	self mvcRedisplay.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'fc 2/19/2004 22:09'!changeEmphasis	| aList reply  |	aList _ #(normal bold italic narrow underlined struckOut).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self setEmphasis: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'fc 2/19/2004 22:09'!changeEmphasisOrAlignment	| aList reply  |	aList _ #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: aList lines: #(6) selections: aList) startUp.	reply ~~ nil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[paragraph perform: reply.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 10/22/2003 15:27'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList _ StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply _ (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ifNotNil:		[(style _ TextStyle named: reply) ifNil: [Beeper beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'RAA 3/15/2001 12:10'!changeStyleTo: aNewStyle	paragraph textStyle: aNewStyle.	paragraph composeAll.	self recomputeSelection.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/27/1999 11:54'!chooseAlignment	self changeAlignment! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/15/2003 22:40'!classCommentsContainingIt	"Open a browser class comments which contain the current selection somewhere in them."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [		self systemNavigation browseClassCommentsWithString: self selection string]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dvf 8/23/2003 11:51'!classNamesContainingIt	"Open a browser on classes whose names contain the selected string"	self lineSelectAndEmptyCheck: [^self].	self systemNavigation 		browseClassesWithNamesContaining: self selection string		caseSensitive: Sensor leftShiftDown! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:37'!clipboardText	^ Clipboard clipboardText! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!clipboardText: text	^ Clipboard clipboardText: text! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!clipboardTextPut: text	^ Clipboard clipboardText: text! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:09'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection _ self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval _ self selectionInterval.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:33'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: self nullText. 	self undoer: #undoCutCopy: with: self clipboardText.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages'!exchange	"See comment in exchangeWith:"	self exchangeWith: otherInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:34'!experimentalCommand	"Use for experimental command-key implementation.  Using this, 	you can try things out without forever needing to reinitialize the 	ParagraphEditor."	self prettyPrint.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ls 10/10/199911:36'!explain	"Try to shed some light on what kind of entity the current selectionis. 	The selection must be a single token or construct. Insert the answerafter 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol|Cursor execute showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry _ sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: [string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are allletters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol _ s])						ifTrue: [cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [										selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:41'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection _ self selection.	self terminateAndInitializeAround:		[(ReadWriteStream on: selection string from: 1 to: selection size) fileIn].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/5/1998 21:55'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages'!findAgain	"Find the text-to-find again.  1/24/96 sw"	self againOrSame: true! !!ParagraphEditor methodsFor: 'menu messages'!fit	"Make the bounding rectangle of the paragraph contain all the text while 	 not changing the width of the view of the paragraph.  No effect on undoability	 of the preceding command."	paragraph clearVisibleRectangle.	paragraph fit.	paragraph displayOn: Display; outline.	self recomputeInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 09:42'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [ self systemNavigation browseAllImplementorsOf: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:12'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	self hasSelection ifFalse: [self flash.  ^ returnBlock value]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:31'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[self terminateAndInitializeAround: [self systemNavigation browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed]].	Cursor normal show! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/15/2003 22:35'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	self lineSelectAndEmptyCheck: [^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	self systemNavigation browseMethodsWithSourceString: self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:28'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [self systemNavigation browseMethodsWithString: self selection string]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:34'!mvcRedisplay	"Overridable by subclasses that do their own display"	Display fill: paragraph clippingRectangle 			fillColor: view backgroundColor.	"very brute force"	self display! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/20/2002 11:21'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary.  Undoer & Redoer: undoAndReselect."	self replace: self selectionInterval with: self clipboardText and:		[self selectAt: self pointIndex]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:36'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self paste! !!ParagraphEditor methodsFor: 'menu messages'!performMenuMessage: aSelector	"If a menu command is invoked, typeIn must be closed first, the selection	 must be unhighlighted before and rehighlighted after, and the marker	 must be updated."	self closeTypeIn.	self deselect.	super performMenuMessage: aSelector.	self selectAndScroll.	self updateMarker! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 1/19/2004 20:59'!presentSpecialMenu	"Present a list of expressions, and if the user chooses one, evaluate it in the context of the receiver, a ParagraphEditor.  Primarily for debugging, this provides a convenient way to talk to the various views, controllers, and models associated with any text pane"	| reply items |	self terminateAndInitializeAround:		[reply _ (PopUpMenu labelArray: (items _ self specialMenuItems) lines: #()) startUp.		reply = 0 ifTrue: [^ self].		Compiler new evaluate: (items at: reply) in: [] to: self]	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrint	self prettyPrint: false! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:41'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageCategoryName ifNil: [^ view flash].	selectedClass _ model selectedClassOrMetaClass.	newText _ selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrintWithColor	self prettyPrint: true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dew 3/7/2000 21:06'!printerSetup		TextPrinter defaultTextPrinter inspect! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 11:47'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectLine.	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'BG 11/1/2003 14:27'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName lastIndex |	stringToSave _ paragraph text string.	stringToSave size == 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow _ self model dependents						detect: [:dep | dep isKindOf: StandardSystemView]						ifNone: [nil].	labelToUse _ parentWindow		ifNil: 		['Untitled']		ifNotNil: 	[parentWindow label].	suggestedName _ nil.	#(('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName _ labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName _ suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex _ suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName _ suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil:		[suggestedName _ labelToUse, '.text'].				fileName _ FillInTheBlank request: 'File name?'			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'bf 10/13/1999 09:09'!selectedSelector	"Try to make a selector out of the current text selection"	^self selection string findSelector! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:27'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString _ self selection string copyWithoutAll:		{Character space.  Character cr.  Character tab}.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'gm 2/16/2003 20:38'!sendContentsToPrinter	| textToPrint printer parentWindow |	textToPrint := paragraph text.	textToPrint size == 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.	parentWindow := self model dependents 				detect: [:dep | dep isSystemWindow]				ifNone: [nil].	parentWindow isNil 		ifTrue: [printer documentTitle: 'Untitled']		ifFalse: [printer documentTitle: parentWindow label].	printer printText: textToPrint! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:30'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/18/2002 17:28'!setAlignment: aSymbol	| attr interval |	attr _ TextAlignment perform: aSymbol.	interval _ self encompassLine: self selectionInterval.	paragraph replaceFrom: interval first to: interval last with:		((paragraph text copyFrom: interval first to: interval last) addAttribute: attr) displaying: true.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:27'!setSearchString	"Make the current selection, if any, be the current search string."	self hasCaret ifTrue: [view flash. ^ self].	self setSearch:  self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 5/20/1998 22:41'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code _ paragraph text string.	self cancel.	model spawn: code.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:44'!spawnWorkspace	| toUse |	self selectLine.	toUse _ self selection asString.	toUse size > 0 ifFalse:		[toUse _ paragraph text string.		toUse size > 0 ifFalse: [^ self flash]].	"NB: BrowserCodeController's version does a cancel here"	self terminateAndInitializeAround:		[Utilities openScratchWorkspaceLabeled: 'Untitled' contents: toUse]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/29/96'!specialMenuItems	"Refer to comment under #presentSpecialMenu.  .	 : added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'SqR 11/14/2000 12:15'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	sensor flushKeyboard. "a way to flush stuck keys"	self closeTypeIn.	UndoParagraph == paragraph ifFalse: "Can't undo another paragraph's edit"		[UndoMessage _ Message selector: #undoReplace.		UndoInterval _ 1 to: 0.		Undone _ true].	UndoInterval ~= self selectionInterval ifTrue: "blink the actual target"		[self selectInterval: UndoInterval; deselect].	"Leave a signal of which phase is in progress"	UndoParagraph _ Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph _ paragraph! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/26/2003 22:02'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list _ self systemNavigation allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply _ ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'SystemNavigation new browseAllImplementorsOf: #' , symbol! !!ParagraphEditor methodsFor: 'explain' stamp: 'di 1/30/2002 21:09'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/10/2004 07:02'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class _ model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class _ class soleInstance].	classes _ (Array with: class)				, class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: [])					~~ nil]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply _ pool.						true]]			ifNone: [])			~~ nil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes _ WriteStream on: Array new.			self systemNavigation				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'sw 5/3/1998 14:32'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply _ '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply _ '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply _ '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply _ '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes _ cls withAllSubclasses.			classes size > 12				ifTrue: [text _ cls printString , ' or a subclass']				ifFalse: 					[classes _ classes printString.					text _ 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply _ '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply _ '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/29/2003 20:07'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes _ Set new.			self systemNavigation allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/12/2004 16:22'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes _ (Array with: cls)				, cls allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	classes _ self systemNavigation allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!ParagraphEditor methodsFor: 'explain' stamp: 'apb 1/5/2000 16:56'!explainNumber: string 	"Is string a Number?"	| strm c |	(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm _ ReadStream on: string.	c _ Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits _ Array with: msg.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes _ self systemNavigation allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!ParagraphEditor methodsFor: 'explain'!explainScan: string 	"Remove beginning and trailing space, tab, cr.	 1/15/96 sw: copied intact from BrowserCodeController"	| c beg end |	beg _ 1.	end _ string size.		[beg = end ifTrue: [^string copyFrom: 1 to: 1].	"if all blank, tell about the first"	c _ string at: beg.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [beg _ beg + 1].		[c _ string at: end.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [end _ end - 1].	^string copyFrom: beg to: end	"Return purely visible characters"! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:19'!explainTemp: string 	"Is string the name of a temporary variable (or block argument variable)?"	| selectedClass tempNames i reply methodNode method msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	selectedClass _ model selectedClassOrMetaClass.	tempNames _ selectedClass parserClass new 			parseArgsAndTemps: model selectedMessage notifying: nil.	method _ selectedClass compiledMethodAt: msg.	(i _ tempNames findFirst: [:each | each = string]) = 0 ifTrue: [		(method numTemps > tempNames size)			ifTrue: 				["It must be an undeclared block argument temporary"				methodNode _ selectedClass compilerClass new							parse: model selectedMessage							in: selectedClass							notifying: nil.				tempNames _ methodNode tempNames]			ifFalse: [^nil]].	(i _ tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs			ifTrue: [reply _ '"is a temporary variable in this method"']			ifFalse: [reply _ '"is an argument to this method"']].	^reply! !!ParagraphEditor methodsFor: 'editing keys'!align: characterStream 	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"	sensor keyboard.		"flush character"	self align.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!browseIt: characterStream 	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	sensor keyboard.		"flush character"	self browseIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!browseItHere: characterStream 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	sensor keyboard.		"flush character"	self browseItHere.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:40'!cancel: characterStream 	"Cancel unsubmitted changes.  Flushes typeahead.  1/12/96 sw	 1/22/96 sw: put in control terminate/init"	sensor keyboard.	self terminateAndInitializeAround: [self cancel].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'BG 10/29/2003 08:00'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	| keyCode attribute oldAttributes index thisSel colors extras indexOfOldAttributes |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	"grab the old set of attributes"	indexOfOldAttributes _		startBlock stringIndex < stopBlock stringIndex			ifTrue: [ startBlock stringIndex ]			ifFalse: [				"if selection is empty, look on character to the left; this is consistent with setEmphasisHere"				(startBlock stringIndex - 1) max: 1 ].	oldAttributes _ paragraph text attributesAt: indexOfOldAttributes forStyle: paragraph textStyle.	thisSel _ self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[colors _ #(black magenta red yellow green blue cyan white).		extras _ false "not a system window"				ifTrue: [#()]				ifFalse: [#('Link to comment of class' 'Link to definition of class' 						'Link to hierarchy of class' 'Link to method')].		index _ (PopUpMenu labelArray: colors , #('choose color...' 'Do it' 'Print it'), 			extras, #('be a web URL link' 			'Edit hidden info' 'Copy hidden info')							lines: (Array with: colors size +1)) startUp.		index = 0 ifTrue: [^ true].		index <= colors size		ifTrue:			[attribute _ TextColor color: (Color perform: (colors at: index))]		ifFalse:			[index _ index - colors size - 1.	"Re-number!!!!!!"			index = 0 ifTrue: [attribute _ self chooseColor].			index = 1 ifTrue: [attribute _ TextDoIt new.				thisSel _ attribute analyze: self selection asString].			index = 2 ifTrue: [attribute _ TextPrintIt new.				thisSel _ attribute analyze: self selection asString].			(extras size = 0) & (index > 2) ifTrue: [index _ index + 5].	"skip those"			index = 3 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Comment'].			index = 4 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Definition'].			index = 5 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Hierarchy'].			index = 6 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString].		"	index = 7 ifTrue: [attribute _ TextURL new. 				thisSel _ attribute analyze: self selection asString]. "			index = 8 ifTrue: ["Edit hidden info"				thisSel _ self hiddenInfo.	"includes selection"				attribute _ TextEmphasis normal].			index = 9 ifTrue: ["Copy hidden info"				self copyHiddenInfo.  ^ true].	"no other action"		thisSel ifNil: [^ true]].	"Could not figure out what to link to"		].	(keyCode between: 7 and: 11) ifTrue:		[sensor leftShiftDown		ifTrue:			[keyCode = 10 ifTrue: [attribute _ TextKern kern: -1].			keyCode = 11 ifTrue: [attribute _ TextKern kern: 1]]		ifFalse:			[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream]		ifFalse:			[self replaceSelectionWith: (thisSel asText addAttribute: attribute)].	emphasisHere _ 	Text addAttribute: attribute toArray: oldAttributes.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr _ Character cr.  lf _ Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 09:11'!chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute.  This is the non-Morphic version."	^ TextColor color: (Color fromUser)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:31'!compareToClipboard: characterStream 	"Compare the receiver to the text on the clipboard.  Flushes typeahead.  5/1/96 sw"	sensor keyboard.		self terminateAndInitializeAround: [self compareToClipboard].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 08:47'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hiddeninfo.  Copy that to the clipboard.  You can paste it and see what it is.Usually enclosed in <>."	^ self clipboardTextPut: self hiddenInfo asText! !!ParagraphEditor methodsFor: 'editing keys'!copySelection: characterStream 	"Copy the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self copySelection.	^true! !!ParagraphEditor methodsFor: 'editing keys'!cut: characterStream 	"Cut out the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self cut.	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:23'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self terminateAndInitializeAround: [self doIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/20/2002 11:41'!duplicate: characterStream	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	sensor keyboard.	self closeTypeIn.	(self hasSelection and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: self pointIndex]]		ifFalse:			[view flash].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:01'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys'!exchange: characterStream	"Exchange the current and prior selections.  Keeps typeahead."	sensor keyboard.	 "Flush character"	self closeTypeIn: characterStream.	self exchange.	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 4/24/2001 12:28'!fileItIn: characterStream 	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self fileItIn].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:31'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList _ paragraph text attributesAt: (self pointIndex +self markIndex)//2 forStyle: paragraph textStyle.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!ParagraphEditor methodsFor: 'editing keys'!implementorsOfIt: characterStream 	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self implementorsOfIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:28'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	sensor keyboard.  "Flush typeahead"	cr _ Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ self startIndex.	realStop _ self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexOfCharacterIndex: realStart.	stopLine _ paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into:		[:m :l |		m _ m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size _  stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: paragraph string from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!ParagraphEditor methodsFor: 'editing keys'!indent: characterStream	"Add a tab at the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-R.  2/29/96 sw"	^ self inOutdent: characterStream delta: 1! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self inspectIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:06'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ls 11/10/2002 12:11'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-Y."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/1/97 15:18'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 9/9/97 16:44'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!noop: characterStream 	"Unimplemented keyboard command; just ignore it."	sensor keyboard.	  "flush character"	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 1/19/2000 11:14'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesWithPointSizes.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys'!offerFontMenu: characterStream 	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw	 Keeps typeahead.  (?? should flush?)"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self offerFontMenu.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!outdent: characterStream	"Remove a tab from the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-L.  2/29/96 sw"	^ self inOutdent: characterStream delta: -1! !!ParagraphEditor methodsFor: 'editing keys'!paste: characterStream 	"Replace the current text selection by the text in the shared buffer.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self paste.	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:48'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self printIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys'!referencesToIt: characterStream 	"Triggered by Cmd-N; browse references to the current selection"	sensor keyboard.		"flush character"	self referencesToIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!save: characterStream	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self terminateAndInitializeAround: [self accept].	^ true! !!ParagraphEditor methodsFor: 'editing keys'!sendersOfIt: characterStream 	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self sendersOfIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'yo 5/27/2004 13:56'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes _ paragraph text attributesAt: self selectionInterval first forStyle: paragraph textStyle.	attribute _ TextEmphasis perform: emphasisSymbol.	(emphasisSymbol == #normal) 		ifFalse:	[oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:20'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	char = $9 ifTrue: [ char _ $( ].	char = $, ifTrue: [ char _ $< ].	char = $[ ifTrue: [ char _ ${ ].	char = $' ifTrue: [ char _ $" ].	char asciiValue = 27 ifTrue: [ char _ ${ ].	"ctrl-["	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [1].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!spawnIt: characterStream	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	sensor keyboard.	self terminateAndInitializeAround: [self spawn].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:00'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars _ self selection) size == 0		ifTrue:			[currentSelection _ self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection _ self pointIndex - 1]].	aString _ self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 11/2/1998 15:50'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!ParagraphEditor methodsFor: 'editing keys'!undo: characterStream 	"Undo the last edit.  Keeps typeahead, so undo twice is a full redo."	sensor keyboard. 	"flush character"	self closeTypeIn: characterStream.	self undo.	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:51'!comment	"All key actions that are neither editing nor typing actions have to	send closeTypeIn at first. See comment in openTypeIn closeTypeIn"! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:08'!cursorDown: characterStream 	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn: characterStream.	self 		moveCursor:[:position | self				sameColumn: position				newLine:[:line | line + 1]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 10/28/2003 10:47'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string _ paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine _ paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lines last						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOf: Character cr						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/20/2002 12:14'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string _ paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOf: Character cr						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:07'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	self closeTypeIn: characterStream.	self		moveCursor:[:position | position - 1 max: 1]		forward: false		specialBlock:[:position | self previousWord: position].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageDown: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo + self pageHeight]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageUp: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo - self pageHeight]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:01'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self closeTypeIn: characterStream.	self		moveCursor: [:position | position + 1]		forward: true		specialBlock:[:position | self nextWord: position].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:15'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	self closeTypeIn: characterStream.	self		moveCursor: [:position | self				sameColumn: position				newLine:[:line | line - 1]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'BG 10/28/2003 21:01'!escapeToDesktop: characterStream 	"Pop up a morph to field keyboard input in the context of the desktop"		^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'dvf 12/8/2001 00:46'!raiseContextMenu: characterStream 	"AFAIK, this is never called in morphic, because a subclass overrides it. Which is good, because a ParagraphEditor doesn't know about Morphic and thus duplicates the text-editing actions that really belong in the specific application, not the controller. So the context menu this would raise is likely to be out of date."	self yellowButtonActivity.	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior _ otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval _ prior.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sma 12/15/1999 11:46'!selectWord: characterStream	sensor keyboard.	self closeTypeIn: characterStream.	self selectWord.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString _  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:22'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start _ paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start _ paragraph text size + 1].	self selectAt: start + 2.	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 10/21/2003 15:46'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[self hasCaret				ifTrue: "a caret, delete at least one character"					[startIndex _ 1 max: self markIndex - 1.					[startIndex > 1 and:						[(paragraph text at: startIndex - 1) asCharacter tokenish]]						whileTrue:							[startIndex _ startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex _ self markIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 18:23'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	characterStream isEmpty		ifTrue:			[startIndex _ self markIndex +				(self hasCaret ifTrue: [0] ifFalse: [1]).			[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex _ 1 max: startIndex - 1.			].			self backTo: startIndex]		ifFalse:			[sensor keyboard.			characterStream skip: -1].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!changeStyle: characterStream 	"Put up the style-change menu"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self changeStyle.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:25'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ self stopIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [i < s size and: [(s at: i+1) ~= $[ ]]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 4/30/2001 21:20'!cursorTopHome: characterStream 	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."		sensor keyboard.	self selectAt: 1.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!doAgainMany: characterStream 	"Do the previous thing again repeatedly. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:) many: true.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!doAgainOnce: characterStream 	"Do the previous thing again once. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self again.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!find: characterStream	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self find.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!findAgain: characterStream 	"Find the desired text again.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self findAgain.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/18/2002 11:39'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ self mark.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	self hasSelection ifTrue:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	upara _ UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!normalCharacter: characterStream 	"A nonspecial character is to be added to the stream of characters."	characterStream nextPut: sensor keyboard.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 18:25'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[view flash].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!search: characterStream	"Invoked by Ctrl-S.  Same as 'again', but always uses the existing FindText	 and ChangeText regardless of the last edit."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: true. "true means use same keys"	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 8/29/2000 14:58'!selectAll	"Make the selection be all the characters of the receiver"	self selectFrom: 1 to: paragraph text string size! !!ParagraphEditor methodsFor: 'typing/selecting keys'!selectAll: characterStream 	"select everything, invoked by cmd-a.  1/17/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectFrom: 1 to: paragraph text string size.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 17:34'!simulatedBackspace	"Backspace over the last character, derived from hand-char recognition.  2/5/96 sw"	| startIndex |	startIndex _ self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).	startIndex _ 1 max: startIndex - 1.	self backTo: startIndex.	^ false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:36'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock		ifNil: [self openTypeIn. UndoSelection _ self nullText. self stopIndex]		ifNotNil: [self startOfTyping].	self setMark: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	self unselect! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:40'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			stop _ self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support'!closeTypeIn: characterStream	"Call instead of closeTypeIn when you want typeahead to be inserted before the	 control character is executed, e.g., from Ctrl-V."	self insertTypeAhead: characterStream.	self closeTypeIn! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 9/7/1999 11:26'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	self terminateAndInitializeAround: [	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self accept].	].	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!insertTypeAhead: typeAhead	typeAhead position = 0 ifFalse:		[self zapSelectionWith: (Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:48'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ self startIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 18:26'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				self setEmphasisHere.				^self selectAndScroll; updateMarker].			self openTypeIn].		self hasSelection ifTrue: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:49'!setEmphasisHere	emphasisHere _ (paragraph text attributesAt: (self pointIndex - 1 max: 1) forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	self markBlock = self pointBlock ifFalse: [UndoSelection _ self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	self unselect.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!ParagraphEditor methodsFor: 'undoers'!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText index subject |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize _ (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText _ self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i |		index _ indices at: i.		(subject _ index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'undoers'!undoAndReselect: undoHighlight redoAndReselect: redoHighlight	"Undo typing, cancel, paste, and other operations that are like replaces	 but the selection is not the whole restored text after undo, redo, or both.	 undoHighlight is selected after this phase and redoHighlight after the next phase.	Redoer: itself."	self replace: self selectionInterval with: UndoSelection and:		[self selectInterval: undoHighlight].	self undoMessage: (UndoMessage argument: redoHighlight) forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'undoers'!undoCutCopy: oldPasteBuffer	"Undo of a cut, copy, or any edit that changed CurrentSelection.  Be sure	 undo-copy does not lock the model.  Redoer: itself, so never isRedoing."	| recentCut |	recentCut _ self clipboardText.		UndoSelection size = UndoInterval size		ifFalse: [self replaceSelectionWith: UndoSelection].	self clipboardTextPut: oldPasteBuffer.	self undoer: #undoCutCopy: with: recentCut! !!ParagraphEditor methodsFor: 'undoers' stamp: 'th 9/19/2002 18:46'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: self stopIndex! !!ParagraphEditor methodsFor: 'undoers'!undoReplace	"Undo of any command that replaced a selection by other text that it left	 highlighted, and that is undone and redone by simple reversal of the	 operation.  This is the most common Undoer; call replaceSelectionWith:	 to get this setup.  Redoer: itself, so never isRedoing."	self replaceSelectionWith: UndoSelection! !!ParagraphEditor methodsFor: 'undo support'!isDoing	"Call from a doer/undoer/redoer any time to see which it is."	^(self isUndoing | self isRedoing) not! !!ParagraphEditor methodsFor: 'undo support'!isRedoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #redoing! !!ParagraphEditor methodsFor: 'undo support'!isUndoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #undoing! !!ParagraphEditor methodsFor: 'undo support'!noUndoer	"The Undoer to use when the command can not be undone.  Checked for	 specially by readKeyboard."	UndoMessage _ Message selector: #noUndoer! !!ParagraphEditor methodsFor: 'undo support'!undoMessage: aMessage forRedo: aBoolean	"Call this from an undoer/redoer to set up UndoMessage as the	 corresponding redoer/undoer.  Also set up UndoParagraph, as well	 as the state variable Undone.  It is assumed that UndoInterval has been	 established (generally by zapSelectionWith:) and that UndoSelection has been	 saved (generally by replaceSelectionWith: or replace:With:and:)."	self isDoing ifTrue: [UndoParagraph _ paragraph].	UndoMessage _ aMessage.	Undone _ aBoolean! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector	"See comment in undoMessage:.  Use this version when aSelector has no arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1	"See comment in undoMessage:.  Use this version when aSelector has one argument, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector argument: arg1) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1 with: arg2	"See comment in undoMessage:.  Use this version when aSelector has two arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2)) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1 with: arg2 with: arg3	"See comment in undoMessage:.  Use this version when aSelector has three arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2 with: arg3)) forRedo: false! !!ParagraphEditor methodsFor: 'current selection'!deselect	"If the text selection is visible on the screen, reverse its highlight."	selectionShowing ifTrue: [self reverseSelection]! !!ParagraphEditor methodsFor: 'current selection'!initializeSelection	"Do the initial activity when starting up the receiver. For example, in the 	ParagraphEditor highlight the current selection."	self select! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/20/2002 11:41'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self computeIntervalFrom: self mark to: self pointIndex - 1! !!ParagraphEditor methodsFor: 'current selection'!recomputeSelection	"Redetermine the selection according to the start and stop block indices; 	do not highlight."	self deselect; recomputeInterval! !!ParagraphEditor methodsFor: 'current selection' stamp: 'BG 12/12/2003 12:50'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing _ selectionShowing not.	paragraph reverseFrom: self pointBlock to: self markBlock! !!ParagraphEditor methodsFor: 'current selection'!select	"If the text selection is visible on the screen, highlight it."	selectionShowing ifFalse: [self reverseSelection]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:47'!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle endBlock |	self select.	endBlock _ self stopBlock.	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ endBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY _ endBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:48'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ self stopBlock top - clippingRectangle top.	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:37'!adjustSelection: directionBlock	"Helper function for Cursor movement. Always moves point thus allowing selections to shrink. "	"See also expandSelection:"	"Accepts a one argument Block that computes the new postion given an old one."	| newPosition |	newPosition _ directionBlock value: self pointIndex.	self selectMark: self markIndex point: newPosition.	^true.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 10/28/2003 12:11'!afterSelectionInsertAndSelect: aString	self insertAndSelect: aString at: self stopIndex ! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/17/2002 16:11'!computeIntervalFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self setMark: start.	self setPoint: stop + 1.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:21'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc _ start.		[(loc _ loc-1)>0 and: [(paragraph text string at: loc) isSeparator]]			whileTrue: [loc _ loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing _ selectionShowing) ifTrue: [ self reverseSelection ].	userSelection _ self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString asText.	delta _ aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:21'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string _ paragraph text string.	left _ (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right _ (string indexOf: Character cr startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 12/17/1998 09:41'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self selectAndScroll]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:25'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc _ start + dir.	str _ paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc _ loc + dir].	^ loc! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/20/1998 08:31'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	self insertAndSelect: aString at: (anInteger max: 1)! !!ParagraphEditor methodsFor: 'new selection'!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	self selectFrom: characterIndex to: characterIndex - 1! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:50'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[self deselect.		self selectInvisiblyFrom: start to: stop].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection'!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: anInterval first to: anInterval last! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/9/1998 20:59'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: start to: stop! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:17'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: mark to: point! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:17'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	self hasSelection ifTrue:[^self].	self selectInterval: (self encompassLine: self selectionInterval)! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:18'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse:		[self deselect.		self selectInvisiblyMark: mark point: point].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 18:49'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ paragraph text string.	stop _ self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:51'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string _ paragraph text string.	here _ self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters _ '([{<''"'.	rightDelimiters _ ')]}>''"'.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: 			[openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [direction < 0								ifTrue: 									[start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:48'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!ParagraphEditor methodsFor: 'private'!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	^ self againOrSame: useOldKeys many: sensor leftShiftDown! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:53'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText _ UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText _ ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: "just inserted at a caret"			[home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home _ self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:16'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime _ self isRedoing		ifTrue: [prior _ sym _ selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret _ self startIndex.			self selectPrecedingIdentifier.			input _ self selection]		ifFalse: "Repeated Ctrl-q"			[caret _ UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input _ hintText.			prior _ selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym _ Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart _ self startIndex.			outStream _ WriteStream on: (String new: 2 * sym size).			1 to: (kwds _ sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret _ newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection _ input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection _ self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone _ true].			view flash].	self selectAt: caret! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:49'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start _ self startIndex.	stop _ self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before _ prior last < start.			selection _ self selection.			priorSelection _ paragraph text copyFrom: prior first to: prior last.			delta _ before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta _ before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval _ prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval _ start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[view flash]! !!ParagraphEditor methodsFor: 'private' stamp: 'raok 11/15/2001 14:01'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = ${ and: [string last = $}]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str _ string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!ParagraphEditor methodsFor: 'private' stamp: 'tk 7/14/2000 12:15'!getPluggableYellowButtonMenu: shiftKeyState	| customMenu |	^ ((view ~~ nil) and: [(customMenu _ view getMenu: shiftKeyState) notNil])		ifTrue: [customMenu]		ifFalse:			[shiftKeyState				ifTrue: [self class shiftedYellowButtonMenu]				ifFalse: [self class yellowButtonMenu]]! !!ParagraphEditor methodsFor: 'private'!indent: delta fromStream: inStream toStream: outStream	"Append the contents of inStream to outStream, adding or deleting delta or -delta	 tabs at the beginning, and after every CR except a final CR.  Do not add tabs	 to totally empty lines, and be sure nothing but tabs are removed from lines."	| ch skip cr tab prev atEnd |	cr _ Character cr.	tab _ Character tab.	delta > 0		ifTrue: "shift right"			[prev _ cr.			 [ch _ (atEnd _ inStream atEnd) ifTrue: [cr] ifFalse: [inStream next].			  (prev == cr and: [ch ~~ cr]) ifTrue:				[delta timesRepeat: [outStream nextPut: tab]].			  atEnd]				whileFalse:					[outStream nextPut: ch.					prev _ ch]]		ifFalse: "shift left"			[skip _ delta. "a negative number"			 [inStream atEnd] whileFalse:				[((ch _ inStream next) == tab and: [skip < 0]) ifFalse:					[outStream nextPut: ch].				skip _ ch == cr ifTrue: [delta] ifFalse: [skip + 1]]]! !!ParagraphEditor methodsFor: 'private' stamp: 'cmm 4/9/2004 14:00'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge _ anInterval size = 0 ifTrue: [1] ifFalse: [0].	^(anInterval last + fudge < self startIndex or:			[anInterval first - fudge >= self stopIndex])! !!ParagraphEditor methodsFor: 'private' stamp: 'th 11/24/2002 17:13'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string index lineIndex stringSize |	string _ paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize _ string size.	lines _ OrderedCollection new: (string size // 15).	index _ 0.	lineIndex _ 0.	string linesDo:[:line |		lines addLast: (Array			with: (index _ index + 1)			with: (lineIndex _ lineIndex + 1)			with: (index _ index + line size min: stringSize))].	"Special workaround for last line empty."	string last == Character cr	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:57'!moveCursor: directionBlock forward: forward specialBlock: specialBlock	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift _ sensor leftShiftDown.	indices _ self setIndices: shift forward: forward.	newPosition _ directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition _ specialBlock value: newPosition].	sensor keyboard.	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:32'!nextWord: position	| string index |	string _ paragraph text string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index + 1].	^ index! !!ParagraphEditor methodsFor: 'private'!nullText	^Text string: '' emphasis: emphasisHere! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/20/2002 11:09'!pageHeight	| howManyLines visibleHeight totalHeight ratio |	howManyLines _ paragraph numberOfLines.	visibleHeight _ self visibleHeight.	totalHeight _ self totalTextHeight.	ratio _ visibleHeight / totalHeight.	^(ratio * howManyLines) rounded - 2! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:33'!previousWord: position	| string index |	string _ paragraph text string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index - 1].	^ index + 1! !!ParagraphEditor methodsFor: 'private' stamp: 'BG 4/29/2004 11:19'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle _ Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines _ paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  _ paragraph lineIndexOfCharacterIndex: start.			currentLine _ lines at: currentLineNumber]		ifFalse: [			lines _ self lines.			numberOfLines := lines size.			currentLine _ lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber _ currentLine second].	column _ start - currentLine first.	targetLineNumber _ ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine _ (lines at: targetLineNumber) first.	targetEOL _ (lines at: targetLineNumber) last + (targetLineNumber == numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber == currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:02'!setIndices: shiftPressed forward: forward	"Little helper method that sets the moving and fixed indices according to some flags."	| indices |	indices _ Dictionary new.	(shiftPressed and:[Preferences selectionsMayShrink])		ifTrue: [			indices at: #moving put: self pointIndex.			indices at: #fixed put: self markIndex		] ifFalse: [			forward				ifTrue:[					indices at: #moving put: self stopIndex.					indices at: #fixed put: self startIndex.				] ifFalse: [					indices at: #moving put: self startIndex.					indices at: #fixed put: self stopIndex.				]		].	^indices! !!ParagraphEditor methodsFor: 'do-its' stamp: 'vb 8/13/2001 23:41'!compileSelectionFor: anObject in: evalContext	| methodNode method |	methodNode _ [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	method _ methodNode generate: #(0 0 0 0).	^method copyWithTempNames: methodNode tempNames! !!ParagraphEditor methodsFor: 'do-its' stamp: 'NS 1/28/2004 11:19'!debug: aCompiledMethod receiver: anObject in: evalContext	| selector guineaPig debugger context |	selector _ evalContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:].	anObject class addSelectorSilently: selector withMethod: aCompiledMethod.	guineaPig _ evalContext isNil		ifTrue: [[anObject DoIt] newProcess]		ifFalse: [[anObject DoItIn: evalContext] newProcess].	context _ guineaPig suspendedContext.	debugger _ Debugger new		process: guineaPig		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: context		isolationHead: nil.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod]		whileFalse: [debugger send].	anObject class basicRemoveSelector: selector! !!ParagraphEditor methodsFor: 'do-its' stamp: 'vb 8/13/2001 23:38'!debugIt	| method receiver context |	(model respondsTo: #doItReceiver) 		ifTrue: 			[FakeClassPool adopt: model selectedClass.			receiver _ model doItReceiver.			context _ model doItContext]		ifFalse:			[receiver _ context _ nil].	self lineSelectAndEmptyCheck: [^self].	method _ self compileSelectionFor: receiver in: context.	method notNil ifTrue:		[self debug: method receiver: receiver in: context].	FakeClassPool adopt: nil! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:38'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection.! !!ParagraphEditor methodsFor: 'do-its' stamp: 'gk 3/3/2004 17:15'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 9/7/1999 11:25'!inspectIt	"1/13/96 sw: minor fixup"	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result inspect].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'sd 4/16/2003 11:41'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self terminateAndInitializeAround: [	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [self systemNavigation					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:52'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'BG 6/1/2003 09:43'!offerMenuFromEsc: aStream   sensor keyboard. " consume the character "   self yellowButtonActivity.  ^true "tell the caller that the character was processed "! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:40'!totalTextHeight	^paragraph boundingBox height! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:33'!visibleHeight	^paragraph clippingRectangle height! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasCaret	^self markBlock = self pointBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasSelection	^self hasCaret not! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:13'!mark	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock	^ stopBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock: aCharacterBlock	stopBlock _ aCharacterBlock.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!markIndex	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock	^ startBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock: aCharacterBlock	startBlock _ aCharacterBlock.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!pointIndex	^ self pointBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 17:28'!selection	"Answer the text in the paragraph that is currently selected."	^paragraph text copyFrom: self startIndex to: self stopIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:10'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadWriteStream		on: paragraph string		from: self startIndex		to: self stopIndex - 1! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 16:18'!selectionInterval	"Answer the interval that is currently selected."	^self startIndex to: self stopIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setMark: anIndex	self markBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setPoint: anIndex	self pointBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:10'!startBlock	^ self pointBlock min: self markBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!startBlock: aCharacterBlock	self markBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!startIndex	^ self startBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:14'!stopBlock	^ self pointBlock max: self markBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!stopBlock: aCharacterBlock	self pointBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!stopIndex	^ self stopBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:23'!unselect	self markBlock: self pointBlock copy.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:12'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/7/2002 03:51'!blinkParenAt: parenLocation 	self text		addAttribute: TextEmphasis bold		from: parenLocation		to: parenLocation.	lastParenLocation _ parenLocation.! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/7/2002 04:03'!blinkPrevParen	| openDelimiter closeDelimiter level string here hereChar |	string _ paragraph text string.	here _ startBlock stringIndex.	openDelimiter _ sensor keyboardPeek.	closeDelimiter _ '([{' at: (')]}' indexOf: openDelimiter).	level _ 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar _ string at: (here _ here - 1).			hereChar = closeDelimiter				ifTrue:					[level _ level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level _ level + 1]]].! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/10/2002 00:30'!clearParens	lastParenLocation ifNotNil:		[self text string size >= lastParenLocation ifTrue: [			self text				removeAttribute: TextEmphasis bold				from: lastParenLocation				to: lastParenLocation]]! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/8/2002 03:30'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	self clearParens.  	char asciiValue = 13 ifTrue: [		^ sensor controlKeyPressed			ifTrue: [self normalCharacter: typeAheadStream]			ifFalse: [self crWithIndent: typeAheadStream]].	((honorCommandKeys _ Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	(')]}' includes: char)		ifTrue: [self blinkPrevParen].	^ self perform: #normalCharacter: with: typeAheadStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParagraphEditor class	instanceVariableNames: ''!!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 5/27/2000 00:03'!abandonChangeText	"Call this to get out of the maddening situation in which the system keeps aggressively trying to do a replacement that you no longer wish to make, every time you make choose a new method in a list."	ChangeText _ FindText	"ParagraphEditor abandonChangeText"! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ar 1/15/2001 18:47'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	Marked this method changed to trigger reinit"  	"ParagraphEditor initialize"	UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'BG 10/28/2003 17:46'!initializeTextEditorMenus	"Initialize the yellow button pop-up menu and corresponding messages."	"ParagraphEditor initializeTextEditorMenus"	TextEditorYellowButtonMenu _ SelectionMenu		labels:'find...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)paste...do it (d)print it (p)inspect it (i)debug itaccept (s)cancel (l)show bytecodesmore...'		lines: #(3 5 9 13 15 16)		selections: #(find findAgain setSearchString again undo copySelection cut paste pasteRecent doIt printIt inspectIt debugIt accept cancel showBytecodes shiftedTextPaneMenuRequest).! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'BG 11/1/2003 14:29'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	^ SelectionMenu fromArray: #(		('set font... (k)'					offerFontMenu)		('set style... (K)'					changeStyle)		('set alignment...'				chooseAlignment)		-		('explain'						explain)		('pretty print'					prettyPrint)		('pretty print with color'		prettyPrintWithColor)		('file it in (G)'					fileItIn)		('recognizer (r)'					recognizeCharacters)		('spawn (o)'						spawn)"		-		('definition of word'				wordDefinition)		('verify spelling of word'		verifyWordSpelling)		('spell check it'					spellCheckIt)			('translate it'					translateIt)		('choose language'				languagePrefs) "		-		('browse it (b)'					browseIt)		('senders of it (n)'				sendersOfIt)		('implementors of it (m)'		implementorsOfIt)		('references to it (N)'			referencesToIt)		-		('selectors containing it (W)'		methodNamesContainingIt)		('method strings with it (E)'		methodStringsContainingit)		('method source with it'			methodSourceContainingIt)		('class names containing it'		classNamesContainingIt)		('class comments with it'		classCommentsContainingIt)		('change sets with it'			browseChangeSetsWithSelector)		-		('save contents to file...'			saveContentsInFile)		-		('special menu...'				presentSpecialMenu)		('more...'						yellowButtonActivity))! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'tk 3/31/98 16:25'!yellowButtonMenu	^ TextEditorYellowButtonMenu! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'di 4/17/1999 00:33'!yellowButtonMessages	^ TextEditorYellowButtonMenu selections! !!ParagraphEditor class methodsFor: 'instance creation'!new	"Answer a new instance of me with a null Paragraph to be edited."	| aParagraphEditor |	aParagraphEditor _ super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: '' asParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'instance creation'!newParagraph: aParagraph 	"Answer an instance of me with aParagraph as the text to be edited."	| aParagraphEditor |	aParagraphEditor _ super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: aParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sw 12/7/2001 22:54'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.	"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.	"end key"	cmdMap at: 8 + 1 put: #backspace:.	"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.	"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.	"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.	"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.	"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.	"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.	"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.	"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.	"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.	"del key"	'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].	'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.	cmds := #($a #selectAll: $b #browseIt: $c #copySelection: $d #doIt: $e #exchange: $f #find: $g #findAgain: $h #setSearchString: $i #inspectIt: $j #doAgainOnce: $k #offerFontMenu: $l #cancel: $m #implementorsOfIt: $n #sendersOfIt: $o #spawnIt: $p #printIt: $q #querySymbol: $r #recognizer: $s #save: $t #tempCommand: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].	CmdActions := cmdMap! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sw 12/9/2001 21:33'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.		"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.		"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.			"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$g	fileItIn:		$h	cursorTopHome:		$i	exploreIt:		$j	doAgainMany:		$k	changeStyle:		$l	outdent:		$m	selectCurrentTypeIn:		$n	referencesToIt:		$p	makeProjectLink:		$r	indent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).		"plain keys"		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"	].	ShiftCmdActions _ cmdMap! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sbw 10/8/1999 21:42'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	11	"page up"	12	"page down"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !Object subclass: #ParseNode	instanceVariableNames: 'comment pc'	classVariableNames: 'Bfp BtpLong CodeBases CodeLimits DblExtDoAll Dup EndMethod EndRemote Jmp JmpLimit JmpLong LdFalse LdInstLong LdInstType LdLitIndType LdLitType LdMinus1 LdNil LdSelf LdSuper LdTempType LdThisContext LdTrue LoadLong LongLongDoAll NodeFalse NodeNil NodeSelf NodeSuper NodeThisContext NodeTrue Pop Send SendLimit SendLong SendLong2 SendPlus SendType ShortStoP StdLiterals StdSelectors StdVariables Store StorePop'	poolDictionaries: ''	category: 'System-Compiler'!!ParseNode commentStamp: '<historical>' prior: 0!This superclass of most compiler/decompiler classes declares common class variables, default messages, and the code emitters for jumps. Some of the class variables are initialized here; the rest are initialized in class VariableNode.!!ParseNode methodsFor: 'testing'!assignmentCheck: encoder at: location	"For messageNodes masquerading as variables for the debugger.	For now we let this through - ie we allow stores ev	into args.  Should check against numArgs, though."	^ -1! !!ParseNode methodsFor: 'testing'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^false! !!ParseNode methodsFor: 'testing'!canCascade	^false! !!ParseNode methodsFor: 'testing'!isComplex	"Used for pretty printing to determine whether to start a new line"	^false! !!ParseNode methodsFor: 'testing'!isConstantNumber  "Overridden in LiteralNode"	^false! !!ParseNode methodsFor: 'testing' stamp: 'di 4/5/2000 11:14'!isLiteral	^ false! !!ParseNode methodsFor: 'testing'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"See comment in MessageNode."	^false! !!ParseNode methodsFor: 'testing'!isReturnSelf	^false! !!ParseNode methodsFor: 'testing'!isReturningIf	^false! !!ParseNode methodsFor: 'testing' stamp: 'tk 8/2/1999 18:39'!isSelfPseudoVariable		"Overridden in VariableNode."	^false! !!ParseNode methodsFor: 'testing'!isSpecialConstant	^ false! !!ParseNode methodsFor: 'testing' stamp: 'di 10/12/1999 15:28'!isTemp	^ false! !!ParseNode methodsFor: 'testing'!isUndefTemp	^ false! !!ParseNode methodsFor: 'testing'!isUnusedTemp	^ false! !!ParseNode methodsFor: 'testing'!isVariableReference	^false! !!ParseNode methodsFor: 'testing'!nowHasDef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'testing'!nowHasRef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'testing'!toDoIncrement: ignored	"Only meant for Messages or Assignments - else return nil"	^ nil! !!ParseNode methodsFor: 'code generation'!emitBranchOn:condition dist: dist pop: stack on: strm	stack pop: 1.	dist = 0 ifTrue: [^ strm nextPut: Pop].	condition		ifTrue: [self emitLong: dist code: BtpLong on: strm]		ifFalse: [self emitShortOrLong: dist code: Bfp on: strm]! !!ParseNode methodsFor: 'code generation'!emitForEffect: stack on: strm	self emitForValue: stack on: strm.	strm nextPut: Pop.	stack pop: 1! !!ParseNode methodsFor: 'code generation'!emitForReturn: stack on: strm	self emitForValue: stack on: strm.	strm nextPut: EndMethod! !!ParseNode methodsFor: 'code generation'!emitJump: dist on: strm	dist = 0 ifFalse: [self emitShortOrLong: dist code: Jmp on: strm]! !!ParseNode methodsFor: 'code generation'!emitLong: dist code: longCode on: aStream 	"Force a two-byte jump."	| code distance |	code _ longCode.	distance _ dist.	distance < 0		ifTrue: 			[distance _ distance + 1024.			code _ code - 4]		ifFalse: 			[distance > 1023 ifTrue: [distance _ -1]].	distance < 0		ifTrue: 			[self error: 'A block compiles more than 1K bytes of code']		ifFalse: 			[aStream nextPut: distance // 256 + code.			aStream nextPut: distance \\ 256]! !!ParseNode methodsFor: 'code generation'!emitShortOrLong: dist code: shortCode on: strm	(1 <= dist and: [dist <= JmpLimit])		ifTrue: [strm nextPut: shortCode + dist - 1]		ifFalse: [self emitLong: dist code: shortCode + (JmpLong-Jmp) on: strm]! !!ParseNode methodsFor: 'code generation' stamp: 'hmm 7/15/2001 21:34'!pc	"Used by encoder source mapping."	pc==nil ifTrue: [^0] ifFalse: [^pc]! !!ParseNode methodsFor: 'code generation'!sizeBranchOn: condition dist: dist	dist = 0 ifTrue: [^1].	^ condition		ifTrue: [2]  "Branch on true is always 2 bytes"		ifFalse: [self sizeShortOrLong: dist]! !!ParseNode methodsFor: 'code generation'!sizeForEffect: encoder	^(self sizeForValue: encoder) + 1! !!ParseNode methodsFor: 'code generation'!sizeForReturn: encoder	^(self sizeForValue: encoder) + 1! !!ParseNode methodsFor: 'code generation'!sizeJump: dist	dist = 0 ifTrue: [^0].	^self sizeShortOrLong: dist! !!ParseNode methodsFor: 'code generation'!sizeShortOrLong: dist	(1 <= dist and: [dist <= JmpLimit])		ifTrue: [^1].	^2! !!ParseNode methodsFor: 'encoding'!encodeSelector: selector	^nil! !!ParseNode methodsFor: 'comment'!comment	^comment! !!ParseNode methodsFor: 'comment'!comment: newComment	comment _ newComment! !!ParseNode methodsFor: 'converting'!asReturnNode	^ReturnNode new expr: self! !!ParseNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^ self].	aStream withStyleFor: #comment		do: [1 to: comment size do: 				[:index | 				index > 1 ifTrue: [aStream crtab: indent].				aStream nextPut: $".				thisComment _ comment at: index.				self printSingleComment: thisComment					on: aStream					indent: indent.				aStream nextPut: $"]].	comment _ nil! !!ParseNode methodsFor: 'printing' stamp: 'di 4/19/2000 11:58'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: '{'.	aStream nextPutAll: ((DialectStream dialect: #ST80								contents: [:strm | self printOn: strm indent: 0])							asString).	aStream nextPutAll: '}'! !!ParseNode methodsFor: 'printing'!printOn: aStream indent: anInteger 	"If control gets here, avoid recursion loop."	super printOn: aStream! !!ParseNode methodsFor: 'printing'!printOn: aStream indent: level precedence: p	self printOn: aStream indent: level! !!ParseNode methodsFor: 'private' stamp: 'sma 5/28/2000 10:47'!nextWordFrom: aStream setCharacter: aBlock	| outStream char |	outStream _ WriteStream on: (String new: 16).	[(aStream peekFor: Character space) 		or: [aStream peekFor: Character tab]] whileTrue.	[aStream atEnd		or:			[char _ aStream next.			char = Character cr or: [char = Character space]]]		whileFalse: [outStream nextPut: char].	aBlock value: char.	^ outStream contents! !!ParseNode methodsFor: 'private' stamp: 'sma 5/28/2000 10:45'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.	Break the string at word breaks, given the widths in the default	font, at 450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth lastChar |	readStream _ ReadStream on: aString.	font _ TextStyle default defaultFont.	tabWidth _ TextConstants at: #DefaultTab.	spaceWidth _ font widthOf: Character space.	position _ indent * tabWidth.	lineBreak _ 450.	[readStream atEnd]		whileFalse: 			[word _ self nextWordFrom: readStream setCharacter: [:lc | lastChar _ lc].			wordWidth _ word inject: 0 into: [:width :char | width + (font widthOf: char)].			position _ position + wordWidth.			position > lineBreak				ifTrue: 					[aStream crtab: indent.					position _ indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					word isEmpty ifFalse: [aStream nextPutAll: word; space]]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position _ position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream crtab: indent.							position _ indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParseNode class	instanceVariableNames: ''!!ParseNode class methodsFor: 'class initialization'!initialize	"ParseNode initialize. VariableNode initialize"	LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4.	SendType _ 5.	CodeBases _ #(0 16 32 64 208 ).	CodeLimits _ #(16 16 32 32 16 ).	LdSelf _ 112.	LdTrue _ 113.	LdFalse _ 114.	LdNil _ 115.	LdMinus1 _ 116.	LoadLong _ 128.	Store _ 129.	StorePop _ 130.	ShortStoP _ 96.	SendLong _ 131.	DblExtDoAll _ 132.	SendLong2 _ 134.	LdSuper _ 133.	Pop _ 135.	Dup _ 136.	LdThisContext _ 137.	EndMethod _ 124.	EndRemote _ 125.	Jmp _ 144.	Bfp _ 152.	JmpLimit _ 8.	JmpLong _ 164.  "code for jmp 0"	BtpLong _ 168.	SendPlus _ 176.	Send _ 208.	SendLimit _ 16! !Object subclass: #ParseStack	instanceVariableNames: 'position length'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!ParseStack commentStamp: '<historical>' prior: 0!I keep track of the current and high position of the stack that will be needed by code being compiled.!!ParseStack methodsFor: 'initialize-release'!init	length _ position _ 0! !!ParseStack methodsFor: 'accessing'!pop: n	(position _ position - n) < 0 		ifTrue: [self error: 'Parse stack underflow']! !!ParseStack methodsFor: 'accessing'!push: n	(position _ position + n) > length 		ifTrue: [length _ position]! !!ParseStack methodsFor: 'accessing'!size	^length! !!ParseStack methodsFor: 'results'!position	^position! !!ParseStack methodsFor: 'printing'!printOn: aStream		super printOn: aStream.	aStream nextPutAll: ' at '; print: position; nextPutAll: ' of '; print: length! !Scanner subclass: #Parser	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!Parser commentStamp: '<historical>' prior: 0!I parse Smalltalk syntax and create a MethodNode that is the root of the parse tree. I look one token ahead.!!Parser methodsFor: 'public access'!encoder	^ encoder! !!Parser methodsFor: 'public access' stamp: 'ajh 1/22/2003 16:51'!parse: sourceStreamOrString class: behavior	^ self parse: sourceStreamOrString readStream class: behavior		noPattern: false context: nil notifying: nil ifFail: [self parseError]! !!Parser methodsFor: 'public access' stamp: 'BG 11/27/2003 10:27'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         | methNode repeatNeeded myStream parser s p |        (req notNil and: [RequestAlternateSyntaxSetting signal and: [(sourceStream isKindOf: FileStream) not]])                ifTrue: [parser _ self as: DialectParser]                ifFalse: [parser _ self].        myStream _ sourceStream.        [repeatNeeded _ false.	   p _ myStream position.	   s _ myStream upToEnd.	   myStream position: p.        parser init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag _ noPattern.        failBlock_ aBlock.        [methNode _ parser method: noPattern context: ctxt                                encoder: (Encoder new init: class context: ctxt notifying: parser)]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded _ true.                        myStream _ ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!Parser methodsFor: 'public access' stamp: 'RAA 6/14/2000 13:50'!parseArgsAndTemps: aString notifying: req         "Parse the argument, aString, notifying req if an error occurs. Otherwise,         answer a two-element Array containing Arrays of strings (the argument         names and temporary variable names)."        (req notNil and: [RequestAlternateSyntaxSetting signal]) ifTrue:                [^ (self as: DialectParser) parseArgsAndTemps: aString notifying: req].        aString == nil ifTrue: [^#()].        doitFlag _ false.               "Don't really know if a doit or not!!"        ^self initPattern: aString                notifying: req                return: [:pattern | (pattern at: 2) , self temporaries]! !!Parser methodsFor: 'public access'!parseSelector: aString 	"Answer the message selector for the argument, aString, which should 	parse successfully up to the temporary declaration or the end of the 	method header."	^self		initPattern: aString		notifying: nil		return: [:pattern | pattern at: 1]! !!Parser methodsFor: 'expression types'!argumentName	hereType == #word		ifFalse: [^self expected: 'Argument name'].	^self advance! !!Parser methodsFor: 'expression types' stamp: 'hmm 7/16/2001 18:47'!assignment: varNode	" var '_' expression => AssignmentNode."	| loc start |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	start _ self startOfNextToken.	varNode nowHasDef.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ AssignmentNode new				variable: varNode				value: parseNode				from: encoder				sourceRange: (start to: self endOfLastToken).	^true! !!Parser methodsFor: 'expression types' stamp: 'hmm 7/17/2001 21:03'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables start |	variableNodes _ OrderedCollection new.	start _ prevMark + requestorOffset.	"Gather parameters."	[self match: #colon] whileTrue: [variableNodes addLast: (encoder autoBind: self argumentName)].	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue: [^self expected: 'Vertical bar'].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].	encoder noteSourceRange: (self endOfLastToken to: self endOfLastToken) forNode: parseNode.	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!Parser methodsFor: 'expression types' stamp: 'di 3/8/2000 09:36'!braceExpression	" { elements } => BraceNode."	| elements locations loc more |	elements _ OrderedCollection new.	locations _ OrderedCollection new.	self advance.	more _ hereType ~~ #rightBrace.	[more]		whileTrue: 			[loc _ hereMark + requestorOffset.			self expression				ifTrue: 					[elements addLast: parseNode.					locations addLast: loc]				ifFalse:					[^self expected: 'Variable or expression'].			(self match: #period)				ifTrue: [more _ hereType ~~ #rightBrace]				ifFalse: [more _ false]].	parseNode _ BraceNode new elements: elements sourceLocations: locations.	(self match: #rightBrace)		ifFalse: [^self expected: 'Period or right brace'].	^true! !!Parser methodsFor: 'expression types'!cascade	" {; message} => CascadeNode."	| rcvr msgs |	parseNode canCascade		ifFalse: [^self expected: 'Cascading not'].	rcvr _ parseNode cascadeReceiver.	msgs _ OrderedCollection with: parseNode.	[self match: #semicolon]		whileTrue: 			[parseNode _ rcvr.			(self messagePart: 3 repeat: false)				ifFalse: [^self expected: 'Cascade'].			parseNode canCascade				ifFalse: [^self expected: '<- No special messages'].			parseNode cascadeReceiver.			msgs addLast: parseNode].	parseNode _ CascadeNode new receiver: rcvr messages: msgs! !!Parser methodsFor: 'expression types' stamp: 'di 11/19/1999 07:43'!expression	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!Parser methodsFor: 'expression types'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [hereType == #word						ifTrue: 							[start _ self startOfNextToken.							selector _ self advance.							args _ #().							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'expression types' stamp: 'di 5/30/2000 22:06'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	encoder _ encoderToUse.	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	prim _ doit ifTrue: [0] ifFalse: [self primitive].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim! !!Parser methodsFor: 'expression types' stamp: 'di 5/30/2000 21:59'!newMethodNode	^ MethodNode new! !!Parser methodsFor: 'expression types' stamp: 'di 4/5/2000 16:52'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[selector nextPutAll: self advance.					args addLast: (encoder bindArg: self argumentName)].			^ {selector contents asSymbol. args. 3}].	^ self expected: 'Message pattern'! !!Parser methodsFor: 'expression types'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode _ self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode _ encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number])		ifTrue: 			[self advance.			parseNode _ encoder encodeLiteral: self advance negated.			^true].	^false! !!Parser methodsFor: 'expression types' stamp: 'di 6/7/2000 08:45'!statements: argNodes innerBlock: inner	| stmts returns start more blockComment |	stmts _ OrderedCollection new.	"give initial comment to block, since others trail statements"	blockComment _ currentComment.	currentComment _ nil.	returns _ false.	more _ hereType ~~ #rightBracket.	[more]		whileTrue: 		[start _ self startOfNextToken.		(returns _ self matchReturn)			ifTrue: 				[self expression					ifFalse: [^self expected: 'Expression to return'].				self addComment.				stmts addLast: (parseNode isReturningIf					ifTrue: [parseNode]					ifFalse: [ReturnNode new							expr: parseNode							encoder: encoder							sourceRange: (start to: self endOfLastToken)])]			ifFalse: 				[self expression					ifTrue: 						[self addComment.						stmts addLast: parseNode]					ifFalse: 						[self addComment.						stmts size = 0							ifTrue: 								[stmts addLast: 									(encoder encodeVariable:										(inner ifTrue: ['nil'] ifFalse: ['self']))]]].		returns 			ifTrue: 				[self match: #period.				(hereType == #rightBracket or: [hereType == #doIt])					ifFalse: [^self expected: 'End of block']].		more _ returns not and: [self match: #period]].	parseNode _ BlockNode new				arguments: argNodes				statements: stmts				returns: returns				from: encoder.	parseNode comment: blockComment.	^ true! !!Parser methodsFor: 'expression types' stamp: 'sw 9/6/2001 15:30'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [requestor				ifNil: [tempsMark _ 1]				ifNotNil: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ (prevEnd ifNil: [0]) + 1.		tempsMark _ hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'crl 2/26/1999 12:22'!temporaryBlockVariables	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse: [		"There are't any temporary variables."		^#()].	variables _ OrderedCollection new.	[hereType == #word] whileTrue: [variables addLast: (encoder bindBlockTemp: self advance)].	(self match: #verticalBar) ifTrue: [^variables].	^self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'di 12/4/1999 21:04'!variable	| varName varStart varEnd |	varStart _ self startOfNextToken + requestorOffset.	varName _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	^ encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [self correctVariable: varName interval: (varStart to: varEnd)]! !!Parser methodsFor: 'scanning' stamp: 'hmm 7/16/2001 20:12'!advance	| this |	prevMark _ hereMark.	prevEnd _ hereEnd.	this _ here.	here _ token.	hereType _ tokenType.	hereMark _ mark.	hereEnd _ source position - (source atEnd ifTrue: [hereChar == 30 asCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]).	self scanToken.	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."	^this! !!Parser methodsFor: 'scanning' stamp: 'hmm 7/16/2001 19:23'!endOfLastToken	^ prevEnd ifNil: [mark]! !!Parser methodsFor: 'scanning'!match: type 	"Answer with true if next tokens type matches."	hereType == type		ifTrue: 			[self advance.			^true].	^false! !!Parser methodsFor: 'scanning' stamp: 'di 6/7/2000 08:44'!matchReturn	^ self match: #upArrow! !!Parser methodsFor: 'scanning'!matchToken: thing 	"Matches the token, not its type."	here = thing ifTrue: [self advance. ^true].	^false! !!Parser methodsFor: 'scanning'!startOfNextToken	"Return starting position in source of next token."	hereType == #doIt ifTrue: [^source position + 1].	^hereMark! !!Parser methodsFor: 'temps'!bindArg: name	^ self bindTemp: name! !!Parser methodsFor: 'temps'!bindTemp: name	^name! !!Parser methodsFor: 'error handling' stamp: 'hmm 7/18/2001 21:45'!expected: aString 	"Notify a problem at token 'here'."	tokenType == #doIt ifTrue: [hereMark _ hereMark + 1].	hereType == #doIt ifTrue: [hereMark _ hereMark + 1].	^ self notify: aString , ' expected' at: hereMark + requestorOffset! !!Parser methodsFor: 'error handling'!fail	| exitBlock |	encoder == nil		ifFalse: [encoder release. encoder _ nil]. "break cycle"	exitBlock _ failBlock.	failBlock _ nil.	^exitBlock value! !!Parser methodsFor: 'error handling'!interactive	^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!Parser methodsFor: 'error handling'!notify: aString 	"Notify problem at token before 'here'."	^self notify: aString at: prevMark + requestorOffset! !!Parser methodsFor: 'error handling' stamp: 'LC 1/6/2002 14:30'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxErrorNotification					inClass: encoder classEncoding					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser methodsFor: 'error handling' stamp: 'di 2/9/1999 15:43'!offEnd: aString 	"Notify a problem beyond 'here' (in lookAhead token). Don't be offEnded!!"	requestorOffset == nil		ifTrue: [^ self notify: aString at: mark]		ifFalse: [^ self notify: aString at: mark + requestorOffset]! !!Parser methodsFor: 'error correction' stamp: 'di 12/1/2000 14:39'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ Symbol possibleSelectorsFor: proposedKeyword.	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Parser methodsFor: 'error correction' stamp: 'md 3/13/2004 17:12'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	| tempIvar labels actions lines alternatives binding userSelection choice action |	"Check if this is an i-var, that has been corrected already (ugly)"	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: [		^LiteralVariableNode new 			name: proposedVariable index: (encoder classEncoding instVarNames indexOf: proposedVariable) - 1 type: 1;			yourself ].	"If we can't ask the user for correction, make it undeclared"	self interactive 		ifFalse: [ ^encoder undeclared: proposedVariable ].	"First check to see if the requestor knows anything about the variable"	tempIvar _ proposedVariable first isLowercase.	(tempIvar and: [ (binding _ requestor bindingOf: proposedVariable) notNil ])		ifTrue: [ ^encoder global: binding name: proposedVariable ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	labels _ OrderedCollection new. actions _ OrderedCollection new. lines _ OrderedCollection new.	alternatives _ encoder possibleVariablesFor: proposedVariable.	tempIvar 		ifTrue: [ 			labels add: 'declare temp'. 			actions add: [ self declareTempAndPaste: proposedVariable ].			labels add: 'declare instance'.			actions add: [ self declareInstVar: proposedVariable ] ]		ifFalse: [ 			labels add: 'define new class'.			actions add: [self defineClass: proposedVariable].			labels add: 'declare global'.			actions add: [ self declareGlobal: proposedVariable ].			encoder classEncoding == UndefinedObject ifFalse: [ 				labels add: 'declare class variable'.				actions add: [ self declareClassVar: proposedVariable ] ] ].	lines add: labels size.	alternatives do: [ :each | 		labels add: each.		actions add: [ 			self substituteWord: each wordInterval: spot offset: 0.			encoder encodeVariable: each ] fixTemps ].	lines add: labels size.	labels add: 'cancel'.	"Display the pop-up menu"	choice _ (PopUpMenu labelArray: labels asArray lines: lines asArray)		startUpWithCaption: 'Unknown variable: ', proposedVariable, ' please correct, or cancel:'.	action _ actions at: choice ifAbsent: [ ^self fail ].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Parser methodsFor: 'error correction'!declareClassVar: name	| sym class |	sym _ name asSymbol.	class _ encoder classEncoding.	class _ class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction'!declareGlobal: name	| sym |	sym _ name asSymbol.	Smalltalk at: sym put: nil.	^ encoder global: (Smalltalk associationAt: sym) name: sym! !!Parser methodsFor: 'error correction' stamp: 'rr 3/6/2004 16:07'!declareInstVar: name	" rr 3/6/2004 16:06 : adds the line to correctly compute the index. uncommented the option in 	the caller."	| index |	encoder classEncoding addInstVarName: name.	index _ encoder classEncoding instVarNames indexOf: name.	encoder classEncoding allSuperclassesDo: [:cls | index := index + cls instVarNames size].	^LiteralVariableNode new		name: name index: index - 1 type: 1;		yourself		! !!Parser methodsFor: 'error correction' stamp: 'RAA 6/5/2001 11:57'!declareTempAndPaste: name	| insertion delta theTextString characterBeforeMark |	theTextString _ requestor text string.	characterBeforeMark _ theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion _ name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion _ ' ', insertion].		delta _ 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion _ '| ' , name , ' |',String cr.		delta _ 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion _ insertion , String tab.			delta _ delta + 1.	"the tab"		].	].	tempsMark _ tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta.	^ encoder bindAndJuggle: name! !!Parser methodsFor: 'error correction' stamp: 'rr 3/4/2004 10:57'!defineClass: className 	"prompts the user to define a new class,	asks for it's category, and lets the users edit further	the definition"	| sym  cat def d2 |	sym := className asSymbol.	cat := FillInTheBlank request: 'Enter class category : ' initialAnswer: 'Unknown'.	cat ifEmpty: [cat := 'Unknown'].	def := 'Object subclass: #', sym, '		instanceVariableNames: '''' 		classVariableNames: ''''		poolDictionaries: ''''		category: ''' , cat, ''''.	d2 := FillInTheBlank request: 'Edit class definition : ' initialAnswer: def.	d2 ifEmpty: [d2 := def].	Compiler evaluate: d2.	^ encoder global: (Smalltalk associationAt: sym) name: sym! !!Parser methodsFor: 'error correction'!queryUndefined	| varStart varName | 	varName _ parseNode key.	varStart _ self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!Parser methodsFor: 'error correction' stamp: 'sw 5/23/2001 13:55'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges _ false.	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)					and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				madeChanges _ true.				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[self inform:'You''ll first have to remove thestatement where it''s stored into']]].	madeChanges ifTrue: [ParserRemovedUnusedTemps signal]! !!Parser methodsFor: 'error correction'!substituteSelector: selectorParts wordIntervals: spots	"Substitute the correctSelector into the (presuamed interactive) receiver."	| offset |	offset _ 0.	selectorParts with: spots do:		[ :word :interval |		offset _ self substituteWord: word wordInterval: interval offset: offset ]! !!Parser methodsFor: 'error correction'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presuamed interactive) receiver."	requestor correctFrom: (spot first + o)					to: (spot last + o)					with: correctWord.	requestorOffset _ requestorOffset + correctWord size - spot size.	^ o + correctWord size - spot size! !!Parser methodsFor: 'private'!addComment	parseNode ~~ nil		ifTrue: 			[parseNode comment: currentComment.			currentComment _ nil]! !!Parser methodsFor: 'private'!init: sourceStream notifying: req failBlock: aBlock	requestor _ req.	failBlock _ aBlock.	super scan: sourceStream.	prevMark _ hereMark _ mark.	requestorOffset _ 0.	self advance! !!Parser methodsFor: 'private'!initPattern: aString notifying: req return: aBlock	| result |	self		init: (ReadStream on: aString asString)		notifying: req		failBlock: [^nil].	encoder _ self.	result _ aBlock value: (self pattern: false inContext: nil).	encoder _ failBlock _ nil.  "break cycles"	^result! !!Parser methodsFor: 'primitives'!allocateLiteral: lit	encoder litIndex: lit! !!Parser methodsFor: 'primitives' stamp: 'md 11/14/2003 16:53'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^0].	callType _ descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^0].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == #')'] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	^120! !!Parser methodsFor: 'primitives' stamp: 'ar 12/2/1999 16:49'!externalType: descriptorClass	"Parse an return an external type"	| xType |	xType _ descriptorClass atomicTypeNamed: here.	xType == nil ifTrue:["Look up from class scope"		Symbol hasInterned: here ifTrue:[:sym|			xType _ descriptorClass structTypeNamed: sym]].	xType == nil ifTrue:[		"Raise an error if user is there"		self interactive ifTrue:[^nil].		"otherwise go over it silently"		xType _ descriptorClass forceTypeNamed: here].	self advance.	(self matchToken:#*)		ifTrue:[^xType asPointerType]		ifFalse:[^xType]! !!Parser methodsFor: 'primitives'!primitive	| n |	(self matchToken: #<) ifFalse: [^ 0].	n _ self primitiveDeclarations.	(self matchToken: #>) ifFalse: [^ self expected: '>'].	^ n! !!Parser methodsFor: 'primitives' stamp: 'ar 11/16/1999 22:01'!primitiveDeclarations	| prim module |	(self matchToken: 'primitive:') ifFalse:[^self externalFunctionDeclaration].	prim _ here.	(self match: #number) ifTrue:[^prim].	"Indexed primitives"	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^117! !Notification subclass: #ParserRemovedUnusedTemps	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!DisplayObject subclass: #Path	instanceVariableNames: 'form collectionOfPoints'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!Path commentStamp: '<historical>' prior: 0!I am the abstract superclass of the Graphic spatial primitives. I represent an ordered sequence of Points. Spatial primitives are used to generate "trajectories" such as lines and circles.!!Path methodsFor: 'accessing'!at: index 	"Answer the point on the receiver's path at position index."	^collectionOfPoints at: index! !!Path methodsFor: 'accessing'!at: index put: aPoint 	"Store the argument, aPoint, as the point on the receiver's path at position	index."	^collectionOfPoints at: index put: aPoint! !!Path methodsFor: 'accessing'!first	"Answer the first point on the receiver's path; included to correspond to 	OrderedCollection protocol."	^collectionOfPoints first! !!Path methodsFor: 'accessing'!firstPoint	"Answer the first point on the receiver's path."	^collectionOfPoints first! !!Path methodsFor: 'accessing'!firstPoint: aPoint 	"Replace the first element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 1 put: aPoint.	^aPoint! !!Path methodsFor: 'accessing'!form	"Answer the receiver's form, or, if form is nil, then answer a 1 x 1 black 	form (a black dot)."	| aForm |	form == nil		ifTrue: 			[aForm _ Form extent: 1 @ 1.			aForm fillBlack.			^aForm]		ifFalse: 			[^form]! !!Path methodsFor: 'accessing'!form: aForm 	"Make the argument, aForm, be the receiver's form."	form _ aForm! !!Path methodsFor: 'accessing'!last	"Answer the last point on the receiver's path; included to correspond to 	OrderedCollection protocol."	^collectionOfPoints last! !!Path methodsFor: 'accessing'!offset	"There are basically two kinds of display objects in the system: those	that, when asked to transform themselves, create a new object; and those	that side effect themselves by maintaining a record of the transformation	request (typically an offset). Path, like Rectangle and Point, is a display	object of the first kind."	self shouldNotImplement! !!Path methodsFor: 'accessing'!secondPoint	"Answer the second element of the receiver."	^collectionOfPoints at: 2! !!Path methodsFor: 'accessing'!secondPoint: aPoint 	"Replace the second element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 2 put: aPoint.	^aPoint! !!Path methodsFor: 'accessing'!size	"Answer the length of the receiver."	^collectionOfPoints size! !!Path methodsFor: 'accessing'!thirdPoint	"Answer the third element of the receiver."	^collectionOfPoints at: 3! !!Path methodsFor: 'accessing'!thirdPoint: aPoint 	"Replace the third element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 3 put: aPoint.	^aPoint! !!Path methodsFor: 'testing'!isEmpty	^collectionOfPoints isEmpty! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Display this Path--offset by aPoint, clipped by clipRect and the form 	associated with this Path will be displayedr according to one of the sixteen 	functions of two logical variables (rule). Also the source form will be first 	anded with aForm as a mask. Does not effect the state of the Path"	collectionOfPoints do: 		[:element | 		self form			displayOn: aDisplayMedium			at: element + aDisplayPoint			clippingBox: clipRectangle			rule: ruleInteger			fillColor: aForm]! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Displays this path, translated and scaled by aTransformation. Get the	scaled and translated Path."	| newPath transformedPath |	transformedPath _ displayTransformation applyTo: self.	newPath _ Path new.	transformedPath do: [:point | newPath add: point].	newPath form: self form.	newPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Path methodsFor: 'display box access'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	| box |	box _ Rectangle origin: (self at: 1) extent: 0 @ 0.	collectionOfPoints do: 		[:aPoint | box _ box merge: (Rectangle origin: aPoint extent: 0 @ 0)].	^box! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:26'!scaleBy: aPoint 	"Answers a new Path scaled by aPoint. Does not affect the current data in 	this Path."	| newPath | 	newPath _ self species new: self size. 	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element scaleBy: aPoint)].	^newPath! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:28'!translateBy: aPoint 	"Answers a new Path whose elements are translated by aPoint. Does not	affect the elements of this Path."	| newPath |	newPath _ self species new: self size.	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element translateBy: aPoint)].	^newPath! !!Path methodsFor: 'adding'!add: aPoint 	"Include aPoint as one of the receiver's elements."	collectionOfPoints add: aPoint! !!Path methodsFor: 'removing' stamp: 'di 4/4/2000 12:33'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element of the receiver.	Remove each element for which aBlock evaluates to true."	collectionOfPoints removeAllSuchThat: aBlock.! !!Path methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect the resulting values into a path that is like the receiver. Answer 	the new path."	| newCollection |	newCollection _ collectionOfPoints collect: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new path like the receiver only those elements for which 	aBlock evaluates to true. Answer the new path."	| newCollection |	newCollection _ collectionOfPoints select: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'private'!initializeCollectionOfPoints	collectionOfPoints _ OrderedCollection new! !!Path methodsFor: 'private'!initializeCollectionOfPoints: anInteger	collectionOfPoints _ OrderedCollection new: anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Path class	instanceVariableNames: ''!!Path class methodsFor: 'instance creation'!new	^self basicNew initializeCollectionOfPoints! !!Path class methodsFor: 'instance creation'!new: anInteger	^self basicNew initializeCollectionOfPoints: anInteger! !!Path class methodsFor: 'examples'!example	"Creates a Path from mousePoints and displays it several ways on the display screen. Messes up the display. For learning about class Path, just select the code below and execute it to create a path and see it redisplayed in another place on the screen. Each path displays using a different form. A path is indicated by pressing the red mouse button in a sequence; press any other mouse button to terminate. "	| aPath aForm pl fl flag |	aForm _ Form extent: 2 @ 40.		"creates a form one inch long"	aForm fillBlack.							"turns it black"	aPath _ Path new.	aPath form: aForm.						"use the long black form for displaying"	flag _ true.	[flag]		whileTrue: 			[Sensor waitButton.			Sensor redButtonPressed				ifTrue: 					[aPath add: Sensor waitButton.					Sensor waitNoButton.					aForm displayOn: Display at: aPath last]				ifFalse: [flag _ false]].	Display fillWhite.	aPath displayOn: Display.			"the original path"	pl _ aPath translateBy: 0 @ 100.	fl _ Form extent: 40 @ 40.	fl fillGray.	pl form: fl.	pl displayOn: Display.				"the translated path"	Sensor waitNoButton	"Path example"! !BitBlt subclass: #Pen	instanceVariableNames: 'location direction penDown'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Pen commentStamp: '<historical>' prior: 0!My instances can scribble on the screen or some other Form, drawing and printing at any angle. Since I am a BitBlt, the drawing can be done with an arbitary source Form.!!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:02'!defaultNib: widthInteger 	"Nib is the tip of a pen. This sets up the pen, with a nib of width widthInteger. You can also set the shape of the pen nib using:		roundNib: widthInteger, or		squareNib: widthInteger, or		sourceForm: aForm""Example:	| bic |	bic _ Pen new sourceForm: Cursor normal.	bic combinationRule: Form paint; turn: 90.	10 timesRepeat: [bic down; go: 3; up; go: 10]."	self color: Color black.	self squareNib: widthInteger.! !!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:03'!roundNib: diameter	"Makes this pen draw with a round dot of the given diameter."	self sourceForm: (Form dotOfSize: diameter).	combinationRule _ Form paint.! !!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:03'!squareNib: widthInteger 	"Makes this pen draw with a square nib of the given width."	self sourceForm: (Form extent: widthInteger @widthInteger) fillBlack.	self combinationRule: Form over.  "a bit faster than paint mode"! !!Pen methodsFor: 'accessing' stamp: 'ssa 2/25/2008 19:58'!destForm: aForm	destForm := aForm! !!Pen methodsFor: 'accessing'!direction	"Answer the receiver's current direction. 0 is towards the top of the	screen."	^direction! !!Pen methodsFor: 'accessing'!location	"Answer where the receiver is currently located."	^location! !!Pen methodsFor: 'operations' stamp: 'jm 4/28/1998 03:40'!color: aColorOrInteger	"Set the pen to the given color or to a color chosen from a fixed set of colors."	| count c |	aColorOrInteger isInteger		ifTrue: [			destForm depth = 1 ifTrue: [^ self fillColor: Color black].			count _ 19.  "number of colors in color wheel"			c _ (Color red wheel: count) at: ((aColorOrInteger * 7) \\ count) + 1]		ifFalse: [c _ aColorOrInteger].  "assume aColorOrInteger is a Color"	self fillColor: c.! !!Pen methodsFor: 'operations'!down	"Set the state of the receiver's pen to down (drawing)."	penDown _ true! !!Pen methodsFor: 'operations'!go: distance 	"Move the pen in its current direction a number of bits equal to the 	argument, distance. If the pen is down, a line will be drawn using the 	receiver's form source as the shape of the drawing brush."	self goto: (direction degreeCos @ direction degreeSin) * distance + location! !!Pen methodsFor: 'operations' stamp: 'di 11/4/97 20:11'!goto: aPoint 	"Move the receiver to position aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change."	| old |	old _ location.	location _ aPoint.	penDown ifTrue: [self drawFrom: old rounded								to: location rounded]	"NOTE:  This should be changed so it does NOT draw the first point, so as	not to overstrike at line junctions.  At the same time, place should draw	a single dot if the pen is down, as should down (put-pen-down) if it	was not down before."! !!Pen methodsFor: 'operations'!home	"Place the receiver at the center of its frame."	location _ destForm boundingBox center! !!Pen methodsFor: 'operations'!north	"Set the receiver's direction to facing toward the top of the display screen."	direction _ 270! !!Pen methodsFor: 'operations'!place: aPoint 	"Set the receiver at position aPoint. No lines are drawn."	location _ aPoint! !!Pen methodsFor: 'operations' stamp: 'ar 5/28/2000 12:10'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart form charStart rowStart scale wasDown bb pix |	scale _ sourceForm width.	wasDown _ penDown.	lineStart _ location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[form _ font characterFormAt: char.			charStart _ location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart _ location.				bb _ BitBlt current bitPeekerFromForm: form.				pix _ RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = 0						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: TextStyle defaultFont]"! !!Pen methodsFor: 'operations'!turn: degrees 	"Change the direction that the receiver faces by an amount equal to the 	argument, degrees."	direction _ direction + degrees! !!Pen methodsFor: 'operations'!up	"Set the state of the receiver's pen to up (no drawing)."	penDown _ false! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs'!hilbert: n side: s 	"Draw an nth level Hilbert curve with side length s in the center of the 	screen. Write directly into the display's bitmap only. A Hilbert curve is 	a space-filling curve."	| a m |	n = 0 ifTrue: [^self turn: 180].	n > 0		ifTrue: 			[a _ 90.			m _ n - 1]		ifFalse: 			[a _ -90.			m _ n + 1].	self turn: a.	self hilbert: 0 - m side: s.	self turn: a; go: s.	self hilbert: m side: s.	self turn: 0 - a; go: s; turn: 0 - a.	self hilbert: m side: s.	self go: s; turn: a.	self hilbert: 0 - m side: s.	self turn: a	" 	(Pen new) hilbert: 3 side: 8. 	(Pen new sourceForm: Cursor wait) combinationRule: Form under; 	hilbert: 3 side: 25.	"! !!Pen methodsFor: 'geometric designs'!hilberts: n   "Display restoreAfter: [Display fillWhite.  Pen new hilberts: 5]"	"Draws n levels of nested Hilbert curves"	| s |	self up; turn: 90; go: 128; down.	1 to: n do: 		[:i | 		s _ 256 bitShift: 0 - i.		self defaultNib: n - i * 2 + 1.		self color: i+1.		self up; go: 0 - s / 2; turn: -90; go: s / 2; turn: 90; down.		self hilbert: i side: s.		self go: s.		self hilbert: i side: s.		self go: s]! !!Pen methodsFor: 'geometric designs'!mandala: npoints	"Display restoreAfter: [Pen new mandala: 30]"	"On a circle of diameter d, place npoints number of points. Draw all 	possible connecting lines between the circumferential points."	| l points d |	Display fillWhite.	d _ Display height-50.	l _ 3.14 * d / npoints.	self home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l / 2; down.	points _ Array new: npoints.	1 to: npoints do: 		[:i | 		points at: i put: location rounded.		self go: l; turn: 360.0 / npoints].	npoints // 2		to: 1		by: -1		do: 			[:i | 			self color: i.			1 to: npoints do: 				[:j | 				self place: (points at: j).				self goto: (points at: j + i - 1 \\ npoints + 1)]]! !!Pen methodsFor: 'geometric designs' stamp: 'jm 5/6/1998 22:26'!spiral: n angle: a 	"Draw a double squiral (see Papert, MindStorms), where each design is made	by moving the receiver a distance of n after turning the amount + or -a."	1 to: n do: 		[:i | 		self color: i * 2.		self go: i; turn: a]"	Display restoreAfter: [		Display fillWhite. Pen new spiral: 200 angle: 89; home; spiral: 200 angle: -89]."! !!Pen methodsFor: 'geometric designs' stamp: 'jm 8/1/97 11:42'!web   "Display restoreAfter: [Pen new web]"	"Draw pretty web-like patterns from the mouse movement on the screen.	Press the mouse button to draw, option-click to exit.	By Dan Ingalls and Mark Lentczner. "	| history newPoint ancientPoint lastPoint filter color |	"self erase."	color _ 1.	[ true ] whileTrue:		[ history _ OrderedCollection new.		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ lastPoint _ Sensor mousePoint.		20 timesRepeat: [ history addLast: lastPoint ].		self color: (color _ color + 1).		[ Sensor redButtonPressed ] whileTrue: 			[ newPoint _ Sensor mousePoint.			(newPoint = lastPoint) ifFalse:				[ ancientPoint _ history removeFirst.				filter _ filter * 4 + newPoint // 5.				self place: filter.				self goto: ancientPoint.				lastPoint _ newPoint.				history addLast: filter ] ] ]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !!Pen methodsFor: 'private'!sourceForm: aForm	(aForm depth = 1 and: [destForm depth > 1])		ifTrue: ["Map 1-bit source to all ones for color mask"				colorMap _ Bitmap with: 0 with: 16rFFFFFFFF]		ifFalse: [colorMap _ nil].	^ super sourceForm: aForm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pen class	instanceVariableNames: ''!!Pen class methodsFor: 'instance creation'!new	^ self newOnForm: Display! !!Pen class methodsFor: 'instance creation'!newOnForm: aForm	| pen |	pen _ super new.	pen setDestForm: aForm.	pen sourceOrigin: 0@0.	pen home.	pen defaultNib: 1.	pen north.	pen down.	^ pen! !!Pen class methodsFor: 'examples' stamp: 'jm 5/6/1998 22:28'!example	"Draw a spiral with a pen that is 2 pixels wide."	"Display restoreAfter: [Pen example]"	| bic |	bic _ self new.	bic defaultNib: 2.	bic color: Color blue.	bic combinationRule: Form over.	1 to: 100 do: [:i | bic go: i*4. bic turn: 89].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'ar 5/14/2001 23:35'!feltTip: width cellSize: cellSize	"Warning: This example potentially uses a large amount of memory--it creates a Form with cellSize squared bits for every Display pixel."	"In this example, all drawing is done into a large, monochrome Form and then scaled down onto the Display using smoothing. The larger the cell size, the more possible shades of gray can be generated, and the smoother the resulting line appears. A cell size of 8 yields 64 possible grays, while a cell size of 16 gives 256 levels, which is about the maximum number of grays that the human visual system can distinguish. The width parameter determines the maximum line thickness. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen feltTip: 2.7 cellSize: 8"	| tabletScale bitForm pen warp p srcR dstR nibSize startP r |	tabletScale _ self tabletScaleFactor.	bitForm _ Form extent: Display extent * cellSize depth: 1.	pen _ Pen newOnForm: bitForm.	pen color: Color black.	warp _ (WarpBlt current toForm: Display)		sourceForm: bitForm;		colorMap: (bitForm colormapIfNeededFor: Display);		cellSize: cellSize;		combinationRule: Form over.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * cellSize * tabletScale) rounded.			nibSize _ (Sensor tabletPressure * (cellSize * width)) rounded.		     nibSize > 0				ifTrue: [					pen squareNib: nibSize.					startP _ pen location.					pen goto: p.					r _ startP rect: pen location.					dstR _ (r origin // cellSize) corner: ((r corner + nibSize + (cellSize - 1)) // cellSize).					srcR _ (dstR origin * cellSize) corner: (dstR corner * cellSize).					warp copyQuad: srcR innerCorners toRect: dstR]				ifFalse: [					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:20'!inkBrush	"Similar to simplePressurePen, but this example uses the average of the recent pen pressure values. The effect is that of a Japanese ink brush that comes up gradually off the paper as the brush is lifted, causing end (and beginning) of each stroke to taper. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen inkBrush"	| tabletScale historyMSecs pressureHistory pen now currentPressure sum averagePressure p |	tabletScale _ self tabletScaleFactor.	historyMSecs _ 120.	pressureHistory _ OrderedCollection new.	pen _ Pen newOnForm: Display.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			"compute the average pressure over last historyMSecs milliseconds"			now _ Time millisecondClockValue.			currentPressure _ (20.0 * Sensor tabletPressure) rounded.			pressureHistory addLast: (Array with: now with: currentPressure).			[pressureHistory size > 0 and:			 [(pressureHistory first first + historyMSecs) < now]]				whileTrue: [pressureHistory removeFirst].  "prune old entries"			sum _ pressureHistory inject: 0 into: [:t :e | t + e last].			averagePressure _ sum // pressureHistory size.			p _ (Sensor tabletPoint * tabletScale) rounded.		     averagePressure > 0				ifTrue: [					pen roundNib: averagePressure.					pen goto: p]				ifFalse: [					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:13'!simplePressurePen	"An example of using a pressure sensitive pen to control the thickness of the pen. This requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen simplePressurePen"	| tabletScale pen pressure p |	tabletScale _ self tabletScaleFactor.	pen _ Pen newOnForm: Display.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * tabletScale) rounded.			pressure _ (15.0 * Sensor tabletPressure) rounded.		     pressure > 0				ifTrue: [					pen roundNib: pressure.					pen goto: p]				ifFalse: [					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:12'!tabletScaleFactor	"Answer a Point that scales tablet coordinates to Display coordinates, where the full extent of the tablet maps to the extent of the entire Display."	| tabletExtent |	tabletExtent _ Sensor tabletExtent.	^ (Display width asFloat / tabletExtent x) @ (Display height asFloat / tabletExtent y)! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/12/1999 12:51'!testMouseTracking	"A very simple example of drawing using the mouse. Compare the tracking speed of this example with that of testTabletTracking. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testMouseTracking"	| pen p |	pen _ Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ Sensor cursorPoint.		     Sensor anyButtonPressed				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:21'!testTabletTracking	"A very simple example of drawing using the pen of a digitizing tablet such as a Wacom ArtZ tablet. This requires the optional tablet support primitives which may not be supported on all platforms. Compare the tracking speed of this example with that of testMouseTracking. On a Macintosh, the tablet primitives provide roughly 120 samples/second versus only 60 mouse samples/second, and the difference is noticable. Works best in full screen mode. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testTabletTracking"	| tabletScale pen p |	tabletScale _ self tabletScaleFactor.	pen _ Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * tabletScale) rounded.		     Sensor tabletPressure > 0				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !Controller subclass: #PluggableButtonController	instanceVariableNames: 'selector arguments shownAsComplemented'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableButtonController commentStamp: '<historical>' prior: 0!The controller for Buttons.  Not meant to be used with buttons that have mouseOver feeback when the button is not pressed.  Use mouseEnter/mouseLeave for that. !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:49'!controlInitialize 	"Provide feedback indicating that button has been entered with the mouse down. If triggerOnMouseDown is true, then do the button action on mouse down--and don't bother with the feedback since the action happens immediately."	sensor anyButtonPressed ifFalse: [^ self].	view triggerOnMouseDown		ifTrue: [sensor yellowButtonPressed 			ifTrue: [self yellowButtonActivity]			ifFalse: [view performAction]]		ifFalse: [view toggleMouseOverFeedback.				 shownAsComplemented _ true]! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:44'!controlTerminate 	"Reverse the feedback displayed by controlInitialize, if any. Perform the button action if necessary."	view ifNotNil:		[view triggerOnMouseDown			ifFalse:				[shownAsComplemented ifTrue: [view toggleMouseOverFeedback].				self viewHasCursor ifTrue: [view performAction]]]! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'sma 5/28/2000 16:29'!controlActivity 	shownAsComplemented ifNil: [^ self].	shownAsComplemented = self viewHasCursor		ifFalse:			[view ifNotNil: [view toggleMouseOverFeedback]. 			shownAsComplemented _ shownAsComplemented not]! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'acg 3/13/2000 08:26'!isControlActive 	^ sensor anyButtonPressed! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'tk 4/29/1998 10:47'!isControlWanted	"sensor flushKeyboard."	self viewHasCursor & sensor anyButtonPressed ifFalse: [^ false].	view askBeforeChanging		ifTrue: [^ model okToChange]  "ask before changing"		ifFalse: [^ true].! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 9/7/1999 08:44'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self terminateAndInitializeAround: [menu invokeOn: model]].! !View subclass: #PluggableButtonView	instanceVariableNames: 'label getStateSelector actionSelector getLabelSelector getMenuSelector shortcutCharacter askBeforeChanging triggerOnMouseDown complemented argumentsProvider argumentsSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableButtonView commentStamp: '<historical>' prior: 0!A PluggableButtonView is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector		invoke this button's action on the modelEither of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs a pluggable view of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.Options:	askBeforeChanging		have model ask user before allowing change that could lose edits	triggerOnMouseDown	do button action on mouse down (vs. up) transition	shortcutCharacter		a place to record an optional shortcut key!!PluggableButtonView methodsFor: 'initialize-release' stamp: 'jm 5/2/1998 15:20'!initialize 	super initialize.	label _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	shortcutCharacter _ nil.	askBeforeChanging _ false.	triggerOnMouseDown _ false.	complemented _ false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'sw 2/17/2002 05:32'!on: anObject getState: getStateSel action: actionSel getArguments: getArgumentsSel from: argsProvidor label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector _ getStateSel.	actionSelector _ actionSel.	argumentsSelector _ getArgumentsSel.	argumentsProvider _ argsProvidor.	getLabelSelector _ labelSel.	getMenuSelector _ menuSel! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector _ getStateSel.	actionSelector _ actionSel.	getLabelSelector _ labelSel.	getMenuSelector _ menuSel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 18:53'!askBeforeChanging	^ askBeforeChanging! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging _ aBoolean.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:38'!label	"Answer the DisplayObject used as this button's label."	^ label! !!PluggableButtonView methodsFor: 'accessing' stamp: 'nk 4/17/2004 19:49'!label: aStringOrDisplayObject 	"Label this button with the given String or DisplayObject."	((aStringOrDisplayObject isKindOf: Paragraph)	or: [aStringOrDisplayObject isForm])		ifTrue: [label _ aStringOrDisplayObject]		ifFalse: [label _ aStringOrDisplayObject asParagraph].	self centerLabel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter	"Return the Character to be used as a shortcut to turn on this switch, or nil if this switch doesn't have a keyboard shortcut."	^ shortcutCharacter! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter _ aCharacter.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 19:26'!triggerOnMouseDown	^ triggerOnMouseDown! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown _ aBoolean.! !!PluggableButtonView methodsFor: 'controller access' stamp: 'jm 4/2/98 17:39'!defaultControllerClass 	^ PluggableButtonController! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:49'!deEmphasizeView 	self getModelState ifTrue: [self displayNormal].! !!PluggableButtonView methodsFor: 'displaying'!display	"Sets the PluggableButtonView mode to 'normal', displays the border, displays the inside and, if its model is 'on', complements the inside."	self displayBorder.	self displayView.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:49'!displayComplemented	"Complement the receiver if it isn't already."	complemented ifFalse: [		complemented _ true.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:43'!displayNormal	"Complement the receiver if its mode is 'complemented'."	complemented ifTrue: [		complemented _ false.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'acg 2/23/2000 00:18'!displayView	"Displays this switch and its label, if any."	self clearInside.	label ifNotNil: [		(label isKindOf: Paragraph) ifTrue: [			label foregroundColor: self foregroundColor				 backgroundColor: self backgroundColor].		label displayOn: Display				at: label boundingBox topLeft				clippingBox: self insetDisplayBox].	complemented _ false.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:41'!emphasizeView 	self getModelState ifTrue: [self displayComplemented].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/5/98 12:54'!toggleMouseOverFeedback	"Complement the label (or a portion of the displayBox if no label is defined) to show that the mouse is over this button. This feedback can be removed by a second call to this method."	Display reverse: self insetDisplayBox fillColor: Color gray.	Display reverse: (self insetDisplayBox insetBy: 2) fillColor: Color gray.! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/7/98 19:12'!defaultWindow	"Return a rectangle large enough to contain this button's label. If this button is label-less, just return the standard View default window."	label == nil		ifTrue: [^ super defaultWindow]		ifFalse: [^ label boundingBox expandBy: 6].! !!PluggableButtonView methodsFor: 'other' stamp: 'sw 2/17/2002 05:32'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed."	argumentsSelector		ifNil:			[actionSelector ifNotNil:				[model perform: actionSelector]]		ifNotNil:			[model perform: actionSelector				withArguments:					(Array with: (argumentsProvider perform: argumentsSelector))]! !!PluggableButtonView methodsFor: 'other' stamp: 'tk 4/27/1998 21:23'!update: aParameter 	aParameter == getLabelSelector ifTrue: [		getLabelSelector ifNotNil: [			self label: (model perform: getLabelSelector).			self displayView]].	self getModelState 		ifTrue: [self displayComplemented]		ifFalse: [self displayNormal].! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/7/98 19:12'!window: aWindow	"Center my label when my window changes."	super window: aWindow.	self centerLabel.! !!PluggableButtonView methodsFor: 'private' stamp: 'nk 4/17/2004 19:49'!centerAlignLabelWith: aPoint	"Align the center of the label with aPoint."	| alignPt |	alignPt _ label boundingBox center.	(label isKindOf: Paragraph) ifTrue: 		[alignPt _ alignPt + (0@(label textStyle leading))]. 	(label isForm)	  ifTrue: [label offset: 0 @ 0].	label align: alignPt with: aPoint! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:10'!centerLabel	"If there is a label, align its center with the center of the insetDisplayBox"	label ifNotNil: 		[self centerAlignLabelWith: self insetDisplayBox center].! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView methodsFor: 'private' stamp: 'jm 4/4/98 20:50'!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	getStateSelector == nil		ifTrue: [^ false]		ifFalse: [^ model perform: getStateSelector].! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:09'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: 		[insetDisplayBox _ self computeInsetDisplayBox.		 self centerLabel].	^insetDisplayBox! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableButtonView class	instanceVariableNames: ''!!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:19'!on: anObject getState: getStateSel action: actionSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: nil		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'sumim 2/15/2002 17:18'!on: anObject getState: getStateSel action: actionSel getArguments: getArgumentsSel from: argsProvidor	^ self new		on: anObject		getState: getStateSel		action: actionSel		getArguments: getArgumentsSel		from: argsProvidor		label: nil		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:19'!on: anObject getState: getStateSel action: actionSel label: labelSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: menuSel! !!PluggableButtonView class methodsFor: 'example' stamp: 'jm 4/7/98 19:55'!example	"PluggableButtonView example"	| s1 s2 s3 b1 b2 b3 topView |	s1 _ Switch new.	s2 _ Switch new turnOn.	s3 _ Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 _ (PluggableButtonView on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 _ (PluggableButtonView on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 _ (PluggableButtonView on: s3 getState: #isOn action: #turnOn) label: 'S3'.	b1 borderWidth: 1.	b2 borderWidth: 1.	b3 borderWidth: 1.	topView _ StandardSystemView new		label: 'Switch Test';		addSubView: b1;		addSubView: b2 toRightOf: b1;		addSubView: b3 toRightOf: b2.	topView controller open.! !Dictionary subclass: #PluggableDictionary	instanceVariableNames: 'hashBlock equalBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!PluggableDictionary commentStamp: '<historical>' prior: 0!Class PluggableDictionary allows the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the dictionary. See the class comment of PluggableSet for an example.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.!!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	equalBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'dvf 6/10/200019:34'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	self equalBlock ifNotNil: [aSet equalBlock: self equalBlock fixTemps].	self hashBlock ifNotNil: [aSet hashBlock: self hashBlock fixTemps].	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!copy	^super copy postCopyBlocks! !!PluggableDictionary methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:35'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableDictionary methodsFor: 'private' stamp: 'dvf 6/11/2000 01:33'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start _ (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !FileList subclass: #PluggableFileList	instanceVariableNames: 'accepted fileFilterBlock canAcceptBlock validateBlock newFiles prompt resultBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!PluggableFileList commentStamp: '<historical>' prior: 0!I am a model for a modal dialog akin to "Standard File Services" on various modern GUI operating systems.  My protocol includes some methods to maintain upward compatibility with StandardFileMenu, which I hope to replace.Sample doIts:	"StandardFileDialog getFolder"-- ask user to select folder, answer corresponding FileDirectory	"StandardFileDialog getFile"	-- ask user to select file, answer corresponding FileStream	"StandardFileDialog putFile"	-- ask user to create new file, answer FileStream  In addition to the instance variables inhereted from FileList, of which I am a subclass, I am pluggable via the following instance variables:prompt			<String>	Display a prompt between the buttons.resultBlock		<BlockContext>	Passed a file directory and a file name, answer the result to be answered by the dialog.	canAcceptBlock	<BlockContext>		Answer whether the accept button should be "active"fileFilterBlock	<BlockContext>		Passed a file directory entry, answer whether the entry should be added to the list.  The list can be further filtered (but not expanded) by the user through the pattern.validateBlock	<BlockContent>	Passed a file directory entry, a file name and a collection of newly created files, answer whether the dialog selection is valid.  validateBlock is checked after the user has pressed accept, for example to ask if the user really meant to delete a file.newFiles		<OrderedCollection>	newFiles is an OrderedCollection of fileNames of files added by the user to the current directory since the user last entered same!!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 21:44'!defaultBackgroundColor	^Color lightYellow! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 14:52'!initialize	prompt _ 'Select File'.	directory _ FileDirectory default.	newFiles _ OrderedCollection new.	fileFilterBlock _ PluggableFileList allFilesAndFoldersFileFilter.	canAcceptBlock _ PluggableFileList fileNameSelectedAcceptBlock.	resultBlock _ PluggableFileList pathNameResultBlock.	validateBlock _ PluggableFileList checkExistingFileValidateBlock.! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/9/2000 01:28'!open	^self openLabel: directory pathName! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 01:10'!openLabel: aString	"Open a view of an instance of me."	"StandardFileDialog new open"	| topView volListView templateView fileListView fileStringView leftButtonView middleButtonView rightButtonView |		self directory: directory.	topView _ (PluggableFileListView new)		model: self.	volListView _ PluggableListView on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: self		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	"fileStringView _ PluggableTextView on: self		text: #fileString		accept: #fileString:.	fileStringView askBeforeDiscardingEdits: false.	fileStringView window: (0@0 extent: 200@15).	topView addSubView: fileStringView below: templateView."	fileStringView _ templateView.	leftButtonView _ PluggableButtonView 		on: self		getState: nil		action: #leftButtonPressed.	leftButtonView		label: 'Cancel';		backgroundColor: Color red;		borderWidth: 3;		window: (0@0 extent: 50@15).	middleButtonView _ PluggableButtonView		on: self		getState: nil		action: nil.	middleButtonView		label: prompt;		window: (0@0 extent: 100@15);		borderWidth: 1;		controller: NoController new.	rightButtonView _ PluggableButtonView		on: self		getState: nil		action: #rightButtonPressed.	rightButtonView		label: 'Accept';		backgroundColor: (self canAccept ifTrue: [Color green] ifFalse: [Color lightYellow]);		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]);		window: (0@0 extent: 50@15).	self canAccept ifFalse: [rightButtonView controller: NoController new].	topView acceptButtonView: rightButtonView.	topView		addSubView: leftButtonView below: fileStringView;		addSubView: middleButtonView toRightOf: leftButtonView;		addSubView: rightButtonView toRightOf: middleButtonView.	self changed: #getSelectionSel.	topView doModalDialog.		^self result! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:33'!beAccepted	^accepted _ true! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 09:10'!canAccept	^canAcceptBlock value: directory value: fileName! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:52'!canAcceptBlock: aBlock	^canAcceptBlock _ aBlock! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 07:33'!fileFilterBlock: aBlock	^fileFilterBlock _ aBlock! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/18/2000 21:21'!fileListIndex	self changed: #fileString.	^super fileListIndex! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/18/2000 21:21'!fileVolumeIndex	self changed: #fileString.	^super fileVolumeIndex! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:28'!prompt: aString	 prompt _ aString! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:31'!resultBlock: aBlock	^resultBlock _ aBlock! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:28'!validate	^validateBlock value: directory value: fileName value: newFiles! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/10/2000 08:02'!validateBlock: aBlock	^validateBlock _ aBlock! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 01:05'!leftButtonPressed	accepted _ false.	self changed: #close.! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/14/2000 22:40'!leftButtonState	^true! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 00:38'!result	accepted ifFalse: [^nil].	^resultBlock value: directory value: fileName! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/10/2000 07:58'!rightButtonPressed	(canAcceptBlock value: directory value: fileName) ifFalse: [^nil].	(validateBlock value: directory value: fileName value: newFiles) ifFalse: [^nil].	accepted _ true.	self changed: #close! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/14/2000 22:43'!rightButtonState	^self canAccept! !!PluggableFileList methodsFor: 'file list menu' stamp: 'acg 2/10/2000 07:47'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'New ',aString,' Name?' 					initialAnswer: aString,'Name')		isEmpty ifTrue: [^ self].	newName _ response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.	newFiles add: newName! !!PluggableFileList methodsFor: 'file list menu' stamp: 'asm 8/25/2003 18:37'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 services |	firstItems _ self itemsForFile: self fullName asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems size.	n2 _ n1 + secondItems size.	n3 _ n2 + thirdItems size.	services _ firstItems, secondItems, thirdItems, 			(OrderedCollection with: (SimpleServiceEntry provider: self label: 'more...' selector: #offerAllFileOptions)).	^ aMenu 		addServices2: services 		for: self		extraLines: (Array with: n1 with: n2 with: n3)! !!PluggableFileList methodsFor: 'file list menu' stamp: 'BG 12/13/2002 10:00'!itemsForNoFile   ^(OrderedCollection new: 5)        add: self serviceSortByName;        add: self serviceSortBySize;        add: self serviceSortByDate;        add: self serviceAddNewFile;        add: self serviceAddNewDirectory;        yourself! !!PluggableFileList methodsFor: 'file list menu' stamp: 'BG 10/29/2003 10:08'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles |	entries _ directory entries select: fileFilterBlock.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList _ (SortedCollection new: 30) sortBlock: self sortBlock.	allFiles _ pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [entry isDirectory or: [pat match: entry first]]) ifTrue:			[newList add: entry]].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray" ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])"].	newFiles _ OrderedCollection new.	^ newList asArray.! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/18/2000 21:23'!fileString	fileName ifNil: [^directory pathName].	^directory fullNameFor: fileName! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/19/2000 01:02'!fileString: aString	"| textName index ending |	textName _ aString asString.	(FileDirectory default fileExists: textName) ifTrue:		[self directory: (FileDirectory forFileName: textName).		 index _ list indexOf: (FileDirectory localNameFor: textName).		 index = 0 ifTrue: 			[ending _ ') ', (FileDirectory localNameFor: textName).		  	 index _ list findFirst: [:line | line endsWith: ending]].		 self fileListIndex: index].	(FileDirectory default directoryExists: textName) ifTrue:		[self directory: (FileDirectory on: textName)]."	self changed: #fileString.	self changed: #contents.	^true! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'ar 3/18/2001 00:55'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor cursorPoint]).! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'acg 2/12/2000 15:35'!startUpWithCaption: aString at: location	self prompt: aString.	^self open! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableFileList class	instanceVariableNames: ''!!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFilePathNameDialog	^(self new)		validateBlock: PluggableFileList alwaysValidateBlock;		yourself! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFilePathNameDialogWithExistenceCheck	^(self new)		prompt: 'Select New File:';		validateBlock: PluggableFileList checkExistingFileValidateBlock;		yourself! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFolderDialog	^(self new)		prompt: 'Select a Folder';		fileFilterBlock: PluggableFileList allFoldersFileFilter;		canAcceptBlock: PluggableFileList alwaysAcceptBlock;		resultBlock: PluggableFileList directoryResultBlock;		validateBlock: PluggableFileList alwaysValidateBlock;		yourself! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/9/2000 00:34'!open	^self new open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:24'!getFile	| result |	result _ self getFilePathName.	^result ifNotNil: [FileStream oldFileNamed: result]! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:31'!getFilePathName	^self getFilePathNameDialog open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!getFilePathNameWithExistenceCheck	^self getFilePathNameDialogWithExistenceCheck open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/9/2000 01:16'!getFolder	^self getFolderDialog open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!putFile	| result |	result _ self getFilePathNameWithExistenceCheck.	^result ifNotNil: 		[FileDirectory deleteFilePath: result.		 FileStream newFileNamed: result]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:19'!directoryResultBlock	^[:theDirectory :theFileName | theDirectory]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:07'!fileNameResultBlock	^[:theDirectory :theFileName | theFileName]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:07'!pathNameResultBlock	^[:theDirectory :theFileName | 		theFileName 			ifNil: [theDirectory pathName]			ifNotNil: [theDirectory fullNameFor: theFileName]].! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/12/2000 15:08'!sfmResultBlock	^[:theDirectory :theFileName | 		StandardFileMenuResult directory: theDirectory name: theFileName]! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'acg 2/10/2000 08:18'!alwaysAcceptBlock	^[:theDirectory :theFileName | true]! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'acg 2/10/2000 08:10'!fileNameSelectedAcceptBlock	^[:theDirectory :theFileName | theFileName isNil not]! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 08:27'!alwaysValidateBlock	^[:theDirectory :theFileName :theNewFiles | true].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/12/2000 14:52'!checkExistingFileValidateBlock	^[:theDirectory :theFileName :theNewFiles | 		(theNewFiles includes: theFileName) or:			[(PluggableFileList okToOverwrite: theFileName)]].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/12/2000 14:52'!existingFileValidateBlock	^[:theDirectory :theFileName :theNewFiles | 		(theNewFiles includes: theFileName) or:			[(PluggableFileList okToOverwrite: theFileName)]].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 08:05'!okToOpen: aFileNameString without: aSuffixString	"Answer whether user confirms that it is ok to overwrite the file named in aString"	^ 1 = ((PopUpMenu		labels:'overwrite that fileselect another file')		startUpWithCaption: aFileNameString, 'already exists.')! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 07:55'!okToOverwrite: aString	"Answer whether user confirms that it is ok to overwrite the file named in aString"	^ 1 = ((PopUpMenu		labels:'overwrite that fileselect another file')		startUpWithCaption: aString, 'already exists.')! !!PluggableFileList class methodsFor: 'fileFilterBlocks' stamp: 'acg 2/10/2000 08:16'!allFilesAndFoldersFileFilter	^[:each | true]! !!PluggableFileList class methodsFor: 'fileFilterBlocks' stamp: 'acg 2/10/2000 08:17'!allFoldersFileFilter	^[:each | each isDirectory]! !!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'BG 12/13/2002 15:31'!newFileMenu: aDirectory	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"	^(self getFilePathNameDialogWithExistenceCheck)		resultBlock: self sfmResultBlock;		directory: aDirectory;		yourself! !!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'BG 12/13/2002 15:32'!oldFileMenu: aDirectory	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"	^(self getFilePathNameDialog)		resultBlock: self sfmResultBlock;		directory: aDirectory;		yourself! !ModalSystemWindowView subclass: #PluggableFileListView	instanceVariableNames: 'acceptButtonView'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!PluggableFileListView commentStamp: '<historical>' prior: 0!I provide aview for PluggableFileList!!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:57'!acceptButtonView: aView	^acceptButtonView _ aView! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/18/2000 20:52'!label: aString	super label: aString.	self noLabel! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:55'!update: aSymbol	(aSymbol = #volumeListIndex or: [aSymbol = #fileListIndex])		ifTrue: [self updateAcceptButton].	^super update: aSymbol! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 09:40'!updateAcceptButton	self model canAccept		ifTrue:			[acceptButtonView				backgroundColor: Color green;				borderWidth: 3;				controller: acceptButtonView defaultController]		ifFalse:			[acceptButtonView				backgroundColor: Color lightYellow;				borderWidth: 1;				controller: NoController new].	acceptButtonView display.! !ListController subclass: #PluggableListController	instanceVariableNames: 'terminateDuringSelect'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableListController methodsFor: 'initialization' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'control defaults' stamp: 'tk 4/1/98 09:40'!redButtonActivity	model okToChange   "Don't change selection if model refuses to unlock"		ifTrue: [^ super redButtonActivity]! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'private' stamp: 'sma 3/11/2000 15:38'!processKeyboard	sensor keyboardPressed		ifTrue: [view handleKeystroke: sensor keyboard]		ifFalse: [super processKeyboard]! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect _ trueOrFalse! !PluggableListController subclass: #PluggableListControllerOfMany	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'tpr 10/4/2001 22:19'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit _ true.	scrollFlag _ false.	lastSelection _ 0.	[sensor redButtonPressed] whileTrue: 		[selection _ view findSelection: (pt _ sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag _ true.				selection _ view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag _ true.				selection _ view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit _ false.				turningOn _ (view listSelectionAt: selection) not].			view selection: selection.			(view listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				view listSelectionAt: selection put: turningOn].			lastSelection _ selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		view listSelectionAt: selection put: (view listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListControllerOfMany methodsFor: 'scrolling' stamp: 'tk 4/8/98 11:09'!scrollView: anInteger 	"Need to minimize the selections which get recomputed"	| oldLimit |	oldLimit _ anInteger > 0		ifTrue: [view firstShown]		ifFalse: [view lastShown].	(view scrollBy: anInteger)		ifTrue: [anInteger > 0  "Highlight selections brought into view"					ifTrue: [view highlightFrom: view firstShown								to: (oldLimit-1 min: view lastShown)]					ifFalse: [view highlightFrom: (oldLimit+1 max: view firstShown)								to: view lastShown].				^ true]		ifFalse: [^ false]! !ListView subclass: #PluggableListView	instanceVariableNames: 'getListSelector getSelectionSelector setSelectionSelector getMenuSelector getMenuTitleSelector keystrokeActionSelector autoDeselect items'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableListView commentStamp: '<historical>' prior: 0!A pluggable list view gets its content from the model. This allows the same kind of view to be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:		getListSel		fetch the list of items (strings) to be displayed		getSelectionSel	get the currently selected item		setSelectionSel	set the currently selected item (takes an argument)		getMenuSel		get the pane-specific, 'yellow-button' menu		keyActionSel	process a keystroke typed in this pane (takes an argument)	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!!	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song.	AutoDeselect is a feature, normally set to true, that will tell the model that there is no selection if you click on an item that is currently selected.  If autoDeselect is false, then the model will simply be told to select the same item again.!!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:56'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect _ trueOrFalse.! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	super font: aFontOrNil.	self list: self getList.  "update display"! !!PluggableListView methodsFor: 'initialization' stamp: 'di 6/20/2001 09:58'!list: arrayOfStrings	"Set the receivers items to be the given list of strings	The instance variable 'items' holds the original list. The instance variable 'list' is a paragraph constructed from this list."	((items == arrayOfStrings) "fastest" or: [items = arrayOfStrings]) ifTrue: [^ self].	items _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do:					[:item | item == nil ifFalse:						[(item isMemberOf: MethodReference)  "A very specific fix for MVC"							ifTrue: [s nextPut: item asStringOrText]							ifFalse: [s nextPut: item]]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'tk 4/12/1998 08:25'!menu: getMenuSel	getMenuSelector _ getMenuSel! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector _ getMenuTitleSel! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:55'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	| newIndex |	newIndex _ anInteger.	(autoDeselect == nil or: [autoDeselect]) ifTrue:		[getSelectionSelector ifNotNil:			[(model perform: getSelectionSelector) = anInteger ifTrue:				["Click on existing selection deselects"				newIndex _ 0]]].	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: newIndex].! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!getCurrentSelectionIndex	"Answer the index of the current selection."	getSelectionSelector == nil ifTrue: [^ 0].	^ model perform: getSelectionSelector! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access' stamp: 'tk 4/2/98 13:36'!getListSelector	^ getListSelector! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu _ model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu _ model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'tk 4/21/1998 08:26'!handleKeystroke: aCharacter	"Answer the menu for this list view."	| args |	keystrokeActionSelector == nil ifTrue: [^ nil].	controller controlTerminate.	(args _ keystrokeActionSelector numArgs) = 1		ifTrue: [model perform: keystrokeActionSelector with: aCharacter.				^ controller controlInitialize].	args = 2		ifTrue: [model perform: keystrokeActionSelector with: aCharacter with: self.				^ controller controlInitialize].	^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'sw 10/9/1998 08:24'!setSelectionSelectorIs: aSelector	^ aSelector == setSelectionSelector! !!PluggableListView methodsFor: 'controller access' stamp: 'jm 3/11/98 17:17'!defaultControllerClass 	^ PluggableListController! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/25/1998 10:24'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].! !!PluggableListView methodsFor: 'updating' stamp: 'BG 1/22/2004 13:15'!verifyContents	| newItems existingSelection anIndex |	"Called on window reactivation to react to possible structural changes.  Update contents if necessary."	newItems _ self getList.	((items == newItems) "fastest" or: [items = newItems]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection _ list stringAtLineNumber: (selection + (topDelimiter ifNil: [0] ifNotNil: [1])).  "account for cursed ------ row"	self list: newItems.	(newItems size > 0 and: [newItems first isKindOf: Symbol]) ifTrue:		[existingSelection _ existingSelection asSymbol].	(anIndex _ newItems indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.]		ifNil:			[self changeModelSelection: 0].	selection := 0. " to display the list without selection "	self displayView.	self update: getSelectionSelector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableListView class	instanceVariableNames: ''!!PluggableListView class methodsFor: 'instance creation' stamp: 'tk 4/17/1998 20:41'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: #arrowKey:from:		"default"! !!PluggableListView class methodsFor: 'instance creation' stamp: 'tk 4/17/1998 20:41'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListView class methodsFor: 'instance creation'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !PluggableListView subclass: #PluggableListViewByItem	instanceVariableNames: 'itemList'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:28'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setSelectionSelector with: item].! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:27'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item _ model perform: getSelectionSelector.	^ itemList findFirst: [ :x | x = item]! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'sw 12/9/1999 18:07'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !PluggableListView subclass: #PluggableListViewOfMany	instanceVariableNames: 'getSelectionListSelector setSelectionListSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	selection _ 0.	1 to: self maximumSelection do:		[:i | selection _ i.		(self listSelectionAt: i) ifTrue: [self deEmphasizeSelectionBox]].	selection _ 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!highlightFrom: start to: stop	(start == nil or: [stop == nil]) ifTrue: [^ self displayView].	start to: stop do:		[:i | selection _ i.		(self listSelectionAt: selection) ifTrue: [self displaySelectionBox]].	selection _ 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 20:42'!scrollBy: anInteger	"This is a possible way to intercept what ListOfManyController did to get multiple selections to show.  Feel to replace this."	| ans |	ans _ super scrollBy: anInteger."	self displaySelectionBox."	^ ans! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tpr 10/4/2001 22:17'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tpr 10/4/2001 22:17'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[selection _ anInteger.			self displaySelectionBox]! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!selection	"Have to override normal controller smarts about deselection"	^ 0! !!PluggableListViewOfMany methodsFor: 'updating' stamp: 'tk 4/8/98 13:12'!update: aSymbol 	aSymbol == getListSelector		ifTrue: [self list: self getList.			^ self displayView; emphasizeView].	aSymbol == getSelectionSelector		ifTrue: [^ self displayView; emphasizeView].	aSymbol == #allSelections		ifTrue: [^ self displayView; emphasizeView].	^ super update: aSymbol! !!PluggableListViewOfMany methodsFor: 'controller access' stamp: 'di 5/17/1998 22:48'!defaultControllerClass 	^ PluggableListControllerOfMany! !!PluggableListViewOfMany methodsFor: 'initialization' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector _ getListSel.	setSelectionListSelector _ setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableListViewOfMany class	instanceVariableNames: ''!!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 20:52'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !Set subclass: #PluggableSet	instanceVariableNames: 'hashBlock equalBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!PluggableSet commentStamp: '<historical>' prior: 0!PluggableSets allow the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the set which in turn can heavily improve the performance of sets and dictionaries.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.Example: Adding 1000 integer points in the range (0@0) to: (100@100) to a set.	| rnd set max pt |	set _ Set new: 1000.	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].The above is way slow since the default hashing function of points leads to an awful lot of collisions in the set. And now the same, with a somewhat different hash function:	| rnd set max pt |	set _ PluggableSet new: 1000.	set hashBlock:[:item| (item x bitShift: 16) + item y].	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].!!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock _ aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:47'!copy	^super copy postCopyBlocks! !!PluggableSet methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:34'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableSet methodsFor: 'private' stamp: 'dvf 6/11/2000 00:54'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start _ (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !StringHolderController subclass: #PluggableTextController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'sma 3/15/2000 21:39'!bsText	self changeText: (self text copyFrom: 1 to: (self text size - 1 max: 0))! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/13/1998 14:16'!changeText: aText	"The paragraph to be edited is changed to aText."	paragraph text: aText.	self resetState.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self selectAndScroll.	self deselect! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect _ paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet _ self visibleAreas.	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController methodsFor: 'transcript' stamp: 'th 9/20/2002 11:26'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY _ self stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY _ self stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/7/1998 22:23'!visibleAreas	"Transcript dependents last controller visibleAreas"	| visibleAreas rect remnants myTopController |	myTopController _ self view topView controller.	visibleAreas _ Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | c == myTopController ifTrue: [^ visibleAreas].		rect _ c view windowBox.		remnants _ OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas _ remnants].	^ visibleAreas! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'dgd 9/21/2003 17:47'!accept 	view hasUnacceptedEdits ifFalse: [^ view flash].	view hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	(view setText: paragraph text from: self) ifTrue:		[initialText _ paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]]    .! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'tk 3/31/98 20:49'!userHasEdited	"Note that the user has edited my text."	view hasUnacceptedEdits: true! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'tk 3/31/98 20:49'!userHasNotEdited	"Note that my text is free of user edits."	view hasUnacceptedEdits: false! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:37'!selectForTopFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: start to: stop scroll: #selectAndScrollToTop! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:37'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: start to: stop scroll: #selectAndScroll! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:35'!selectFrom: start to: stop scroll: scrollCommand	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[view superView ifNotNil: [self deselect].		self selectInvisiblyFrom: start to: stop].	view superView ifNotNil: [self perform: scrollCommand]! !StringHolderView subclass: #PluggableTextView	instanceVariableNames: 'getTextSelector setTextSelector getSelectionSelector getMenuSelector hasEditingConflicts'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!PluggableTextView commentStamp: '<historical>' prior: 0!A PluggableTextView gets its content from the model. This allows the same kind of view to be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. See the class comment for PluggableListView.Selectors are:		getTextSel		fetch the original text from the model		setTextSel		submit new text to the model when user "accepts"		getSelectionSel	get the current text selection range		getMenuSel		get the pane-specific, 'yellow-button' menu	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if setTextSel is nil then this view is consider read-only.	The model informs a pluggable view of changes by sending #changed: to itself with getTextSel as a parameter. The view informs the model of selection changes by sending setTextSel to it with the newly selected item as a parameter, and invokes menu actions on the model via getMenuSel.!!PluggableTextView methodsFor: 'initialization' stamp: 'jm 3/29/98 07:24'!defaultControllerClass 	^ PluggableTextController! !!PluggableTextView methodsFor: 'initialization' stamp: 'sw 10/29/1999 21:02'!initialize 	super initialize.	hasEditingConflicts _ false! !!PluggableTextView methodsFor: 'initialization' stamp: 'tk 4/6/98 10:51'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	getMenuSelector _ getMenuSel.	self borderWidth: 1.	self editString: self getText.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'initialization' stamp: 'jm 3/29/98 07:25'!setSelection: sel	controller selectFrom: sel first to: sel last.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'sw 1/16/1999 14:31'!getSelection	"Answer the model's selection interval."	getSelectionSelector == nil ifTrue: [^ 1 to: 0].  "null selection"	^ getSelectionSelector ifNotNil: [model perform: getSelectionSelector]! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 4/1/98 08:32'!getText 	"Answer the list to be displayed."	| txt |	getTextSelector == nil ifTrue: [^ Text new].	txt _ model perform: getTextSelector.	txt == nil ifTrue: [^ Text new].	self hasUnacceptedEdits: false.	"clean now"	^ txt! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 3/31/98 15:58'!getTextSelector	"This is sent to the model to find out what text to display"	^ getTextSelector! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 5/3/1998 19:29'!isReadOnlyView	^ setTextSelector == nil! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 8/20/1998 11:55'!model: aLockedModel 	"Refer to the comment in View|model:." 	self model: aLockedModel controller: controller.	self editString: self getText.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 3/10/98 13:51'!setText: textToAccept from: ctlr	"Inform the model of text to be accepted, and return true if OK.	Any errors should be reported to the controller, ctlr."	setTextSelector == nil ifTrue: [^ true].	setTextSelector numArgs = 2		ifTrue: [^ model perform: setTextSelector with: textToAccept with: ctlr]		ifFalse: [^ model perform: setTextSelector with: textToAccept]! !!PluggableTextView methodsFor: 'model access' stamp: 'di 4/27/1998 12:46'!updateDisplayContents	self editString: self getText.	self displayView.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:03'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasUnacceptedEdits: aBoolean	super hasUnacceptedEdits: aBoolean.	aBoolean ifFalse: [hasEditingConflicts _ false]! !!PluggableTextView methodsFor: 'updating' stamp: 'tk 5/23/2001 12:26'!update: aSymbol	"Refer to the comment in View|update:. Do nothing if the given symbol does not match any action. "	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [self promptForCancel].  ^ self].	aSymbol == #flash ifTrue: [^ controller flash].	aSymbol == getTextSelector ifTrue: [^ self updateDisplayContents].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[ParagraphEditor abandonChangeText.	"no replacement!!"			^ controller setSearch: model autoSelectString;					againOrSame: true].	aSymbol == #appendEntry ifTrue:			[^ controller doOccluded: [controller appendEntry]].	aSymbol == #clearText ifTrue:			[^ controller doOccluded:				[controller changeText: Text new]].	aSymbol == #bs ifTrue:			[^ controller doOccluded:				[controller bsText]].	aSymbol == #codeChangedElsewhere ifTrue:			[^ self hasEditingConflicts: true]! !!PluggableTextView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasEditingConflicts ifNil: [hasEditingConflicts _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PluggableTextView methodsFor: 'controller access' stamp: 'BG 11/26/2003 16:06'!selectionInterval  ^self controller selectionInterval! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableTextView class	instanceVariableNames: ''!!PluggableTextView class methodsFor: 'instance creation' stamp: 'jm 3/29/98 07:24'!on: anObject text: getTextSel accept: setTextSel	^ self on: anObject		text: getTextSel		accept: setTextSel		readSelection: nil		menu: nil! !!PluggableTextView class methodsFor: 'instance creation' stamp: 'jm 3/29/98 07:24'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	^ self new on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !Object subclass: #Point	instanceVariableNames: 'x y'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Point commentStamp: '<historical>' prior: 0!I represent an x-y pair of numbers usually designating a location on the screen.!!Point methodsFor: 'accessing'!x	"Answer the x coordinate."	^x! !!Point methodsFor: 'accessing'!y	"Answer the y coordinate."	^y! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!Point methodsFor: 'arithmetic'!abs	"Answer a Point whose x and y are the absolute values of the receiver's x 	and y."	^ x abs @ y abs! !!Point methodsFor: 'comparing'!< aPoint 	"Answer whether the receiver is above and to the left of aPoint."	^x < aPoint x and: [y < aPoint y]! !!Point methodsFor: 'comparing'!<= aPoint 	"Answer whether the receiver is neither below nor to the right of aPoint."	^x <= aPoint x and: [y <= aPoint y]! !!Point methodsFor: 'comparing'!= aPoint	self species = aPoint species		ifTrue: [^x = aPoint 	"Refer to the comment in Object|=." x and: [y = aPoint y]]		ifFalse: [^false]! !!Point methodsFor: 'comparing'!> aPoint 	"Answer whether the receiver is below and to the right of aPoint."	^x > aPoint x and: [y > aPoint y]! !!Point methodsFor: 'comparing'!>= aPoint 	"Answer whether the receiver is neither above nor to the left of aPoint."	^x >= aPoint x and: [y >= aPoint y]! !!Point methodsFor: 'comparing' stamp: 'SqR 11/3/2000 17:08'!hash	"Hash is reimplemented because = is implemented."	^(x hash hashMultiply + y hash) hashMultiply! !!Point methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Point methodsFor: 'comparing'!max: aPoint 	"Answer the lower right corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x max: aPoint x) @ (y max: aPoint y)! !!Point methodsFor: 'comparing'!min: aPoint 	"Answer the upper left corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x min: aPoint x) @ (y min: aPoint y)! !!Point methodsFor: 'comparing'!min: aMin max: aMax 	^ (self min: aMin) max: aMax! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Point methodsFor: 'converting' stamp: 'di 11/9/1998 12:44'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Point methodsFor: 'converting'!asFloatPoint	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting'!asIntegerPoint	^ x asInteger @ y asInteger! !!Point methodsFor: 'converting'!asPoint	"Answer the receiver itself."	^self! !!Point methodsFor: 'converting'!corner: aPoint 	"Answer a Rectangle whose origin is the receiver and whose corner is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self corner: aPoint! !!Point methodsFor: 'converting'!extent: aPoint 	"Answer a Rectangle whose origin is the receiver and whose extent is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self extent: aPoint! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 07:45'!isPoint	^ true! !!Point methodsFor: 'converting' stamp: 'di 12/3/97 19:00'!rect: aPoint 	"Answer a Rectangle that encompasses the receiver and aPoint.	This is the most general infix way to create a rectangle."	^ Rectangle 		origin: (self min: aPoint)		corner: (self max: aPoint)! !!Point methodsFor: 'copying'!deepCopy	"Implemented here for better performance."	^x deepCopy @ y deepCopy! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Point methodsFor: 'geometry' stamp: 'laza 1/24/2000 03:44'!isInsideCircle: a with: b with: c 	"Returns TRUE if self is inside the circle defined by the     	points a, b, c. See Guibas and Stolfi (1985) p.107"	^ (a dotProduct: a)		* (b triangleArea: c with: self) - ((b dotProduct: b)			* (a triangleArea: c with: self)) + ((c dotProduct: c)			* (a triangleArea: b with: self)) - ((self dotProduct: self)			* (a triangleArea: b with: c)) > 0.0! !!Point methodsFor: 'geometry' stamp: 'laza 1/6/2000 10:30'!sideOf: otherPoint 	"Returns #left, #right or #center if the otherPoint lies to the left, right 	or on the line given by the vector from 0@0 to self"	| side |	side _ (self crossProduct: otherPoint) sign.	^ {#right. #center. #left} at: side + 2! !!Point methodsFor: 'geometry' stamp: 'ar 4/6/2000 18:37'!to: end1 intersects: start2 to: end2 	"Returns true if the linesegment from start1 (=self) to end1 intersects      	    with the segment from start2 to end2, otherwise false."	| start1 sideStart sideEnd |	start1 _ self.	(((start1 = start2 or: [end1 = end2])		or: [start1 = end2])		or: [start2 = end1])		ifTrue: [^ true].	sideStart _ start1 to: end1 sideOf: start2.	sideEnd _ start1 to: end1 sideOf: end2.	sideStart = sideEnd ifTrue: [^ false].	sideStart _ start2 to: end2 sideOf: start1.	sideEnd _ start2 to: end2 sideOf: end1.	sideStart = sideEnd ifTrue: [^ false].	^ true! !!Point methodsFor: 'geometry' stamp: 'laza 1/5/2000 11:50'!to: end sideOf: otherPoint 	"Returns #left, #right, #center if the otherPoint lies to the left, right or on the line given by the vector from self to end"	^ end - self sideOf: otherPoint - self! !!Point methodsFor: 'geometry' stamp: 'laza 1/17/2000 15:47'!triangleArea: b with: c	"Returns twice the area of the oriented triangle (a, b, c), i.e., the   	area is positive if the triangle is oriented counterclockwise"	^ b x - self x * (c y - self y) - (b y - self y * (c x - self x))! !!Point methodsFor: 'interpolating' stamp: 'jsp 3/22/1999 16:31'!interpolateTo: end at: amountDone	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."	^ self + ((end - self) * amountDone).! !!Point methodsFor: 'point functions' stamp: 'sw 2/15/98 02:27'!bearingToPoint: anotherPoint    "Return the bearing, in degrees, from the receiver to anotherPoint.     Adapted from Playground, where the ultimate provenance of the algorithm was a wild earlier method of Jay Fenton's which I never checked carefully, but the thing has always seemed to work"    | deltaX deltaY  |    deltaX := anotherPoint x -  x.    deltaY := anotherPoint y - y.    deltaX abs < 0.001        ifTrue:            [^ deltaY > 0 ifTrue: [180] ifFalse: [0]].    ^ ((deltaX >= 0 ifTrue: [90] ifFalse: [270])            - ((deltaY / deltaX) arcTan negated * 57.2957795131)) rounded! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions'!dist: aPoint 	"Answer the distance between aPoint and the receiver."	^(aPoint - self) r! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'point functions'!eightNeighbors	^ (Array with: self + (1@0)		with: self + (1@1)		with: self + (0@1)		with: self + (-1@1)) ,	(Array with: self + (-1@0)		with: self + (-1@-1)		with: self + (0@-1)		with: self + (1@-1))! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 16:08'!flipBy: direction centerAt: c	"Answer a Point which is flipped according to the direction about the point c.	Direction must be #vertical or #horizontal."	direction == #vertical ifTrue: [^ x @ (c y * 2 - y)].	direction == #horizontal ifTrue: [^ (c x * 2 - x) @ y].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions'!fourNeighbors	^ Array with: self + (1@0)		with: self + (0@1)		with: self + (-1@0)		with: self + (0@-1)! !!Point methodsFor: 'point functions'!grid: aPoint 	"Answer a Point to the nearest rounded grid modules specified by aPoint."	| newX newY |	newX _ x + (aPoint x // 2) truncateTo: aPoint x.	newY _ y + (aPoint y // 2) truncateTo: aPoint y.	^newX @ newY! !!Point methodsFor: 'point functions' stamp: 'ar 5/22/2001 23:46'!insideTriangle: p1 with: p2 with: p3	"Return true if the receiver is within the triangle defined by the three coordinates.	Note: This method computes the barycentric coordinates for the receiver and tests those coordinates."	| p0 b0 b1 b2 b3 |	p0 _ self.	b0 _ ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).	b0 isZero ifTrue:[^false]. "degenerate"	b0 _ 1.0 / b0.	b1 _ (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.	b2 _ (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.	b3 _ (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.	b1 < 0.0 ifTrue:[^false].	b2 < 0.0 ifTrue:[^false].	b3 < 0.0 ifTrue:[^false].	^true! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:37'!nearestPointAlongLineFrom: p1 to: p2	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [^ p1 x @ y].	p1 y = p2 y ifTrue: [^ x @ p1 y].	x1 _ p1 x asFloat.	y1 _ p1 y asFloat.	x21 _ p2 x asFloat - x1.	y21 _ p2 y asFloat - y1.	t _ ((y asFloat - y1 / x21) + (x asFloat - x1 / y21))			/ ((x21 / y21) + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))"	| old new |	Pen new place: 200@100; goto: (old _ 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new _ (Sensor cursorPoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old _ new) extent: 10@10)]]"! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:40'!nearestPointOnLineFrom: p1 to: p2	"This will not give points beyond the endpoints"	^ (self nearestPointAlongLineFrom: p1 to: p2)		adhereTo: (p1 rect: p2)! !!Point methodsFor: 'point functions'!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise."	| n |	n _ y negated @ x.	^n / (n x * n x + (n y * n y)) sqrt! !!Point methodsFor: 'point functions' stamp: 'ar 8/26/2001 22:15'!normalized	"Optimized for speed -- ar 8/26/2001"	| r |	r _ ((x*x) + (y * y)) sqrt.	^(x / r) @ (y / r)! !!Point methodsFor: 'point functions' stamp: 'laza 12/13/1999 11:43'!octantOf: otherPoint 	"Return 1..8 indicating relative direction to otherPoint.  	1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"	"[Sensor anyButtonPressed] whileFalse: [(Display boundingBox center 	octantOf: Sensor cursorPoint) printString displayAt: 0@0]"	| quad moreHoriz |	(x = otherPoint x and: [y > otherPoint y])		ifTrue: [^ 6].	"special case"	(y = otherPoint y and: [x < otherPoint x])		ifTrue: [^ 8].	quad _ self quadrantOf: otherPoint.	moreHoriz _ (x - otherPoint x) abs >= (y - otherPoint y) abs.	(quad even eqv: moreHoriz)		ifTrue: [^ quad * 2]		ifFalse: [^ quad * 2 - 1]! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:12'!onLineFrom: p1 to: p2	^ self onLineFrom: p1 to: p2 within: 2! !!Point methodsFor: 'point functions' stamp: 'jm 2/24/98 08:34'!onLineFrom: p1 to: p2 within: epsilon	"Answer true if the receiver lies on the given line segment between p1 and p2 within a small epsilon."	"is this point within the box spanning p1 and p2 expanded by epsilon? (optimized)"	p1 x < p2 x		ifTrue: [			((x < (p1 x - epsilon)) or: [x > (p2 x + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((x < (p2 x - epsilon)) or: [x > (p1 x + epsilon)]) ifTrue: [^ false]].	p1 y < p2 y		ifTrue: [			((y < (p1 y - epsilon)) or: [y > (p2 y + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((y < (p2 y - epsilon)) or: [y > (p1 y + epsilon)]) ifTrue: [^ false]].	"it's in the box; is it on the line?"	^ (self dist: (self nearestPointAlongLineFrom: p1 to: p2)) <= epsilon! !!Point methodsFor: 'point functions' stamp: '6/9/97 14:51 di'!quadrantOf: otherPoint	"Return 1..4 indicating relative direction to otherPoint.	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"	^ x <= otherPoint x		ifTrue: [y < otherPoint y ifTrue: [1] ifFalse: [4]]		ifFalse: [y <= otherPoint y ifTrue: [2] ifFalse: [3]]"[Sensor anyButtonPressed] whileFalse:	[(Display boundingBox center quadrantOf: Sensor cursorPoint) printString displayAt: 0@0]"! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 15:12'!rotateBy: direction centerAt: c	"Answer a Point which is rotated according to direction, about the point c.	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."	| offset |	offset _ self - c.	direction == #right ifTrue: [^ (offset y negated @ offset x) + c].	direction == #left ifTrue: [^ (offset y @ offset x negated) + c].	direction == #pi ifTrue: [^ c - offset].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions' stamp: 'ar 4/18/1999 05:17'!sortsBefore: otherPoint	"Return true if the receiver sorts before the other point"	^y = otherPoint y		ifTrue:[x <= otherPoint x]		ifFalse:[y <= otherPoint y]! !!Point methodsFor: 'point functions' stamp: 'ar 5/23/2001 21:29'!squaredDistanceTo: aPoint	"Answer the distance between aPoint and the receiver."	| delta |	delta _ aPoint - self.	^delta dotProduct: delta! !!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!transposed	^y@x! !!Point methodsFor: 'polar coordinates' stamp: 'di 6/12/97 12:18'!degrees	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 90.0]				ifFalse: [^ 270.0]]		ifFalse: 			[tan _ y asFloat / x asFloat.			theta _ tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^ theta radiansToDegrees]						ifFalse: [^ 360.0 + theta radiansToDegrees]]				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !!Point methodsFor: 'polar coordinates'!r	"Answer the receiver's radius in polar coordinate system."	^(self dotProduct: self) sqrt! !!Point methodsFor: 'polar coordinates'!theta	"Answer the angle the receiver makes with origin in radians. right is 0; 	down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^1.5708"90.0 degreesToRadians"]				ifFalse: [^4.71239"270.0 degreesToRadians"]]		ifFalse: 			[tan _ y asFloat / x asFloat.			theta _ tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^theta]						ifFalse: [^360.0 degreesToRadians + theta]]				ifFalse: [^180.0 degreesToRadians + theta]]! !!Point methodsFor: 'printing' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Point methodsFor: 'printing'!printOn: aStream 	"The receiver prints on aStream in terms of infix notation."	x printOn: aStream.	aStream nextPut: $@.	y printOn: aStream! !!Point methodsFor: 'printing'!storeOn: aStream 	"x@y printed form is good for storing too"	self printOn: aStream! !!Point methodsFor: 'private' stamp: 'ar 4/4/1999 00:40'!bitShiftPoint: bits	x _ x bitShift: bits.	y _ y bitShift: bits.! !!Point methodsFor: 'private' stamp: 'tk 10/4/2001 16:16'!setR: rho degrees: degrees 	| radians |	radians _ degrees asFloat degreesToRadians.	x _ rho asFloat * radians cos.	y _ rho asFloat * radians sin.! !!Point methodsFor: 'private' stamp: 'sw 3/21/2000 13:24'!setX: xValue setY: yValue	x _ xValue.	y _ yValue! !!Point methodsFor: 'transforming' stamp: 'di 4/30/1998 11:16'!adhereTo: aRectangle	"If the receiver lies outside aRectangle, return the nearest point on the boundary of the rectangle, otherwise return self."	(aRectangle containsPoint: self) ifTrue: [^ self].	^ ((x max: aRectangle left) min: aRectangle right)		@ ((y max: aRectangle top) min: aRectangle bottom)! !!Point methodsFor: 'transforming' stamp: 'ar 8/26/2001 22:14'!negated	"Answer a point whose x and y coordinates are the negatives of those of the receiver.  6/6/96 sw"	"Optimized for speed -- ar 8/26/2001"	^ (0 - x) @ (0 - y)! !!Point methodsFor: 'transforming'!rotateBy: angle about: center	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p _ self - center.	r _ p r.	theta _ angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))! !!Point methodsFor: 'transforming'!scaleBy: factor 	"Answer a Point scaled by factor (an instance of Point)."	^(factor x * x) @ (factor y * y)! !!Point methodsFor: 'transforming' stamp: 'di 12/4/97 14:34'!scaleFrom: rect1 to: rect2	"Produce a point stretched according to the stretch from rect1 to rect2"	^ rect2 topLeft + (((x-rect1 left) * rect2 width // rect1 width)					@ ((y-rect1 top) * rect2 height // rect1 height))! !!Point methodsFor: 'transforming'!translateBy: delta 	"Answer a Point translated by delta (an instance of Point)."	^(delta x + x) @ (delta y + y)! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off'!truncateTo: grid	"Answer a Point that is the receiver's x and y truncated to grid x and 	grid y."	| gridPoint |	gridPoint _ grid asPoint.	^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!Point methodsFor: 'testing' stamp: 'ar 10/29/2000 19:02'!isZero	^x isZero and:[y isZero]! !!Point methodsFor: '*morphic-Postscript Canvases'!encodePostscriptOn:aStream 	aStream writePoint:self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Point class	instanceVariableNames: ''!!Point class methodsFor: 'instance creation' stamp: 'sw 9/20/97 15:34'!fromUser	Sensor waitNoButton.	Cursor crossHair show.	Sensor waitButton.	Cursor normal show.	^ Sensor cursorPoint"Point fromUser"! !!Point class methodsFor: 'instance creation' stamp: 'tk 10/4/2001 16:17'!r: rho degrees: degrees	"Answer an instance of me with polar coordinates rho and theta."	^self new setR: rho degrees: degrees! !!Point class methodsFor: 'instance creation'!x: xInteger y: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self new setX: xInteger setY: yInteger! !Model subclass: #PointerFinder	instanceVariableNames: 'goal parents toDo toDoNext hasGemStone pointerList objectList parentsSize todoSize depth pointerListIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!PointerFinder commentStamp: '<historical>' prior: 0!I can search for reasons why a certain object isn't garbage collected.  I'm a quick port of a VisualWorks program written by Hans-Martin Mosner.  Call me as shown below.  I'll search for a path from a global variable to the given object, presenting it in a small morphic UI.Examples:	PointerFinder on: self currentHand	PointerFinder on: StandardSystemView someInstanceNow, let's see why this image contains more HandMorphs as expected...HandMorph allInstancesDo: [:e | PointerFinder on: e]!!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 18:58'!buildList	| list obj parent object key |	list := OrderedCollection new.	obj := goal.		[list addFirst: obj.	obj := parents at: obj ifAbsent: [].	obj == nil] whileFalse.	list removeFirst.	parent := Smalltalk.	objectList := OrderedCollection new.	pointerList := OrderedCollection new.	[list isEmpty]		whileFalse: 			[object := list removeFirst.			key := nil.			(parent isKindOf: Dictionary)				ifTrue: [list size >= 2						ifTrue: 							[key := parent keyAtValue: list second ifAbsent: [].							key == nil								ifFalse: 									[object := list removeFirst; removeFirst.									pointerList add: key printString , ' -> ' , object class name]]].			key == nil				ifTrue: 					[parent class == object ifTrue: [key := 'CLASS'].					key == nil ifTrue: [1 to: parent class instSize do: [:i | key == nil ifTrue: [(parent instVarAt: i)									== object ifTrue: [key := parent class allInstVarNames at: i]]]].					key == nil ifTrue: [1 to: parent basicSize do: [:i | key == nil ifTrue: [(parent basicAt: i)									== object ifTrue: [key := i printString]]]].					key == nil ifTrue: [(parent isMorph and: [object isKindOf: Array]) ifTrue: [key := 'submorphs?']].					key == nil ifTrue: [key := '???'].					pointerList add: key , ': ' , object class name].			objectList add: object.			parent := object]! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 23:08'!follow: anObject from: parentObject	anObject == goal		ifTrue: 			[parents at: anObject put: parentObject.			^ true].	anObject isLiteral ifTrue: [^ false].	anObject class isPointers ifFalse: [^ false].	anObject class isWeak ifTrue: [^ false].	(parents includesKey: anObject)		ifTrue: [^ false].	parents at: anObject put: parentObject.	toDoNext add: anObject.	^ false! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 10:01'!followObject: anObject	(self follow: anObject class from: anObject)		ifTrue: [^ true].	1 to: anObject class instSize do:		[:i |		(self follow: (anObject instVarAt: i) from: anObject)			ifTrue: [^ true]].	1 to: anObject basicSize do:		[:i |		(self follow: (anObject basicAt: i) from: anObject)			ifTrue: [^ true]].	^ false! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 09:52'!goal: anObject	goal _ anObject! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/7/2000 00:19'!initialize	parents _ IdentityDictionary new: 20000.	parents at: Smalltalk put: nil.	parents at: Processor put: nil.	parents at: self put: nil.	toDo _ OrderedCollection new: 5000.	toDo add: Smalltalk.	toDoNext _ OrderedCollection new: 5000! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/7/2000 00:19'!isLiteral	"Horrible hack to omit other Pointer Finders from scanning."	^ true! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/7/2000 00:17'!search	Smalltalk garbageCollect.	self initialize.		Cursor wait showWhile: [		[[toDo isEmpty or: [self followObject: toDo removeFirst]] whileFalse.		toDo isEmpty and: [toDoNext isEmpty not]]			whileTrue: 				[toDo _ toDoNext.				toDoNext _ OrderedCollection new: 5000]].	self buildList! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 19:10'!update	('done: ' , parents size asString , ' todo: ' , toDo size asString , '   ') displayAt: 0@0! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:23'!arrowKey: key from: aController	key = $i ifTrue: [^ self inspectObject].	^ super arrowKey: key from: aController! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:48'!initialExtent	^ 300 @ 300! !!PointerFinder methodsFor: 'morphic ui' stamp: 'nb 6/17/2003 12:25'!inspectObject	pointerListIndex = 0 ifTrue: [^ Beeper beep].	(objectList at: pointerListIndex) inspect! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:15'!perform: selector orSendTo: otherTarget	selector == #inspectObject ifTrue: [^ self inspectObject].	selector == #searchAgain ifTrue: [^ self searchAgain].	^ super perform: selector orSendTo: otherTarget! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:49'!pointerList	^ pointerList asArray! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:27'!pointerListIndex	^ pointerListIndex ifNil: [0]! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:51'!pointerListIndex: anInteger	pointerListIndex _ anInteger.	self changed: #pointerListIndex! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:16'!searchAgain	self pointerListIndex: 0.	self search.	self changed: #pointerList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PointerFinder class	instanceVariableNames: ''!!PointerFinder class methodsFor: 'instance creation' stamp: 'sma 6/6/2000 23:52'!on: anObject	^ self new goal: anObject; search; open! !Object subclass: #PopUpMenu	instanceVariableNames: 'labelString font lineArray frame form marker selection'	classVariableNames: 'CacheMenuForms MenuStyle'	poolDictionaries: ''	category: 'Tools-Menus'!!PopUpMenu commentStamp: '<historical>' prior: 0!I represent a list of items. My instances are presented on the display screen in a rectangular area. The user points to an item, pressing a mouse button; the item is highlighted. When the button is released, the highlighted item indicates the selection.!!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:44'!center	"Answer the point at the center of the receiver's rectangular area."	^ frame center! !!PopUpMenu methodsFor: 'accessing' stamp: 'di 4/20/1999 14:33'!frameHeight	"Designed to avoid the entire frame computation (includes MVC form),	since the menu may well end up being displayed in Morphic anyway."	| nItems |	frame ifNotNil: [^ frame height].	nItems _ 1 + (labelString occurrencesOf: Character cr).	^ (nItems * MenuStyle lineGrid) + 4 "border width"! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!labelString	^ labelString! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!lineArray	^ lineArray! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 12:32'!nItems	^ (labelString occurrencesOf: Character cr) + 1! !!PopUpMenu methodsFor: 'accessing' stamp: 'sw 3/12/2002 21:37'!startUpLeftFlush	"Build and invoke this menu with no initial selection.  By Jerry Archibald, 4/01.	If in MVC, align menus items with the left margin.	Answer the selection associated with the menu item chosen by the user or nil if none is chosen.  	The mechanism for getting left-flush appearance in mvc leaves a tiny possibility for misadventure: if the user, in mvc, puts up the jump-to-project menu, then hits cmd period while it is up, then puts up a second jump-to-project menu before dismissing or proceeding through the debugger, it's possible for mvc popup-menus thereafter to appear left-aligned rather than centered; this very unlikely condition can be cleared by evaluating 'PopUpMenu alignment: 2'"	| saveAlignment result |	Smalltalk isMorphic ifFalse:		[saveAlignment _ PopUpMenu alignment.		PopUpMenu leftFlush].	[result _ self startUp] ensure:		[Smalltalk isMorphic ifFalse:			[PopUpMenu alignment: saveAlignment]].	^ result! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 13:04'!controlActivity	"Do whatever a menu must do - now with keyboard support."	| didNotMove downPos |	didNotMove _ true.	Sensor anyButtonPressed		ifFalse:			[didNotMove _ false.			Sensor waitButtonOrKeyboard]. 		Sensor keyboardPressed ifFalse: [self manageMarker].	(didNotMove and: [selection = 0])		ifTrue:			[downPos _ Sensor cursorPoint.			[didNotMove and: [Sensor anyButtonPressed]]				whileTrue:					[(downPos dist: Sensor cursorPoint) < 2 ifFalse: [didNotMove _ false]].			didNotMove ifTrue: [Sensor waitButtonOrKeyboard]].	[Sensor keyboardPressed] whileTrue:		[self readKeyboard ifTrue: [^ self].		Sensor waitButtonOrKeyboard].	[Sensor anyButtonPressed] whileTrue: [self manageMarker]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 10:55'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch _ Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch _ ch asCharacter asLowercase.	labels _ labelString findTokens: Character cr asString.	occurences _ 0.	1 + selection to: selection + labels size do:		[:index |		| i | i _ index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences _ occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence'!startUp	"Display and make a selection from the receiver as long as the button 	is pressed. Answer the current selection."		^ self startUpWithCaption: nil! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:55'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor]) cursorPoint - (20@0)! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sw 12/17/2001 17:26'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines _ allLabels size.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:55'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor]) cursorPoint! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 12/27/2001 22:47'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."		^ self startUpWithCaption: captionOrNil at: location allowKeyboard: Preferences menuKeyboardControl! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'BG 10/28/2003 21:02'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	| maxHeight |	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location			allowKeyboard: aBoolean].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!PopUpMenu methodsFor: 'displaying' stamp: 'sw 12/10/1999 09:55'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta _ 0 - frame width @ delta y].	frame _ frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm _ captionText form.		captionBox _ captionForm boundingBox expandBy: 4.		captionBox _ captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave _ Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 4/13/1999 17:42'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt _ Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				((Display boundingBox insetBy: 0@3) containsPoint: pt)					ifFalse: [pt _ pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 5/28/2000 15:27'!markerOff	"No item is selected. Reverse the highlight if any item has been marked 	as selected."	self setSelection: 0! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 6/1/2000 13:01'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection > 0 ifTrue: [Display reverse: marker].						marker _ 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection _ marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'marker adjustment'!markerTop: aPoint 	"Answer aPoint, gridded to lines in the receiver."	^(aPoint y - frame inside top truncateTo: font height) + frame inside top! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 3/9/98 19:46'!scrollIntoView: cursorLoc	| dy |	dy _ 0.	cursorLoc y < 2 ifTrue: [dy _ font height].	cursorLoc y > (Display height-3) ifTrue: [dy _ font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame _ frame translateBy: 0@dy.	marker _ marker translateBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'private' stamp: 'BG 8/17/2005 18:01'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset _ 4@4.	paraForm _ (DisplayText text: (Text string: labelString attribute: TextEmphasis normal) textStyle: MenuStyle) form.	menuForm _ Form extent: paraForm extent + (borderInset * 2) depth: paraForm depth.      menuForm fill: (0 @ 0 extent: menuForm  extent)                        rule: Form over                        fillColor: Color white.	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame _ Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection _ 1.	^ form _ menuForm! !!PopUpMenu methodsFor: 'private'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 16:21'!labels: aString font: aFont lines: anArray	labelString _ aString.	font _ aFont.	lineArray _ anArray.! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 17:51'!menuForm	"Answer a Form to be displayed for this menu."	form == nil ifTrue: [self computeForm].	^ form! !!PopUpMenu methodsFor: 'private' stamp: 'BG 8/17/2005 17:57'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString _ 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: MenuStyle defaultFontIndex) lines: lineArray.	frame _ marker _ form _ nil.	"PopUpMenu allSubInstancesDo: [:m | m rescan]"! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 5/28/2000 12:27'!selection	"Answer the current selection."	^ selection! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 6/1/2000 11:01'!setSelection: index	| newSelection |	selection = index ifTrue: [^ self].	newSelection _ (0 max: index) min: frame height // marker height.	selection > 0 ifTrue: [Display reverse: marker].	marker _ marker translateBy: 0 @ (newSelection - selection * marker height).	selection _ newSelection.	selection > 0 ifTrue: [Display reverse: marker]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PopUpMenu class	instanceVariableNames: ''!!PopUpMenu class methodsFor: 'class initialization' stamp: 'jla 4/2/2001 20:41'!alignment	^ MenuStyle alignment! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'jla 4/2/2001 20:46'!alignment: anAlignment	^ MenuStyle alignment: anAlignment! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'BG 8/17/2005 18:01'!initialize  "PopUpMenu initialize"	(MenuStyle _ TextStyle default copy)		defaultFontIndex: 3;		gridForFont: MenuStyle defaultFontIndex withLead: 0;		centered.	PopUpMenu allSubInstancesDo: [:m | m rescan]! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'jla 4/2/2001 20:56'!leftFlush	MenuStyle leftFlush! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'sw 4/17/2001 13:12'!setMenuFontTo: aFont	"Set the menu font as indicated"	MenuStyle _ aFont textStyle copy consistOnlyOf: aFont.	MenuStyle 		gridForFont: 1 withLead: 0;		centered.	self allSubInstancesDo: [:m | m rescan]! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:44'!labelArray: labelArray	"Answer an instance of me whose items are in labelArray."	^ self labelArray: labelArray lines: nil! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:43'!labelArray: labelArray lines: lineArray	"Answer an instance of me whose items are in labelArray, with lines 	drawn after each item indexed by anArray. 2/1/96 sw"	labelArray isEmpty ifTrue: [self error: 'Menu must not be zero size'].	^ self		labels: (String streamContents: 			[:stream |			labelArray do: [:each | stream nextPutAll: each; cr].			stream skip: -1 "remove last CR"])		lines: lineArray"Example:	(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #()) startUp"! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:36'!labels: aString	"Answer an instance of me whose items are in aString."	^ self labels: aString lines: nil! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sw 12/6/1999 17:55'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^ self new		labels: aString		font: MenuStyle defaultFont		lines: anArray! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'tk 7/12/2000 17:29'!withCaption: cap chooseFrom: labels	"Simply put up a menu.  Get the args in the right order with the caption first.  labels may be either an array of items or a string with CRs in it.  May use backslashes for returns."	(labels isKindOf: String) 		ifTrue: [^ (self labels: labels withCRs lines: nil) startUpWithCaption: cap withCRs]		ifFalse: [^ (self labelArray: labels lines: nil) startUpWithCaption: cap withCRs]! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dgd 9/5/2003 18:24'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"PopUpMenu confirm: 'Are you hungry?'"	^ self confirm: queryString trueChoice: 'Yes' translated falseChoice: 'No' translated! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dgd 9/5/2003 18:23'!confirm: queryString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"	| menu choice |	menu _ PopUpMenu labelArray: {'Yes' translated. 'No' translated. 'Cancel' translated}.	choice _ menu startUpWithCaption: queryString.	choice = 1 ifTrue: [^ true].	choice = 2 ifTrue: [^ false].	^ cancelBlock value! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 6/5/2000 09:12'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice	"Put up a yes/no menu with caption queryString. The actual wording 	for the two choices will be as provided in the trueChoice and 	falseChoice parameters. Answer true if the response is the true-choice, 	false if it's the false-choice.	This is a modal question -- the user must respond one way or the other."	"PopUpMenu 		confirm: 'Are you hungry?'		trueChoice: 'yes, I''m famished'		falseChoice: 'no, I just ate'"	| menu choice |	menu _ PopUpMenu labelArray: {trueChoice. falseChoice}.	[(choice _ menu startUpWithCaption: queryString) isNil] whileTrue.	^ choice = 1! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dgd 9/5/2003 18:34'!inform: aString	"PopUpMenu inform: 'I like Squeak'"	(PopUpMenu labels: ' OK ' translated) startUpWithCaption: aString! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:57'!notify: message	"Deprecated. Use #inform: instead."	self inform: message! !Stream subclass: #PositionableStream	instanceVariableNames: 'collection position readLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!PositionableStream commentStamp: '<historical>' prior: 0!I represent an accessor for a sequence of objects (a collection) that are externally named by indices so that the point of access can be repositioned. I am abstract in that I do not implement the messages next and nextPut: which are inherited from my superclass Stream.!!PositionableStream methodsFor: 'accessing' stamp: 'ajh 1/18/2002 01:03'!back	"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream"	self position = 0 ifTrue: [self errorCantGoBack].	self position = 1 ifTrue: [self position: 0.  ^ nil].	self skip: -2.	^ self next! !!PositionableStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	^collection copyFrom: 1 to: readLimit! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!contentsOfEntireFile	"For non-file streams"	^ self contents! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 9/23/2001 01:14'!last	"Return the final element in the receiver"	^ collection at: position! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	| newArray |	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:58'!next: n into: aCollection	"Read n objects into the given collection.	Return aCollection or a partial copy if less than	n elements have been read."	^self next: n into: aCollection startingAt: 1! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:54'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| obj |	0 to: n-1 do:[:i|		(obj _ self next) == nil ifTrue:[^aCollection copyFrom: 1 to: startIndex+i-1].		aCollection at: startIndex+i put: obj].	^aCollection! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 3/27/98 08:44'!nextDelimited: terminator	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."	| out ch |	out _ WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	self next == terminator ifFalse: [self skip: -1].	"absorb initial terminator"	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:53'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!PositionableStream methodsFor: 'accessing' stamp: 'bf 11/24/1998 13:35'!nextLine	"Answer next line (may be empty), or nil if at end"	self atEnd ifTrue: [^nil].	^self upTo: Character cr! !!PositionableStream methodsFor: 'accessing' stamp: 'nk 3/18/2004 08:52'!nextWordsInto: aBitmap 	"Fill the word based buffer from my collection. 	Stored on stream as Big Endian. Optimized for speed. 	Read in BigEndian, then restoreEndianness."	| blt pos source byteSize |	collection class isBytes		ifFalse: [^ self next: aBitmap size into: aBitmap startingAt: 1].	byteSize := aBitmap byteSize.	"is the test on collection basicSize \\ 4 necessary?"	((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0])		ifTrue: [source := collection.			pos := self position.			self skip: byteSize]		ifFalse: ["forced to copy it into a buffer"			source := self next: byteSize.			pos := 0].	"Now use BitBlt to copy the bytes to the bitmap."	blt := (BitBlt current				toForm: (Form new hackBits: aBitmap))				sourceForm: (Form new hackBits: source).	blt combinationRule: Form over. "store"	blt sourceX: 0;		 sourceY: pos // 4;		 height: byteSize // 4;		 width: 4.	blt destX: 0;		 destY: 0.	blt copyBits.	"And do whatever the bitmap needs to do to convert from big-endian order."	aBitmap restoreEndianness.	^ aBitmap 	"May be WordArray, ColorArray, etc"! !!PositionableStream methodsFor: 'accessing'!originalContents	"Answer the receiver's actual contents collection, NOT a copy.  1/29/96 sw"	^ collection! !!PositionableStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| nextObject |	self atEnd ifTrue: [^nil].	nextObject _ self next.	position _ position - 1.	^nextObject! !!PositionableStream methodsFor: 'accessing' stamp: 'ajh 1/18/2002 01:02'!peekBack	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."	| element |	element _ self back.	self skip: 1.	^ element! !!PositionableStream methodsFor: 'accessing'!peekFor: anObject 	"Answer false and do not move over the next element if it is not equal to 	the argument, anObject, or if the receiver is at the end. Answer true 	and increment the position for accessing elements, if the next element is 	equal to anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject _ self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	position _ position - 1.	^false! !!PositionableStream methodsFor: 'accessing'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream _ WriteStream on: (collection species new: 100).	[self atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 7/18/1999 17:10'!upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	| startPos endMatch result |	startPos _ self position.	(self match: aCollection) 		ifTrue: [endMatch _ self position.			self position: startPos.			result _ self next: endMatch - startPos - aCollection size.			self position: endMatch.			^ result]		ifFalse: [self position: startPos.			^ self upToEnd]! !!PositionableStream methodsFor: 'accessing' stamp: 'BG 2/19/2004 14:06'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream |	newStream _ WriteStream on: (collection species new: 100).	[self atEnd] whileFalse: [ newStream nextPut: self next ].	^ newStream contents! !!PositionableStream methodsFor: 'testing'!atEnd	"Primitive. Answer whether the receiver can access any more objects.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 67>	^position >= readLimit! !!PositionableStream methodsFor: 'testing' stamp: 'ar 1/2/2000 17:24'!isBinary	"Return true if the receiver is a binary byte stream"	^collection class == ByteArray! !!PositionableStream methodsFor: 'testing'!isEmpty	"Answer whether the receiver's contents has no elements."	^position = 0! !!PositionableStream methodsFor: 'positioning' stamp: 'hmm 10/22/1999 21:18'!match: subCollection	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern _ ReadStream on: subCollection.	startMatch _ nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch _ nil]]].	^ true! !!PositionableStream methodsFor: 'positioning'!position	"Answer the current position of accessing the sequence of objects."	^position! !!PositionableStream methodsFor: 'positioning'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	anInteger >= 0 & (anInteger <= readLimit)		ifTrue: [position _ anInteger]		ifFalse: [self positionError]! !!PositionableStream methodsFor: 'positioning'!reset	"Set the receiver's position to the beginning of the sequence of objects."	position _ 0! !!PositionableStream methodsFor: 'positioning' stamp: 'sw 3/10/98 13:55'!resetContents	"Set the position and limits to 0."	position _ 0.	readLimit _ 0! !!PositionableStream methodsFor: 'positioning'!setToEnd	"Set the position of the receiver to the end of the sequence of objects."	position _ readLimit! !!PositionableStream methodsFor: 'positioning' stamp: 'RAH 6/29/2000 05:44'!skip: anInteger 	"Skips the next amount objects in the receiver's future sequence values."	"2000/06/23 Harmon, R. Changed for ANSI <gettableStream> protocol."	#Stream.	self position: (self position + (anInteger min: (self contents size - self position)))! !!PositionableStream methodsFor: 'positioning'!skipTo: anObject 	"Set the access position of the receiver to be past the next occurrence of 	anObject. Answer whether anObject is found."	[self atEnd]		whileFalse: [self next = anObject ifTrue: [^true]].	^false! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'ajh 1/18/2002 01:02'!backChunk	"Answer the contents of the receiver back to the previous terminator character.  Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	[(ch _ self back) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peekBack == terminator ifTrue: [				self back.  "skip doubled terminator"			] ifFalse: [				^ out contents reversed  "we're done!!"			].		].		out nextPut: ch.	].	^ out contents reversed! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:40'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [ChangeSet current preambleString == nil])		ifTrue: [ChangeSet current preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [ChangeSet current postscriptString == nil])		ifTrue: [ChangeSet current postscriptString: chunk].							! !!PositionableStream methodsFor: 'fileIn/Out'!command: aString	"Overridden by HtmlFileStream to append commands directly without translation.  4/5/96 tk"	"We ignore any HTML commands.  Do nothing"! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 2/3/98 14:44'!copyMethodChunkFrom: aStream	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	chunk _ aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 09:16'!copyPreamble: preamble from: aStream	"Look for a changeStamp for this method by peeking backward.	Write a method preamble, with that stamp if found."	| terminator methodPos p last50 stamp i |	terminator _ $!!.	"Look back to find stamp in old preamble, such as...	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "	methodPos _ aStream position.	aStream position: (p _ 0 max: methodPos-50).	last50 _ aStream next: methodPos - p.	stamp _ String new.	(i _ last50 findString: 'stamp:' startingAt: 1) > 0 ifTrue:		[stamp _ (last50 copyFrom: i+8 to: last50 size) copyUpTo: $'].	"Write the new preamble, with old stamp if any."	self cr; nextPut: terminator.	self nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: preamble.		stamp size > 0 ifTrue:			[strm nextPutAll: ' stamp: '; print: stamp]]).	self cr! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'mir 7/26/2000 13:28'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	^ self fileInAnnouncing: 'Reading ' , self name! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'NS 1/28/2004 11:22'!fileInAnnouncing: announcement 	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	announcement 		displayProgressAt: Sensor cursorPoint		from: 0		to: self size		during: 			[:bar | 			[self atEnd] whileFalse: 					[bar value: self position.					self skipSeparators.										[val := (self peekFor: $!!) 								ifTrue: [(Compiler evaluate: self nextChunk logged: false) scanFrom: self]								ifFalse: 									[chunk := self nextChunk.									self checkForPreamble: chunk.									Compiler evaluate: chunk logged: true]] 							on: InMidstOfFileinNotification							do: [:ex | ex resume: true].					self skipStyleChunk].			self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	self flag: #ThisMethodShouldNotBeThere.	"sd"	Smalltalk forgetDoIts.	^val! !!PositionableStream methodsFor: 'fileIn/Out'!header	"If the stream requires a standard header, override this message.  See HtmlFileStream"! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 2/3/98 14:29'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:54'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."	| string runsRaw strm runs peek |	"Read the plain text"	string _ self nextChunk.		"Test for ]style[ tag"	peek _ self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [^ string asText].  "no tag"	(self upTo: $[) = ']style' ifFalse: [^ string asText].  "different tag"	"Read and decode the style chunk"	runsRaw _ self nextChunk.	"style encoding"	strm _ ReadStream on: runsRaw from: 1 to: runsRaw size.	runs _ RunArray scanFrom: strm.	^ Text basicNew setString: string setRunsChecking: runs.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/13/97 12:00'!skipSeparators	[self atEnd]		whileFalse:		[self next isSeparator ifFalse: [^ self position: self position-1]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:08'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd]		whileFalse:		[(peek _ self next) isSeparator			ifFalse: [self position: self position-1. ^ peek]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 12:37'!skipStyleChunk	"Get to the start of the next chunk that is not a style for the previous chunk"	| pos |	pos _ self position.	self skipSeparators.	self peek == $] 		ifTrue: [(self upTo: $[) = ']text' 	"old -- no longer needed"				"now positioned past the open bracket"			ifFalse: [self nextChunk]]	"absorb ]style[ and its whole chunk"						ifFalse: [self position: pos]	"leave untouched"! !!PositionableStream methodsFor: 'fileIn/Out'!trailer	"If the stream requires a standard trailer, override this message.  See HtmlFileStream"! !!PositionableStream methodsFor: 'fileIn/Out'!unCommand	"If this read stream is at a <, then skip up to just after the next >.  For removing html commands."	| char |	[self peek = $<] whileTrue: ["begin a block"		[self atEnd == false and: [self next ~= $>]] whileTrue.		"absorb characters"		]. ! !!PositionableStream methodsFor: 'private'!on: aCollection	collection _ aCollection.	readLimit _ aCollection size.	position _ 0.	self reset! !!PositionableStream methodsFor: 'private'!positionError	"Since I am not necessarily writable, it is up to my subclasses to override 	position: if expanding the collection is preferrable to giving this error."	self error: 'Attempt to set the position of a PositionableStream out of bounds'! !!PositionableStream methodsFor: 'private'!setFrom: newStart to: newStop	position _ newStart - 1.	readLimit _ newStop! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s _ 0.	1 to: 4 do: [:i | s _ (s bitShift: 8) + self next].	(s bitAnd: 16r80000000) = 0		ifTrue: [^ s]		ifFalse: [^ -1 - s bitInvert32]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	| pos |	pos _ int32 < 0		ifTrue: [(0-int32) bitInvert32 + 1]		ifFalse: [int32].	1 to: 4 do: [:i | self nextPut: (pos digitAt: 5-i)].	^ int32! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'jm 4/9/98 21:36'!nextLittleEndianNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes s |	bytes _ self next: n.	s _ 0.	n to: 1 by: -1 do: [:i | s _ (s bitShift: 8) bitOr: (bytes at: i)].	^ s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'di 12/6/1999 10:13'!nextLittleEndianNumber: n put: value	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes |	bytes _ ByteArray new: n.	1 to: n do: [: i | bytes at: i put: (value digitAt: i)].	self nextPutAll: bytes! !!PositionableStream methodsFor: 'nonhomogeneous accessing'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s _ 0.	1 to: n do: 		[:i | s _ (s bitShift: 8) bitOr: self next asInteger].	^ s normalize! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextNumber: n put: v 	"Append to the receiver the argument, v, which is a positive 	SmallInteger or a LargePositiveInteger, as the next n bytes.	Possibly pad with leading zeros."	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].	^ v! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextWord	"Answer the next two bytes from the receiver as an Integer."	| high low |	high _ self next.		high==nil ifTrue: [^false].	low _ self next.		low==nil ifTrue: [^false].	^(high asInteger bitShift: 8) + low asInteger! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextWordPut: aWord 	"Append to the receiver an Integer as the next two bytes."	self nextPut: ((aWord bitShift: -8) bitAnd: 255).	self nextPut: (aWord bitAnd: 255).	^aWord! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 9/5/2001 07:35'!string	"Answer the next string from this (binary) stream."	| size |	size _ self uint16.	^ (self next: size) asString! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 9/5/2001 12:09'!string: aString	"Store the given string on this (binary) stream. The string must contain 65535 or fewer characters."	aString size > 16rFFFF ifTrue: [self error: 'string too long for this format'].	self uint16: aString size.	self nextPutAll: aString asByteArray.! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint16	"Answer the next unsigned, 16-bit integer from this (binary) stream."	| n |	n _ self next.	n _ (n bitShift: 8) + (self next).	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint16: anInteger	"Store the given unsigned, 16-bit integer on this (binary) stream."	(anInteger < 0) | (anInteger >= 16r10000)		ifTrue: [self error: 'outside unsigned 16-bit integer range'].	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PositionableStream class	instanceVariableNames: ''!!PositionableStream class methodsFor: 'instance creation'!on: aCollection 	"Answer an instance of me, streaming over the elements of aCollection."	^self basicNew on: aCollection! !!PositionableStream class methodsFor: 'instance creation'!on: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me, streaming over the elements of aCollection 	starting with the element at firstIndex and ending with the one at 	lastIndex."	^self basicNew on: (aCollection copyFrom: firstIndex to: lastIndex)! !Object subclass: #Preference	instanceVariableNames: 'name value defaultValue helpString localToProject categoryList changeInformee changeSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!Preference commentStamp: 'sw 1/14/2003 22:33' prior: 0!Represents a true/false flag that is under user control and which can be interrogated by a call to Preferences	name 				a symbol, the formal name of the preference.	value				a boolean, the current value	defaultValue		the default value of the preference	helpString 			string or text, constituting the help message	localToProject		boolean, whether each project holds its own version	categoryList			list of categories under which to offer this	changeInformee 	whom, if anyone, to inform if the value changes:	changeSelector 		what selector to send to the changeInformee when the value changes!!Preference methodsFor: 'initialization' stamp: 'sw 3/5/2002 14:12'!name: aName defaultValue: aValue helpString: aString localToProject: projectBoolean categoryList: aList changeInformee: informee changeSelector:  aChangeSelector	"Initialize the preference from the given values.  There is an extra tolerence here for the symbols #true, #false, and #nil, which are interpreted, when appropriate, as meaning true, false, and nil"	name _ aName asSymbol.	defaultValue _ aValue == true or: [aValue = #true].	value _ defaultValue.	helpString _ aString.	localToProject _ projectBoolean == true or: [projectBoolean = #true].	categoryList _ (aList ifNil: [OrderedCollection with: #unclassified]) collect:		[:elem | elem asSymbol].	changeInformee _ (informee == nil or: [informee == #nil])						ifTrue: [nil]						ifFalse:	[(informee isKindOf: Symbol)							ifTrue:								[Smalltalk at: informee]							ifFalse:								[informee]].	changeSelector  _ aChangeSelector! !!Preference methodsFor: 'menu' stamp: 'sw 4/13/2001 00:01'!copyName	"Copy the name of the given preference to the clipboard"	Clipboard clipboardText: name asString asText! !!Preference methodsFor: 'menu' stamp: 'sw 4/10/2001 15:02'!name	"Answer this preference's name"	^ name! !!Preference methodsFor: 'value' stamp: 'sw 4/10/2001 15:01'!defaultValue	"Answer this preference's defaultValue"	^ defaultValue! !!Preference methodsFor: 'value' stamp: 'sw 4/10/2001 15:35'!preferenceValue	"Answer the current value of the preference"	^ value! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 23:28'!preferenceValue: aValue	"set the value as indicated, and invoke the change selector if appropriate"	| oldValue |	oldValue _ value.	value _ aValue.	oldValue ~~ value ifTrue:		[self notifyInformeeOfChange]! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 23:28'!rawValue: aValue	"set the value as indicated, with no side effects"	value _ aValue! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 00:04'!restoreDefaultValue	"restore the default value to the preference"	value _ defaultValue! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 00:04'!togglePreferenceValue	"Toggle whether the value of the preference"	value _ value not.	self notifyInformeeOfChange! !!Preference methodsFor: 'local to project' stamp: 'sw 4/10/2001 01:14'!localToProject	"Answer whether this preference is project-local"	^ localToProject! !!Preference methodsFor: 'change notification' stamp: 'sw 4/12/2001 00:03'!notifyInformeeOfChange	"If there is a changeInformee, notify her that I have changed value"	changeInformee ifNotNil: [changeInformee perform: changeSelector]! !!Preference methodsFor: 'debugging' stamp: 'sw 4/13/2001 00:05'!printOn: aStream	"Print a string decribing the receiver to the given stream"	super printOn: aStream.	aStream nextPutAll: name storeString, ' ', value storeString! !!Preference methodsFor: 'as yet unclassified' stamp: 'BG 10/31/2003 14:32'!changeInformee  ^changeInformee! !!Preference methodsFor: 'as yet unclassified' stamp: 'BG 10/31/2003 14:47'!deleteInformee  changeInformee := nil! !Object subclass: #Preferences	instanceVariableNames: ''	classVariableNames: 'DesktopColor DictionaryOfPreferences Parameters'	poolDictionaries: ''	category: 'System-Support'!!Preferences commentStamp: '<historical>' prior: 0!A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  	To open the control panel:		Preferences openFactoredPanel	To read how to use the panel (and how to make a preference be per-project):		 Preferences giveHelpWithPreferencesAll messages are on the class side.To query a a preference:	Preferences logDebuggerStackToFileor some people prefer the more verbose	Preferences valueOfFlag: #logDebuggerStackToFileYou can make up a new preference any time.  Do not define a new message in Preferences class. Accessor methods are compiled automatically when you add a preference as illustrated below:To add a preference (e.g. in the Postscript of a fileout):	Preferences addPreference: #samplePreference categories: #(general browsing)		default: true balloonHelp: 'This is an example of a preference added by a do-it'		projectLocal: false changeInformee: nil changeSelector: nil.To change a preference programatically:	Preferences disable: #logDebuggerStackToFile.Or to turn it on,	Preferences enable: #logDebuggerStackToFile.!]style[(220 29 81 35 812)f1,f1dPreferences openFactoredPanel;;,f1,f1dPreferences giveHelpWithPreferences;;,f1!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Preferences class	instanceVariableNames: ''!!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/10/2001 14:55'!addPreference: prefSymbol categories: categoryList default: defaultValue balloonHelp: helpString 	"Add an item repreesenting the given preference symbol to the system"	self addPreference: prefSymbol  categories: categoryList  default:  defaultValue balloonHelp: helpString  projectLocal: false  changeInformee: nil changeSelector: nil! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 8/19/2001 08:28'!addPreference: prefSymbol categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol  changeSelector: aChangeSelector	"Add or replace a preference as indicated.  Reuses the preexisting Preference object for this symbol, if there is one, so that UI artifacts that interact with it will remain valid."	| aPreference |	aPreference _ DictionaryOfPreferences at: prefSymbol ifAbsent: [Preference new].	aPreference name: prefSymbol defaultValue: aValue helpString: helpString localToProject: localBoolean categoryList: categoryList changeInformee: informeeSymbol changeSelector:  aChangeSelector.	DictionaryOfPreferences at: prefSymbol put: aPreference.	self compileAccessMethodForPreference: aPreference! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 2/5/2001 22:20'!addPreference: prefSymbol category: categorySymbol default: defaultValue balloonHelp: helpString 	"Add the given preference, putting it in the given category, with the given default value, and with the given balloon help"	self addPreference: prefSymbol categories: {categorySymbol} default: defaultValue balloonHelp: helpString ! !!Preferences class methodsFor: 'fonts' stamp: 'laza 3/25/2004 23:10'!chooseCodeFont	"Not currently sent, but once protocols are sorted out so that we can disriminate on whether a text object being launched is for code or not, will be reincorporated"	self chooseFontWithPrompt: 'standard code font' andSendTo: self withSelector: #setCodeFontTo: highlight: self standardCodeFont.! !!Preferences class methodsFor: 'fonts' stamp: 'BG 8/18/2004 14:53'!chooseFontWithPrompt: aPrompt andSendTo: aReceiver withSelector: aSelector highlight: currentFont	TextStyle mvcPromptForFont: aPrompt andSendTo: aReceiver withSelector: aSelector! !!Preferences class methodsFor: 'fonts' stamp: 'laza 3/25/2004 23:11'!chooseListFont	self chooseFontWithPrompt: 'standard list font' andSendTo: self withSelector: #setListFontTo: highlight: self standardListFont! !!Preferences class methodsFor: 'fonts' stamp: 'laza 3/25/2004 23:11'!chooseMenuFont	self chooseFontWithPrompt: 'standard menu font' andSendTo: self withSelector: #setMenuFontTo: highlight: self standardMenuFont! !!Preferences class methodsFor: 'fonts' stamp: 'laza 3/25/2004 23:11'!chooseSystemFont	self chooseFontWithPrompt: 'Default text font' andSendTo: self withSelector: #setSystemFontTo: highlight: (TextConstants at: #DefaultTextStyle) defaultFont! !!Preferences class methodsFor: 'fonts' stamp: 'laza 3/25/2004 23:11'!chooseWindowTitleFont	self chooseFontWithPrompt: 'window title font' andSendTo: self withSelector: #setWindowTitleFontTo: highlight: self windowTitleFont! !!Preferences class methodsFor: 'fonts' stamp: 'BG 10/30/2003 21:20'!presentMvcFontConfigurationMenu	| aMenu result |	aMenu _ CustomMenu new.	aMenu title: 'Standard System Fonts'.	aMenu add: 'default text font...' action: #chooseSystemFont.	aMenu add: 'list font...' action: #chooseListFont.	aMenu add: 'menu font...' action: #chooseMenuFont.	aMenu add: 'window-title font...' action: #chooseWindowTitleFont.	"aMenu add: 'code font...' action: #chooseCodeFont."	aMenu addLine.	aMenu add: 'restore default font choices' action: #restoreDefaultFonts.	(result _ aMenu startUp) ifNotNil:		[self perform: result]! !!Preferences class methodsFor: 'fonts' stamp: 'BG 10/30/2003 21:20'!restoreDefaultFonts	"Preferences restoreDefaultFonts"	#(	(setButtonFontTo:		ComicBold		16)		"(setCodeFontTo:			NewYork		12)"  "Later"		(setListFontTo:			NewYork		12)		(setMenuFontTo:			NewYork		12)		(setWindowTitleFontTo:	NewYork		15)		(setSystemFontTo:		NewYork		12)) do:			[:triplet |				self perform: triplet first with: (StrikeFont familyName: triplet second size: triplet third)].	Smalltalk at: #BalloonMorph ifPresent:		[:thatClass | thatClass setBalloonFontTo: (StrikeFont familyName: #ComicPlain size: 12)].	"Note:  The standardCodeFont is not currently used -- the default font is instead; later hopefully we can split the code font out as  a separate choice, but only after we're able to have the protocols reorganized such that we can know whether it's code or not when we launch the text object.	Note:  The standard button font is reset by this code but is not otherwise settable by a public UI (too many things can go afoul) "! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 22:06'!setButtonFontTo: aFont	Parameters at: #standardButtonFont put: aFont! !!Preferences class methodsFor: 'fonts' stamp: 'BG 10/28/2003 19:52'!setCodeFontTo: aFont	"Not currently sent, but once protocols are sorted out so that we can discriminate on whether a text object being launched is for code or not, might deserve to be reincorporated"	Parameters at: #standardCodeFont put: aFont.! !!Preferences class methodsFor: 'fonts' stamp: 'BG 10/28/2003 19:52'!setListFontTo: aFont	"Set the list font as indicated"	Parameters at: #standardListFont put: aFont.	ListParagraph initialize.! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 18:04'!setMenuFontTo: aFont	Parameters at: #standardMenuFont put: aFont.	PopUpMenu setMenuFontTo: aFont! !!Preferences class methodsFor: 'fonts' stamp: 'BG 10/28/2003 19:52'!setSystemFontTo: aFont	"Establish the default text font and style"	| aStyle newDefaultStyle |	aFont ifNil: [^ self].	aStyle _ aFont textStyle ifNil: [^ self].	newDefaultStyle _ aStyle copy.	newDefaultStyle defaultFontIndex: (aStyle fontIndexOf: aFont).	TextConstants at: #DefaultTextStyle put: newDefaultStyle.! !!Preferences class methodsFor: 'fonts' stamp: 'BG 10/28/2003 19:52'!setWindowTitleFontTo: aFont	"Set the window-title font to be as indicated"	Parameters at: #windowTitleFont put: aFont.	StandardSystemView setLabelStyle.! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:13'!standardButtonFont	"Answer an attractive font to use for buttons"	"Answer the font to be used for textual flap tab labels"	^ Parameters at: #standardButtonFont ifAbsent:		[Parameters at: #standardButtonFont put: (StrikeFont familyName: #ComicBold size: 16)]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:58'!standardCodeFont	"Answer the font to be used in code"	 ^ Parameters at: #standardCodeFont ifAbsent:		[Parameters at: #standardCodeFont put: TextStyle defaultFont]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:09'!standardListFont	"Answer the font to be used in lists"	 ^ Parameters at: #standardListFont ifAbsent:		[Parameters at: #standardListFont put: TextStyle defaultFont]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:58'!standardMenuFont	"Answer the font to be used in menus"	 ^ Parameters at: #standardMenuFont ifAbsent:		[Parameters at: #standardMenuFont put: TextStyle defaultFont]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:10'!windowTitleFont	"Answer the standard font to use for window titles"	^  Parameters at: #windowTitleFont ifAbsent:		[Parameters at: #windowTitleFont put: (StrikeFont familyName: #NewYork size: 15)]! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/12/2001 23:29'!disable: aSymbol	"Shorthand access to enabling a preference of the given name.  If there is none in the image, conjure one up"	| aPreference |	aPreference _ self preferenceAt: aSymbol ifAbsent:		[self addPreference: aSymbol category: 'unclassified' default: false balloonHelp: 'this preference was added idiosyncratically and has no help message.'.		self preferenceAt: aSymbol].	aPreference preferenceValue: false! !!Preferences class methodsFor: 'get/set' stamp: 'sw 1/19/2000 13:51'!disableGently: preferenceNameSymbol	"Unlike #disable:, this on does not reset the CategoryInfo cache"	self setPreference: preferenceNameSymbol toValue: false! !!Preferences class methodsFor: 'get/set' stamp: 'sw 11/11/1998 11:40'!doesNotUnderstand: aMessage	"Look up the message selector as a flag."	aMessage arguments size > 0 ifTrue: [^ super doesNotUnderstand: aMessage].	^ self valueOfFlag: aMessage selector! !!Preferences class methodsFor: 'get/set' stamp: 'sw 1/19/2000 13:53'!enableGently: preferenceNameSymbol	"Unlike #enable:, this one does not reset the CategoryInfo cache"	self setPreference: preferenceNameSymbol toValue: true! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/12/2001 23:29'!setPreference: prefSymbol toValue: aBoolean	"Set the given preference to the given value, and answer that value"	^ (self preferenceAt: prefSymbol ifAbsent: [^ aBoolean]) preferenceValue: aBoolean! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/12/2001 00:04'!togglePreference: prefSymbol	"Toggle the given preference"	(self preferenceAt: prefSymbol ifAbsent: [self error: 'unknown preference: ', prefSymbol]) togglePreferenceValue! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/13/2001 01:07'!valueOfFlag: aFlagName	"Answer the value of the given flag"	^ (self preferenceAt: aFlagName ifAbsent: [^ false]) preferenceValue! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/13/2001 01:07'!valueOfFlag: aFlagName ifAbsent: booleanValuedBlock	"Answer the value of the given flag"	^ (self preferenceAt: aFlagName ifAbsent: [^ booleanValuedBlock value]) preferenceValue! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'ar 1/31/2001 17:06'!browseToolClass	^ Preferences browserShowsPackagePane		ifTrue:			[PackagePaneBrowser]		ifFalse:			[Browser]! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'programmatic 7/15/1999 09:55'!cmdKeysInText	"compiled programatically -- return hard-coded preference value"	^ true! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/10/2001 15:28'!chooseInitialSettings	"Restore the default choices for all of the standard Preferences."	self allPreferenceObjects do:		[:aPreference |			aPreference restoreDefaultValue].	Project current installProjectPreferences! !!Preferences class methodsFor: 'initialization' stamp: 'NS 1/28/2004 14:43'!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class compileSilently: (aPreference name, '	^ self valueOfFlag: #', aPreference name, ' ifAbsent: [', aPreference defaultValue storeString, ']') classified: 'standard queries'! !!Preferences class methodsFor: 'misc' stamp: 'sw 10/6/1999 15:20'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	aMenu add: 'restore default preference settings' target: self action: #chooseInitialSettings.	aMenu add: 'restore default text highlighting' target: self action: #initializeTextHighlightingParameters! !!Preferences class methodsFor: 'misc' stamp: 'sw 1/4/2001 06:56'!setFlag: prefSymbol toValue: aBoolean during: aBlock	"Set the flag to the given value for the duration of aBlock"	| existing |	existing _ self valueOfFlag: prefSymbol.	existing == aBoolean ifFalse: [self setPreference: prefSymbol toValue: aBoolean].	aBlock value.	existing == aBoolean ifFalse: [self setPreference: prefSymbol toValue: existing]! !!Preferences class methodsFor: 'misc' stamp: 'dgd 10/17/2003 12:14'!soundEnablingString	^ self soundsEnabled		ifFalse:			['turn sound on' translated]		ifTrue:			['turn sound off' translated]! !!Preferences class methodsFor: 'misc' stamp: 'dgd 9/21/2003 13:46'!staggerPolicyString	"Answer the string to be shown in a menu to represent the 	stagger-policy status"	^ ((self valueOfFlag: #reverseWindowStagger)		ifTrue: ['<yes>']		ifFalse: ['<no>']), 'stagger windows' translated! !!Preferences class methodsFor: 'misc' stamp: 'sw 6/11/1999 20:49'!toggleWindowPolicy	self togglePreference: #reverseWindowStagger! !!Preferences class methodsFor: 'misc' stamp: 'sw 8/29/2000 16:12'!wantsChangeSetLogging	"Answer whether method changes in the receiver should be logged to current change set.  This circumlocution avoids such logging for programmatically-compiled methods in Preferences, removing an annoyance"	^ Utilities authorInitialsPerSe  ~= 'programmatic'! !!Preferences class methodsFor: 'parameters' stamp: 'sw 2/17/1999 00:40'!defaultAnnotationRequests	^ Parameters at: #MethodAnnotations ifAbsent:		[self setDefaultAnnotationInfo]	"Preferences annotationInfo"! !!Preferences class methodsFor: 'parameters' stamp: 'sma 6/1/2000 12:08'!defaultAuthorName	"Answer the author name to be planted, by default, in a changeset-preamble template.  You can hard-code this to hold your name, thus saving you time when writing the preambles of subsequent changesets"	^ Utilities authorName! !!Preferences class methodsFor: 'parameters' stamp: 'jhm 10/15/97 17:31'!desktopColor	"Answer the desktop color. Initialize it if necessary."		DesktopColor == nil ifTrue: [DesktopColor _ Color gray].	^ DesktopColor! !!Preferences class methodsFor: 'parameters' stamp: 'jhm 10/15/97 17:31'!desktopColor: aColor	"Record a new desktop color preference."	DesktopColor _ aColor.! !!Preferences class methodsFor: 'parameters' stamp: 'sw 2/7/2001 14:37'!parameterAt: aKey ifAbsent: aBlock	"Answer the parameter saved at the given key; if there is no such key in the Parameters dictionary, evaluate aBlock"	^ Parameters at: aKey ifAbsent: [aBlock value]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/28/2001 08:40'!parameterAt: aKey ifAbsentPut: defaultValueBlock	"Return the Parameter setting at the given key.  If there is no entry for this key in the Parameters dictionary, create one with the value of defaultValueBlock as its value"	^ Parameters at: aKey ifAbsentPut: defaultValueBlock! !!Preferences class methodsFor: 'parameters'!scrollBarColor	"Answer the preferred color for scroll bar elevators."	^ Color gray! !!Preferences class methodsFor: 'parameters'!scrollBarWidth	"Answer the preferred width for scroll bars."	^ 8! !!Preferences class methodsFor: 'parameters' stamp: 'sw 2/17/1999 00:41'!setDefaultAnnotationInfo	"Preferences setDefaultAnnotationInfo"	^ Parameters at: #MethodAnnotations put: #(timeStamp messageCategory implementorsCount allChangeSets)! !!Preferences class methodsFor: 'parameters' stamp: 'stp 01/13/2000 13:29'!setParameter: paramName to: paramValue	"Set the given field in the parameters dictionary."	Parameters at: paramName put: paramValue! !!Preferences class methodsFor: 'personalization' stamp: 'sw 4/18/2002 18:02'!restorePersonalPreferences	"Restore all the user's saved personal preference settings"	| savedPrefs |	savedPrefs _ self parameterAt: #PersonalDictionaryOfPreferences ifAbsent: [^ self inform: 'There are no personal preferences saved in this image yet'].	savedPrefs associationsDo:		[:assoc | (self preferenceAt: assoc key ifAbsent: [nil]) ifNotNilDo:			[:pref | pref preferenceValue: assoc value preferenceValue]]! !!Preferences class methodsFor: 'preference-object access' stamp: 'sw 4/13/2001 00:06'!allPreferenceObjects	"Answer a list of all the Preference objects registered in the system"	^ DictionaryOfPreferences values! !!Preferences class methodsFor: 'preference-object access' stamp: 'sw 4/13/2001 01:06'!preferenceAt: aSymbol	"Answer the Preference object at the given symbol, or nil if not there"	^ DictionaryOfPreferences at: aSymbol ifAbsent: [nil]! !!Preferences class methodsFor: 'preference-object access' stamp: 'sw 4/13/2001 01:06'!preferenceAt: aSymbol ifAbsent: aBlock	"Answer the Preference object at the given symbol, or the value of aBlock if not present"	^ DictionaryOfPreferences at: aSymbol ifAbsent: [aBlock value]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 9/15/1999 09:15'!initialExtent	^ (Preferences inboardScrollbars and: [Smalltalk isMorphic])		ifFalse:       		[219 @ 309]		ifTrue:			[232 @ 309]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 4/11/2001 23:55'!inspectPreferences	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings.  This is fallen back upon if Morphic is not present"	"Preferences inspectPreferences"	DictionaryOfPreferences inspectWithLabel: 'Preferences'! !!Preferences class methodsFor: 'preferences panel' stamp: 'BG 10/30/2003 21:17'!openPreferencesInspector	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"		self inspectPreferences! !!Preferences class methodsFor: 'standard queries'!alphabeticalProjectMenu	^ self		valueOfFlag: #alphabeticalProjectMenu		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!alternativeBrowseIt	^ self		valueOfFlag: #alternativeBrowseIt		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!annotationPanes	^ self		valueOfFlag: #annotationPanes		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!ansiAssignmentOperatorWhenPrettyPrinting	^ self		valueOfFlag: #ansiAssignmentOperatorWhenPrettyPrinting		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!autoAccessors	^ self		valueOfFlag: #autoAccessors		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!automaticPlatformSettings	^ self		valueOfFlag: #automaticPlatformSettings		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!browseWithPrettyPrint	^ self		valueOfFlag: #browseWithPrettyPrint		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!browserShowsPackagePane	^ self		valueOfFlag: #browserShowsPackagePane		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!capitalizedReferences	^ self		valueOfFlag: #capitalizedReferences		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!caseSensitiveFinds	^ self		valueOfFlag: #caseSensitiveFinds		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!changeSetVersionNumbers	^ self		valueOfFlag: #changeSetVersionNumbers		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!checkForSlips	^ self		valueOfFlag: #checkForSlips		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!clickOnLabelToEdit	^ self		valueOfFlag: #clickOnLabelToEdit		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!cmdDotEnabled	^ self		valueOfFlag: #cmdDotEnabled		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!colorWhenPrettyPrinting	^ self		valueOfFlag: #colorWhenPrettyPrinting		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!confirmFirstUseOfStyle	^ self		valueOfFlag: #confirmFirstUseOfStyle		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!conversionMethodsAtFileOut	^ self		valueOfFlag: #conversionMethodsAtFileOut		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!cpuWatcherEnabled	^ self		valueOfFlag: #cpuWatcherEnabled		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!decorateBrowserButtons	^ self		valueOfFlag: #decorateBrowserButtons		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!diffsInChangeList	^ self		valueOfFlag: #diffsInChangeList		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!diffsWithPrettyPrint	^ self		valueOfFlag: #diffsWithPrettyPrint		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!duplicateControlAndAltKeys	^ self		valueOfFlag: #duplicateControlAndAltKeys		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!eToyFriendly	^ self		valueOfFlag: #eToyFriendly		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!ignoreStyleIfOnlyBold	^ self		valueOfFlag: #ignoreStyleIfOnlyBold		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!inboardScrollbars	^ self		valueOfFlag: #inboardScrollbars		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!logDebuggerStackToFile	^ self		valueOfFlag: #logDebuggerStackToFile		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!menuKeyboardControl	^ self		valueOfFlag: #menuKeyboardControl		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!optionalButtons	^ self		valueOfFlag: #optionalButtons		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!printAlternateSyntax	^ self		valueOfFlag: #printAlternateSyntax		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!projectZoom	^ self		valueOfFlag: #projectZoom		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!projectsSentToDisk	^ self		valueOfFlag: #projectsSentToDisk		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!restartAlsoProceeds	^ self		valueOfFlag: #restartAlsoProceeds		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!reverseWindowStagger	^ self		valueOfFlag: #reverseWindowStagger		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!selectionsMayShrink	^ self		valueOfFlag: #selectionsMayShrink		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!showDeprecationWarnings	^ self		valueOfFlag: #showDeprecationWarnings		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!showSharedFlaps	^ self		valueOfFlag: #showSharedFlaps		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!smartUpdating	^ self		valueOfFlag: #smartUpdating		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!soundsEnabled	^ self		valueOfFlag: #soundsEnabled		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!startInUntrustedDirectory	^ self		valueOfFlag: #startInUntrustedDirectory		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!swapControlAndAltKeys	^ self		valueOfFlag: #swapControlAndAltKeys		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!swapMouseButtons	^ self		valueOfFlag: #swapMouseButtons		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!thoroughSenders	^ self		valueOfFlag: #thoroughSenders		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!timeStampsInMenuTitles	^ self		valueOfFlag: #timeStampsInMenuTitles		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!translationWithBabel	^ self		valueOfFlag: #translationWithBabel		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!twentyFourHourFileStamps	^ self		valueOfFlag: #twentyFourHourFileStamps		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!universalTiles	^ self		valueOfFlag: #universalTiles		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!warnIfNoChangesFile	^ self		valueOfFlag: #warnIfNoChangesFile		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!warnIfNoSourcesFile	^ self		valueOfFlag: #warnIfNoSourcesFile		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!warningForMacOSFileNameLength	^ self		valueOfFlag: #warningForMacOSFileNameLength		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!wordStyleCursorMovement	^ self		valueOfFlag: #wordStyleCursorMovement		ifAbsent: [true]! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 13:07'!initializeTextHighlightingParameters	"Preferences initializeTextHighlightingParameters"	Parameters at: #insertionPointColor put: (Color r: 0.4 g: 1.0 b: 0).	Parameters at: #textHighlightColor put: (Color r: 0.4 g: 1.0 b: 0).! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:53'!insertionPointColor	^ Parameters at: #insertionPointColor! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:53'!textHighlightColor	^ Parameters at: #textHighlightColor! !!Preferences class methodsFor: 'themes' stamp: 'sw 5/2/2002 10:45'!personal	"Settings saved (by sometime earlier having hit the 'Save Current Settings as my Personal Preferences' in a Preferences panel) as my personal preferences"	self restorePersonalPreferences! !!Preferences class methodsFor: 'window colors' stamp: 'sw 2/26/2002 13:56'!installBrightWindowColors	"Install the factory-provided default window colors for all tools"	"Preferences installBrightWindowColors"	self installWindowColorsVia: [:aSpec | aSpec brightColor]! !!Preferences class methodsFor: 'window colors' stamp: 'sw 2/26/2002 13:59'!installWindowColorsVia: colorSpecBlock	"Install windows colors using colorSpecBlock to deliver the color source for each element; the block is handed a WindowColorSpec object"	"Preferences installBrightWindowColors"	| windowColorDict |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new].	windowColorDict _ Parameters at: #windowColors.	self windowColorTable do:		[:aColorSpec |			windowColorDict at: aColorSpec classSymbol put: (Color colorFrom: (colorSpecBlock value: aColorSpec))]! !!Preferences class methodsFor: 'window colors' stamp: 'sw 7/13/1999 16:03'!windowColorFor: aModelClassName	| classToCheck windowColors |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new.		self installBrightWindowColors].	classToCheck _ Smalltalk at: aModelClassName.	windowColors _ Parameters at: #windowColors.	[windowColors includesKey: classToCheck name]		whileFalse:			[classToCheck _ classToCheck superclass].	^ windowColors at: classToCheck name ifAbsent: [Color white]	! !!Preferences class methodsFor: 'window colors' stamp: 'dvf 8/23/2003 12:18'!windowColorTable	"Answer a list of WindowColorSpec objects, one for each tool to be represented in the window-color panel"		^ (((self systemNavigation allClassesImplementing: #windowColorSpecification) collect:		[:aClass | aClass theNonMetaClass windowColorSpecification]) asSortedCollection:			[:specOne :specTwo | specOne wording < specTwo wording]) asArray"Preferences windowColorTable"! !!Preferences class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 10:18'!initialize	self registerInFlapsRegistry.	! !!Preferences class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 10:20'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(Preferences	preferencesControlPanel	'Preferences'	'Allows you to control numerous options')						forFlapNamed: 'Tools'.						cl registerQuad: #(Preferences			annotationEditingWindow	'Annotations'		'Allows you to specify the annotations to be shown in the annotation panes of browsers, etc.')						forFlapNamed: 'Tools'.]! !!Preferences class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:38'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!Preferences class methodsFor: 'as yet unclassified' stamp: 'BG 10/31/2003 14:46'!removeObsoleteInstances "Preferences removeObsoleteInstances"    | oc | oc := OrderedCollection new.Preference allInstances  collect: [:item | ( item changeInformee notNil and: [item changeInformee isObsolete])         ifTrue: [item deleteInformee]          ].! !TextDiffBuilder subclass: #PrettyTextDiffBuilder	instanceVariableNames: 'sourceClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!PrettyTextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:16'!sourceClass: aClass	sourceClass _ aClass.! !!PrettyTextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:20'!split: aString 	| formatted |	formatted _ sourceClass compilerClass newformat: aString				in: sourceClass				notifying: nil				decorated: false.	^super split: formatted! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PrettyTextDiffBuilder class	instanceVariableNames: ''!!PrettyTextDiffBuilder class methodsFor: 'instance creation' stamp: 'nk 10/29/2000 12:35'!from: srcString to: dstString inClass: srcClass 	^ (self new sourceClass: srcClass) from: srcString to: dstString		!]style[(6 9 5 9 10 8 6 4 18 8 8 9 5 9 3)f1b,f1cblack;b,f1b,f1cblack;b,f1b,f1cblack;b,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1! !Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler name'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Process commentStamp: '<historical>' prior: 0!I represent an independent path of control in the system. This path of control may be stopped (by sending the message suspend) in such a way that it can later be restarted (by sending the message resume). When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using the value of priority.(If anyone ever makes a subclass of Process, be sure to use allSubInstances in anyProcessesAbove:.)!!Process methodsFor: 'changing process state' stamp: 'tpr 2/14/2001 10:00'!primitiveResume	"Primitive. Allow the process that the receiver represents to continue. Put 	the receiver in line to become the activeProcess. Fail if the receiver is 	already waiting in a queue (in a Semaphore or ProcessScheduler). 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 87>	self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'ajh 7/20/2003 22:51'!primitiveSuspend	"Primitive. Stop the process that self represents in such a way 	that it can be restarted at a later time (by sending #resume).	ASSUMES self is the active process.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 88>	self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'tpr 2/14/2001 10:03'!resume	"Allow the process that the receiver represents to continue. Put  	the receiver in line to become the activeProcess. Check for a nil 	suspendedContext, which indicates a previously terminated Process that 	would cause a vm crash if the resume attempt were permitted"	suspendedContext ifNil: [^ self primitiveFailed].	^ self primitiveResume! !!Process methodsFor: 'changing process state' stamp: 'ajh 7/20/2003 22:47'!suspend	"Stop the process that the receiver represents in such a way 	that it can be restarted at a later time (by sending the receiver the 	message resume). If the receiver represents the activeProcess, suspend it. 	Otherwise remove the receiver from the list of waiting processes."	self isActiveProcess ifTrue: [		myList _ nil.		self primitiveSuspend.	] ifFalse: [		myList ifNotNil: [			myList remove: self ifAbsent: [].			myList _ nil].	]! !!Process methodsFor: 'changing process state' stamp: 'nk 6/21/2004 14:07'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock |	self isActiveProcess ifTrue: [		ctxt _ thisContext.		[	ctxt _ ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock _ ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		myList _ nil.		self primitiveSuspend.	] ifFalse: [		myList ifNotNil: [			myList remove: self ifAbsent: [].			myList _ nil].		suspendedContext ifNotNil: [			ctxt _ self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 16:14'!activateReturn: aContext value: value	"Activate 'aContext return: value', so execution will return to aContext's sender"	^ suspendedContext _ suspendedContext activateReturn: aContext value: value! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 3/5/2004 03:13'!complete: aContext 	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."		| ctxt pair error |	ctxt _ suspendedContext.	suspendedContext _ nil.  "disable this process while running its stack in active process below"	pair _ ctxt runUntilErrorOrReturnFrom: aContext.	suspendedContext _ pair first.	error _ pair second.	error ifNotNil: [^ error signalerContext].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:16'!completeStep: aContext 	"Resume self until aContext is on top, or if already on top, complete next step"	| callee |	self suspendedContext == aContext ifFalse: [		^ self complete: (self calleeOf: aContext)].	callee _ self step.	callee == aContext ifTrue: [^ callee].	aContext isDead ifTrue: [^ self suspendedContext].  "returned"	^ self complete: callee  "finish send"! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 3/5/2004 03:26'!popTo: aContext 	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee _ (self calleeOf: aContext) ifNil: [^ aContext].  "aContext is on top"	^ self return: callee value: callee receiver! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 20:40'!restartTop	"Rollback top context and replace with new method.  Assumes self is suspended"	suspendedContext privRefresh! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 20:33'!restartTopWith: method	"Rollback top context and replace with new method.  Assumes self is suspended"	suspendedContext privRefreshWith: method.! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 3/5/2004 03:26'!return: aContext value: value	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."	suspendedContext == aContext ifTrue: [		^ suspendedContext _ aContext return: value from: aContext].	self activateReturn: aContext value: value.	^ self complete: aContext.! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:17'!step	^ suspendedContext _ suspendedContext step! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/31/2003 14:45'!step: aContext 	"Resume self until aContext is on top, or if already on top, do next step"	^ self suspendedContext == aContext		ifTrue: [self step]		ifFalse: [self complete: (self calleeOf: aContext)]! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 22:06'!stepToCallee	"Step until top context changes"	| ctxt |	ctxt _ suspendedContext.	[ctxt == suspendedContext] whileTrue: [		suspendedContext _ suspendedContext step].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 7/18/2003 22:13'!stepToHome: aContext 	"Resume self until the home of top context is aContext.  Top context may be a block context."	| home ctxt |	home _ aContext home.	[	ctxt _ self step.		home == ctxt home.	] whileFalse: [		home isDead ifTrue: [^ self suspendedContext].	].	^ self suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:17'!stepToSendOrReturn	^ suspendedContext _ suspendedContext stepToSendOrReturn! !!Process methodsFor: 'accessing' stamp: 'ajh 1/24/2003 14:53'!calleeOf: aContext	"Return the context whose sender is aContext.  Return nil if aContext is on top.  Raise error if aContext is not in process chain."	suspendedContext == aContext ifTrue: [^ nil].	^ (suspendedContext findContextSuchThat: [:c | c sender == aContext])		ifNil: [self error: 'aContext not in process chain']! !!Process methodsFor: 'accessing' stamp: 'ajh 1/24/2003 19:44'!isActiveProcess	^ self == Processor activeProcess! !!Process methodsFor: 'accessing' stamp: 'nk 10/28/2000 19:55'!isSuspended	^myList isNil! !!Process methodsFor: 'accessing' stamp: 'ajh 3/4/2004 22:18'!isTerminated	self isActiveProcess ifTrue: [^ false].	^ suspendedContext isNil or: [		suspendedContext == suspendedContext bottomContext and: [			suspendedContext pc > suspendedContext startpc]]! !!Process methodsFor: 'accessing' stamp: 'svp 12/5/2002 14:42'!name

	^name ifNil: [ self hash asString forceTo: 5 paddingStartWith: $ ]! !!Process methodsFor: 'accessing' stamp: 'svp 12/5/2002 14:42'!name: aString

	name _ aString! !!Process methodsFor: 'accessing'!offList	"Inform the receiver that it has been taken off a list that it was 	suspended on. This is to break a backpointer."	myList _ nil! !!Process methodsFor: 'accessing'!priority	"Answer the priority of the receiver."	^priority! !!Process methodsFor: 'accessing' stamp: 'ar 7/8/2001 17:04'!priority: anInteger 	"Set the receiver's priority to anInteger."	(anInteger >= Processor lowestPriority and:[anInteger <= Processor highestPriority])		ifTrue: [priority _ anInteger]		ifFalse: [self error: 'Invalid priority: ', anInteger printString]! !!Process methodsFor: 'accessing'!suspendedContext	"Answer the context the receiver has suspended."	^suspendedContext! !!Process methodsFor: 'accessing'!suspendingList	"Answer the list on which the receiver has been suspended."	^myList! !!Process methodsFor: 'printing' stamp: 'nk 10/28/2000 07:33'!browserPrintString	^self browserPrintStringWith: suspendedContext! !!Process methodsFor: 'printing' stamp: 'svp 12/5/2002 14:45'!browserPrintStringWith: anObject 	| stream |	stream _ WriteStream				on: (String new: 100).	stream nextPut: $(.	priority printOn: stream.	self isSuspended		ifTrue: [stream nextPut: $s].	stream nextPutAll: ') '.	stream nextPutAll: self name.	stream nextPut: $:.	stream space.	stream nextPutAll: anObject asString.	^ stream contents! !!Process methodsFor: 'printing' stamp: 'ajh 10/2/2001 14:36'!longPrintOn: stream	| ctxt |	super printOn: stream.	stream cr.	ctxt _ self suspendedContext.	[ctxt == nil] whileFalse: [		stream space.		ctxt printOn: stream.		stream cr.		ctxt _ ctxt sender.	].! !!Process methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' in '.	suspendedContext printOn: aStream! !!Process methodsFor: 'private'!suspendedContext: aContext	suspendedContext _ aContext! !!Process methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:46'!objectForDataStream: refStrm	"I am not allowed to be written on an object file."	refStrm replace: self with: nil.	^ nil! !!Process methodsFor: 'debugging' stamp: 'nk 10/29/2000 13:43'!debug	self debugWithTitle: 'Debug'.! !!Process methodsFor: 'debugging' stamp: 'ajh 7/20/2003 23:54'!debug: context title: title	"Open debugger on self with context shown on top"	self debug: context title: title full: false.! !!Process methodsFor: 'debugging' stamp: 'ajh 7/20/2003 23:53'!debug: context title: title full: bool	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt _ self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].	Debugger openOn: self context: context label: title contents: nil fullView: bool.! !!Process methodsFor: 'debugging' stamp: 'ajh 7/20/2003 23:55'!debugWithTitle: title	"Open debugger on self"	| context |	context _ self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	self debug: context title: title full: true.! !!Process methodsFor: 'signaling' stamp: 'svp 9/19/2003 18:41'!pvtSignal: anException list: aList	"Private. This method is used to signal an exception from another	process...the receiver must be the active process.  If the receiver 	was previously waiting on a Semaphore, then return the process	to the waiting state after signaling the exception and if the Semaphore	has not been signaled in the interim"	"Since this method is not called in a normal way, we need to take care	that it doesn't directly return to the caller (because I believe that could	have the potential to push an unwanted object on the caller's stack)."	| blocker |	self isActiveProcess ifFalse: [^self].	anException signal.	blocker := Semaphore new.	[self suspend.	suspendedContext := suspendedContext swapSender: nil.	aList class == Semaphore 		ifTrue:			[aList isSignaled				ifTrue: 					[aList wait.  "Consume the signal that would have restarted the receiver"					self resume]				ifFalse:					["Add us back to the Semaphore's list (and remain blocked)"					myList := aList.					aList add: self]]		ifFalse: [self resume]] fork.	blocker wait.! !!Process methodsFor: 'signaling' stamp: 'svp 9/19/2003 18:42'!signal: anException	"Signal an exception in the receiver process...if the receiver is currently	suspended, the exception will get signaled when the receiver is resumed.  If 	the receiver is blocked on a Semaphore, it will be immediately re-awakened	and the exception will be signaled; if the exception is resumed, then the receiver	will return to a blocked state unless the blocking Semaphore has excess signals"	"If we are the active process, go ahead and signal the exception"	self isActiveProcess ifTrue: [^anException signal].	"Add a new method context to the stack that will signal the exception"	suspendedContext := MethodContext		sender: suspendedContext		receiver: self		method: (self class methodDict at: #pvtSignal:list:)		arguments: (Array with: anException with: myList).	"If we are on a list to run, then suspend and restart the receiver 	(this lets the receiver run if it is currently blocked on a semaphore).  If	we are not on a list to be run (i.e. this process is suspended), then when the	process is resumed, it will signal the exception"	myList ifNotNil: [self suspend; resume].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Process class	instanceVariableNames: ''!!Process class methodsFor: 'instance creation'!forContext: aContext priority: anInteger 	"Answer an instance of me that has suspended aContext at priority 	anInteger."	| newProcess |	newProcess _ self new.	newProcess suspendedContext: aContext.	newProcess priority: anInteger.	^newProcess! !Model subclass: #ProcessBrowser	instanceVariableNames: 'selectedProcess selectedContext methodText processList processListIndex stackList stackListIndex sourceMap selectedClass selectedSelector searchString autoUpdateProcess deferredMessageRecipient lastUpdate startedCPUWatcher'	classVariableNames: 'Browsers SuspendedProcesses'	poolDictionaries: ''	category: 'Tools-Process Browser'!!ProcessBrowser commentStamp: '<historical>' prior: 0!Change Set:		ProcessBrowserDate:			14 March 2000Author:			Ned Konzemail: ned@bike-nomad.comThis is distributed under the Squeak License.Added 14 March:	CPUWatcher integration	automatically start and stop CPUWatcher	added CPUWatcher to process list menuAdded 29 October:	MVC version	2.8, 2.7 compatibility	rearranged menus	added pointer inspection and chasing	added suspend/resume	recognized more well-known processes	misc. bug fixesAdded 26 October: highlight pc in source codeAdded 27 October: added 'signal semaphore'added 'inspect receiver', 'explore receiver', 'message tally' to stack list menuadded 'find context', 'next context' to process list menuadded 'change priority' and 'debug' choices to process list menu27 October mods by Bob Arning:alters process display in Ned's ProcessBrowser to - show process priority- drop 'a Process in' that appears on each line- show in priority order- prettier names for known processes- fix to Utilities to forget update downloading process when it ends (1 less deadprocess)- correct stack dump for the active process!!ProcessBrowser methodsFor: 'accessing'!processList	^ processList! !!ProcessBrowser methodsFor: 'accessing'!processListIndex	^ processListIndex! !!ProcessBrowser methodsFor: 'accessing'!processListIndex: index 	processListIndex _ index.	selectedProcess _ processList				at: index				ifAbsent: [].	self updateStackList.	self changed: #processListIndex.! !!ProcessBrowser methodsFor: 'accessing' stamp: 'nk 2/16/2001 13:39'!selectedMethod	^ methodText ifNil: [methodText _ selectedContext						ifNil: ['']						ifNotNil: [| pcRange | 							methodText _ [ selectedContext sourceCode ]								ifError: [ :err :rcvr | 'error getting method text' ].							pcRange _ self pcRange.							methodText asText								addAttribute: TextColor red								from: pcRange first								to: pcRange last;																addAttribute: TextEmphasis bold								from: pcRange first								to: pcRange last]]! !!ProcessBrowser methodsFor: 'accessing' stamp: 'ajh 9/7/2002 21:22'!selectedSelector	"Answer the class in which the currently selected context's method was  	found."	^ selectedSelector		ifNil: [selectedSelector _ selectedContext receiver				ifNil: [| who | 					who _ selectedContext method.					selectedClass _ who first.					who last]				ifNotNil: [selectedContext methodSelector]]! !!ProcessBrowser methodsFor: 'accessing'!stackList	^ stackList! !!ProcessBrowser methodsFor: 'accessing'!stackListIndex	^ stackListIndex! !!ProcessBrowser methodsFor: 'accessing' stamp: 'nk 10/28/2000 08:57'!stackListIndex: index 	stackListIndex _ index.	selectedContext _ nil.	(stackList notNil			and: [index > 0])		ifTrue: [selectedContext _ stackList						at: index						ifAbsent: []].	sourceMap _ nil.	selectedClass _ nil.	selectedSelector _ nil.	methodText _ nil.	self changed: #stackListIndex.	self changed: #selectedMethod! !!ProcessBrowser methodsFor: 'accessing' stamp: 'nk 10/28/2000 08:36'!text	^methodText! !!ProcessBrowser methodsFor: 'initialize-release' stamp: 'nk 10/31/2001 10:54'!initialize	methodText _ ''.	stackListIndex _ 0.	searchString _ ''.	lastUpdate _ 0.	startedCPUWatcher _ Preferences cpuWatcherEnabled and: [ self startCPUWatcher ].	self updateProcessList; processListIndex: 1! !!ProcessBrowser methodsFor: 'initialize-release' stamp: 'nk 3/14/2001 09:26'!startCPUWatcher	"Answers whether I started the CPUWatcher"	| pw |	pw _ Smalltalk at: #CPUWatcher ifAbsent: [ ^self ].	pw ifNotNil: [		pw isMonitoring ifFalse: [			pw startMonitoringPeriod: 5 rate: 100 threshold: 0.85.			self setUpdateCallbackAfter: 7.			^true		]	].	^false! !!ProcessBrowser methodsFor: 'initialize-release' stamp: 'nk 3/14/2001 09:26'!stopCPUWatcher	| pw |	pw _ Smalltalk at: #CPUWatcher ifAbsent: [ ^self ].	pw ifNotNil: [		pw stopMonitoring.		self updateProcessList.		startedCPUWatcher _ false.	"so a manual restart won't be killed later"	]! !!ProcessBrowser methodsFor: 'initialize-release' stamp: 'nk 3/14/2001 08:03'!windowIsClosing	startedCPUWatcher ifTrue: [ CPUWatcher stopMonitoring ]! !!ProcessBrowser methodsFor: 'menus' stamp: 'nk 10/26/2000 23:31'!selectedClass	"Answer the class in which the currently selected context's method was  	found."	^ selectedClass		ifNil: [selectedClass _ selectedContext receiver				ifNil: [| who | 					who _ selectedContext method who.					selectedSelector _ who last.					who first]				ifNotNil: [selectedContext mclass]]! !!ProcessBrowser methodsFor: 'message handling' stamp: 'nk 10/28/2000 20:53'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 3/8/2001 17:02'!changePriority	| str newPriority nameAndRules |	nameAndRules _ self nameAndRulesForSelectedProcess.	nameAndRules third		ifFalse: [PopUpMenu inform: 'Nope, won''t change priority of ' , nameAndRules first.			^ self].	str _ FillInTheBlank request: 'New priority' initialAnswer: selectedProcess priority asString.	newPriority _ str asNumber asInteger.	newPriority		ifNil: [^ self].	(newPriority < 1			or: [newPriority > Processor highestPriority])		ifTrue: [PopUpMenu inform: 'Bad priority'.			^ self].	self class setProcess: selectedProcess toPriority: newPriority.	self updateProcessList! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 10/29/2000 10:18'!chasePointers	| saved |	selectedProcess		ifNil: [^ self].	saved _ selectedProcess.	[selectedProcess _ nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: saved]		ifFalse: [self inspectPointers]]		ensure: [selectedProcess _ saved]! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 3/8/2001 16:37'!debugProcess	| nameAndRules |	nameAndRules _ self nameAndRulesForSelectedProcess.	nameAndRules third		ifFalse: [PopUpMenu inform: 'Nope, won''t debug ' , nameAndRules first.			^ self].	self class debugProcess: selectedProcess.! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 10/29/2000 10:17'!inspectPointers	| tc pointers |	selectedProcess		ifNil: [^ self].	tc _ thisContext.			pointers _ Smalltalk pointersTo: selectedProcess except: {self processList. tc. self}.			pointers isEmpty				ifTrue: [^ self].			OrderedCollectionInspector				openOn: pointers				withEvalPane: false				withLabel: 'Objects pointing to ' , selectedProcess browserPrintString! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 3/8/2001 13:35'!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	aProcess == autoUpdateProcess ifTrue: [ ^{'my auto-update process'. true. true} ].	^self class nameAndRulesFor: aProcess ! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 10/28/2000 20:31'!nameAndRulesForSelectedProcess	"Answer a nickname and two flags: allow-stop, and allow-debug"	^self nameAndRulesFor: selectedProcess! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 3/8/2001 13:23'!resumeProcess	selectedProcess		ifNil: [^ self].	self class resumeProcess: selectedProcess.	self updateProcessList! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 10/29/2000 09:58'!signalSemaphore	(selectedProcess suspendingList isKindOf: Semaphore)		ifFalse: [^ self].	[selectedProcess suspendingList signal] fork.	(Delay forMilliseconds: 300) wait.	"Hate to make the UI wait, but it's convenient..."	self updateProcessList! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 3/8/2001 13:21'!suspendProcess	| nameAndRules |	selectedProcess isSuspended		ifTrue: [^ self].	nameAndRules _ self nameAndRulesForSelectedProcess.	nameAndRules second		ifFalse: [PopUpMenu inform: 'Nope, won''t suspend ' , nameAndRules first.			^ self].	self class suspendProcess: selectedProcess.	self updateProcessList! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 3/8/2001 13:25'!terminateProcess	| nameAndRules |	nameAndRules _ self nameAndRulesForSelectedProcess.	nameAndRules second		ifFalse: [PopUpMenu inform: 'Nope, won''t kill ' , nameAndRules first.			^ self].	self class terminateProcess: selectedProcess.		self updateProcessList! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 10/29/2000 08:56'!wasProcessSuspendedByProcessBrowser: aProcess	^self class suspendedProcesses includesKey: aProcess! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 10/27/2000 09:24'!exploreProcess	selectedProcess explore! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 10/27/2000 11:53'!findContext	| initialProcessIndex initialStackIndex found |	initialProcessIndex _ self processListIndex.	initialStackIndex _ self stackListIndex.	searchString _ FillInTheBlank request: 'Enter a string to search for in the process stack lists' initialAnswer: searchString.	searchString isEmpty		ifTrue: [^ false].	self processListIndex: 1.	self stackListIndex: 1.	found _ self nextContext.	found		ifFalse: [self processListIndex: initialProcessIndex.			self stackListIndex: initialStackIndex].	^ found! !!ProcessBrowser methodsFor: 'process list'!inspectProcess	selectedProcess inspect! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 10/27/2000 11:52'!nextContext	| initialProcessIndex initialStackIndex found |	searchString isEmpty ifTrue: [ ^false ].	initialProcessIndex _ self processListIndex.	initialStackIndex _ self stackListIndex.	found _ false.	initialProcessIndex		to: self processList size		do: [:pi | found				ifFalse: [self processListIndex: pi.					self stackNameList						withIndexDo: [:name :si | (found not									and: [pi ~= initialProcessIndex											or: [si > initialStackIndex]])								ifTrue: [(name includesSubString: searchString)										ifTrue: [self stackListIndex: si.											found _ true]]]]].	found		ifFalse: [self processListIndex: initialProcessIndex.			self stackListIndex: initialStackIndex].	^ found! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 10/28/2000 08:19'!notify: errorString at: location in: aStream 	"A syntax error happened when I was trying to highlight my pc. 	Raise a signal so that it can be ignored."	Warning signal: 'syntax error'!]style[(8 11 5 8 5 7 3 107 2 7 23)f1b,f1cblack;b,f1b,f1cblack;b,f1b,f1cblack;b,f1,f1c142040000,f1,f1cblack;,f1! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 10/28/2000 20:30'!prettyNameForProcess: aProcess 	| nameAndRules |	nameAndRules _ self nameAndRulesFor: aProcess.	^ aProcess browserPrintStringWith: nameAndRules first! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 10/29/2000 10:20'!processListKey: aKey from: aView 	^ aKey caseOf: {		[$i] -> [self inspectProcess].		[$I] -> [self exploreProcess].		[$c] -> [self chasePointers].		[$P] -> [self inspectPointers].		[$t] -> [self terminateProcess].		[$r] -> [self resumeProcess].		[$s] -> [self suspendProcess].		[$d] -> [self debugProcess].		[$p] -> [self changePriority].		[$m] -> [self messageTally].		[$f] -> [self findContext].		[$g] -> [self nextContext].		[$a] -> [self toggleAutoUpdate].		[$u] -> [self updateProcessList].		[$S] -> [self signalSemaphore].		[$k] -> [self moreStack]}		 otherwise: [self arrowKey: aKey from: aView]! !!ProcessBrowser methodsFor: 'process list' stamp: 'LC 1/7/2002 16:35'!processListMenu: menu 	| pw |	selectedProcess		ifNotNil: [| nameAndRules | 			nameAndRules _ self nameAndRulesForSelectedProcess.			menu addList: {{'inspect (i)'. #inspectProcess}. {'explore (I)'. #exploreProcess}. {'inspect Pointers (P)'. #inspectPointers}}.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [ menu add: 'chase pointers (c)' action: #chasePointers.  ].			nameAndRules second				ifTrue: [menu add: 'terminate (t)' action: #terminateProcess.					selectedProcess isSuspended						ifTrue: [menu add: 'resume (r)' action: #resumeProcess]						ifFalse: [menu add: 'suspend (s)' action: #suspendProcess]].			nameAndRules third				ifTrue: [menu addList: {{'change priority (p)'. #changePriority}. {'debug (d)'. #debugProcess}}].			menu addList: {{'profile messages (m)'. #messageTally}}.			(selectedProcess suspendingList isKindOf: Semaphore)				ifTrue: [menu add: 'signal Semaphore (S)' action: #signalSemaphore].			menu add: 'full stack (k)' action: #moreStack.			menu addLine].	menu addList: {{'find context... (f)'. #findContext}. {'find again (g)'. #nextContext}}.	menu addLine.	menu		add: (self isAutoUpdating				ifTrue: ['turn off auto-update (a)']				ifFalse: ['turn on auto-update (a)'])		action: #toggleAutoUpdate.	menu add: 'update list (u)' action: #updateProcessList.	pw _ Smalltalk at: #CPUWatcher ifAbsent: [].	pw ifNotNil: [		menu addLine.		pw isMonitoring				ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher ]				ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher  ]	].	^ menu! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 6/21/2004 09:59'!processNameList	"since processList is a WeakArray, we have to strengthen the result"	| pw tally |	pw _ Smalltalk at: #CPUWatcher ifAbsent: [ ].	tally _ pw ifNotNil: [ pw current ifNotNil: [ pw current tally ] ].	^ (processList asOrderedCollection		copyWithout: nil)		collect: [:each | | percent |			percent _ tally				ifNotNil: [ ((((tally occurrencesOf: each) * 100.0 / tally size) roundTo: 1)						asString padded: #left to: 2 with: $ ), '% '  ]				ifNil: [ '' ].			percent, (self prettyNameForProcess: each)		] ! !!ProcessBrowser methodsFor: 'process list' stamp: 'ajh 7/21/2003 10:11'!updateProcessList	| oldSelectedProcess newIndex now |	now _ Time millisecondClockValue.	now - lastUpdate < 500		ifTrue: [^ self].	"Don't update too fast"	lastUpdate _ now.	oldSelectedProcess _ selectedProcess.	processList _ selectedProcess _ selectedSelector _ nil.	Smalltalk garbageCollectMost.	"lose defunct processes"	processList _ Process allSubInstances				reject: [:each | each isTerminated].	processList _ processList				sortBy: [:a :b | a priority >= b priority].	processList _ WeakArray withAll: processList.	newIndex _ processList				indexOf: oldSelectedProcess				ifAbsent: [0].	self changed: #processNameList.	self processListIndex: newIndex! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/28/2000 16:49'!browseContext	selectedContext		ifNil: [^ self].	Browser newOnClass: self selectedClass selector: self selectedSelector!]style[(13 30 4 4 7 42 4 17)f1b,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1! !!ProcessBrowser methodsFor: 'stack list' stamp: 'RAA 10/27/2000 15:21'!changeStackListTo: aCollection         stackList _ aCollection.        self changed: #stackNameList.        self stackListIndex: 0! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/27/2000 09:28'!exploreContext	selectedContext explore! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/27/2000 09:41'!exploreReceiver	selectedContext ifNotNil: [ selectedContext receiver explore ]! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 7/8/2000 20:23'!inspectContext	selectedContext inspect! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/27/2000 09:41'!inspectReceiver	selectedContext		ifNotNil: [selectedContext receiver inspect]! !!ProcessBrowser methodsFor: 'stack list' stamp: 'BG 10/29/2003 10:17'!messageTally	| secString secs |	secString _ FillInTheBlank request: 'Profile for how many seconds?' initialAnswer: '4'.	secs _ secString asNumber asInteger.	(secs isNil			or: [secs isZero])		ifTrue: [^ self].	! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/28/2000 12:13'!moreStack	self updateStackList: 2000! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 7/4/2003 19:55'!pcRange	"Answer the indices in the source code for the method corresponding to  	the selected context's program counter value."	| i methodNode pc end tempNames |	methodText isEmptyOrNil		ifTrue: [^ 1 to: 0].	sourceMap == nil		ifTrue: [self selectedClass == #unknown				ifTrue: [^ 1 to: 0].			[[methodNode _ self selectedClass compilerClass new						parse: methodText						in: self selectedClass						notifying: self ]				on: Warning				do: [:ex | 					methodText _ ('(syntax error) ' , ex description , String cr , methodText) asText.					ex return]]				on: Error				do: [:ex | 					methodText _ ('(parse error) ' , ex description , String cr , methodText) asText.					ex return].			methodNode				ifNil: [sourceMap _ nil.					^ 1 to: 0].			sourceMap _ methodNode sourceMap.			tempNames _ methodNode tempNames.			selectedContext method cacheTempNames: tempNames].	(sourceMap size = 0 or: [ selectedContext isDead ])		ifTrue: [^ 1 to: 0].	pc _ selectedContext pc.	pc _ pc - 2.	i _ sourceMap				indexForInserting: (Association key: pc value: nil).	i < 1		ifTrue: [^ 1 to: 0].	i > sourceMap size		ifTrue: [end _ sourceMap						inject: 0						into: [:prev :this | prev max: this value last].			^ end + 1 to: end].	^ (sourceMap at: i) value! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/28/2000 16:53'!stackListMenu: aMenu 	| menu |	selectedContext		ifNil: [^ aMenu].	menu _ aMenu				labels: 'inspect context (c)explore context (C)inspect receiver (i)explore receiver (I)browse (b)'				lines: #(2 4 )				selections: #(#inspectContext #exploreContext #inspectReceiver #exploreReceiver #browseContext ).	^ menu! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/28/2000 16:18'!stackNameList	^ stackList		ifNil: [#()]		ifNotNil: [stackList				collect: [:each | each asString]]! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 7/8/2000 20:24'!updateStackList	self updateStackList: 20! !!ProcessBrowser methodsFor: 'stack list' stamp: 'nk 10/28/2000 09:00'!updateStackList: depth 	| suspendedContext oldHighlight |	selectedProcess		ifNil: [^ self changeStackListTo: nil].	(stackList notNil and: [ stackListIndex > 0 ])		ifTrue: [oldHighlight _ stackList at: stackListIndex].	selectedProcess == Processor activeProcess		ifTrue: [self				changeStackListTo: (thisContext stackOfSize: depth)]		ifFalse: [suspendedContext _ selectedProcess suspendedContext.			suspendedContext				ifNil: [self changeStackListTo: nil]				ifNotNil: [self						changeStackListTo: (suspendedContext stackOfSize: depth)]].	self		stackListIndex: (stackList				ifNil: [0]				ifNotNil: [stackList indexOf: oldHighlight])!]style[(17 5 4 30 4 15 13 4 20 3 29 14 3 4 12 12 3 9 5 14 4 15 4 9 26 4 25 11 14 5 15 16 3 15 22 16 13 4 20 3 17 4 27 16 14 5 6 4 20 9 13 1 17 9 10 12 2)f1b,f1cblack;b,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 10/28/2000 21:48'!isAutoUpdating	^autoUpdateProcess notNil and: [ autoUpdateProcess isSuspended  not ]! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 6/18/2003 07:20'!isAutoUpdatingPaused	^autoUpdateProcess notNil and: [ autoUpdateProcess isSuspended ]! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 6/18/2003 07:20'!pauseAutoUpdate	self isAutoUpdating		ifTrue: [ autoUpdateProcess suspend ].	self updateProcessList! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 3/14/2001 09:08'!setUpdateCallbackAfter: seconds		deferredMessageRecipient ifNotNil: [ | d |			d _ Delay forSeconds: seconds.			[  d wait.				d _ nil.				deferredMessageRecipient addDeferredUIMessage: [self updateProcessList]			] fork		]! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 6/18/2003 07:21'!startAutoUpdate	self isAutoUpdatingPaused ifTrue: [ ^autoUpdateProcess resume ].	self isAutoUpdating		ifFalse: [| delay | 			delay _ Delay forSeconds: 2.			autoUpdateProcess _ [[self hasView]						whileTrue: [delay wait.							deferredMessageRecipient ifNotNil: [								deferredMessageRecipient addDeferredUIMessage: [self updateProcessList]]							ifNil: [ self updateProcessList ]].					autoUpdateProcess _ nil] fork].	self updateProcessList! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 6/18/2003 07:22'!stopAutoUpdate	autoUpdateProcess ifNotNil: [		autoUpdateProcess terminate.		autoUpdateProcess _ nil].	self updateProcessList! !!ProcessBrowser methodsFor: 'updating' stamp: 'nk 10/28/2000 21:50'!toggleAutoUpdate	self isAutoUpdating		ifTrue: [ self stopAutoUpdate ]		ifFalse: [ self startAutoUpdate ].! !!ProcessBrowser methodsFor: 'views' stamp: 'nk 10/28/2000 11:44'!hasView	^self dependents isEmptyOrNil not! !!ProcessBrowser methodsFor: 'views' stamp: 'nk 3/14/2001 09:04'!openAsMVC	"Create a pluggable version of me, answer a window"	| window processListView stackListView methodTextView |	window _ StandardSystemView new model: self controller: (deferredMessageRecipient _ DeferredActionStandardSystemController new).	window borderWidth: 1.	processListView _ PluggableListView				on: self				list: #processNameList				selected: #processListIndex				changeSelected: #processListIndex:				menu: #processListMenu:				keystroke: #processListKey:from:.	processListView		window: (0 @ 0 extent: 300 @ 200).	window addSubView: processListView.	stackListView _ PluggableListView				on: self				list: #stackNameList				selected: #stackListIndex				changeSelected: #stackListIndex:				menu: #stackListMenu:				keystroke: #stackListKey:from:.	stackListView		window: (300 @ 0 extent: 300 @ 200).	window addSubView: stackListView toRightOf: processListView.	methodTextView _ PluggableTextView				on: self				text: #selectedMethod				accept: nil				readSelection: nil				menu: nil.	methodTextView askBeforeDiscardingEdits: false.	methodTextView		window: (0 @ 200 corner: 600 @ 400).	window addSubView: methodTextView below: processListView.	window setUpdatablePanesFrom: #(#processNameList #stackNameList ).	window label: 'Process Browser'.	window minimumSize: 300 @ 200.	window subViews		do: [:each | each controller].	window controller open.	startedCPUWatcher ifTrue: [ self setUpdateCallbackAfter: 7 ].	^ window! !!ProcessBrowser methodsFor: 'views' stamp: 'nk 10/28/2000 16:53'!stackListKey: aKey from: aView 	^ aKey caseOf: {		[$c] -> [self inspectContext].		[$C] -> [self exploreContext].		[$i] -> [self inspectReceiver].		[$I] -> [self exploreReceiver].		[$b] -> [self browseContext]}		 otherwise: [self arrowKey: aKey from: aView]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProcessBrowser class	instanceVariableNames: ''!!ProcessBrowser class methodsFor: 'instance creation' stamp: 'BG 10/29/2003 00:38'!open	"ProcessBrowser open"	"Create and schedule a ProcessBrowser."	Smalltalk garbageCollect.	^ Smalltalk isMorphic		ifTrue: [ ]		ifFalse: [ self new openAsMVC ]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 3/8/2001 17:09'!debugProcess: aProcess	self resumeProcess: aProcess.	aProcess debugWithTitle: 'Interrupted from the Process Browser'.! !!ProcessBrowser class methodsFor: 'process control' stamp: 'ssa 9/3/2008 11:08'!isUIProcess: aProcess	^aProcess == ScheduledControllers activeControllerProcess ! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 4/12/2004 19:37'!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	^ [aProcess caseOf: {		[] -> [{'no process'. false. false}].		[Smalltalk lowSpaceWatcherProcess] -> [{'the low space watcher'. false. false}].		[WeakArray runningFinalizationProcess] -> [{'the WeakArray finalization process'. false. false}].		[Processor activeProcess] -> [{'the UI process'. false. true}].		[Processor backgroundProcess] -> [{'the idle process'. false. false}].		[Sensor interruptWatcherProcess] -> [{'the user interrupt watcher'. false. false}].		[Sensor eventTicklerProcess] -> [{'the event tickler'. false. false}].		[Project uiProcess] -> [{'the inactive Morphic UI process'. false. false}].		[Smalltalk			at: #SoundPlayer			ifPresent: [:sp | sp playerProcess]] -> [{'the Sound Player'. false. false}].		[ScheduledControllers			ifNotNil: [ScheduledControllers activeControllerProcess]] -> [{'the inactive MVC controller process'. false. true}].		[Smalltalk			at: #CPUWatcher			ifPresent: [:cw | cw currentWatcherProcess]] -> [{'the CPUWatcher'. false. false}]}		 otherwise: 			[(aProcess priority = Processor timingPriority					and: [aProcess suspendedContext receiver == Delay])				ifTrue: [{'the timer interrupt watcher'. false. false}]				ifFalse: [{aProcess suspendedContext asString. true. true}]]]		ifError: [:err :rcvr | {aProcess suspendedContext asString. true. true}]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 2/12/2002 10:09'!resumeProcess: aProcess	| priority |	priority _ self suspendedProcesses				removeKey: aProcess				ifAbsent: [aProcess priority].	aProcess priority: priority.	aProcess suspendedContext ifNotNil: [ aProcess resume ]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 3/8/2001 17:07'!setProcess: aProcess toPriority: priority	| oldPriority |	oldPriority _ self suspendedProcesses at: aProcess ifAbsent: [ ].	oldPriority ifNotNil: [ self suspendedProcesses at: aProcess put: priority ].	aProcess priority: priority.	^oldPriority! !!ProcessBrowser class methodsFor: 'process control' stamp: 'dew 9/16/2001 01:53'!suspendProcess: aProcess	| priority |	priority _ aProcess priority.	self suspendedProcesses at: aProcess put: priority.	"Need to take the priority down below the caller's	so that it can keep control after signaling the Semaphore"	(aProcess suspendingList isKindOf: Semaphore)		ifTrue: [aProcess priority: Processor lowestPriority.			aProcess suspendingList signal].	[aProcess suspend]		on: Error		do: [:ex | self suspendedProcesses removeKey: aProcess].	aProcess priority: priority.! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 10/29/2000 08:55'!suspendedProcesses	"Answer a collection of processes that my instances have suspended.  	This is so that they don't get garbage collected."	^ SuspendedProcesses		ifNil: [SuspendedProcesses _ IdentityDictionary new]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 3/8/2001 13:25'!terminateProcess: aProcess	aProcess ifNotNil: [		self suspendedProcesses			removeKey: aProcess			ifAbsent: [].		aProcess terminate	].! !!ProcessBrowser class methodsFor: 'process control' stamp: 'nk 3/8/2001 13:26'!wasProcessSuspendedByProcessBrowser: aProcess	^self suspendedProcesses includesKey: aProcess! !!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'nk 3/14/2001 08:59'!dumpTallyOnTranscript: tally	"tally is from ProcessorScheduler>>tallyCPUUsageFor:	Dumps lines with percentage of time, hash of process, and a friendly name"	tally sortedCounts do: [ :assoc | | procName |		procName _ (self nameAndRulesFor: assoc value) first.		Transcript print: (((assoc key / tally size) * 100.0) roundTo: 1);			nextPutAll: '%   ';			print: assoc value identityHash; space;			nextPutAll: procName;			cr.	].	Transcript flush.! !!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'nk 3/8/2001 12:49'!tallyCPUUsageFor: seconds	"Compute CPU usage using a 10-msec sample for the given number of seconds,	then dump the usage statistics on the Transcript. The UI is free to continue, meanwhile"	"ProcessBrowser tallyCPUUsageFor: 10"	^self tallyCPUUsageFor: seconds every: 10! !!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'BG 10/29/2003 01:07'!tallyCPUUsageFor: seconds every: msec	"Compute CPU usage using a msec millisecond sample for the given number of seconds,	then dump the usage statistics on the Transcript. The UI is free to continue, meanwhile"	"ProcessBrowser tallyCPUUsageFor: 10 every: 100"	| promise |	promise _ Processor tallyCPUUsageFor: seconds every: msec.	[ | tally |		tally _ promise value.		Smalltalk isMorphic			ifTrue: [ ]			ifFalse: [ [ Transcript open ] forkAt: Processor userSchedulingPriority.					[ (Delay forSeconds: 1) wait.					self dumpTallyOnTranscript: tally ] forkAt: Processor userSchedulingPriority.]	] fork.! !!ProcessBrowser class methodsFor: 'class initialization' stamp: 'nk 6/18/2003 07:31'!initialize	"ProcessBrowser initialize"	Browsers ifNil: [ Browsers _ WeakSet new ].	SuspendedProcesses ifNil: [ SuspendedProcesses _ IdentityDictionary new ].	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.	self registerInFlapsRegistry.! !!ProcessBrowser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 10:22'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | 	cl registerQuad: #(ProcessBrowser			prototypicalToolWindow		'Processes'			'A Process Browser shows you all the running processes')						forFlapNamed: 'Tools'.]! !!ProcessBrowser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:39'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:32'!shutDown	Browsers do: [ :ea | ea isAutoUpdating ifTrue: [ ea pauseAutoUpdate ]]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:32'!startUp	Browsers do: [ :ea | ea isAutoUpdatingPaused ifTrue: [ ea startAutoUpdate ]]! !Object subclass: #ProcessorScheduler	instanceVariableNames: 'quiescentProcessLists activeProcess'	classVariableNames: 'BackgroundProcess HighIOPriority LowIOPriority SystemBackgroundPriority SystemRockBottomPriority TimingPriority UserBackgroundPriority UserInterruptPriority UserSchedulingPriority'	poolDictionaries: ''	category: 'Kernel-Processes'!!ProcessorScheduler commentStamp: '<historical>' prior: 0!My single instance, named Processor, coordinates the use of the physical processor by all Processes requiring service.!!ProcessorScheduler methodsFor: 'accessing'!activePriority	"Answer the priority level of the currently running Process."	^activeProcess priority! !!ProcessorScheduler methodsFor: 'accessing'!activeProcess	"Answer the currently running Process."	^activeProcess! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'nk 10/27/2000 16:27'!backgroundProcess	"Answer the background process"	^ BackgroundProcess! !!ProcessorScheduler methodsFor: 'accessing'!highestPriority	"Answer the number of priority levels currently available for use."	^quiescentProcessLists size! !!ProcessorScheduler methodsFor: 'removing'!remove: aProcess ifAbsent: aBlock 	"Remove aProcess from the list on which it is waiting for the processor 	and answer aProcess. If it is not waiting, evaluate aBlock."	(quiescentProcessLists at: aProcess priority)		remove: aProcess ifAbsent: aBlock.	^aProcess! !!ProcessorScheduler methodsFor: 'process state change'!terminateActive	"Terminate the process that is currently running."	activeProcess terminate! !!ProcessorScheduler methodsFor: 'process state change' stamp: 'tpr 4/28/2004 17:53'!yield	"Give other Processes at the current priority a chance to run."	| semaphore |	<primitive: 167>	semaphore _ Semaphore new.	[semaphore signal] fork.	semaphore wait! !!ProcessorScheduler methodsFor: 'priority names'!lowIOPriority	"Answer the priority at which most input/output processes should run. 	Examples are the process handling input from the user (keyboard, 	pointing device, etc.) and the process distributing input from a network."	^LowIOPriority! !!ProcessorScheduler methodsFor: 'priority names' stamp: 'ar 7/8/2001 17:02'!lowestPriority	"Return the lowest priority that is allowed with the scheduler"	^SystemRockBottomPriority! !!ProcessorScheduler methodsFor: 'priority names'!timingPriority	"Answer the priority at which the system processes keeping track of real 	time should run."	^TimingPriority! !!ProcessorScheduler methodsFor: 'priority names'!userInterruptPriority	"Answer the priority at which user processes desiring immediate service 	should run. Processes run at this level will preempt the window 	scheduler and should, therefore, not consume the processor forever."	^UserInterruptPriority! !!ProcessorScheduler methodsFor: 'priority names'!userSchedulingPriority	"Answer the priority at which the window scheduler should run."	^UserSchedulingPriority! !!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'nk 3/8/2001 12:56'!nextReadyProcess	quiescentProcessLists reverseDo: [ :list |		list isEmpty ifFalse: [ | proc |			proc _ list first.			proc suspendedContext ifNotNil: [ ^proc ]]].	^nil! !!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'nk 3/8/2001 12:48'!tallyCPUUsageFor: seconds	"Start a high-priority process that will tally the next ready process for the given	number of seconds. Answer a Block that will return the tally (a Bag) after the task	is complete" 	^self tallyCPUUsageFor: seconds every: 10! !!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'nk 3/17/2001 10:06'!tallyCPUUsageFor: seconds every: msec	"Start a high-priority process that will tally the next ready process for the given	number of seconds. Answer a Block that will return the tally (a Bag) after the task	is complete" 	| tally sem delay endDelay |	tally _ IdentityBag new: 200.	delay _ Delay forMilliseconds: msec truncated.	endDelay _ Delay forSeconds: seconds.	endDelay schedule.	sem _ Semaphore new.	[		[ endDelay isExpired ] whileFalse: [			delay wait.			tally add: Processor nextReadyProcess		].		sem signal.	] forkAt: self highestPriority.	^[ sem wait. tally ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProcessorScheduler class	instanceVariableNames: ''!!ProcessorScheduler class methodsFor: 'class initialization' stamp: 'ar 7/8/2001 16:39'!initialize     	SystemRockBottomPriority _ 10.	SystemBackgroundPriority _ 20.	UserBackgroundPriority _ 30.	UserSchedulingPriority _ 40.	UserInterruptPriority _ 50.	LowIOPriority _ 60.	HighIOPriority _ 70.	TimingPriority _ 80.	"ProcessorScheduler initialize."! !!ProcessorScheduler class methodsFor: 'instance creation'!new	"New instances of ProcessorScheduler should not be created."	self error:'New ProcessSchedulers should not be created sincethe integrity of the system depends on a unique scheduler'! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:44'!idleProcess	"A default background process which is invisible."	[true] whileTrue:		[self relinquishProcessorForMicroseconds: 1000]! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/3/97 11:17'!relinquishProcessorForMicroseconds: anInteger	"Platform specific. This primitive is used to return processor cycles to the host operating system when Squeak's idle process is running (i.e., when no other Squeak process is runnable). On some platforms, this primitive causes the entire Squeak application to sleep for approximately the given number of microseconds. No Squeak process can run while the Squeak application is sleeping, even if some external event makes it runnable. On the Macintosh, this primitive simply calls GetNextEvent() to give other applications a chance to run. On platforms without a host operating system, it does nothing. This primitive should not be used to add pauses to a Squeak process; use a Delay instead."	<primitive: 230>	"don't fail if primitive is not implemented, just do nothing"! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'di 2/4/1999 08:45'!startUp	"Install a background process of the lowest possible priority that is always runnable."	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."	Smalltalk installLowSpaceWatcher.	BackgroundProcess == nil ifFalse: [BackgroundProcess terminate].	BackgroundProcess _ [self idleProcess] newProcess.	BackgroundProcess priority: SystemRockBottomPriority.	BackgroundProcess resume.! !Exception subclass: #ProgressInitiationException	instanceVariableNames: 'workBlock maxVal minVal aPoint progressTitle'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ProgressInitiationException commentStamp: '<historical>' prior: 0!I provide a way to alter the behavior of the old-style progress notifier in String. See examples in:ProgressInitiationException testWithout.ProgressInitiationException testWith.!!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 6/6/2000 18:46'!defaultAction	| delta savedArea captionText textFrame barFrame outerFrame result range lastW w |	barFrame _ aPoint - (75@10) corner: aPoint + (75@10).	captionText _ DisplayText text: progressTitle asText allBold.	captionText		foregroundColor: Color black		backgroundColor: Color white.	textFrame _ captionText boundingBox insetBy: -4.	textFrame _ textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame _ barFrame merge: textFrame.	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	barFrame _ barFrame translateBy: delta.	textFrame _ textFrame translateBy: delta.	outerFrame _ outerFrame translateBy: delta.	savedArea _ Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"	lastW _ 0.	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal |		w _ ((barFrame width-4) asFloat * ((barVal-minVal) asFloat / range min: 1.0)) asInteger.		w ~= lastW ifTrue: [			Display fillGray: (barFrame topLeft + (2@2) extent: w@16).			lastW _ w]].	savedArea displayOn: Display at: outerFrame topLeft.	self resume: result! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 11:43'!display: argString at: argPoint from: argMinVal to: argMaxVal during: argWorkBlock	progressTitle _ argString.	aPoint _ argPoint.	minVal _ argMinVal.	maxVal _ argMaxVal.	workBlock _ argWorkBlock.	^self signal! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 12:39'!isResumable		^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProgressInitiationException class	instanceVariableNames: ''!!ProgressInitiationException class methodsFor: 'signalling' stamp: 'ajh 1/22/2003 23:51'!display: aString at: aPoint from: minVal to: maxVal during: workBlock	^ self new		display: aString at: aPoint from: minVal to: maxVal during: workBlock! !Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth viewSize thumbnail nextProject guards projectParameters isolatedHead inForce version urlList environment lastDirectory lastSavedAtSeconds projectPreferenceFlagDictionary resourceManager'	classVariableNames: 'AllProjects CurrentProject GoalFreePercent GoalNotMoreThan UIProcess'	poolDictionaries: ''	category: 'System-Support'!!Project commentStamp: '<historical>' prior: 0!A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet.  A project knows who its parent project is.  When you change projects, whether by entering or exiting, the screen state of the project being exited is saved in that project.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Project named: 'xxx') exportSegment, or choose 'store project on file...'.  Projects may be loaded from a server and stored back.  Storing on a server never overwrites;  it always makes a new version.  A project remembers the url of where it lives in urlList.  The list is length one, for now.  The url may point to a local disk instead of a server.  All projects that the user looks at, are cached in the Squeaklet folder.  Sorted by server.  The cache holds the most recent version only.  IsolationWhen you accept a method, the entire system feels the change, except projects that are "isolated".  In an isolated project, all new global variables (including new classes) are stored in the project-local environment, and all changes to preexisting classes are revoked when you leave the project.  When you enter another project, that project's changes are invoked.  Invocation and revocation are handled efficiently by swapping pointers.  To make a project be isolated, choose 'isolate changes of this project' from the 'changes...' section of the screen menu.  You can use an isolated project for making dangerous change to a system, and you can get out if it crashes.  A foreign application can have the separate environment it wants.  Also, you can freeze part of the system for a demo that you don't want to disturb.  An isolated project shares methods with all subprojects inside it, unless they are isolated themselves.   Each isolated project is the head of a tree of projects with which it shares all methods.You may 'assert' all changes ever made in the current project to take effect above this project.  This amounts to exporting all the globals in the current environment, and zapping the revocation lists to that the current state of the world will remain in force upon exit from this project.[Later: A project may be 'frozen'.  Asserts do not apply to it after that.  (Great for demos.)  You should be informed when an assert was blocked in a frozen project.]Class definitions are layered by the isolation mechanism.  You are only allowed to change the shape of a class in projects that lie within its isolation scope.  All versions of the methods are recompiled, in all projects.  If you remove an inst var that is in use in an isolated project, it will become an Undeclared global.  It is best not to remove an inst var when it is being used in another isolated project. [If we recompile them all, why can't we diagnose the problem before allowing the change??]Senders and Implementors do not see versions of a method in isolated projects.  [again, we might want to make this possible at a cost].  When you ask for versions of a method, you will not get the history in other isolated projects.Moving methods and classes between changeSets, and merging changeSets has no effect on which methods are in force.  But, when you look at a changeSet from a different isolated project, the methods will contain code that is not in force.  A changeSet is just a list of method names, and does not keep separate copies of any code.When finer grained assertion is needed, use the method (aProject assertClass: aClass from: thisProject warn: warnConflicts).How isolated changes work: The first time a class changes, store its MethodDictionary object.  Keep parallel arrays of associations to Classes and MethodDictionaries.  Traverse these and install them when you enter an "ioslated project".  When you leave, store this project's own MethodDictionaries there.	To do an assert, we must discover which methods changed here, and which changed only in the project we are asserting into.  There is one copy of the 'virgin' method dictionaries in the system.  It is always being temporarily stored by the currently inForce isolated project.isolatedHead - true for the top project, and for each isolated project.  false or nil for any subproject that shares all methods with its parent project.inForce -  true if my methods are installed now.  false if I am dormant. [is this equivalent to self == Project Current?]classArray - list of associations to classes methodDictArray - the method dictionaries of those classes before we started changing methods.  They hang onto the original compiledMethods.  (If this project is dormant, it contains the method dictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - No longer used.When you want to save a project in export format from within that very project, it gets tricky.  We set two flags in parentProject, exit to it, and let parentProject write the project.  ProjectViewMorph in parentProject checks in its step method, does the store, clears the flags, and reenters the subProject.!!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!backgroundColorForMvcProject	^ Color r: 1.0 g: 1.0 b: 0.065! !!Project methodsFor: 'initialization' stamp: 'ssa 9/3/2008 11:08'!defaultBackgroundColor	^ self isMorphic		ifTrue: []		ifFalse: [self backgroundColorForMvcProject]! !!Project methodsFor: 'initialization'!initialExtent	^ (Display extent // 6) + (0@17)! !!Project methodsFor: 'initialization' stamp: 'di 4/14/1999 13:55'!initialProject	self saveState.	parentProject _ self.	previousProject _ nextProject _ nil! !!Project methodsFor: 'initialization' stamp: 'di 4/6/2001 10:30'!initialize	"Initialize the project, seting the CurrentProject as my parentProject and initializing my project preferences from those of the CurrentProject"	changeSet _ ChangeSet new.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ CurrentProject.	isolatedHead _ false.	self initializeProjectPreferences! !!Project methodsFor: 'initialization' stamp: 'ar 5/16/2001 17:08'!installNewDisplay: extent depth: depth	"When entering a new project, install a new Display if necessary."	^Display setExtent: extent depth: depth! !!Project methodsFor: 'initialization' stamp: 'RAA 6/21/2000 22:59'!setChangeSet: aChangeSet	isolatedHead == true ifTrue: [^ self].  "ChangeSet of an isolated project cannot be changed"	changeSet _ aChangeSet! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!setProjectHolder: aProject	self initialize.	world _ ControlManager new.! !!Project methodsFor: 'initialization' stamp: 'di 6/10/1998 13:54'!windowActiveOnFirstClick	^ true! !!Project methodsFor: 'initialization' stamp: 'di 6/12/1998 15:58'!windowReqNewLabel: newLabel	newLabel isEmpty ifTrue: [^ false].	newLabel = changeSet name ifTrue: [^ true].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ false].	changeSet name: newLabel.	^ true! !!Project methodsFor: 'accessing' stamp: 'tk 4/5/2000 16:29'!changeSet	^ changeSet! !!Project methodsFor: 'accessing' stamp: 'jla 5/28/2001 21:50'!children	"Answer a list of all the subprojects of the receiver"		| children |	children _ OrderedCollection new.	Project allProjects do: [ :p | 		(self == p parent and: [self ~~ p]) ifTrue:			[ children add: p ]].	^ children"Project topProject children"! !!Project methodsFor: 'accessing'!displayDepth: newDepth	displayDepth _ newDepth! !!Project methodsFor: 'accessing' stamp: 'tk 2/24/2000 13:51'!environment	^ environment! !!Project methodsFor: 'accessing' stamp: 'RAA 6/3/2000 10:23'!isCurrentProject	^self == CurrentProject! !!Project methodsFor: 'accessing' stamp: 'tk 9/22/1999 18:32'!isMorphic	"Complexity is because #isMVC is lazily installed"	^ world isInMemory 		ifTrue: [world isMorph]		ifFalse: [(self projectParameters at: #isMVC ifAbsent: [false]) not]! !!Project methodsFor: 'accessing' stamp: 'di 3/29/2000 15:37'!isTopProject	"Return true only if this is the top project (its own parent).	Also include the test here for malformed project hierarchy."	parentProject == self ifTrue: [^ true].	parentProject == nil ifTrue: [self error: 'No project should have a nil parent'].	^ false! !!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Project methodsFor: 'accessing' stamp: 'di 7/19/1999 15:06'!name	changeSet == nil ifTrue: [^ 'no name'].	^ changeSet name! !!Project methodsFor: 'accessing' stamp: 'jla 5/28/2001 20:01'!nameAdjustedForDepth	"Answer the name of the project, prepended with spaces reflecting the receiver's depth from the top project"	"	Project current nameAdjustedForDepth	"	| stream |	stream _ WriteStream on: String new.	self depth timesRepeat: 	  [2 timesRepeat: [stream nextPut: $ ]].	stream nextPutAll: self name.	^ stream contents! !!Project methodsFor: 'accessing' stamp: 'sw 2/15/1999 12:12'!nextProject	^ nextProject! !!Project methodsFor: 'accessing' stamp: 'di 3/6/98 10:22'!parent	^ parentProject! !!Project methodsFor: 'accessing' stamp: 'jm 5/20/1998 23:31'!previousProject	^ previousProject! !!Project methodsFor: 'accessing'!projectChangeSet	^ changeSet! !!Project methodsFor: 'accessing' stamp: 'ssa 9/3/2008 11:21'!renameTo: newName	| |	newName = self name		ifFalse: [			version _ nil.			self changeSet name: newName.			].! !!Project methodsFor: 'accessing' stamp: 'di 4/14/1999 13:59'!setParent: newParent	parentProject _ newParent.	nextProject _ previousProject _ nil.! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:06'!setViewSize: aPoint	viewSize _ aPoint! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:07'!thumbnail	^ thumbnail! !!Project methodsFor: 'accessing' stamp: 'jla 5/28/2001 21:51'!withChildrenDo: aBlock	"Evaluate the block first with the receiver as argument, then, recursively and depth first, with each of the receiver's children as argument"		aBlock value: self.	self children do: [:p | 		p withChildrenDo:			[:c | aBlock value: c]]! !!Project methodsFor: 'accessing'!world	^ world! !!Project methodsFor: 'menu messages' stamp: 'BG 10/28/2003 21:03'!assureNavigatorPresenceMatchesPreference	"Make sure that the current project conforms to the presence/absence of the navigator"	Smalltalk isMorphic ifFalse: [^ self].! !!Project methodsFor: 'menu messages' stamp: 'tk 10/26/1999 14:25'!enter	"Enter the new project"	self enter: (CurrentProject parent == self) revert: false saveForRevert: false.! !!Project methodsFor: 'menu messages' stamp: 'ssa 9/3/2008 11:09'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert 	"Install my ChangeSet, Transcript, and scheduled views as current 	globals. If returningFlag is true, we will return to the project from 	whence the current project was entered; don't change its 	previousProject link in this case. 	If saveForRevert is true, save the ImageSegment of the project being 	left. If revertFlag is true, make stubs for the world of the project being 	left. If revertWithoutAsking is true in the project being left, then 	always revert."	| showZoom old forceRevert response seg newProcess |	self isCurrentProject		ifTrue: [^ self].	"Check the guards"	guards		ifNotNil: [guards := guards						reject: [:obj | obj isNil].			guards				do: [:obj | obj okayToEnterProject						ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert := false.	CurrentProject rawParameters		ifNil: [revertFlag				ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert				ifFalse: [forceRevert := CurrentProject projectParameters								at: #revertWithoutAsking								ifAbsent: [false]]].	forceRevert not & revertFlag		ifTrue: [response := SelectionMenu						confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs						trueChoice: 'Revert to saved version'						falseChoice: 'Cancel'.			response				ifFalse: [^ self]].	revertFlag | forceRevert		ifTrue: [seg := CurrentProject projectParameters						at: #revertToMe						ifAbsent: [^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue: [ProjectHistory forget: CurrentProject.					"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse: [ProjectHistory remember: CurrentProject]].	revertFlag | saveForRevert | forceRevert		ifFalse: [(Preferences valueOfFlag: #projectsSentToDisk)				ifTrue: [self storeToMakeRoom]].	CurrentProject abortResourceLoading.	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old := CurrentProject.	"for later"	"Show the project transition. 	Note: The project zoom is run in the context of the old project, 	so that eventual errors can be handled accordingly"	displayDepth == nil		ifTrue: [displayDepth := Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom := self showZoom)		ifTrue: [self displayZoom: CurrentProject parent ~~ self].	(world isMorph			and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk				at: #ScorePlayer				ifPresentAndInMemory: [:playerClass | playerClass						allSubInstancesDo: [:player | player pause]]].	returningFlag == #specialReturn		ifTrue: [old removeChangeSetIfPossible.			"keep this stuff from accumulating"			nextProject := nil]		ifFalse: [returningFlag				ifTrue: [nextProject := CurrentProject]				ifFalse: [previousProject := CurrentProject]].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead		ifFalse: [self invokeFrom: CurrentProject].	CurrentProject := self.	self installProjectPreferences.	ChangeSet newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue: []		ifFalse: [World := nil.			"Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert		ifTrue: [Smalltalk garbageCollect.			"let go of pointers"			old storeSegment.			"result _"			old world isInMemory				ifTrue: ['Can''t seem to write the project.']				ifFalse: [old projectParameters at: #revertToMe put: old world xxxSegment clone].			'Project written.'].	"original is for coming back in and continuing."	revertFlag | forceRevert		ifTrue: [seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph		ifFalse: [newProcess := [ScheduledControllers resetActiveController.					"in case of walkback in #restore"					showZoom						ifFalse: [ScheduledControllers restore].					ScheduledControllers searchForActiveController] fixTemps newProcess priority: Processor userSchedulingPriority.			newProcess resume.			"lose the current process and its referenced morphs"			Processor terminateActive]! !!Project methodsFor: 'menu messages' stamp: 'BG 10/30/2003 21:26'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject _ self.	Display newDepthNoRestore: displayDepth.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	world isMorph		ifTrue:			["Entering a Morphic project"			World _ world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World _ nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess _ Processor activeProcess.! !!Project methodsFor: 'menu messages'!fileOut	changeSet fileOut! !!Project methodsFor: 'menu messages' stamp: 'BG 10/29/2003 01:09'!finalExitActions	world isMorph ifTrue: [	].! !!Project methodsFor: 'menu messages' stamp: 'sw 4/19/2001 12:58'!installProjectPreferences	"Install the settings of all preferences presently held individually by projects in the receiver's projectPreferenceFlagDictionary"	| localValue |	Preferences allPreferenceObjects do:		[:aPreference | 			aPreference localToProject ifTrue:				[localValue _ self projectPreferenceFlagDictionary at: aPreference name ifAbsent: [nil].				localValue ifNotNil:					[aPreference rawValue: localValue]]]! !!Project methodsFor: 'menu messages' stamp: 'BG 10/28/2003 20:07'!makeThumbnail	"Make a thumbnail image of this project from the Display."	world isMorph ifTrue: [world displayWorldSafely]. "clean pending damage"	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt current toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).	^thumbnail! !!Project methodsFor: 'menu messages' stamp: 'sw 4/12/2001 22:29'!saveProjectPreferences	"Preserve the settings of all preferences presently held individually by projects in the receiver's projectPreferenceFlagDictionary"	Preferences allPreferenceObjects do:		[:aPreference | 			aPreference localToProject ifTrue:				[projectPreferenceFlagDictionary at: aPreference name put: aPreference preferenceValue]]! !!Project methodsFor: 'menu messages' stamp: 'BG 11/26/2003 23:15'!saveState	"Save the current state in me prior to leaving this project"	changeSet := ChangeSet current.	thumbnail		ifNotNil: [thumbnail hibernate].	Smalltalk isMorphic		ifFalse: [world := ScheduledControllers.			ScheduledControllers unCacheWindows].	Sensor flushAllButDandDEvents.	"Will be reinstalled by World>>install"	transcript := Transcript! !!Project methodsFor: 'menu messages' stamp: 'BG 10/29/2003 09:53'!viewLocFor: exitedProject	"Look for a view of the exitedProject, and return its center"	| ctlr |	world isMorph		ifTrue: []		ifFalse: [ctlr _ world controllerWhoseModelSatisfies:							[:p | p == exitedProject].				ctlr ifNotNil: [^ ctlr view windowBox center]].	^ Sensor cursorPoint.  "default result"! !!Project methodsFor: 'release' stamp: 'di 9/28/1999 23:46'!addDependent: aMorph	"Projects do not keep track of their dependents, lest they point into other projects and thus foul up the tree structure for image segmentation."	^ self  "Ignore this request"! !!Project methodsFor: 'release' stamp: 'sw 7/6/1998 11:16'!canDiscardEdits	"Don't regard a window of mine as one to be discarded as part of a 'closeUnchangedWindows' sweep"	^ false! !!Project methodsFor: 'release' stamp: 'RAA 5/10/2001 12:58'!deletingProject: aProject	"Clear my previousProject link if it points at the given Project, which is being deleted."	self flag: #bob.		"zapping projects"	parentProject == aProject ifTrue: [		parentProject _ parentProject parent	].	previousProject == aProject		ifTrue: [previousProject _ nil].	nextProject == aProject		ifTrue:	[nextProject _ nil]! !!Project methodsFor: 'release' stamp: 'ssa 9/3/2008 11:09'!okToChange	"Answer whether the window in which the project is housed can be dismissed -- which is destructive. We never clobber a project without confirmation"	| ok |	self subProjects size  >0 ifTrue:		[self inform: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ world isMorph not and: [world scheduledControllers size <= 1].	ok ifFalse: [self isMorphic ifTrue:		[]].  "view from elsewhere.  just delete it."	ok _ (self confirm:'Really delete the project', self name printString, 'and all its windows?').			ok ifFalse: [^ false].	self removeChangeSetIfPossible.	"do this last since it will render project inaccessible to #allProjects and their ilk"	ProjectHistory forget: self.	Project deletingProject: self.	^ true! !!Project methodsFor: 'release' stamp: 'RAA 6/7/2000 09:24'!release	self flag: #bob.	"this can be trouble if Projects are reused before garbage collection"	world == nil ifFalse:		[world release.		world _ nil].	^ super release! !!Project methodsFor: 'release' stamp: 'RAA 5/10/2001 13:06'!removeChangeSetIfPossible	| itsName |	changeSet ifNil: [^self].	changeSet isEmpty ifFalse: [^self].	(changeSet projectsBelongedTo copyWithout: self) isEmpty ifFalse: [^self].	itsName _ changeSet name.	ChangeSorter removeChangeSet: changeSet.	"Transcript cr; show: 'project change set ', itsName, ' deleted.'"! !!Project methodsFor: 'release' stamp: 'BG 10/28/2003 21:04'!subProjects	"Answer a list of all the subprojects  of the receiver.  This is nastily idiosyncratic."	^ self isMorphic				ifFalse:			[(world controllersSatisfying:					[:m | m model isKindOf: Project])				collect:					[:c | c model]]! !!Project methodsFor: 'printing' stamp: 'jm 5/21/1998 07:40'!printOn: aStream	aStream nextPutAll: 'a Project(', self name, ')'.! !!Project methodsFor: 'file in/out' stamp: 'BG 10/29/2003 00:50'!beep	! !!Project methodsFor: 'file in/out' stamp: 'BG 10/29/2003 08:18'!currentVersionNumber	version ifNil: [^0].	version isInteger ifTrue:[^version].	"version _ Base64MimeConverter decodeInteger: version unescapePercents."	^version! !!Project methodsFor: 'file in/out' stamp: 'ar 2/27/2001 13:44'!projectExtension	^self class projectExtension! !!Project methodsFor: 'file in/out' stamp: 'tk 10/26/1999 14:23'!revert	| |	"Exit this project and do not save it.  Warn user unless in dangerous projectRevertNoAsk mode.  Exit to the parent project.  Do a revert on a clone of the segment, to allow later reverts."	projectParameters ifNil: [^ self inform: 'nothing to revert to'].	parentProject enter: false revert: true saveForRevert: false.	"does not return!!"! !!Project methodsFor: 'file in/out' stamp: 'BG 10/29/2003 09:10'!saveAs	"Forget where stored before, and store.  Will ask user where."	"self forgetExistingURL.	self storeOnServer. "! !!Project methodsFor: 'file in/out' stamp: 'BG 10/29/2003 09:16'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"(World == world) ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].! !!Project methodsFor: 'file in/out' stamp: 'md 10/22/2003 17:54'!storeToMakeRoom	"Write out enough projects to fulfill the space goals.	Include the size of the project about to come in."	| params memoryEnd goalFree cnt gain proj skip tried |	GoalFreePercent ifNil: [GoalFreePercent _ 33].	GoalNotMoreThan ifNil: [GoalNotMoreThan _ 20000000].	params _ SmalltalkImage current  getVMParameters.	memoryEnd	_ params at: 3."	youngSpaceEnd	_ params at: 2.	free _ memoryEnd - youngSpaceEnd."	goalFree _ GoalFreePercent asFloat / 100.0 * memoryEnd.	goalFree _ goalFree min: GoalNotMoreThan.	world isInMemory ifFalse: ["enough room to bring it in"		goalFree _ goalFree + (self projectParameters at: #segmentSize ifAbsent: [0])].	cnt _ 30.	gain _ Smalltalk garbageCollectMost.	"skip a random number of projects that are in memory"	proj _ self.  skip _ 6 atRandom.	[proj _ proj nextInstance ifNil: [Project someInstance].		proj world isInMemory ifTrue: [skip _ skip - 1].		skip > 0] whileTrue.	cnt _ 0.  tried _ 0.	[gain > goalFree] whileFalse: [		proj _ proj nextInstance ifNil: [Project someInstance].		proj storeSegment ifTrue: ["Yes, did send its morphs to the disk"			gain _ gain + (proj projectParameters at: #segmentSize 						ifAbsent: [20000]).	"a guess"			Beeper beep.			(cnt _ cnt + 1) > 5 ifTrue: [^ self]].	"put out 5 at most"		(tried _ tried + 1) > 23 ifTrue: [^ self]].	"don't get stuck in a loop"! !!Project methodsFor: 'file in/out' stamp: 'mir 6/25/2001 10:55'!url	| firstURL |	"compose my url on the server"	urlList isEmptyOrNil ifTrue: [^''].	firstURL _ urlList first.	firstURL isEmpty		ifFalse: [			firstURL last == $/				ifFalse: [firstURL _ firstURL, '/']].	^ firstURL, self versionedFileName! !!Project methodsFor: 'file in/out' stamp: 'mir 6/21/2001 15:45'!versionForFileName	"Project current versionForFileName"	^self class versionForFileName: self currentVersionNumber! !!Project methodsFor: 'file in/out' stamp: 'mir 6/21/2001 15:43'!versionedFileName	"Project current versionedFileName"	^String streamContents:[:s|		s nextPutAll: self name.		s nextPutAll: FileDirectory dot.		s nextPutAll: self versionForFileName.		s nextPutAll: FileDirectory dot.		s nextPutAll: self projectExtension.	]! !!Project methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		isolatedHead ifNil: [isolatedHead _ false].	inForce ifNil: [inForce _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!Project methodsFor: 'project parameters' stamp: 'sw 4/24/2001 11:58'!initializeProjectParameters	"Initialize the project parameters."	projectParameters _ IdentityDictionary new.	^ projectParameters! !!Project methodsFor: 'project parameters' stamp: 'di 11/16/2001 21:08'!initializeProjectPreferences	"Initialize the project's preferences from currently-prevailing preferences that are currently being held in projects in this system"		projectPreferenceFlagDictionary _ Project current projectPreferenceFlagDictionary deepCopy.    "Project overrides in the new project start out being the same set of overrides in the calling project"	Preferences allPreferenceObjects do:  "in case we missed some"		[:aPreference |			aPreference localToProject ifTrue:				[(projectPreferenceFlagDictionary includesKey: aPreference name) ifFalse:			[projectPreferenceFlagDictionary at: aPreference name put: aPreference preferenceValue]]].	self isMorphic ifFalse: [self flapsSuppressed: true].	(Project current projectParameterAt: #disabledGlobalFlapIDs  ifAbsent: [nil]) ifNotNilDo:		[:idList | self projectParameterAt: #disabledGlobalFlapIDs put: idList copy]! !!Project methodsFor: 'project parameters' stamp: 'sw 2/16/2001 22:35'!noteThatParameter: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a project parameter might precipitate some immediate action"! !!Project methodsFor: 'project parameters' stamp: 'ar 5/25/2000 23:23'!parameterAt: aSymbol ifAbsent: aBlock	projectParameters ifNil:[^aBlock value].	^projectParameters at: aSymbol ifAbsent: aBlock! !!Project methodsFor: 'project parameters' stamp: 'sw 2/15/2001 14:32'!projectParameterAt: aSymbol ifAbsent: aBlock	"Answer the project parameter stored at the given symbol, or the result of evaluating the block"	^ self projectParameters at: aSymbol ifAbsent: [aBlock value]! !!Project methodsFor: 'project parameters' stamp: 'sw 2/17/2001 21:36'!projectParameterAt: aSymbol put: aValue	"Set the given project parameter to the given value"	self projectParameters at: aSymbol put: aValue.	self noteThatParameter: aSymbol justChangedTo: aValue.	^ aValue! !!Project methodsFor: 'project parameters' stamp: 'sw 4/22/1999 15:14'!projectParameters	^ projectParameters ifNil: [self initializeProjectParameters]! !!Project methodsFor: 'project parameters' stamp: 'sw 2/16/2001 22:25'!projectPreferenceAt: aSymbol ifAbsent: aBlock	"Answer the project preference stored at the given symbol, or the result of evaluating the block"	^ self projectPreferenceFlagDictionary at: aSymbol ifAbsent: [aBlock value]! !!Project methodsFor: 'project parameters' stamp: 'sw 2/16/2001 22:23'!projectPreferenceFlagDictionary	"Answer the dictionary that holds the project preferences, creating it if necessary"	^ projectPreferenceFlagDictionary ifNil: [projectPreferenceFlagDictionary _ IdentityDictionary new]! !!Project methodsFor: 'project parameters' stamp: 'tk 10/26/1999 13:55'!rawParameters	^ projectParameters! !!Project methodsFor: 'project parameters' stamp: 'ar 6/2/1999 05:29'!removeParameter: aKey	projectParameters ifNil:[^self].	projectParameters removeKey: aKey ifAbsent:[].! !!Project methodsFor: 'flaps support' stamp: 'BG 10/29/2003 08:42'!flapsSuppressed: aBoolean	"Make the setting of the flag that governs whether global flaps are suppressed in the project be as indicated and add or remove the actual flaps"	self projectPreferenceFlagDictionary at: #showSharedFlaps put: aBoolean not.	self == Project current  "Typical case"		ifTrue:			[Preferences setPreference: #showSharedFlaps toValue: aBoolean not]		ifFalse:   "Anomalous case where this project is not the current one."			[aBoolean				ifTrue:							[]				ifFalse:					[Smalltalk isMorphic  ifTrue:						[]]].	Project current assureNavigatorPresenceMatchesPreference! !!Project methodsFor: 'flaps support' stamp: 'sw 4/24/2001 11:02'!showSharedFlaps	"Answer whether shared flaps are shown or suppressed in this project"	| result |	result _ Preferences showSharedFlaps.	^ self == Project current		ifTrue:			[result]		ifFalse:			[self projectPreferenceAt: #showSharedFlaps ifAbsent: [result]]! !!Project methodsFor: 'displaying' stamp: 'ar 5/28/2000 19:43'!displayZoom: entering	"Show the project transition when entering a new project"	| newDisplay vanishingPoint |	"Play the flash transition if any."	self projectParameters at: #flashTransition ifPresent:[:dict|		dict at: CurrentProject ifPresent:[:player| ^player playProjectTransitionFrom: CurrentProject to: self entering: entering]].	"Show animated zoom to new display"	newDisplay _ self imageForm.	entering		ifTrue: [vanishingPoint _ Sensor cursorPoint]		ifFalse: [vanishingPoint _ self viewLocFor: CurrentProject].	Display zoomIn: entering orOutTo: newDisplay at: 0@0			vanishingPoint: vanishingPoint.! !!Project methodsFor: 'displaying' stamp: 'ar 6/2/1999 01:58'!imageForm	^self imageFormOfSize: Display extent		depth: (displayDepth ifNil:[Display depth])! !!Project methodsFor: 'displaying' stamp: 'BG 10/29/2003 08:31'!imageFormOfSize: extentPoint depth: d	| newDisplay |	newDisplay _ DisplayScreen extent: extentPoint depth: d.	Display replacedBy: newDisplay do:[		world restore. "MVC"	].	^newDisplay! !!Project methodsFor: 'displaying' stamp: 'sw 1/12/2000 18:44'!showZoom	"Decide if user wants a zoom transition, and if there is enough memory to do it."	^ Preferences projectZoom and:		"Only show zoom if there is room for both displays plus a megabyte"		[Smalltalk garbageCollectMost > 						(Display boundingBox area*displayDepth //8+1000000)]! !!Project methodsFor: 'isolation layers' stamp: 'di 4/1/2000 09:22'!compileAll: newClass from: oldClass	"Make sure that shadowed methods in isolation layers get recompiled.	Traversal is done elsewhere.  This simply handles the current project."	isolatedHead == true ifFalse: [^ self].   "only isolated projects need to act on this."		changeSet compileAll: newClass from: oldClass! !!Project methodsFor: 'isolation layers' stamp: 'RAA 9/27/2000 18:53'!compileAllIsolated: newClass from: oldClass	"Whenever a recompile is needed in a class, look in other isolated projects for saved methods and recompile them also.	At the time this method is called, the recompilation has already been done for the project now in force."	Project allProjects do: [:proj | proj compileAll: newClass from: oldClass].! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:04'!invoke	"Install all methods changed here into method dictionaries.	Make my versions be the ones that will be called."	isolatedHead ifFalse: [^ self error: 'This isnt an isolation layer.'].	inForce ifTrue: [^ self error: 'This layer is already in force.'].	changeSet invoke.		inForce _ true.! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 15:49'!invokeFrom: otherProject	"Revoke the changes in force for this project, and then invoke those in force for otherProject.  This method shortens the process to the shortest path up then down through the isolation layers."	| pathUp pathDown |	pathUp _ otherProject layersToTop.  "Full paths to top"	pathDown _ self layersToTop.	"Shorten paths to nearest common ancestor"	[pathUp isEmpty not		and: [pathDown isEmpty not		and: [pathUp last == pathDown last]]]		whileTrue: [pathUp removeLast.  pathDown removeLast].	"Now revoke changes up from otherProject and invoke down to self."	pathUp do: [:p | p revoke].	pathDown reverseDo: [:p | p invoke].! !!Project methodsFor: 'isolation layers' stamp: 'di 4/4/2000 21:10'!isolationHead	"Go up the parent chain and find the nearest isolated project."	isolatedHead == true ifTrue: [^ self].	self isTopProject ifTrue: [^ nil].	^ parentProject isolationHead! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 17:00'!isolationSet	"Return the changeSet for this isolation layer or nil"	isolatedHead == true ifTrue: [^ changeSet].	self isTopProject ifTrue: [^ nil].  "At the top, but not isolated"	^ parentProject isolationSet! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 15:40'!layersToTop	"Return an OrderedCollection of all the projects that are isolation layers from this one up to the top of the project hierarchy, inclusive."	| layers |	self isTopProject		ifTrue: [layers _ OrderedCollection new]		ifFalse: [layers _ parentProject layersToTop].	isolatedHead ifTrue: [layers addFirst: self].	^ layers! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:06'!revoke	"Take back all methods changed here.	Install the original method dictionaries and organizations.	The orignal method versions will now be the ones used."	isolatedHead ifFalse: [^ self error: 'This isnt an isolation layer.'].	inForce ifFalse: [^ self error: 'This layer should have been in force.'].	changeSet revoke.		inForce _ false.! !!Project methodsFor: 'OBSOLETE' stamp: 'RAA 6/3/2000 19:01'!obsolete	self flag: #obsolete.	"instance variable 		exitFlag is no longer used		activeProcess is on the way out	"! !!Project methodsFor: 'resources' stamp: 'ar 3/2/2001 17:25'!abortResourceLoading	"Abort loading resources"	resourceManager ifNil:[^self].	resourceManager stopDownload.! !!Project methodsFor: 'active process' stamp: 'jla 4/2/2001 15:12'!depth	"Return the depth of this project from the top.	 topProject = 0, next = 1, etc."	"Project current depth."	| depth topProject project |	depth _ 0.	topProject _ Project topProject.	project _ self.		[project ~= topProject]		whileTrue:			[project _ project parent.			depth _ depth + 1].	^ depth! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Project class	instanceVariableNames: ''!!Project class methodsFor: 'class initialization' stamp: 'RAA 6/3/2000 18:50'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		Project spawnNewProcessAndTerminateOld: true].	"Project initialize"! !!Project class methodsFor: 'class initialization' stamp: 'RAA 12/17/2000 12:37'!rebuildAllProjects	"Project rebuildAllProjects"	AllProjects _ nil.	self allProjects.! !!Project class methodsFor: 'instance creation' stamp: 'RAA 11/16/2000 12:07'!new	| new |	new _ super new.	new setProjectHolder: CurrentProject.	self addingProject: new.	^new! !!Project class methodsFor: 'instance creation' stamp: 'RAA 9/27/2000 13:41'!uiProcess	^ UIProcess! !!Project class methodsFor: 'utilities' stamp: 'ssa 9/3/2008 11:11'!addItem: item toMenu: menu selection: action project: aProject	menu add: item action: action! !!Project class methodsFor: 'utilities' stamp: 'RAA 11/16/2000 12:04'!addingProject: newProject	(self allProjects includes: newProject) ifTrue: [^self].	AllProjects _ self allProjects copyWith: newProject.! !!Project class methodsFor: 'utilities' stamp: 'di 6/10/1999 11:30'!allNamesAndProjects	^ (self allProjects asSortedCollection: [:p1 :p2 | p1 name asLowercase < p2 name asLowercase]) collect:		[:aProject | Array with: aProject name with: aProject]! !!Project class methodsFor: 'utilities' stamp: 'RAA 11/13/2000 17:14'!allProjects	^AllProjects ifNil: [		Smalltalk garbageCollect.		AllProjects _ self allSubInstances select: [:p | p name notNil].	].! !!Project class methodsFor: 'utilities' stamp: 'jla 5/28/2001 21:48'!allProjectsOrdered	"Answer a list of all projects in hierarchical order, depth first"		| allProjects  |	allProjects _ OrderedCollection new.	Project topProject withChildrenDo:		[:p | allProjects add: p].	^ allProjects"Project allProjectsOrdered"! !!Project class methodsFor: 'utilities' stamp: 'sw 11/24/2002 10:57'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, alphabetically or hierarchically"	| prev listed i next  toAdd |	listed _ OrderedCollection with: CurrentProject.	i _ 0.	"The previous Project chain"	prev _ CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:	  [i _ i + 1.		listed add: prev.		self 	addItem: prev name , ' (back ' , i printString , ')'				toMenu: menu 				selection: ('%back' , i printString) 				project: prev.		prev _ prev previousProject].	i > 0 ifTrue: [menu addLine].	"Then the next Project"	(((next _ CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self	addItem: (next name, ' (forward 1)') 				toMenu: menu 				selection: next name 				project: next]. 	next ~~ nil ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self	addItem: CurrentProject parent name , ' (parent)' 				toMenu: menu 				selection: #parent 				project: CurrentProject parent.		  menu addLine].	"Finally all the projects, in hierarchical or alphabetical order:"	(Preferences alphabeticalProjectMenu			ifTrue:				[Project allNamesAndProjects]			ifFalse:				[Project hierarchyOfNamesAndProjects]) do:		[:aPair | 			toAdd _ aPair last isCurrentProject				ifTrue:				  [aPair first, ' (current)']				ifFalse:				  [aPair first].			self	addItem: toAdd 				toMenu: menu 				selection: aPair first 				project: aPair last].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'BG 10/29/2003 09:18'!deletingProject: outgoingProject		Project allProjects do: [:p | p deletingProject: outgoingProject].	"ones that are in"		AllProjects _ self allProjects copyWithout: outgoingProject.! !!Project class methodsFor: 'utilities' stamp: 'RAA 12/26/2000 12:42'!forget: aProject	AllProjects _ self allProjects reject: [ :x | x == aProject].! !!Project class methodsFor: 'utilities' stamp: 'jla 5/28/2001 21:43'!hierarchyOfNamesAndProjects	"Answer a list of all project names, with each entry preceded by white space commensurate with its depth beneath the top project"		^ self allProjectsOrdered collect:		[:project | Array with: project nameAdjustedForDepth with: project]! !!Project class methodsFor: 'utilities' stamp: 'BG 10/28/2003 21:04'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."		Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].! !!Project class methodsFor: 'utilities' stamp: 'jla 4/2/2001 20:34'!jumpToProject		"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUpLeftFlush! !!Project class methodsFor: 'utilities' stamp: 'jla 4/2/2001 15:57'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."		"Project jumpToProject"	| nBack prev pr |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack _ (selection copyFrom: 6 to: selection size) asNumber.		prev _ CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev _ prev previousProject]].		prev ifNotNil: [prev enter: true revert: false saveForRevert: false]].	selection = #parent ifTrue:		[CurrentProject parent enter: false revert: false saveForRevert: false.		^ self].	(pr _ Project namedWithDepth: selection) ifNil: [^ self].	pr enter: false revert: false saveForRevert: false! !!Project class methodsFor: 'utilities' stamp: 'tk 3/10/2000 21:10'!named: projName	"Answer the project with the given name, or nil if there is no project of that given name."	"(Project named: 'New Changes') enter"	^ self allProjects		detect: [:proj | proj name = projName]		ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'jla 4/2/2001 15:57'!namedWithDepth: projName	"Answer the project with the given name, or nil if there is no project of that given name."	"(Project named: 'New Changes') enter"	^ self allProjects		detect: [:proj | 			  proj name = projName or:				[proj nameAdjustedForDepth = projName]]		ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:28'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	UIProcess _ aProcess.	UIProcess resume! !!Project class methodsFor: 'utilities' stamp: 'tk 10/26/1999 14:25'!returnToPreviousProject	"Return to the project from which this project was entered. Do nothing if the current project has no link to its previous project."	| prevProj |	prevProj _ CurrentProject previousProject.	prevProj ifNotNil: [prevProj enter: true revert: false saveForRevert: false].! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:49'!spawnNewProcess	UIProcess _ [		[World doOneCycle.  Processor yield.  false] whileFalse: [].	] newProcess priority: Processor userSchedulingPriority.	UIProcess resume! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:49'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'utilities' stamp: 'RAA 9/27/2000 19:00'!topProject	"Answer the top project.  There is only one"	^ self allProjects detect: [:p | p isTopProject]! !!Project class methodsFor: 'utilities' stamp: 'mir 6/21/2001 15:44'!versionForFileName: version	"Project versionForFileName: 7"	| v |	^String streamContents:[:s|		v _ version printString.		v size < 3 ifTrue:[v _ '0', v].		v size < 3 ifTrue:[v _ '0', v].		s nextPutAll: v.	]! !!Project class methodsFor: 'constants'!current	"Answer the project that is currently being used."	^CurrentProject! !!Project class methodsFor: 'squeaklet on server' stamp: 'ar 2/27/2001 13:43'!projectExtension	^'pr'! !StandardSystemController subclass: #ProjectController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!ProjectController methodsFor: 'control activity' stamp: 'tk 10/26/1999 14:26'!redButtonActivity	| index |	view isCollapsed ifTrue: [^ super redButtonActivity].	(view insetDisplayBox containsPoint: Sensor cursorPoint)		ifFalse: [^ super redButtonActivity].	index _ (PopUpMenu labelArray: #('enter' 'jump to project...') lines: #()) 		startUpCenteredWithCaption: nil.	index = 0 ifTrue: [^ self].	"save size on enter for thumbnail on exit"	model setViewSize: view insetDisplayBox extent.	index = 1 ifTrue: [^ model enter: false revert: false saveForRevert: false].	index = 2 ifTrue: [Project jumpToProject. ^ self].! !Model subclass: #ProjectHistory	instanceVariableNames: 'mostRecent'	classVariableNames: 'ChangeCounter CurrentHistory'	poolDictionaries: ''	category: 'System-Support'!!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:57'!changed	ChangeCounter _ (ChangeCounter ifNil: [0]) + 1.	super changed.! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 20:27'!forget: aProject	| newTuple |	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.	mostRecent _ mostRecent reject: [ :each |		each fourth first == aProject or: [			each fourth first isNil & (each first = newTuple first)		].	].	self changed.	^newTuple! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:27'!initialize	mostRecent _ OrderedCollection new.! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:17'!remember: aProject	| newTuple |	newTuple _ self forget: aProject.	mostRecent addFirst: newTuple.	mostRecent size > 10 ifTrue: [mostRecent _ mostRecent copyFrom: 1 to: 10].	self changed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProjectHistory class	instanceVariableNames: ''!!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:27'!currentHistory	^CurrentHistory ifNil: [CurrentHistory _ self new initialize].! !!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:16'!forget: aProject	self currentHistory forget: aProject! !!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:31'!remember: aProject	self currentHistory remember: aProject! !StandardSystemView subclass: #ProjectView	instanceVariableNames: ''	classVariableNames: 'ArmsLengthCmd'	poolDictionaries: ''	category: 'ST80-Support'!!ProjectView methodsFor: 'initialization'!defaultControllerClass	^ ProjectController! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!maybeRelabel: newLabel	"If the change set name given by newLabel is already in use, do nothing; else relabel the view"	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [^ self].	self relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'di 5/6/1998 17:03'!relabel: newLabel	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ self].	model projectChangeSet name: newLabel.	super relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'sw 1/11/2000 15:30'!uncacheBits	super uncacheBits.	self label ~=  model name ifTrue: [self setLabelTo: model name]! !!ProjectView methodsFor: 'displaying' stamp: 'tk 4/19/2000 17:15'!armsLengthCommand: aCommand	"Set up a save to be done after the subproject exits to here.  displayOn: checks it."	ArmsLengthCmd _ aCommand.! !!ProjectView methodsFor: 'displaying'!cacheBitsAsTwoTone	^ false! !!ProjectView methodsFor: 'displaying' stamp: 'tk 6/21/2000 16:22'!displayDeEmphasized	| cmd |	"Display this view with emphasis off.  Check for a command thatcould not be executed in my subproject.  Once it is done, remove thetrigger."	super displayDeEmphasized.	ArmsLengthCmd ifNil: [^ self].	ArmsLengthCmd first == model ifFalse: [^ self].	"not ours"	cmd _ ArmsLengthCmd second.	ArmsLengthCmd _ nil.	model "project" perform: cmd.	model "project" enter.! !!ProjectView methodsFor: 'displaying' stamp: 'sw 1/11/2000 15:32'!displayView	super displayView.	self label = model name		ifFalse: [self setLabelTo: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectView methodsFor: 'displaying' stamp: 'sw 9/14/1998 13:01'!release	super release.	Smalltalk garbageCollect! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProjectView class	instanceVariableNames: ''!!ProjectView class methodsFor: 'as yet unclassified'!open: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView controller open! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 10:35'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on 	the display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView world: nil).	ScheduledControllers schedulePassive: topView controller.	aProject		enter: false		revert: false		saveForRevert: false! !ProtoObject subclass: #ProtoObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'.ProtoObject superclass: nil!!ProtoObject commentStamp: '<historical>' prior: 0!ProtoObject establishes minimal behavior required of any object in Squeak, even objects that should balk at normal object behavior. Generally these are proxy objects designed to read themselves in from the disk, or to perform some wrapper behavior, before responding to a message. Current examples are ObjectOut and ImageSegmentRootStub, and one could argue that ObjectTracer should also inherit from this class.ProtoObject has no instance variables, nor should any be added.!!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:23'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:25'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:25'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:25'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock value! !!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:57'!isInMemory	"All normal objects are."	^ true! !!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:26'!isNil	"Coerces nil to true and everything else to false."	^false! !!ProtoObject methodsFor: 'testing' stamp: 'md 11/24/1999 19:58'!pointsTo: anObject	"This method returns true if self contains a pointer to anObject,		and returns false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!ProtoObject methodsFor: 'comparing' stamp: 'md 11/24/1999 19:27'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!ProtoObject methodsFor: 'comparing' stamp: 'md 11/24/1999 19:27'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!ProtoObject methodsFor: 'comparing' stamp: 'md 11/24/1999 19:27'!~~ anObject	"Answer whether the receiver and the argument are not the same object 	(do not have the same object pointer)."	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!ProtoObject methodsFor: 'system primitives' stamp: 'md 11/24/1999 19:30'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!ProtoObject methodsFor: 'system primitives' stamp: 'ajh 1/13/2002 17:02'!cannotInterpret: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but a null methodDictionary was encountered while looking up the message selector.  Hopefully this is the result of encountering a stub for a swapped out class which induces this exception on purpose.""If this is the result of encountering a swap-out stub, then simulating the lookup in Smalltalk should suffice to install the class properly, and the message may be resent."	(self class lookupSelector: aMessage selector) == nil ifFalse:		["Simulated lookup succeeded -- resend the message."		^ aMessage sentTo: self].	"Could not recover by simulated lookup -- it's an error"	Error signal: 'MethodDictionary fault'.	"Try again in case an error handler fixed things"	^ aMessage sentTo: self! !!ProtoObject methodsFor: 'system primitives' stamp: 'ajh 10/9/2001 17:20'!doesNotUnderstand: aMessage	^ MessageNotUnderstood new 		message: aMessage;		receiver: self;		signal! !!ProtoObject methodsFor: 'system primitives' stamp: 'md 11/24/1999 19:58'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!ProtoObject methodsFor: 'system primitives' stamp: 'md 11/24/1999 19:58'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!ProtoObject methodsFor: 'objects from disk' stamp: 'md 11/24/1999 20:03'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!ProtoObject methodsFor: 'debugging' stamp: 'sw 10/26/2000 14:29'!doOnlyOnce: aBlock	"If the 'one-shot' mechanism is armed, evaluate aBlock once and disarm the one-shot mechanism.  To rearm the mechanism, evaluate  'self rearmOneShot' manually."	(Smalltalk at: #OneShotArmed ifAbsent: [true])		ifTrue:			[Smalltalk at: #OneShotArmed put: false.			aBlock value]! !!ProtoObject methodsFor: 'debugging' stamp: 'sw 4/28/2000 14:41'!flag: aSymbol	"Send this message, with a relevant symbol as argument, to flag a message for subsequent retrieval.  For example, you might put the following line in a number of messages:	self flag: #returnHereUrgently	Then, to retrieve all such messages, browse all senders of #returnHereUrgently."! !!ProtoObject methodsFor: 'initialize-release' stamp: 'md 11/18/2003 10:33'!initialize	"Subclasses should redefine this method to perform initializations on instance creation"! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:20'!tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:20'!tryNamedPrimitive: arg1	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:20'!tryNamedPrimitive: arg1 with: arg2	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:20'!tryNamedPrimitive: arg1 with: arg2 with: arg3	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:20'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:21'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:21'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:21'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:21'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!ProtoObject methodsFor: 'apply primitives' stamp: 'ajh 1/31/2003 22:21'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118>	^ ContextPart primitiveFailToken! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProtoObject class	instanceVariableNames: ''!!ProtoObject class methodsFor: 'as yet unclassified' stamp: 'sw 5/5/2000 09:31'!initializedInstance	^ nil! !MessageSet subclass: #ProtocolBrowser	instanceVariableNames: 'selectedClass selectedSelector'	classVariableNames: 'TextMenu'	poolDictionaries: ''	category: 'Tools-Browser'!!ProtocolBrowser commentStamp: '<historical>' prior: 0!An instance of ProtocolBrowser shows the methods a class understands--inherited or implemented at this level--as a "flattened" list.!!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!getList	"Answer the receiver's message list."	^ messageList! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'sw 1/28/2001 21:01'!growable	"Answer whether the receiver is subject to manual additions and deletions"	^ false! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!list	"Answer the receiver's message list."	^ messageList! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector	"Answer the receiver's selected selector."	^ selectedSelector! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString.	self changed: #selector! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!setSelector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString! !!ProtocolBrowser methodsFor: 'private' stamp: 'nk 8/18/2001 18:16'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface."	| defClass item |	messageList := OrderedCollection new.	selectorCollection do: [ :selector |  		defClass := aClass whichClassIncludesSelector: selector.		item _ selector, '     (' , defClass name , ')'.		defClass == aClass ifTrue: [item _ item asText allBold].		messageList add: (			MethodReference new				setClass: defClass 				methodSymbol: selector 				stringVersion: item		)	].	selectedClass _ aClass.! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:26'!on: aClass 	"Initialize with the entire protocol for the class, aClass."	self initListFrom: aClass allSelectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 11/26/1999 19:39'!onSubProtocolOf: aClass 	"Initialize with the entire protocol for the class, aClass,		but excluding those inherited from Object."	| selectors |	selectors := Set new.	aClass withAllSuperclasses do:		[:each | (each == Object or: [each == ProtoObject]) 			ifFalse: [selectors addAll: each selectors]].	self initListFrom: selectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser methodsFor: 'private' stamp: 'RAA 5/28/2001 11:07'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])"	| i classAndSelString selString sel |	sel _ self selection ifNil: [^ csBlock value: nil value: nil].	(sel isKindOf: MethodReference) ifTrue: [		sel setClassAndSelectorIn: csBlock	] ifFalse: [		selString _ sel asString.		i _ selString indexOf: $(.		"Rearrange to  <className> [class] <selectorName> , and use MessageSet"		classAndSelString _ (selString copyFrom: i + 1 to: selString size - 1) , ' ' ,							(selString copyFrom: 1 to: i - 1) withoutTrailingBlanks.		MessageSet parse: classAndSelString toClassAndSelector: csBlock.	].! !!ProtocolBrowser methodsFor: 'class list' stamp: 'nk 4/10/2001 08:16'!selectedClassOrMetaClass	^selectedClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProtocolBrowser class	instanceVariableNames: ''!!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openFullProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openFullProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new on: aClass.	label := 'Entire protocol of: ', aClass name.	self open: aPBrowser name: label! !!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openSubProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.	label := 'Sub-protocol of: ', aClass name.	self open: aPBrowser name: label! !Object subclass: #PseudoClass	instanceVariableNames: 'name definition organization source metaClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!PseudoClass commentStamp: '<historical>' prior: 0!I provide an inert model of a Class, used by FileContentsBrowser to manipulate filedout code. Instead of a method dictionary or selectors onto CompiledMethods, I have a dictionary ("source") of selectors onto ChangeRecords, which were, in the case of FileContentsBrowser, parsed from a source or change set file.!!PseudoClass methodsFor: 'class'!classComment: aChangeRecord	self organization classComment: aChangeRecord! !!PseudoClass methodsFor: 'class' stamp: 'di 1/13/1999 12:00'!classPool 	self exists ifFalse: [^ nil].	^ self realClass classPool! !!PseudoClass methodsFor: 'class' stamp: 'BJP 4/23/2001 13:50'!comment	| rStr |	rStr := self organization commentRemoteStr.	^rStr isNil		ifTrue:[self name,' has not been commented in this file']		ifFalse:[rStr string]! !!PseudoClass methodsFor: 'class'!comment: aString	self commentString: aString.! !!PseudoClass methodsFor: 'class' stamp: 'ar 2/5/2004 15:18'!commentString	^self comment asString! !!PseudoClass methodsFor: 'class'!commentString: aString	self classComment: aString asText. "Just wrap it"! !!PseudoClass methodsFor: 'class' stamp: 'LC 10/8/2001 04:46'!definition	| link linkText defText |	^definition ifNil:		[defText _ Text fromString: 'There is no class definition for '.		link _ TextLink new.		linkText _ link analyze: self name with: 'Definition'.		linkText _ Text string: (linkText ifNil: ['']) attribute: link.		defText append: linkText; append: ' in this file'].! !!PseudoClass methodsFor: 'class'!definition: aString	definition := aString! !!PseudoClass methodsFor: 'class'!metaClass	^metaClass ifNil:[metaClass := PseudoMetaclass new name: (self name)].! !!PseudoClass methodsFor: 'class' stamp: 'nk 2/18/2004 18:30'!renameTo: aString	self hasDefinition ifTrue:[		self isMeta ifTrue:[			self definition: (self definition				copyReplaceAll: name,' class'				with: aString, ' class').		] ifFalse:[			self definition: (self definition 					copyReplaceAll:'ubclass: #',name					with:'ubclass: #', aString)]].	name := aString.	metaClass ifNotNil:[metaClass renameTo: aString].! !!PseudoClass methodsFor: 'class' stamp: 'di 1/13/1999 12:00'!sharedPools 	self exists ifFalse: [^ nil].	^ self realClass sharedPools! !!PseudoClass methodsFor: 'accessing' stamp: 'nk 4/29/2004 06:59'!allCallsOn	^ (self realClass ifNil: [ ^#() ]) allCallsOn! !!PseudoClass methodsFor: 'accessing' stamp: 'sma 6/16/1999 22:59'!allInstVarNames	^#()! !!PseudoClass methodsFor: 'accessing' stamp: 'nk 2/18/2004 18:32'!allSuperclasses	^ (self realClass ifNil: [ ^#() ]) allSuperclasses! !!PseudoClass methodsFor: 'accessing' stamp: 'sma 4/28/2000 17:24'!compilerClass	^ (Smalltalk at: name ifAbsent: [^ Compiler]) compilerClass! !!PseudoClass methodsFor: 'accessing'!fullName	^self name! !!PseudoClass methodsFor: 'accessing' stamp: 'nk 3/9/2004 10:24'!instVarNames	^ #()! !!PseudoClass methodsFor: 'accessing'!name	^name! !!PseudoClass methodsFor: 'accessing'!name: anObject	name _ anObject! !!PseudoClass methodsFor: 'accessing' stamp: 'NS 4/6/2004 15:46'!organization	organization ifNil: [organization _ PseudoClassOrganizer defaultList: SortedCollection new].	"Making sure that subject is set correctly. It should not be necessary."	organization setSubject: self.	^ organization! !!PseudoClass methodsFor: 'accessing' stamp: 'nk 2/18/2004 18:32'!realClass	^Smalltalk at: self name asSymbol ifAbsent: []! !!PseudoClass methodsFor: 'accessing' stamp: 'wod 5/19/1998 17:42'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self! !!PseudoClass methodsFor: 'removing'!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass isNil ifFalse:[metaClass removeAllUnmodified].! !!PseudoClass methodsFor: 'removing'!removeUnmodifiedMethods: aCollection	| stClass |	self exists ifFalse:[^self].	stClass := self realClass.	aCollection do:[:sel|		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asString ifTrue:[			self removeMethod: sel.		].	].	self organization removeEmptyCategories.! !!PseudoClass methodsFor: 'private' stamp: 'nk 2/18/2004 18:33'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level	^ (self realClass ifNil: [ ^self ])  allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level! !!PseudoClass methodsFor: 'private'!confirmRemovalOf: aString	^self confirm:'Remove ',aString,' ?'! !!PseudoClass methodsFor: 'private'!evaluate: aString	^Compiler evaluate: aString for: nil logged: true! !!PseudoClass methodsFor: 'private'!makeSureSuperClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: 'The super class ',aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private' stamp: 'ajh 1/21/2003 13:03'!parserClass	^ Compiler parserClass! !!PseudoClass methodsFor: 'testing'!exists	^(Smalltalk at: self name asSymbol ifAbsent:[^false]) isKindOf: Behavior! !!PseudoClass methodsFor: 'testing'!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition isNil ifFalse:[^true].	metaClass isNil ifFalse:[^metaClass hasChanges].	^false! !!PseudoClass methodsFor: 'testing'!hasComment	^self organization commentRemoteStr notNil! !!PseudoClass methodsFor: 'testing'!hasDefinition	^definition notNil! !!PseudoClass methodsFor: 'testing'!hasMetaclass	^metaClass notNil! !!PseudoClass methodsFor: 'testing' stamp: 'nk 2/18/2004 18:30'!isMeta	^false! !!PseudoClass methodsFor: 'testing'!needsInitialize	^self hasMetaclass and:[		self metaClass selectors includes: #initialize]! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileIn	"FileIn the receiver"	self hasDefinition ifTrue:[self fileInDefinition].	self fileInMethods: self selectors.	metaClass ifNotNil:[metaClass fileIn].	self needsInitialize ifTrue:[		self evaluate: self name,' initialize'.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInCategory: aCategory	^self fileInMethods: (self organization listAtCategoryNamed: aCategory)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInDefinition	(self makeSureSuperClassExists: (definition copyUpTo: Character space)) ifFalse:[^self].	self hasDefinition ifTrue:[		Transcript cr; show:'Defining ', self name.		self evaluate: self definition].	self exists ifFalse:[^self].	self hasComment ifTrue:[self realClass classComment: self comment].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethod: selector	^self fileInMethods: (Array with: selector)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods	^self fileInMethods: self selectors! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods: aCollection	"FileIn all methods with selectors taken from aCollection"	| theClass cat |	self exists ifFalse:[^self classNotDefined].	theClass := self realClass.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			theClass 				compile: (self sourceCodeAt: sel) 				classified: cat				withStamp: (self stampAt: sel)				notifying: nil.		].	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOut	| f |	f := (FileStream newFileNamed: self name,'.st').	self fileOutOn: f.	self needsInitialize ifTrue:[		f cr; nextChunkPut: self name,' initialize'.	].	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutCategory: categoryName	| f |	f := (FileStream newFileNamed: self name,'-',categoryName,'.st').	self fileOutMethods: (self organization listAtCategoryNamed: categoryName)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'hg 9/6/2000 12:45'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment		ifTrue:			[aStream cr.			self organization commentRemoteStr fileOutOn:aStream]! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethod: selector	| f |	f := (FileStream newFileNamed: self name,'-', selector, '.st').	self fileOutMethods: (Array with: selector)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'ar 2/7/2004 01:04'!fileOutMethods: aCollection on: aStream	"FileOut all methods with selectors taken from aCollection"	| cat categories |	categories := Dictionary new.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			(categories includesKey: cat) 				ifFalse:[categories at: cat put: Set new].			(categories at: cat) add: sel].	].	categories associationsDo:[:assoc|		cat := assoc key.		assoc value do:[:sel|			aStream cr.			(self sourceCode at: sel) fileOutOn: aStream.		].	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethodsOn: aStream	^self fileOutMethods: self selectors on: aStream.! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutOn: aStream	"FileOut the receiver"	self fileOutDefinitionOn: aStream.	metaClass ifNotNil:[metaClass fileOutDefinitionOn: aStream].	self fileOutMethods: self selectors on: aStream.	metaClass ifNotNil:[metaClass fileOutMethods: metaClass selectors on: aStream].! !!PseudoClass methodsFor: 'errors'!classNotDefined	^self inform: self name,' is not defined in the system.You have to define this class first.'.! !!PseudoClass methodsFor: 'categories'!removeCategory: selector	(self organization listAtCategoryNamed: selector) do:[:sel|		self organization removeElement: sel.		self sourceCode removeKey: sel.	].	self organization removeCategory: selector.! !!PseudoClass methodsFor: 'categories'!removedCategoryName	^'*** removed methods ***' asSymbol! !!PseudoClass methodsFor: 'categories'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	^ self organization categoryOfElement: aSelector! !!PseudoClass methodsFor: 'methods' stamp: 'sma 6/1/2000 14:54'!addMethodChange: aChangeRecord	| selector |	selector _ self parserClass new parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!PseudoClass methodsFor: 'methods'!methodChange: aChangeRecord	aChangeRecord isMetaClassChange ifTrue:[		^self metaClass addMethodChange: aChangeRecord.	] ifFalse:[		^self addMethodChange: aChangeRecord.	].! !!PseudoClass methodsFor: 'methods'!removeMethod: selector	self organization removeElement: selector.	self sourceCode removeKey: selector.! !!PseudoClass methodsFor: 'methods'!removeSelector: aSelector	| catName |	catName := self removedCategoryName.	self organization addCategory: catName before: self organization categories first.	self organization classify: aSelector under: catName.	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !!PseudoClass methodsFor: 'methods'!selectors	^self sourceCode keys! !!PseudoClass methodsFor: 'methods'!sourceCode	^source ifNil:[source := Dictionary new]! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel	^(self sourceCode at: sel) string! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel put: object	self sourceCode at: sel put: object! !!PseudoClass methodsFor: 'methods'!sourceCodeTemplate	^''! !!PseudoClass methodsFor: 'methods'!stampAt: selector	^(self sourceCode at: selector) stamp! !!PseudoClass methodsFor: 'printing' stamp: 'sma 6/17/1999 00:00'!literalScannedAs: scannedLiteral notifying: requestor 	^ scannedLiteral! !!PseudoClass methodsFor: 'printing' stamp: 'ar 2/5/2004 16:04'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; print: name; nextPut:$)! !!PseudoClass methodsFor: 'testing method dictionary' stamp: 'ar 5/17/2003 14:06'!bindingOf: varName	self exists ifTrue:[		(self realClass bindingOf: varName) ifNotNilDo:[:binding| ^binding].	].	^Smalltalk bindingOf: varName asSymbol! !BasicClassOrganizer subclass: #PseudoClassOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!PseudoClassOrganizer methodsFor: 'comment accessing' stamp: 'NS 4/6/2004 16:44'!classComment	"Answer the comment associated with the object that refers to the receiver."	classComment == nil ifTrue: [^''].	^classComment! !!PseudoClassOrganizer methodsFor: 'comment accessing' stamp: 'NS 4/6/2004 16:44'!classComment: aChangeRecord	classComment := aChangeRecord! !!PseudoClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/6/2004 12:27'!setDefaultList: aCollection	super setDefaultList: aCollection.	self classComment: nil.! !ProtoObject variableSubclass: #PseudoContext	instanceVariableNames: 'fixed fields never accessed from smalltalk'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'.PseudoContext superclass: nil!!PseudoContext commentStamp: '<historical>' prior: 0!I represent cached context state within the virtual machine.  I have the same format as normal method and block contexts, but my fields are never referenced directly from Smalltalk.  Whenever a message is sent to me I will magically transform myself into a real context which will respond to all the usual messages.	I rely on the fact that block and method contexts have exactly the same number of fixed fields.!!PseudoContext methodsFor: 'testing' stamp: 'ikp 9/26/97 14:45'!isPseudoContext	^true! !!PseudoContext methodsFor: 'system primitives' stamp: 'ikp 10/20/97 15:36'!nextObject	"See Object>>nextObject."	<primitive: 139>	self primitiveFailed.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PseudoContext class	instanceVariableNames: ''!!PseudoContext class methodsFor: 'class initialization' stamp: 'ikp 1/10/98 02:33'!initialize	"It's tricky to do the necessary stuff with the regular file-in machinery."	PseudoContext superclass = nil		ifFalse: [			(Smalltalk confirm: 'Shall I convert PseudoContext into a compact subclass of nil?("yes" is almost always the correct response)')				ifTrue: [					PseudoContext becomeCompact.					PseudoContext superclass removeSubclass: PseudoContext.					PseudoContext superclass: nil]].	Smalltalk recreateSpecialObjectsArray.	Smalltalk specialObjectsArray size = 41		ifFalse: [self error: 'Please check size of special objects array!!']! !!PseudoContext class methodsFor: 'filing out' stamp: 'ikp 9/26/97 14:45'!definition	"Our superclass is really nil, but this causes problems when we try to become compact	after filing in for the first time.  Fake the superclass as Object, and repair the situation	during class initialisation."	| defn |	defn _ super definition.	^(defn beginsWith: 'nil ')		ifTrue: ['Object' , (defn copyFrom: 4 to: defn size)]		ifFalse: [defn].! !PseudoClass subclass: #PseudoMetaclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!PseudoMetaclass methodsFor: 'accessing'!fullName	^self name,' class'! !!PseudoMetaclass methodsFor: 'accessing'!realClass	^super realClass class! !!PseudoMetaclass methodsFor: 'accessing' stamp: 'FBS 3/4/2004 14:17'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self realClass theNonMetaClass! !!PseudoMetaclass methodsFor: 'testing' stamp: 'nk 2/18/2004 18:30'!isMeta	^true! !Rectangle subclass: #Quadrangle	instanceVariableNames: 'borderWidth borderColor insideColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Quadrangle commentStamp: '<historical>' prior: 0!I represent a particular kind of Rectangle that has a border and inside color.!!Quadrangle methodsFor: 'initialize-release'!initialize	"Initialize the region to a null Rectangle, the borderWidth to 1, the 	borderColor to black, and the insideColor to white."	origin _ 0 @ 0.	corner _ 0 @ 0.	borderWidth _ 1.	borderColor _ Color black.	insideColor _ Color white.! !!Quadrangle methodsFor: 'bordering'!borderWidth	"Answer the borderWidth of the receiver."	^borderWidth! !!Quadrangle methodsFor: 'bordering'!borderWidth: anInteger 	"Set the borderWidth of the receiver to anInteger."	borderWidth _ anInteger! !!Quadrangle methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border width of the receiver to a Rectangle that represents the 	left, right, top, and bottom border widths."	borderWidth _ anInteger1 @ anInteger3 corner: anInteger2 @ anInteger4! !!Quadrangle methodsFor: 'bordering'!inside	"Answer a Rectangle that is the receiver inset by the borderWidth."	^self insetBy: borderWidth! !!Quadrangle methodsFor: 'bordering'!insideColor	"Answer the form that is the insideColor of the receiver."	^insideColor! !!Quadrangle methodsFor: 'bordering'!insideColor: aColor 	"Set the insideColor of the receiver to aColor, a Form."	insideColor _ aColor! !!Quadrangle methodsFor: 'bordering'!region	"Answer a Rectangle that defines the area of the receiver."	^origin corner: corner! !!Quadrangle methodsFor: 'bordering'!region: aRectangle 	"Set the rectangular area of the receiver to aRectangle."	origin _ aRectangle origin.	corner _ aRectangle corner! !!Quadrangle methodsFor: 'rectangle functions'!intersect: aRectangle 	"Answer a new Quadrangle whose region is the intersection of the 	receiver's area and aRectangle.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class	 	region: (super intersect: aRectangle)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Answer a new Quadrangle translated by aPoint2 - aPoint1.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super translateBy: aPoint2 - aPoint1)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!alignedTo: alignPointSelector	"Return a copy with offset according to alignPointSelector which is one of...	#(topLeft, topCenter, topRight, leftCenter, center, etc)	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super translateBy: (0@0) - (self perform: alignPointSelector))		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!scaleBy: aPoint 	"Answer a new Quadrangle scaled by aPoint.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super scaleBy: aPoint)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!translateBy: aPoint 	"Answer a new Quadrangle translated by aPoint.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super translateBy: aPoint)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium	"Display the border and insideRegion of the receiver."	borderWidth ~~ 0		ifTrue:	[aDisplayMedium				border: self region				widthRectangle: borderWidth				rule: Form over				fillColor: borderColor].	insideColor ~~ nil		ifTrue:	[aDisplayMedium fill: self inside fillColor: insideColor]! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle	"Display the border and region of the receiver so that it is scaled and 	translated with respect to aWindowingTransformation. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed."	| screenRectangle |	screenRectangle _ 		(aWindowingTransformation applyTo: self) intersect: aRectangle.	borderWidth ~~ 0 & (insideColor ~~ nil)		ifTrue: 			[aDisplayMedium fill: screenRectangle fillColor: Color black "borderColor".			aDisplayMedium				fill: (screenRectangle insetBy: borderWidth)				fillColor: insideColor]! !!Quadrangle methodsFor: 'displaying-generic'!displayOnPort: aPort at: p	"Display the border and insideRegion of the receiver."	(insideColor == nil or: [borderWidth <= 0])		ifFalse: [aPort fill: (self region translateBy: p) 			fillColor: borderColor rule: Form over].	insideColor == nil		ifFalse: [aPort fill: (self inside translateBy: p) 			fillColor: insideColor rule: Form over]! !!Quadrangle methodsFor: 'displaying-Display'!display 	"Display the border and insideRegion of the receiver on the Display."	self displayOn: Display! !!Quadrangle methodsFor: 'private'!setRegion: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	origin _ aRectangle origin.	corner _ aRectangle corner.	borderWidth _ anInteger.	borderColor _ aMask1.	insideColor _ aMask2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quadrangle class	instanceVariableNames: ''!!Quadrangle class methodsFor: 'instance creation'!region: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	"Answer an instance of me with rectangle, border width and color, and 	inside color determined by the arguments."	^super new		setRegion: aRectangle		borderWidth: anInteger		borderColor: aMask1		insideColor: aMask2! !ReadWriteStream subclass: #RWBinaryOrTextStream	instanceVariableNames: 'isBinary'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!RWBinaryOrTextStream commentStamp: '<historical>' prior: 0!A simulation of a FileStream, but living totally in memory.  Hold the contents of a file or web page from the network.  Can then fileIn like a normal FileStream.Need to be able to switch between binary and text, as a FileStream does, without recopying the whole collection.  Convert to binary upon input and output.  Always keep as text internally.!!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/25/97 13:22'!ascii	isBinary _ false! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:46'!binary	isBinary _ true! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/21/97 12:49'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	isBinary ifFalse: [^ super contents].	"String"	readLimit _ readLimit max: position.	newArray _ ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 08:25'!contentsOfEntireFile	"For compatibility with file streams."	^ self contents! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:47'!isBinary	^ isBinary! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 12/13/97 13:07'!next	| byte |	^ isBinary 			ifTrue: [byte _ super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 2/7/2000 15:34'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray _ (isBinary ifTrue: [ByteArray] ifFalse: [String]) new: anInteger.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 22:24'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max _ (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position _ position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 07:38'!nextPut: charOrByte	super nextPut: charOrByte asCharacter! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/21/97 13:04'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary _ false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection _ collection asString.		isBinary _ true].! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:47'!text	isBinary _ false! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ar 3/5/2001 12:12'!upToEnd	"Must override to get class right."	| newArray |	newArray _ (isBinary ifTrue: [ByteArray] ifFalse: [String]) new: self size - self position.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'ar 8/12/2003 16:54'!nextPutAll: aCollection	^super nextPutAll: aCollection asString! !Object subclass: #Random	instanceVariableNames: 'seed a m q r'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Random commentStamp: 'md 4/26/2003 16:32' prior: 0!This Random Number Generator graciously contributed by David N. Smith.  It is an adaptation of the Park-Miller RNG which uses Floats to avoid the need for LargeInteger arithmetic.If you just want a quick random integer, use:		10 atRandomEvery integer interval can give a random number:		(6 to: 12) atRandomSequenceableCollections can give randomly selected elements:		'pick one of these letters randomly' atRandomSequenceableCollections also respond to shuffled, as in:		($A to: $Z) shuffledThe correct way to use class Random is to store one in an instance or class variable:		myGenerator _ Random new.Then use it every time you need another number between 0.0 and 1.0 (excluding)		myGenerator nextYou can also generate a positive integer		myGenerator nextInt: 10!!Random methodsFor: 'initialization' stamp: 'di 8/6/1999 15:32'!initialize	" Set a reasonable Park-Miller starting seed "	[seed := (Time millisecondClockValue bitAnd: 16r3FFFFFFF) bitXor: self hash.	seed = 0] whileTrue: ["Try again if ever get a seed = 0"].	a := 16r000041A7 asFloat.    " magic constant =      16807 "	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 "	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:25'!next	"Answer a random Float in the interval [0 to 1)."	^ (seed _ self nextValue) / m! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:45'!next: anInteger	^ self next: anInteger into: (Array new: anInteger)! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:46'!next: anInteger into: anArray	1 to: anInteger do: [:index | anArray at: index put: self next].	^ anArray! !!Random methodsFor: 'accessing' stamp: 'dns 8/26/2001 18:43'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]."	anInteger strictlyPositive ifFalse: [ self error: 'Range must be positive' ].	^ (self next * anInteger) truncated + 1! !!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:28'!nextValue	"This method generates random instances of Integer 	in the interval	0 to 16r7FFFFFFF. This method does NOT update the seed; repeated sends	answer the same value.	The algorithm is described in detail in 'Random Number Generators: 	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller 	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988)."	| lo hi aLoRHi answer |	hi _ (seed quo: q) asFloat.	lo _ seed - (hi * q).  " = seed rem: q"  	aLoRHi _ (a * lo) - (r * hi).	answer _ (aLoRHi > 0.0)		ifTrue:  [aLoRHi]		ifFalse: [aLoRHi + m].	^ answer! !PluggableTextController subclass: #ReadOnlyTextController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:41'!accept 	"Overridden to allow accept of clean text"	(view setText: paragraph text from: self) ifTrue:		[initialText _ paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]].! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 14:02'!userHasEdited	"Ignore this -- I stay clean"! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:45'!zapSelectionWith: aText	view flash  "no edits allowed"! !LookupKey subclass: #ReadOnlyVariableBinding	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/14/2001 23:09'!value	^value! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/17/2001 18:03'!value: aValue	(AttemptToWriteReadOnlyGlobal signal: 'Cannot store into read-only bindings') == true ifTrue:[		value _ aValue.	].! !!ReadOnlyVariableBinding methodsFor: 'testing' stamp: 'ar 8/14/2001 23:08'!isSpecialWriteBinding	"Return true if this variable binding is write protected, e.g., should not be accessed primitively but rather by sending #value: messages"	^true! !!ReadOnlyVariableBinding methodsFor: 'private' stamp: 'ar 8/14/2001 23:11'!privateSetKey: aKey value: aValue	key _ aKey.	value _ aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReadOnlyVariableBinding class	instanceVariableNames: ''!!ReadOnlyVariableBinding class methodsFor: 'instance creation' stamp: 'ar 8/14/2001 23:11'!key: key value: aValue	^self new privateSetKey: key value: aValue! !PositionableStream subclass: #ReadStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!ReadStream commentStamp: '<historical>' prior: 0!I represent an accessor for a sequence of objects that can only read objects from the sequence.!!ReadStream methodsFor: 'accessing'!ascii! !!ReadStream methodsFor: 'accessing'!binary! !!ReadStream methodsFor: 'accessing'!next	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position _ position + 1)]! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:01'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| max |	max _ (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position _ position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!ReadStream methodsFor: 'accessing'!nextPut: anObject	self shouldNotImplement! !!ReadStream methodsFor: 'accessing' stamp: 'ajh 9/5/2002 22:11'!readStream	"polymorphic with SequenceableCollection.  Return self"	^ self! !!ReadStream methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:20'!size	"Compatibility with other streams (e.g., FileStream)"	^readLimit! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start _ position+1.	position _ collection size.	^collection copyFrom: start to: position! !!ReadStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection _ aCollection.	readLimit _  lastIndex > (len _ collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position _ firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!ReadStream methodsFor: 'file stream compatibility' stamp: 'nk 12/13/2002 12:00'!localName	^'ReadStream'! !!ReadStream methodsFor: 'file stream compatibility' stamp: 'nk 12/13/2002 12:01'!openReadOnly! !!ReadStream methodsFor: 'file stream compatibility' stamp: 'nk 12/13/2002 12:00'!readOnly! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReadStream class	instanceVariableNames: ''!!ReadStream class methodsFor: 'instance creation'!on: aCollection from: firstIndex to: lastIndex 	"Answer with a new instance streaming over a copy of aCollection from	firstIndex to lastIndex."	^self basicNew		on: aCollection		from: firstIndex		to: lastIndex! !WriteStream subclass: #ReadWriteStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!ReadWriteStream commentStamp: '<historical>' prior: 0!I represent an accessor for a sequence of objects. My instances can both read and store objects.!!ReadWriteStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	readLimit _ readLimit max: position.	^collection copyFrom: 1 to: readLimit! !!ReadWriteStream methodsFor: 'accessing'!name	^ 'a stream'   "for fileIn compatibility"! !!ReadWriteStream methodsFor: 'accessing'!next	"Primitive. Return the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	"treat me as a FIFO"	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position _ position + 1)]! !!ReadWriteStream methodsFor: 'accessing' stamp: 'ar 8/5/2003 02:23'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	readLimit := readLimit max: position.	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadWriteStream methodsFor: 'file status'!close	"Presumably sets the status of the receiver to be closed. This message does 	nothing at this level, but is included for FileStream compatibility."	^self! !!ReadWriteStream methodsFor: 'file status'!closed	"If you have close (for FileStream compatibility), you must respond to closed.  The result in nonsense here.  TK 29 May 96"	^ false! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:41'!fileOutChanges	"Append to the receiver a description of all class changes."	Cursor write showWhile:		[self header; timeStamp.		ChangeSet current fileOutOn: self.		self trailer; close]! !!ReadWriteStream methodsFor: 'converting' stamp: 'ajh 9/14/2002 20:37'!readStream	"polymorphic with SequenceableCollection.  Return self"	^ self! !!ReadWriteStream methodsFor: 'testing' stamp: 'tk 11/29/2001 12:47'!= other	(self class == ReadWriteStream and: [other class == ReadWriteStream]) ifFalse: [		^ super = other].	"does an identity test.  Don't read contents of FileStream"	^ self position = other position and: [self contents = other contents]! !!ReadWriteStream methodsFor: 'testing' stamp: 'tk 12/2/2001 17:13'!hash	self class == ReadWriteStream ifFalse: [^ super hash].	^ (self position + readLimit + 53) hash! !Object subclass: #RealEstateAgent	instanceVariableNames: ''	classVariableNames: 'ReverseStaggerOffset StaggerOffset StaggerOrigin StandardSize StandardWindowOrigins'	poolDictionaries: ''	category: 'System-Support'!!RealEstateAgent commentStamp: '<historical>' prior: 0!Responsible for real-estate management on the screen, which is to say, controlling where new windows appear, with what sizes, etc.  5/20/96 sw!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RealEstateAgent class	instanceVariableNames: ''!!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'BG 10/29/2003 09:53'!assignCollapseFrameFor: aSSView 	"Offer up a location along the left edge of the screen for a collapsed SSView. Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames topLeft viewBox collapsedFrame extent newFrame verticalBorderDistance top |	grid _ 8.	verticalBorderDistance _ 8.	aSSView isMorph		ifTrue: []		ifFalse: [otherFrames _ ScheduledControllers scheduledWindowControllers						collect: [:aController | aController view ~= aSSView ifTrue: [aController view collapsedFrame]]						thenSelect: [:rect | rect notNil].				viewBox _ Display boundingBox].	collapsedFrame _ aSSView collapsedFrame.	extent _ collapsedFrame notNil				ifTrue: [collapsedFrame extent]				ifFalse: [aSSView isMorph					ifTrue: [aSSView getRawLabel width + aSSView labelWidgetAllowance @ (aSSView labelHeight + 2)]					ifFalse: [(aSSView labelText extent x + 70) @ aSSView labelHeight							min: aSSView labelDisplayBox extent]].	collapsedFrame notNil		ifTrue: [(otherFrames anySatisfy: [:f | collapsedFrame intersects: f])				ifFalse: ["non overlapping"					^ collapsedFrame]].	top _ viewBox top + verticalBorderDistance.	[topLeft _ viewBox left @ top.	newFrame _ topLeft extent: extent.	newFrame bottom <= (viewBox height - verticalBorderDistance)]		whileTrue: 			[(otherFrames anySatisfy: [:w | newFrame intersects: w])				ifFalse: ["no overlap"					^ newFrame].			top _ top + grid].	"If all else fails... (really to many wins here)"	^ 0 @ 0 extent: extent! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 10:48'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames y free topLeft viewBox |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	aSSView isMorph		ifTrue: []		ifFalse: [otherFrames _ ScheduledControllers scheduledWindowControllers					collect: [:aController | aController view collapsedFrame]					thenSelect: [:rect | rect notNil].				viewBox _ Display boundingBox].	y _ viewBox top.	[(y _ y + grid) <= (viewBox height - grid)]		whileTrue:		[topLeft _ viewBox left@y.		free _ true.		otherFrames do: [:w | free _ free & (topLeft ~= w topLeft)].		free ifTrue: [^ topLeft]].	"If all else fails..."	^ 0 @ 0! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'BG 10/29/2003 09:54'!initialFrameFor: aView initialExtent: initialExtent world: aWorld	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView initialExtent: initialExtent world: aWorld].	allowedArea _ self maximumUsableAreaInWorld: aWorld.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	otherFrames _ Smalltalk isMorphic		ifTrue: []		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins _ otherFrames collect: [:f | f origin].	(self standardPositionsInWorld: aWorld) do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ (self standardPositionsInWorld: aWorld) first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:13'!initialFrameFor: aView world: aWorld	"Find a plausible initial screen area for the supplied view.  See called method."	^ self initialFrameFor: aView initialExtent: aView initialExtent world: aWorld! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'tk 11/26/1998 09:34'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset _ 6 @ 20.	ReverseStaggerOffset _ -6 @ 20.	StaggerOrigin _ 200 @ 30.	StandardSize _ 600@400.! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:11'!maximumUsableArea	| allowedArea |	allowedArea _ Display usableArea.	^allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:42'!maximumUsableAreaInWorld: aWorldOrNil	| allowedArea |	allowedArea _ Display usableArea.	aWorldOrNil ifNotNil: [allowedArea _ allowedArea intersect: aWorldOrNil viewBox].	^allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:12'!screenTopSetback	Smalltalk isMorphic		ifTrue: []		ifFalse: [^ 18]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:12'!scrollBarSetback	Smalltalk isMorphic		ifTrue: []  "width = 16; inset from border by 3"		ifFalse: [^ 24]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:43'!standardPositionsInWorld: aWorldOrNil	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ self maximumUsableAreaInWorld: aWorldOrNil.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:55'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ self maximumUsableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self maximumUsableArea insetBy: (			self scrollBarSetback @ self screenTopSetback extent: 0@0		).		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: StandardSize "600@400"].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'BG 10/29/2003 09:54'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld	"This method implements a staggered window placement policy that I (di) like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible."	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _(self maximumUsableAreaInWorld: aWorld)		insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0@0).		"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: []		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:54'!windowColumnsDesired	"Answer how many separate vertical columns of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(self maximumUsableArea width > 640)				ifTrue:					[2]				ifFalse:					[1]]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:54'!windowRowsDesired	"Answer how many separate horizontal rows of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(self maximumUsableArea height > 480)				ifTrue:					[2]				ifFalse:					[1]]! !AbstractEvent subclass: #RecategorizedEvent	instanceVariableNames: 'oldCategory'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!RecategorizedEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 19:51'!isRecategorized	^true! !!RecategorizedEvent methodsFor: 'printing' stamp: 'rw 7/2/2003 09:12'!printEventKindOn: aStream	aStream nextPutAll: 'Recategorized'! !!RecategorizedEvent methodsFor: 'accessing' stamp: 'rw 7/1/2003 20:08'!oldCategory: aCategoryName	oldCategory := aCategoryName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RecategorizedEvent class	instanceVariableNames: ''!!RecategorizedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:09'!changeKind	^#Recategorized! !!RecategorizedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 11:20'!supportedKinds	^Array with: self classKind with: self methodKind! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'rw 7/9/2003 14:21'!class: aClass category: cat oldCategory: oldName	^(self class: aClass category: cat) oldCategory: oldName! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'rw 7/31/2003 16:35'!method: aMethod protocol: prot class: aClass oldProtocol: oldName	^(self method: aMethod protocol: prot class: aClass) oldCategory: oldName! !MessageSet subclass: #RecentMessageSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!RecentMessageSet commentStamp: 'sw 8/1/2002 17:40' prior: 0!RecentMessageSet is a message set that shows the most recently-submitted methods, in chronological order.!!RecentMessageSet methodsFor: 'contents' stamp: 'sw 10/19/1999 17:33'!contents: c notifying: n	| result |	result _ super contents: c notifying: n.	result == true ifTrue:		[self reformulateList].	^ result! !!RecentMessageSet methodsFor: 'update' stamp: 'sw 1/28/2001 20:59'!growable	"Answer whether the receiver can be changed by manual additions & deletions"	^ false! !!RecentMessageSet methodsFor: 'update' stamp: 'RAA 5/29/2001 10:19'!reformulateList	| myList |	"Reformulate the receiver's list.  Exclude methods now deleted"	myList _ Utilities recentMethodSubmissions reversed select: [ :each | each isValid].	self initializeMessageList: myList.	self messageListIndex: (messageList size min: 1).	"0 or 1"	self changed: #messageList.	self changed: #messageListIndex! !!RecentMessageSet methodsFor: 'update' stamp: 'RAA 5/29/2001 10:42'!updateListsAndCodeIn: aWindow	| recentFromUtilities |	"RAA 20 june 2000 - a recent change to how messages were displayed in the list caused them not to match what was stored in Utilities. This caused the recent submissions to be continuously updated. The hack below fixed that problem"	self flag: #mref.	"in second pass, use simpler test"	self canDiscardEdits ifFalse: [^ self].	recentFromUtilities _ Utilities mostRecentlySubmittedMessage,' '.	(messageList first asStringOrText asString beginsWith: recentFromUtilities)		ifFalse:			[self reformulateList]		ifTrue:			[self updateCodePaneIfNeeded]! !!RecentMessageSet methodsFor: 'selection'!maybeSetSelection	"After a browser's message list is changed, this message is dispatched to the model, to give it a chance to refigure a selection"		self messageListIndex: 1! !!RecentMessageSet methodsFor: 'message list' stamp: 'sw 7/28/2002 23:20'!addExtraShiftedItemsTo: aMenu	"The shifted selector-list menu is being built.  Overridden here to defeat the presence of the items that add or change order, since RecentMessageSet defines methods & order explicitly based on external criteria"	aMenu add: 'set size of recent history...' action: #setRecentHistorySize! !!RecentMessageSet methodsFor: 'message list' stamp: 'sw 7/28/2002 23:50'!setRecentHistorySize	"Let the user specify the recent history size"	| aReply aNumber |	aReply _ FillInTheBlank request: 'How many recent methodsshould be maintained?' initialAnswer: Utilities numberOfRecentSubmissionsToStore asString.	aReply isEmptyOrNil ifFalse:		[aNumber _ aReply asNumber rounded.		(aNumber > 1 and: [aNumber <= 1000])			ifTrue:				[Utilities numberOfRecentSubmissionsToStore: aNumber.				self inform: 'Okay, ', aNumber asString, ' is the new size of the recent method history']			ifFalse:				[self inform: 'Sorry, must be a number between 2 & 1000']]			! !!RecentMessageSet methodsFor: 'message functions' stamp: 'BG 11/1/2003 13:27'!messageListMenu: aMenu shifted: shifted	"Answer the message-list menu"	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			('remove from RecentSubmissions'		removeFromRecentSubmissions)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !!RecentMessageSet methodsFor: 'message functions' stamp: 'sw 9/26/2002 18:09'!removeFromRecentSubmissions	"Remove the currently-selected method from the RecentSubmissions list"	| aClass methodSym |	((aClass _ self selectedClassOrMetaClass) notNil and: [(methodSym _ self selectedMessageName) notNil])		ifTrue: 			[Utilities purgeFromRecentSubmissions: (MethodReference new setStandardClass: aClass methodSymbol: methodSym).			self reformulateList]! !Object subclass: #Rectangle	instanceVariableNames: 'origin corner'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Rectangle commentStamp: '<historical>' prior: 0!I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.!!Rectangle methodsFor: 'accessing' stamp: 'acg 2/23/2000 00:52'!aboveCenter	"Answer the point slightly above the center of the receiver."	^self topLeft + self bottomRight // (2@3)! !!Rectangle methodsFor: 'accessing' stamp: 'di 11/17/2001 14:01'!area	"Answer the receiver's area, the product of width and height."	| w |	(w _ self width) <= 0 ifTrue: [^ 0].	^ w * self height max: 0! !!Rectangle methodsFor: 'accessing'!bottom	"Answer the position of the receiver's bottom horizontal line."	^corner y! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!bottom: aNumber	^origin corner: corner x @ aNumber! !!Rectangle methodsFor: 'accessing'!bottomCenter	"Answer the point at the center of the bottom horizontal line of the 	receiver."	^self center x @ self bottom! !!Rectangle methodsFor: 'accessing'!bottomLeft	"Answer the point at the left edge of the bottom horizontal line of the 	receiver."	^origin x @ corner y! !!Rectangle methodsFor: 'accessing'!bottomRight	"Answer the point at the right edge of the bottom horizontal line of the 	receiver."	^corner! !!Rectangle methodsFor: 'accessing'!boundingBox	^ self! !!Rectangle methodsFor: 'accessing'!center	"Answer the point at the center of the receiver."	^self topLeft + self bottomRight // 2! !!Rectangle methodsFor: 'accessing'!corner	"Answer the point at the bottom right corner of the receiver."	^corner! !!Rectangle methodsFor: 'accessing'!corners	"Return an array of corner points in the order of a quadrilateral spec for WarpBlt."	^ Array		with: self topLeft		with: self bottomLeft		with: self bottomRight		with: self topRight! !!Rectangle methodsFor: 'accessing'!extent	"Answer with a rectangle with origin 0@0 and corner the receiver's 	width @ the receiver's height."	^corner - origin! !!Rectangle methodsFor: 'accessing'!height	"Answer the height of the receiver."	^corner y - origin y! !!Rectangle methodsFor: 'accessing'!innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 _ self topLeft corner: self bottomRight - (1@1).	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !!Rectangle methodsFor: 'accessing'!left	"Answer the position of the receiver's left vertical line."	^origin x! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:16'!left: aNumber	^aNumber @ origin y corner: corner! !!Rectangle methodsFor: 'accessing'!leftCenter	"Answer the point at the center of the receiver's left vertical line."	^self left @ self center y! !!Rectangle methodsFor: 'accessing'!origin	"Answer the point at the top left corner of the receiver."	^origin! !!Rectangle methodsFor: 'accessing'!right	"Answer the position of the receiver's right vertical line."	^corner x! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!right: aNumber	^origin corner: aNumber @ corner y! !!Rectangle methodsFor: 'accessing'!rightCenter	"Answer the point at the center of the receiver's right vertical line."	^self right @ self center y! !!Rectangle methodsFor: 'accessing'!top	"Answer the position of the receiver's top horizontal line."	^origin y! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!top: aNumber	^origin x @ aNumber corner: corner! !!Rectangle methodsFor: 'accessing'!topCenter	"Answer the point at the center of the receiver's top horizontal line."	^self center x @ self top! !!Rectangle methodsFor: 'accessing'!topLeft	"Answer the point at the top left corner of the receiver's top horizontal line."	^origin! !!Rectangle methodsFor: 'accessing'!topRight	"Answer the point at the top right corner of the receiver's top horizontal 	line."	^corner x @ origin y! !!Rectangle methodsFor: 'accessing'!width	"Answer the width of the receiver."	^corner x - origin x! !!Rectangle methodsFor: 'comparing'!= aRectangle 	"Answer true if the receiver's species, origin and corner match aRectangle's."	self species = aRectangle species		ifTrue: [^origin = aRectangle origin and: [corner = aRectangle corner]]		ifFalse: [^false]! !!Rectangle methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^origin hash bitXor: corner hash! !!Rectangle methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/22/1998 16:11'!adjustTo: newRect along: side 	"Return a copy adjusted to fit a neighbor that has changed size."	side = #left ifTrue: [^ self withRight: newRect left].	side = #right ifTrue: [^ self withLeft: newRect right].	side = #top ifTrue: [^ self withBottom: newRect top].	side = #bottom ifTrue: [^ self withTop: newRect bottom].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 1/5/2002 18:04'!allAreasOutsideList: aCollection do: aBlock	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	^self allAreasOutsideList: aCollection startingAt: 1 do: aBlock! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 1/5/2002 18:03'!allAreasOutsideList: aCollection startingAt: startIndex do: aBlock	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	| yOrigin yCorner aRectangle index rr |	index _ startIndex.	"Find the next intersecting rectangle from aCollection"	[index <= aCollection size ifFalse:[^aBlock value: self].	aRectangle _ aCollection at: index.	origin <= aRectangle corner and: [aRectangle origin <= corner]] 		whileFalse:[index _ index + 1].	"aRectangle is intersecting; process it"	aRectangle origin y > origin y 		ifTrue: [rr _ origin corner: corner x @ (yOrigin _ aRectangle origin y).				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [rr _ origin x @ (yCorner _ aRectangle corner y) corner: corner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [rr _ origin x @ yOrigin corner: aRectangle origin x @ yCorner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock].	aRectangle corner x < corner x 		ifTrue: [rr _ aRectangle corner x @ yOrigin corner: corner x @ yCorner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock].! !!Rectangle methodsFor: 'rectangle functions'!amountToTranslateWithin: aRectangle	"Answer a Point, delta, such that self + delta is forced within aRectangle."	"Altered so as to prefer to keep self topLeft inside when all of self	cannot be made to fit 7/27/96 di"	| dx dy |	dx _ 0.  dy _ 0.	self right > aRectangle right ifTrue: [dx _ aRectangle right - self right].	self bottom > aRectangle bottom ifTrue: [dy _ aRectangle bottom - self bottom].	(self left + dx) < aRectangle left ifTrue: [dx _ aRectangle left - self left].	(self top + dy) < aRectangle top ifTrue: [dy _ aRectangle top - self top].	^ dx@dy! !!Rectangle methodsFor: 'rectangle functions'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"	(origin <= aRectangle corner and: [aRectangle origin <= corner])		ifFalse: [^Array with: self].	areas _ OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:00'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) < (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) < (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions'!encompass: aPoint 	"Answer a Rectangle that contains both the receiver and aPoint.  5/30/96 sw"	^ Rectangle 		origin: (origin min: aPoint)		corner: (corner max:  aPoint)! !!Rectangle methodsFor: 'rectangle functions'!expandBy: delta 	"Answer a Rectangle that is outset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin - delta origin 					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin - delta 					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions'!extendBy: delta 	"Answer a Rectangle with the same origin as the receiver, but whose corner is offset by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:11'!forPoint: aPoint closestSideDistLen: sideDistLenBlock	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side _ self sideNearestTo: aPoint.	side == #right ifTrue:		[^ sideDistLenBlock value: side value: (self right - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #left ifTrue:		[^ sideDistLenBlock value: side value: (self left - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #bottom ifTrue:		[^ sideDistLenBlock value: side value: (self bottom - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].	side == #top ifTrue:		[^ sideDistLenBlock value: side value: (self top - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].! !!Rectangle methodsFor: 'rectangle functions'!insetBy: delta 	"Answer a Rectangle that is inset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin + delta origin 					corner: corner - delta corner]		ifFalse: [^Rectangle 					origin: origin + delta 					corner: corner - delta]! !!Rectangle methodsFor: 'rectangle functions'!insetOriginBy: originDeltaPoint cornerBy: cornerDeltaPoint 	"Answer a Rectangle that is inset from the receiver by a given amount in 	the origin and corner."	^Rectangle		origin: origin + originDeltaPoint		corner: corner - cornerDeltaPoint! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 11/12/2000 19:10'!intersect: aRectangle 	"Answer a Rectangle that is the area in which the receiver overlaps with 	aRectangle. Optimized for speed; old code read:		^Rectangle 			origin: (origin max: aRectangle origin)			corner: (corner min: aRectangle corner)	"	| aPoint left right top bottom |	aPoint _ aRectangle origin.	aPoint x > origin x ifTrue:[left _ aPoint x] ifFalse:[left _ origin x].	aPoint y > origin y ifTrue:[top _ aPoint y] ifFalse:[top _ origin y].	aPoint _ aRectangle corner.	aPoint x < corner x ifTrue:[right _ aPoint x] ifFalse:[right _ corner x].	aPoint y < corner y ifTrue:[bottom _ aPoint y] ifFalse:[bottom _ corner y].	^Rectangle		origin: (left@top)		corner: (right@bottom)! !!Rectangle methodsFor: 'rectangle functions'!merge: aRectangle 	"Answer a Rectangle that contains both the receiver and aRectangle."	^Rectangle 		origin: (origin min: aRectangle origin)		corner: (corner max: aRectangle corner)! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 10/29/2000 02:41'!outsetBy: delta 	"Answer a Rectangle that is outset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin - delta origin 					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin - delta 					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 4/30/1998 11:22'!pointNearestTo: aPoint	"Return the point on my border closest to aPoint"	| side |	(self containsPoint: aPoint)		ifTrue:			[side _ self sideNearestTo: aPoint.			side == #right ifTrue: [^ self right @ aPoint y].			side == #left ifTrue: [^ self left @ aPoint y].			side == #bottom ifTrue: [^ aPoint x @ self bottom].			side == #top ifTrue: [^ aPoint x @ self top]]		ifFalse:			[^ aPoint adhereTo: self]! !!Rectangle methodsFor: 'rectangle functions'!quickMerge: aRectangle 	"Answer the receiver if it encloses the given rectangle or the merge of the two rectangles if it doesn't. THis method is an optimization to reduce extra rectangle creations."	| useRcvr rOrigin rCorner minX maxX minY maxY |	useRcvr _ true.	rOrigin _ aRectangle topLeft.	rCorner _ aRectangle bottomRight.	minX _ rOrigin x < origin x ifTrue: [useRcvr _ false. rOrigin x] ifFalse: [origin x].	maxX _ rCorner x > corner x ifTrue: [useRcvr _ false. rCorner x] ifFalse: [corner x].	minY _ rOrigin y < origin y ifTrue: [useRcvr _ false. rOrigin y] ifFalse: [origin y].	maxY _ rCorner y > corner y ifTrue: [useRcvr _ false. rCorner y] ifFalse: [corner y].	useRcvr		ifTrue: [^ self]		ifFalse: [^ Rectangle origin: minX@minY corner: maxX@maxY].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/20/97 23:01'!rectanglesAt: y height: ht	(y+ht) > self bottom ifTrue: [^ Array new].	^ Array with: (origin x @ y corner: corner x @ (y+ht))! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09'!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft _ aPoint x - self left.	distToRight _ self right - aPoint x.	distToTop _ aPoint y - self top.	distToBottom _ self bottom - aPoint y.	closest _ distToLeft. side _ #left.	distToRight < closest ifTrue: [closest _ distToRight. side _ #right].	distToTop < closest ifTrue: [closest _ distToTop. side _ #top].	distToBottom < closest ifTrue: [closest _ distToBottom. side _ #bottom].	^ side" | r | r _ Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 8/15/2008 11:39'!subDivideBy: aPoint	"Answer a collection of rectangles which divide the receiver evenly into aPoint x columns and aPoint y rows.  Answer the new rectangles left to right then down.  Yes, this method could be much shorter, but I tried to minimize duplications of arithmetic for efficiency."	"(0@0 corner: 100@100) subDivideBy: 4@2"		| rows columns eachWidth eachHeight subRegions rowTop baseIndex myLeft rowBottom columnLeft columnRight |	columns _ aPoint x.	rows _ aPoint y.	eachWidth _ self width / columns.	eachHeight _ self height / rows.	subRegions _ Array new: columns * rows.	rowTop _ self top.	baseIndex _ 0.	myLeft _ self left.	1 to: rows do: [:rowNumber |		rowBottom _ rowTop + eachHeight.		columnLeft _ myLeft.		columnRight _ columnLeft + eachWidth.		1 to: columns do: [:columnNumber |			subRegions 				at: baseIndex + columnNumber				put: (self species origin: columnLeft @ rowTop corner: columnRight @ rowBottom).			columnLeft _ columnRight.			columnRight _ columnRight + eachWidth].		rowTop _ rowBottom.		rowBottom _ rowBottom + eachHeight.		baseIndex _ baseIndex + columns].	^subRegions! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 8/15/2008 12:24'!subDivideRoundedBy: aPoint	"ssa - round the orign and extent points"	"Answer a collection of rectangles which divide the receiver evenly into aPoint x columns and aPoint y rows.  Answer the new rectangles left to right then down.  Yes, this method could be much shorter, but I tried to minimize duplications of arithmetic for efficiency."	"(0@0 corner: 100@100) subDivideBy: 4@2"		| rows columns eachWidth eachHeight subRegions rowTop baseIndex myLeft rowBottom columnLeft columnRight |	columns _ aPoint x.	rows _ aPoint y.	eachWidth _ self width / columns.	eachHeight _ self height / rows.	subRegions _ Array new: columns * rows.	rowTop _ self top.	baseIndex _ 0.	myLeft _ self left.	1 to: rows do: [:rowNumber |		rowBottom _ rowTop + eachHeight.		columnLeft _ myLeft.		columnRight _ columnLeft + eachWidth.		1 to: columns do: [:columnNumber |			subRegions 				at: baseIndex + columnNumber				put: (self species origin: columnLeft @ rowTop corner: columnRight @ rowBottom) rounded.			columnLeft _ columnRight.			columnRight _ columnRight + eachWidth].		rowTop _ rowBottom.		rowBottom _ rowBottom + eachHeight.		baseIndex _ baseIndex + columns].	^subRegions! !!Rectangle methodsFor: 'rectangle functions'!translatedToBeWithin: aRectangle	"Answer a copy of the receiver that does not extend beyond aRectangle.  7/8/96 sw"	^ self translateBy: (self amountToTranslateWithin: aRectangle)! !!Rectangle methodsFor: 'rectangle functions'!withBottom: y 	"Return a copy of me with a different bottom y"	^ origin x @ origin y corner: corner x @ y! !!Rectangle methodsFor: 'rectangle functions'!withHeight: height 	"Return a copy of me with a different height"	^ origin corner: corner x @ (origin y + height)! !!Rectangle methodsFor: 'rectangle functions'!withLeft: x 	"Return a copy of me with a different left x"	^ x @ origin y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withRight: x 	"Return a copy of me with a different right x"	^ origin x @ origin y corner: x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withSide: side setTo: value  "return a copy with side set to value"	^ self perform: (#(withLeft: withRight: withTop: withBottom: )							at: (#(left right top bottom) indexOf: side))		with: value! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 9/8/1999 21:25'!withSideOrCorner: side setToPoint: newPoint	"Return a copy with side set to newPoint"	^ self withSideOrCorner: side setToPoint: newPoint minExtent: 0@0! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:16'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent	"Return a copy with side set to newPoint"	^self withSideOrCorner: side setToPoint: newPoint minExtent: minExtent		limit: ((#(left top) includes: side) ifTrue: [SmallInteger minVal] ifFalse: [SmallInteger maxVal])! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:07'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit	"Return a copy with side set to newPoint"	side = #top ifTrue: [^ self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y)].	side = #bottom ifTrue: [^ self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y)].	side = #left ifTrue: [^ self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x)].	side = #right ifTrue: [^ self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x)].	side = #topLeft ifTrue: [^ (newPoint min: corner - minExtent) corner: self bottomRight].	side = #bottomRight ifTrue: [^ self topLeft corner: (newPoint max: origin + minExtent)].	side = #bottomLeft ifTrue: [^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))].	side = #topRight ifTrue: [^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))].! !!Rectangle methodsFor: 'rectangle functions'!withTop: y 	"Return a copy of me with a different top y"	^ origin x @ y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withWidth: width 	"Return a copy of me with a different width"	^ origin corner: (origin x + width) @ corner y! !!Rectangle methodsFor: 'testing'!containsPoint: aPoint 	"Answer whether aPoint is within the receiver."	^origin <= aPoint and: [aPoint < corner]! !!Rectangle methodsFor: 'testing'!containsRect: aRect	"Answer whether aRect is within the receiver (OK to coincide)."	^ aRect origin >= origin and: [aRect corner <= corner]! !!Rectangle methodsFor: 'testing'!hasPositiveExtent	^ (corner x > origin x) and: [corner y > origin y]! !!Rectangle methodsFor: 'testing' stamp: 'ar 9/10/2000 15:29'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin _ aRectangle origin.	rCorner _ aRectangle corner.	rCorner x <= origin x	ifTrue: [^ false].	rCorner y <= origin y	ifTrue: [^ false].	rOrigin x >= corner x	ifTrue: [^ false].	rOrigin y >= corner y	ifTrue: [^ false].	^ true! !!Rectangle methodsFor: 'testing'!isTall	^ self height > self width! !!Rectangle methodsFor: 'testing'!isWide	^ self width > self height! !!Rectangle methodsFor: 'testing' stamp: 'ar 10/29/2000 19:03'!isZero	^origin isZero and:[corner isZero]! !!Rectangle methodsFor: 'truncation and round off'!rounded	"Answer a Rectangle whose origin and corner are rounded."	^Rectangle origin: origin rounded corner: corner rounded! !!Rectangle methodsFor: 'truncation and round off'!truncateTo: grid	"Answer a Rectangle whose origin and corner are truncated to grid x and grid y."	^Rectangle origin: (origin truncateTo: grid)				corner: (corner truncateTo: grid)! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!Rectangle methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Answer a Rectangle that is a translated by aPoint2 - aPoint1."	^self translateBy: aPoint2 - aPoint1! !!Rectangle methodsFor: 'transforming'!centeredBeneath: aRectangle	 "Move the reciever so that its top center point coincides with the bottom center point of aRectangle.  5/20/96 sw:"	^ self align: self topCenter with: aRectangle bottomCenter! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 16:24'!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	^ (origin flipBy: direction centerAt: aPoint)		rect: (corner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming' stamp: 'ssa 9/3/2008 11:12'!newRectButtonPressedDo: newRectBlock 	"Track the outline of a new rectangle until mouse button 	changes. newFrameBlock produces each new rectangle from the 	previous. Only tracks while mouse is down."	| rect newRect buttonNow delay |	delay _ Delay forMilliseconds: 10.	buttonNow _ Sensor anyButtonPressed.	rect _ self.	Display		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	[buttonNow]		whileTrue: [delay wait.			buttonNow _ Sensor anyButtonPressed.			newRect _ newRectBlock value: rect.			newRect = rect				ifFalse: [Display						border: rect						width: 2						rule: Form reverse						fillColor: Color gray.					Display						border: newRect						width: 2						rule: Form reverse						fillColor: Color gray.					rect _ newRect]].	Display		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	" pay the price for reading the sensor directly ; get this party started "	Smalltalk isMorphic		ifTrue: [].	Sensor processEvent: Sensor createMouseEvent.	^ rect! !!Rectangle methodsFor: 'transforming' stamp: 'ssa 9/3/2008 11:12'!newRectFrom: newRectBlock	"Track the outline of a new rectangle until mouse button changes.	newFrameBlock produces each new rectangle from the previous"	| rect newRect buttonStart buttonNow delay |	delay _ Delay forMilliseconds: 10.	buttonStart _ buttonNow _ Sensor anyButtonPressed.	rect _ self.	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	[buttonNow == buttonStart] whileTrue: 		[delay wait.		buttonNow _ Sensor anyButtonPressed.		newRect _ newRectBlock value: rect.		newRect = rect ifFalse:			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.			rect _ newRect]].	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	" pay the price for reading the sensor directly ; get this party started "	Sensor processEvent: Sensor createMouseEvent.	^ rect! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 15:11'!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	^ (origin rotateBy: direction centerAt: aPoint)		rect: (corner rotateBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming'!scaleBy: scale 	"Answer a Rectangle scaled by scale, a Point or a scalar."	^Rectangle origin: origin * scale corner: corner * scale! !!Rectangle methodsFor: 'transforming' stamp: 'ssa 8/27/2008 04:43'!scaleByRect: scale 	"Answer a Rectangle scaled by scale, a rectangle."	^Rectangle origin: origin * scale origin corner: corner * scale corner! !!Rectangle methodsFor: 'transforming'!scaleFrom: rect1 to: rect2	"Produce a rectangle stretched according to the stretch from rect1 to rect2"	^ (origin scaleFrom: rect1 to: rect2)		corner: (corner scaleFrom: rect1 to: rect2)! !!Rectangle methodsFor: 'transforming' stamp: 'sw 5/21/96'!squishedWithin: aRectangle	"Return an adjustment of the receiver that fits within aRectangle by reducing its size, not by changing its origin.  "	^ origin corner: (corner min: aRectangle bottomRight)"(50 @ 50 corner: 160 @ 100) squishedWithin:  (20 @ 10 corner: 90 @ 85)"! !!Rectangle methodsFor: 'transforming'!translateBy: factor 	"Answer a Rectangle translated by factor, a Point or a scalar."	^Rectangle origin: origin + factor corner: corner + factor! !!Rectangle methodsFor: 'transforming' stamp: 'nk 7/5/2003 08:31'!translatedAndSquishedToBeWithin: aRectangle	"Return an adjustment of the receiver that fits within aRectangle by		- translating it to be within aRectangle if necessary, then		- reducing its size, if necessary"	^ (self translatedToBeWithin: aRectangle) squishedWithin: aRectangle! !!Rectangle methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	origin printOn: aStream.	aStream nextPutAll: ' corner: '.	corner printOn: aStream! !!Rectangle methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:18'!propertyListOn: aStream 	" {x=a; y=b; width=c; height=d} "	aStream print:'{ x='; write:origin x;			print:' y='; write:origin y;			print:' width='; write:self extent x;			print:' height='; write:self extent y;			print:'};'.! !!Rectangle methodsFor: 'printing'!storeOn: aStream 	"printed form is good for storing too"	self printOn: aStream! !!Rectangle methodsFor: 'private'!setOrigin: topLeft corner: bottomRight	origin _ topLeft.	corner _ bottomRight! !!Rectangle methodsFor: 'FMP' stamp: 'RAA 6/1/1999 17:41'!deltaToEnsureInOrCentered: r extra: aNumber	| dX dY halfXDiff halfYDiff |	dX _ dY _ 0.	halfXDiff _ (r width - self width * aNumber) truncated.	halfYDiff _ (r height - self height  * aNumber) truncated.	self left < r left		ifTrue: [dX _ self left - r left - halfXDiff]		ifFalse: [self right > r right ifTrue: [dX _ self right - r right + halfXDiff]].	self top < r top		ifTrue: [dY _ self top - r top - halfYDiff]		ifFalse: [self bottom > r bottom ifTrue: [dY _ self bottom - r bottom + halfYDiff]].	^dX @ dY! !!Rectangle methodsFor: '*nebraska-Morphic-Remote' stamp: 'RAA 7/31/2000 16:39'!encodeForRemoteCanvasB	| encoded |	encoded := Bitmap new: 4.	encoded at: 1 put: origin x asInteger.	encoded at: 2 put: origin y asInteger.	encoded at: 3 put: corner x asInteger.	encoded at: 4 put: corner y asInteger.	^encoded! !!Rectangle methodsFor: '*morphic-Postscript Canvases' stamp: 'mpw 8/9/1930 08:00'!encodePostscriptOn:aStream 	aStream write:self origin; print:' '; write:self extent; print:' '.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Rectangle class	instanceVariableNames: ''!!Rectangle class methodsFor: 'instance creation' stamp: 'tk 3/9/97'!center: centerPoint extent: extentPoint 	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  "	^self origin: centerPoint - (extentPoint//2) extent: extentPoint! !!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:42'!encompassing: listOfPoints	"A number of callers of encompass: should use this method."	| topLeft bottomRight |	topLeft _ bottomRight _ nil.	listOfPoints do:		[:p | topLeft == nil			ifTrue: [topLeft _ bottomRight _ p]			ifFalse: [topLeft _ topLeft min: p.					bottomRight _ bottomRight max: p]].	^ topLeft corner: bottomRight! !!Rectangle class methodsFor: 'instance creation'!fromUser	"Answer an instance of me that is determined by having the user 	designate the top left and bottom right corners. The gridding for user 	selection is 1@1."	^self fromUser: 1 @ 1! !!Rectangle class methodsFor: 'instance creation'!fromUser: gridPoint	"Answer a Rectangle that is determined by having the user 	designate the top left and bottom right corners. 	The cursor reamins linked with the sensor, but	the outline is kept gridded."	| originRect |	originRect _ Cursor origin showWhile: 		[((Sensor cursorPoint grid: gridPoint) extent: 0@0) newRectFrom:			[:f | (Sensor cursorPoint grid: gridPoint) extent: 0@0]].	^ Cursor corner showWhile:		[originRect newRectFrom:			[:f | f origin corner: (Sensor cursorPoint grid: gridPoint)]]! !!Rectangle class methodsFor: 'instance creation'!left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber 	"Answer an instance of me whose left, right, top, and bottom coordinates 	are determined by the arguments."	^ self new setOrigin: leftNumber @ topNumber corner: rightNumber @ bottomNumber! !!Rectangle class methodsFor: 'instance creation' stamp: 'btr 2/14/2003 16:29'!merging: listOfRects 	"A number of callers of merge: should use this method."	| minX minY maxX maxY |	listOfRects		do: [:r | minX				ifNil: [minX _ r topLeft x. minY _ r topLeft y.					maxX _ r bottomRight x. maxY _ r bottomRight y]				ifNotNil: [minX _ minX min: r topLeft x. minY _ minY min: r topLeft y.					maxX _ maxX max: r bottomRight x. maxY _ maxY max: r bottomRight y]].	^ minX@minY corner: maxX@maxY! !!Rectangle class methodsFor: 'instance creation'!origin: originPoint corner: cornerPoint 	"Answer an instance of me whose corners (top left and bottom right) are 	determined by the arguments."	^self new setOrigin: originPoint corner: cornerPoint! !!Rectangle class methodsFor: 'instance creation'!origin: originPoint extent: extentPoint 	"Answer an instance of me whose top left corner is originPoint and width 	by height is extentPoint."	^self new setOrigin: originPoint corner: originPoint + extentPoint! !!Rectangle class methodsFor: 'instance creation'!originFromUser: extentPoint 	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint. The gridding for user selection is 1@1."	^self originFromUser: extentPoint grid: 1 @ 1! !!Rectangle class methodsFor: 'instance creation'!originFromUser: extentPoint grid: gridPoint 	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint. The gridding for user selection is scaleFactor. Assumes that 	the sender has determined an extent that is a proper multiple of 	scaleFactor."	^ Cursor origin showWhile: 		[((Sensor cursorPoint grid: gridPoint) extent: extentPoint) newRectFrom:			[:f | (Sensor cursorPoint grid: gridPoint) extent: extentPoint]].! !Object subclass: #RemoteString	instanceVariableNames: 'sourceFileNumber filePositionHi'	classVariableNames: 'CurrentTextAttStructure CurrentTextAttVersion TextAttributeStructureVersions'	poolDictionaries: ''	category: 'System-Files'!!RemoteString commentStamp: '<historical>' prior: 0!My instances provide an external file reference to a piece of text.  It may be the sourceCode of a method, or the class comments of a class.The changes file or file-in file usually has a chunk that is just the source string of a method:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!I can return either a String or a Text.  Some a chunk is followed by a second chunk (beginning with ]style[) containing style information.  The encoding is like this:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!]style[(14 50 312)f1,f1b,f1LInteger +;i!!Allowed TextAttributes are TextFontChange, TextEmphasis, TextColor, TextDoIt, TextKern, TextLink, TextURL.  TextFontReference and TextAnchor are not supported.See PositionableStream nextChunkText and RunArray class scanFrom:.!]style[(748 32 5 24 1)f1,f1LPositionableStream nextChunkText;,f1,f1LRunArray class scanFrom:;,f1!!RemoteString methodsFor: 'accessing' stamp: 'ajh 1/18/2002 01:04'!fileStream 	"Answer the file stream with position set at the beginning of my string"	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile! !!RemoteString methodsFor: 'accessing' stamp: 'nk 11/26/2002 12:05'!last	^self string ifNotNilDo: [ :s | s last ]! !!RemoteString methodsFor: 'accessing'!position 	"Answer the location of the string on a file."	^ filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:28'!setSourcePointer: aSourcePointer	sourceFileNumber _ SourceFiles fileIndexFromSourcePointer: aSourcePointer.	filePositionHi _ SourceFiles filePositionFromSourcePointer: aSourcePointer! !!RemoteString methodsFor: 'accessing'!sourceFileNumber	"Answer the index of the file on which the string is stored."	^sourceFileNumber! !!RemoteString methodsFor: 'accessing' stamp: 'hmm 4/26/2000 20:47'!sourcePointer	sourceFileNumber ifNil: [^ 0].	^SourceFiles sourcePointerFromFileIndex: sourceFileNumber andPosition: filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'di 1/13/98 16:57'!string 	"Answer the receiver's string if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunk! !!RemoteString methodsFor: 'accessing' stamp: 'tk 1/21/95 17:55'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunkText! !!RemoteString methodsFor: 'private'!fileNumber: fileNumber position: position 	sourceFileNumber _ fileNumber.	filePositionHi _ position! !!RemoteString methodsFor: 'private'!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile _ SourceFiles at: fileNumber.		theFile setToEnd; cr.		self string: aString onFileNumber: fileNumber toFile: theFile]! !!RemoteString methodsFor: 'private' stamp: 'tk 12/12/97 10:41'!string: aStringOrText onFileNumber: fileNumber toFile: aFileStream 	"Store this as the receiver's text if source files exist. If aStringOrText is a Text, store a marker with the string part, and then store the runs of TextAttributes in the next chunk."	| position |	position _ aFileStream position.	self fileNumber: fileNumber position: position.	aFileStream nextChunkPutWithStyle: aStringOrText	"^ self		(important)"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RemoteString class	instanceVariableNames: ''!!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/11/97 10:35'!initialize	"Derive the current TextAttributes classes object structure"	self new makeNewTextAttVersion! !!RemoteString class methodsFor: 'as yet unclassified'!newFileNumber: sourceIndex position: anInteger 	"Answer an instance of me fora file indexed by sourceIndex, at the 	position anInteger. Assume that the string is already stored on the file 	and the instance will be used to access it."	^self new fileNumber: sourceIndex position: anInteger! !!RemoteString class methodsFor: 'as yet unclassified'!newString: aString onFileNumber: sourceIndex 	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file and create the remote reference."	^self new string: aString onFileNumber: sourceIndex! !!RemoteString class methodsFor: 'as yet unclassified'!newString: aString onFileNumber: sourceIndex toFile: aFileStream	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file, aFileStream, and create the 	remote reference. Assume that the index corresponds properly to 	aFileStream."	^self new string: aString onFileNumber: sourceIndex toFile: aFileStream! !AbstractEvent subclass: #RemovedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!RemovedEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:35'!isRemoved	^true! !!RemovedEvent methodsFor: 'printing' stamp: 'rw 6/30/2003 09:31'!printEventKindOn: aStream	aStream nextPutAll: 'Removed'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RemovedEvent class	instanceVariableNames: ''!!RemovedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:09'!changeKind	^#Removed! !!RemovedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:28'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self methodKind with: self categoryKind with: self protocolKind! !AbstractEvent subclass: #RenamedEvent	instanceVariableNames: 'newName oldName'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!RenamedEvent methodsFor: 'printing' stamp: 'rw 7/1/2003 11:34'!printEventKindOn: aStream	aStream nextPutAll: 'Renamed'! !!RenamedEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 11:34'!isRenamed	^true! !!RenamedEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:18'!newName	^ newName! !!RenamedEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:18'!newName: aName	newName := aName! !!RenamedEvent methodsFor: 'accessing' stamp: 'rw 7/1/2003 12:01'!oldName: aName	oldName := aName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RenamedEvent class	instanceVariableNames: ''!!RenamedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:09'!changeKind	^#Renamed! !!RenamedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:30'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self categoryKind with: self protocolKind! !!RenamedEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 12:19'!class: aClass category: cat oldName: oldName newName: newName	^(self class: aClass category: cat) oldName: oldName; newName: newName! !AbstractEvent subclass: #ReorganizedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!ReorganizedEvent methodsFor: 'testing' stamp: 'NS 1/27/2004 12:44'!isReorganized	^ true! !!ReorganizedEvent methodsFor: 'printing' stamp: 'NS 1/27/2004 12:44'!printEventKindOn: aStream	aStream nextPutAll: 'Reorganized'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReorganizedEvent class	instanceVariableNames: ''!!ReorganizedEvent class methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:46'!changeKind	^#Reorganized! !!ReorganizedEvent class methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:46'!supportedKinds	^Array with: self classKind! !Notification subclass: #RequestAlternateSyntaxSetting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!RequestAlternateSyntaxSetting commentStamp: '<historical>' prior: 0!I provide a way to override the current setting of the alternate syntax preference. I am used when filing in code to insure that the Smalltalk-80 preference is used regardless of what the user likes to see in her browsers.!!RequestAlternateSyntaxSetting methodsFor: 'as yet unclassified' stamp: 'RAA 6/14/2000 13:41'!defaultAction        self resume: Preferences printAlternateSyntax! !ParseNode subclass: #ReturnNode	instanceVariableNames: 'expr'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!ReturnNode commentStamp: '<historical>' prior: 0!I represent an expression of the form ^expr.!!ReturnNode methodsFor: 'initialize-release'!expr: e	expr _ e! !!ReturnNode methodsFor: 'initialize-release'!expr: e encoder: encoder sourceRange: range	expr _ e.	encoder noteSourceRange: range forNode: self! !!ReturnNode methodsFor: 'converting'!asReturnNode! !!ReturnNode methodsFor: 'testing'!isReturnSelf	^expr == NodeSelf! !!ReturnNode methodsFor: 'testing'!isSpecialConstant	^expr isSpecialConstant! !!ReturnNode methodsFor: 'testing'!isVariableReference	^expr isVariableReference! !!ReturnNode methodsFor: 'code generation'!code	^expr code! !!ReturnNode methodsFor: 'code generation'!emitForReturn: stack on: strm	expr emitForReturn: stack on: strm.	pc _ strm position! !!ReturnNode methodsFor: 'code generation'!emitForValue: stack on: strm	expr emitForReturn: stack on: strm.	pc _ strm position! !!ReturnNode methodsFor: 'code generation'!pc	"Used by encoder source mapping."	^pc! !!ReturnNode methodsFor: 'code generation'!sizeForReturn: encoder	^expr sizeForReturn: encoder! !!ReturnNode methodsFor: 'code generation'!sizeForValue: encoder	^expr sizeForReturn: encoder! !!ReturnNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:28'!printOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Answer '].				expr printOn: aStream indent: level]		ifFalse: [aStream nextPutAll: '^ '.				expr printOn: aStream indent: level].	expr printCommentOn: aStream indent: level.! !ArrayedCollection subclass: #RunArray	instanceVariableNames: 'runs values lastIndex lastRun lastOffset'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!RunArray commentStamp: '<historical>' prior: 0!My instances provide space-efficient storage of data which tends to be constant over long runs of the possible indices. Essentially repeated values are stored singly and then associated with a "run" length that denotes the number of consecutive occurrences of the value.My two important variables are	runs	An array of how many elements are in each run	values	An array of what the value is over those elementsThe variables lastIndex, lastRun and lastOffset cache the last accessso that streaming through RunArrays is not an N-squared process.Many complexities of access can be bypassed by using the method	RunArray withStartStopAndValueDo:!]style[(615 33)f1,f1LRunArray withStartStopAndValueDo:;!!RunArray methodsFor: 'accessing' stamp: 'di 1/15/1999 00:04'!= otherArray 	"Test if all my elements are equal to those of otherArray"	(otherArray isMemberOf: RunArray) ifFalse: [^ self hasEqualElements: otherArray].	"Faster test between two RunArrays" 	^ (runs hasEqualElements: otherArray runs)		and: [values hasEqualElements: otherArray values]! !!RunArray methodsFor: 'accessing'!at: index	self at: index setRunOffsetAndValue: [:run :offset :value | ^value]! !!RunArray methodsFor: 'accessing' stamp: 'ar 10/16/2001 18:56'!first	^values at: 1! !!RunArray methodsFor: 'accessing' stamp: 'ar 10/16/2001 18:56'!last	^values at: values size! !!RunArray methodsFor: 'accessing'!runLengthAt: index 	"Answer the length remaining in run beginning at index."	self at: index 		setRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]! !!RunArray methodsFor: 'accessing'!size	| size |	size _ 0.	1 to: runs size do: [:i | size _ size + (runs at: i)].	^size! !!RunArray methodsFor: 'accessing' stamp: 'di 11/10/97 13:34'!withStartStopAndValueDo: aBlock	| start stop |	start _ 1.	runs with: values do:		[:len : val | stop _ start + len - 1.		aBlock value: start value: stop value: val.		start _ stop + 1]		! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:47'!addFirst: value	"Add value as the first element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs _ {1}, runs.		values _ {value}, values]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 20:25'!addLast: value	"Add value as the last element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs _ runs copyWith: 1.		values _ values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:47'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs _ runs copyWith: times.		values _ values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'tk 1/28/98 09:28'!coalesce	"Try to combine adjacent runs"	| ind |	ind _ 2.	[ind > values size] whileFalse: [		(values at: ind-1) = (values at: ind) 			ifFalse: [ind _ ind + 1]			ifTrue: ["two are the same, combine them"				values _ values copyReplaceFrom: ind to: ind with: #().				runs at: ind-1 put: (runs at: ind-1) + (runs at: ind).				runs _ runs copyReplaceFrom: ind to: ind with: #().				"self error: 'needed to combine runs' "]].			! !!RunArray methodsFor: 'adding' stamp: 'BG 6/12/2003 11:07'!rangeOf: attr startingAt: startPos	"Answer an interval that gives the range of attr at index position  startPos. An empty interval with start value startPos is returned when the attribute attr is not present at position startPos.  self size > 0 is assumed, it is the responsibility of the caller to test for emptiness of self.Note that an attribute may span several adjancent runs. "	self at: startPos 		setRunOffsetAndValue:             [:run :offset :value |                ^(value includes: attr)                  ifFalse: [startPos to: startPos - 1]                  ifTrue:                    [ | firstRelevantPosition lastRelevantPosition idxOfCandidateRun |                     lastRelevantPosition := startPos - offset + (runs at: run) - 1.                     firstRelevantPosition := startPos - offset.                     idxOfCandidateRun := run + 1.                     [idxOfCandidateRun <= runs size                              and: [(values at: idxOfCandidateRun) includes: attr]]                        whileTrue:                          [lastRelevantPosition := lastRelevantPosition + (runs at: idxOfCandidateRun).                           idxOfCandidateRun := idxOfCandidateRun + 1].                      idxOfCandidateRun := run - 1.                     [idxOfCandidateRun >= 1                              and: [(values at: idxOfCandidateRun) includes: attr]]                        whileTrue:                          [firstRelevantPosition := firstRelevantPosition - (runs at: idxOfCandidateRun).                           idxOfCandidateRun := idxOfCandidateRun - 1].                      firstRelevantPosition to: lastRelevantPosition]		  ]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:48'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs _ runs copyWith: times.		values _ values copyWith: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:48'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs _ runs copyWith: 1.		values _ values copyWith: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ar 10/16/2001 18:57'!, aRunArray 	"Answer a new RunArray that is a concatenation of the receiver and	aRunArray."	| new newRuns |	(aRunArray isMemberOf: RunArray)		ifFalse: 			[new _ self copy.			"attempt to be sociable"			aRunArray do: [:each | new addLast: each].			^new].	runs size = 0 ifTrue: [^aRunArray copy].	aRunArray runs size = 0 ifTrue: [^self copy].	(values at: values size) ~= (aRunArray values at: 1)		ifTrue: [^RunArray					runs: runs , aRunArray runs					values: values , aRunArray values].	newRuns _ runs					copyReplaceFrom: runs size					to: runs size					with: aRunArray runs.	newRuns at: runs size put: (runs at: runs size) + (aRunArray runs at: 1).	^RunArray		runs: newRuns		values: 			(values				copyReplaceFrom: values size				to: values size				with: aRunArray values)! !!RunArray methodsFor: 'copying' stamp: 'ls 10/10/1999 13:15'!copyFrom: start to: stop	| newRuns run1 run2 offset1 offset2 | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:r :o :value1 | run1 _ r. offset1_ o.  value1].	self at: stop setRunOffsetAndValue: [:r :o :value2 | run2 _ r. offset2_ o. value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacement	^(self copyFrom: 1 to: start - 1)		, replacement 		, (self copyFrom: stop + 1 to: self size)! !!RunArray methodsFor: 'printing' stamp: 'sma 6/1/2000 09:47'!printOn: aStream	self printNameOn: aStream.	aStream		nextPutAll: ' runs: ';		print: runs;		nextPutAll: ' values: ';		print: values! !!RunArray methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	aStream nextPutAll: self class name.	aStream nextPutAll: ' runs: '.	runs storeOn: aStream.	aStream nextPutAll: ' values: '.	values storeOn: aStream.	aStream nextPut: $)! !!RunArray methodsFor: 'printing'!writeOn: aStream	aStream nextWordPut: runs size.	1 to: runs size do:		[:x |		aStream nextWordPut: (runs at: x).		aStream nextWordPut: (values at: x)]! !!RunArray methodsFor: 'printing' stamp: 'tk 12/16/97 09:18'!writeScanOn: strm	"Write out the format used for text runs in source files. (14 50 312)f1,f1b,f1LInteger +;i"	strm nextPut: $(.	runs do: [:rr | rr printOn: strm.  strm space].	strm skip: -1; nextPut: $).	values do: [:vv |		vv do: [:att | att writeScanOn: strm].		strm nextPut: $,].	strm skip: -1.  "trailing comma"! !!RunArray methodsFor: 'private'!at: index setRunOffsetAndValue: aBlock 	"Supply all run information to aBlock."	"Tolerates index=0 and index=size+1 for copyReplace: "	| run limit offset |	limit _ runs size.	(lastIndex == nil or: [index < lastIndex])		ifTrue:  "cache not loaded, or beyond index - start over"			[run _ 1.			offset _ index-1]		ifFalse:  "cache loaded and before index - start at cache"			[run _ lastRun.			offset _ lastOffset + (index-lastIndex)].	[run <= limit and: [offset >= (runs at: run)]]		whileTrue: 			[offset _ offset - (runs at: run).			run _ run + 1].	lastIndex _ index.  "Load cache for next access"	lastRun _ run.	lastOffset _ offset.	run > limit		ifTrue: 			["adjustment for size+1"			run _ run - 1.			offset _ offset + (runs at: run)].	^aBlock		value: run	"an index into runs and values"		value: offset	"zero-based offset from beginning of this run"		value: (values at: run)	"value for this run"! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values _ values collect: [:val | mapBlock value: val]! !!RunArray methodsFor: 'private'!runs	^runs! !!RunArray methodsFor: 'private' stamp: 'ar 10/16/2001 18:47'!setRuns: newRuns setValues: newValues	lastIndex _ nil.  "flush access cache"	runs _ newRuns asArray.	values _ newValues asArray.! !!RunArray methodsFor: 'private'!values	"Answer the values in the receiver."	^values! !!RunArray methodsFor: 'enumerating' stamp: 'ar 12/17/2001 00:00'!runsFrom: start to: stop do: aBlock	"Evaluate aBlock with all existing runs in the range from start to stop"	| run value index |	start > stop ifTrue:[^self].	self at: start setRunOffsetAndValue:[:firstRun :offset :firstValue|		run _ firstRun.		value _ firstValue.		index _ start + (runs at: run) - offset.		[aBlock value: value.		index <= stop] whileTrue:[			run _ run + 1.			value _ values at: run.			index _ index + (runs at: run)]].! !!RunArray methodsFor: 'converting' stamp: 'BG 6/8/2003 15:17'!reversed

  ^self class runs: runs reversed values: values reversed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RunArray class	instanceVariableNames: ''!!RunArray class methodsFor: 'instance creation' stamp: 'ar 10/16/2001 19:03'!new	^self runs: Array new values: Array new! !!RunArray class methodsFor: 'instance creation' stamp: 'ar 10/16/2001 19:04'!new: size withAll: value 	"Answer a new instance of me, whose every element is equal to the	argument, value."	size = 0 ifTrue: [^self new].	^self runs: (Array with: size) values: (Array with: value)! !!RunArray class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection _ self new.	aCollection do: [:x | newCollection addLast: x].	^newCollection"	RunArray newFrom: {1. 2. 2. 3}	{1. $a. $a. 3} as: RunArray	({1. $a. $a. 3} as: RunArray) values"! !!RunArray class methodsFor: 'instance creation'!readFrom: aStream	"Answer an instance of me as described on the stream, aStream."	| size runs values |	size _ aStream nextWord.	runs _ Array new: size.	values _ Array new: size.	1 to: size do:		[:x |		runs at: x put: aStream nextWord.		values at: x put: aStream nextWord].	^ self runs: runs values: values! !!RunArray class methodsFor: 'instance creation'!runs: newRuns values: newValues 	"Answer an instance of me with runs and values specified by the 	arguments."	| instance |	instance _ self basicNew.	instance setRuns: newRuns setValues: newValues.	^instance! !!RunArray class methodsFor: 'instance creation' stamp: 'ssa 9/3/2008 11:15'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds.  These are written by the implementors of writeScanOn:"	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv _ OrderedCollection new.	"Value array"	aa _ OrderedCollection new.	"Attributes list"	[(this _ strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa _ OrderedCollection new].		this == $a ifTrue: [aa add: 			(TextAlignment new alignment: (Integer readFrom: strm))].		this == $f ifTrue: [aa add: 			(TextFontChange new fontNumber: (Integer readFrom: strm))].		this == $F ifTrue: [aa add: (TextFontReference new toFont: 			(StrikeFont familyName: (strm upTo: $#) size: (Integer readFrom: strm)))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"	"	this == $R ifTrue: [aa add: (TextURL scanFrom: strm)]."				"R capitalized so it can follow a number"	"	this == $q ifTrue: [aa add: (TextSqkPageLink scanFrom: strm)]. "	"	this == $p ifTrue: [aa add: (TextSqkProjectLink scanFrom: strm)]. "		this == $P ifTrue: [aa add: (TextPrintIt scanFrom: strm)].		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !Number subclass: #ScaledDecimal	instanceVariableNames: 'fraction scale'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!ScaledDecimal commentStamp: '<historical>' prior: 0!ScaledDecimal provides a numeric representation of fixed point decimal numbers able to accurately represent decimal fractions.  It supports unbounded precision, with no limit to the number of digits before and after the decimal point.	ScaledDecimal complies with the ANSI protocols:	Object	number	ScaledDecimal	????#todo. "finish protocol list."Implementation Notes:	I implemented ScaledDecimal with the decimal fraction stored in instance variables numerator and denominator, and the number of digits after the decimal point in fractionalDigit as a positive Integer.  I implemented operations by first coercing the aurguments to fractions, doing the operations, then coercing the result to the proper numeric representation when necessary and scale.  This is because I assume the Fraction class is more likely to implement them correctly.  Richard A. Harmon!!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToFraction: receiver andSend: arithmeticOpSelector 	"Convert me to a Fraction and do the arithmetic. 	receiver arithmeticOpSelector self."	^ receiver perform: arithmeticOpSelector with: fraction! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToInteger: receiver andSend: arithmeticOpSelector 	"Convert receiver to a ScaledDecimal and do the arithmetic. 	receiver arithmeticOpSelector self."	^ (receiver asScaledDecimal: 0)		perform: arithmeticOpSelector with: self! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFloat	"Reimplementation - Number 'converting' method."	^ fraction asFloat! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFraction	"Implementation - Number 'converting' method."	^ fraction! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scaleIn 	"Reimplementation - Number 'converting' method."	^ ScaledDecimal newFromNumber: fraction scale: scaleIn! !!ScaledDecimal methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printOn: aStream 	"Reimplementation - Object 'printing' method."	| aFraction tmpFractionPart |	self < 0 ifTrue: [aStream nextPut: $-].	aFraction := fraction abs.	aStream nextPutAll: aFraction truncated printString.	scale = 0 ifTrue: [^ aStream nextPutAll: 's0'].	aStream nextPut: $..	tmpFractionPart := aFraction fractionPart.	1 to: scale		do: 			[:dummy | 			tmpFractionPart := tmpFractionPart * 10.			aStream nextPut: (Character digitValue: tmpFractionPart truncated).			tmpFractionPart := tmpFractionPart fractionPart].	aStream nextPut: $s.	scale printOn: aStream! !!ScaledDecimal methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printString	"Reimplementation - Number 'printing' method."	| tempStream |	tempStream := WriteStream on: (String new: 10).	self printOn: tempStream.	^ tempStream contents! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!* operand 	"Implementation of Number 'arithmetic' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction * operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #*! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!+ operand 	"Implementation of Number 'arithmetic' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction + operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #+! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!- operand 	"Implementation of Number 'arithmetic' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction - operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #-! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!/ operand 	"Implementation of Number 'arithmetic' method."	#ScalDec.	"Protocol: ANSI <number>."	operand = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction / operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #/! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!// operand 	"Answer the integer quotient after dividing the receiver by operand 	with truncation towards negative infinity."	^ fraction // operand! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!negated	"Reimplementation of Number 'arithmetic' method."	^ ScaledDecimal newFromNumber: fraction negated scale: scale! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	"Reimplementation of Number 'arithmetic' method."	self = 0 ifTrue: [^ (ZeroDivide dividend: 1) signal].	^ ScaledDecimal newFromNumber: fraction reciprocal scale: scale! !!ScaledDecimal methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!fractionPart	"Answer the fractional part of the receiver."	^ ScaledDecimal newFromNumber: fraction fractionPart scale: scale! !!ScaledDecimal methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!integerPart	"Answer the fractional part of the receiver."	^ ScaledDecimal newFromNumber: fraction integerPart scale: scale! !!ScaledDecimal methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!truncated	"Reimplementation of Number 'truncation and round off' method."	^ fraction truncated! !!ScaledDecimal methodsFor: 'comparing' stamp: 'AFi 11/23/2002 19:12'!< operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction < operand asFraction].	^ operand adaptToScaledDecimal: self andSend: #<! !!ScaledDecimal methodsFor: 'comparing' stamp: 'AFi 11/23/2002 19:13'!= comparand 	"Implementation of Number 'comparing' method."	comparand isNumber ifFalse: [^ false].	(comparand isKindOf: ScaledDecimal) ifTrue: [^ fraction = comparand asFraction].	^ comparand adaptToScaledDecimal: self andSend: #=! !!ScaledDecimal methodsFor: 'comparing' stamp: 'RAH 4/25/2000 19:49'!hash	"Reimplementation of Object 'comparing' method."	^ fraction hash! !!ScaledDecimal methodsFor: 'comparing' stamp: 'RAH 4/25/2000 19:49'!isZero	"Answer whether the receiver is equal to its class' zero"	^ fraction numerator = 0! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!denominator	"Private - Answer an Integer, the denominator part of the receiver."	^ fraction denominator! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!numerator	"Private - Answer an Integer, the numerator part of the receiver."	^ fraction numerator! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!scale	"Private - Answer a integer which represents the total number of digits 	used to represent the fraction part of the receiver, including trailing 	zeroes. "	^ scale! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!setFraction: fractionIn scale: scaleIn 	"Private - Set the fraction to fractionIn and the total number of digits 	used to represent the fraction part of the receiver, including trailing 	zeroes, to the Integer scaleIn."	fraction := fractionIn.	scale := scaleIn! !!ScaledDecimal methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49'!squared	"Reimplementation - Number 'mathematical functions' method."	"not used ->"	^ ScaledDecimal newFromNumber: fraction squared scale: scale! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScaledDecimal class	instanceVariableNames: ''!!ScaledDecimal class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!newFromNumber: aNumber scale: scaleIn 	"Answer a new instance of me."	| temp |	temp := self basicNew.	temp setFraction: aNumber asFraction scale: scaleIn.	^ temp! !!ScaledDecimal class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	"Answer the receiver's representation of one."	^ self newFromNumber: 1 scale: 0! !!ScaledDecimal class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!zero	"Answer the receiver's representation of zero."	^ self newFromNumber: 0 scale: 0! !Object subclass: #Scanner	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable'	classVariableNames: 'TypeTable'	poolDictionaries: ''	category: 'System-Compiler'!!Scanner commentStamp: '<historical>' prior: 0!I scan a string or text, picking out Smalltalk syntactic tokens. I look one character ahead. I put each token found into the instance variable, token, and its type (a Symbol) into the variable, tokenType. At the end of the input stream, I pretend to see an endless sequence of special characters called doits.!!Scanner methodsFor: 'initialize-release'!initScanner	buffer _ WriteStream on: (String new: 40).	typeTable _ TypeTable! !!Scanner methodsFor: 'initialize-release'!scan: inputStream 	"Bind the input stream, fill the character buffers and first token buffer."	source _ inputStream.	self step.	self step.	self scanToken! !!Scanner methodsFor: 'public access'!scanFieldNames: stringOrArray	"Answer an Array of Strings that are the identifiers in the input string, 	stringOrArray. If passed an Array, just answer with that Array, i.e., 	assume it has already been scanned."	| strm |	(stringOrArray isMemberOf: Array)		ifTrue: [^stringOrArray].	self scan: (ReadStream on: stringOrArray asString).	strm _ WriteStream on: (Array new: 10).	[tokenType = #doIt]		whileFalse: 			[tokenType = #word ifTrue: [strm nextPut: token].			self scanToken].	^strm contents	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !!Scanner methodsFor: 'public access'!scanTokens: textOrString 	"Answer an Array that has been tokenized as though the input text, 	textOrString, had appeared between the array delimitors #( and ) in a 	Smalltalk literal expression."	self scan: (ReadStream on: textOrString asString).	self scanLitVec.	^token	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !!Scanner methodsFor: 'expression types'!advance	| prevToken |	prevToken _ token.	self scanToken.	^prevToken! !!Scanner methodsFor: 'expression types' stamp: 'di 4/23/2000 22:15'!checkpoint	"Return a copy of all changeable state.  See revertToCheckpoint:"	^ {self clone. source clone. currentComment copy}! !!Scanner methodsFor: 'expression types' stamp: 'di 4/23/2000 22:11'!revertToCheckpoint: checkpoint	"Revert to the state when checkpoint was made."	| myCopy |	myCopy _ checkpoint first.	1 to: self class instSize do:		[:i | self instVarAt: i put: (myCopy instVarAt: i)].	source _ checkpoint second.	currentComment _ checkpoint third! !!Scanner methodsFor: 'expression types' stamp: 'avi 2/16/2004 21:28'!scanLitVec	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanLitVec]				ifFalse: 					[tokenType = #word | (tokenType = #keyword) | (tokenType = #colon)						ifTrue: 							[self scanLitWord.							token = #true ifTrue: [token _ true].							token = #false ifTrue: [token _ false].							token = #nil ifTrue: [token _ nil]]						ifFalse:							[(token == #- 									and: [(typeTable at: hereChar asciiValue) = #xDigit])								ifTrue: 									[self scanToken.									token _ token negated]]].			s nextPut: token.			self scanToken].	token _ s contents! !!Scanner methodsFor: 'expression types'!scanLitWord	"Accumulate keywords and asSymbol the result."	| t |	[(typeTable at: hereChar asciiValue) = #xLetter]		whileTrue: 			[t _ token.			self xLetter.			token _ t , token].	token _ token asSymbol! !!Scanner methodsFor: 'expression types'!scanToken	[(tokenType _ typeTable at: hereChar asciiValue) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark _ source position - 1.	(tokenType at: 1) = $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token _ self step asSymbol "else just unique the first char"].	^token! !!Scanner methodsFor: 'expression types'!step	| c |	c _ hereChar.	hereChar _ aheadChar.	source atEnd		ifTrue: [aheadChar _ 30 asCharacter "doit"]		ifFalse: [aheadChar _ source next].	^c! !!Scanner methodsFor: 'multi-character scans' stamp: 'SqR 8/23/2000 16:20'!xBinary	tokenType _ #binary.	token _ self step asSymbol.	[(typeTable at: hereChar asciiValue) = #xBinary and: [hereChar ~= $-]]		whileTrue: [token _ (token , (String with: self step)) asSymbol]! !!Scanner methodsFor: 'multi-character scans' stamp: 'md 11/14/2003 17:14'!xColon		"Allow := for assignment by converting to #_ "	aheadChar = $= ifTrue:		[self step.		tokenType _ #leftArrow.		self step.		^ token _ #'_'].	"Otherwise, just do what normal scan of colon would do"	tokenType _ #colon.	^ token _ self step asSymbol! !!Scanner methodsFor: 'multi-character scans'!xDelimiter	"Ignore blanks, etc."	self scanToken! !!Scanner methodsFor: 'multi-character scans' stamp: 'tao 4/23/98 12:55'!xDigit	"Form a number."	tokenType _ #number.	(aheadChar = 30 asCharacter and: [source atEnd			and:  [source skip: -1. source next ~= 30 asCharacter]])		ifTrue: [source skip: -1 "Read off the end last time"]		ifFalse: [source skip: -2].	token _ [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].	self step; step! !!Scanner methodsFor: 'multi-character scans'!xDollar	"Form a Character literal."	self step. "pass over $"	token _ self step.	tokenType _ #number "really should be Char, but rest of compiler doesn't know"! !!Scanner methodsFor: 'multi-character scans' stamp: 'wod 1/10/98 00:43'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."    | aStream stopChar |    stopChar _ 30 asCharacter.    aStream _ WriteStream on: (String new: 200).    self step.    [hereChar == $"]        whileFalse:            [(hereChar == stopChar and: [source atEnd])                ifTrue: [^self offEnd: 'Unmatched comment quote'].            aStream nextPut: self step.].    self step.    currentComment == nil        ifTrue: [currentComment _ OrderedCollection with: aStreamcontents]        ifFalse: [currentComment add: aStream contents].    self scanToken! !!Scanner methodsFor: 'multi-character scans' stamp: 'di 4/22/2000 16:36'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type == #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			["Allow any number of embedded colons in literal symbols"			(typeTable at: hereChar asciiValue) == #xColon]				whileTrue: [buffer nextPut: self step].			tokenType _ #keyword]		ifFalse: 			[tokenType _ #word].	token _ buffer contents! !!Scanner methodsFor: 'multi-character scans' stamp: 'hmm 7/18/2001 21:55'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start _ mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanLitVec.			mark _ start+1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[(token isMemberOf: Symbol)								ifTrue: "##word"									[token _ token "May want to move toward ANSI here"]]						ifFalse:							[tokenType==#string ifTrue: [token _ token asSymbol]]]].	mark _ start.	tokenType _ #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!Scanner methodsFor: 'multi-character scans'!xSingleQuote	"String."	self step.	buffer reset.	[hereChar = $' 		and: [aheadChar = $' 				ifTrue: [self step. false]				ifFalse: [true]]]		whileFalse: 			[buffer nextPut: self step.			(hereChar = 30 asCharacter and: [source atEnd])				ifTrue: [^self offEnd: 'Unmatched string quote']].	self step.	token _ buffer contents.	tokenType _ #string! !!Scanner methodsFor: 'error handling'!notify: string 	"Refer to the comment in Object|notify:." 	self error: string! !!Scanner methodsFor: 'error handling'!offEnd: aString 	"Parser overrides this"	^self notify: aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Scanner class	instanceVariableNames: ''!!Scanner class methodsFor: 'class initialization' stamp: 'dgd 8/24/2003 14:55'!initialize	| newTable |	newTable _ Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable _ newTable "bon voyage!!"	"Scanner initialize"! !!Scanner class methodsFor: 'instance creation'!new	^super new initScanner! !!Scanner class methodsFor: 'testing' stamp: 'bf 4/27/2000 12:56'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()#0123456789' includes: (aSymbol at: 1))		ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !Timespan subclass: #Schedule	instanceVariableNames: 'schedule'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!!Schedule commentStamp: 'brp 5/13/2003 09:48' prior: 0!I represent a powerful class for implementing recurring schedules.!!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!between: aStart and: anEnd do: aBlock
	| element end i |	end _ self end min: anEnd.	element _ self start.
		i _ 1.	[ element < aStart ] whileTrue:	
	[ element _ element + (schedule at: i).
		i _ i + 1. (i > schedule size) ifTrue: [i _ 1]].
	i _ 1.
	[ element <= end ] whileTrue:	
	[ aBlock value: element.		element _ element + (schedule at: i).
		i _ i + 1.		(i > schedule size) ifTrue: [i _ 1]]
.! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!schedule	^ schedule
! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!schedule: anArrayOfDurations	schedule _ anArrayOfDurations
! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:51'!scheduleDo: aBlock	self between: (self start) and: (self end) do: aBlock.
! !!Schedule methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:38'!includes: aDateAndTime
	| dt |
	dt _ aDateAndTime asDateAndTime.
	self scheduleDo: [ :e | e = dt ifTrue: [^true] ].
	^ false.
! !Controller subclass: #ScreenController	instanceVariableNames: ''	classVariableNames: 'LastScreenModeSelected'	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!ScreenController commentStamp: '<historical>' prior: 0!I am the controller for the parts of the display screen that have no view on them. I only provide a standard yellow button menu. I view (a FormView of) an infinite gray form.  (ScheduledControllers screenController) is the way to find me.!!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:21'!controlActivity	"Any button opens the screen's menu.	If the shift key is down, do find window."	sensor leftShiftDown ifTrue: [^ self findWindow].	(self projectScreenMenu invokeOn: self) ifNil: [super controlActivity]! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:06'!isControlActive	^ self isControlWanted! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:05'!isControlWanted	^ self viewHasCursor and: [sensor anyButtonPressed]! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 2/15/1999 16:18'!aboutThisSystem 	Smalltalk aboutThisSystem! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:25'!bitCachingString	^ StandardSystemView cachingBits		ifTrue: ['don''t save bits (compact)']		ifFalse: ['save bits (fast)']! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/23/2003 15:17'!browseChangedMessages	ChangeSet  browseChangedMessages! !!ScreenController methodsFor: 'menu messages'!browseRecentLog	"Open a changelist browser on changes submitted since the last snapshot.  1/17/96 sw"	ChangeList browseRecentLog! !!ScreenController methodsFor: 'menu messages'!browseRecentSubmissions	"Open a method-list browser on recently-submitted methods.  5/16/96 sw"	Utilities browseRecentSubmissions! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:50'!changeWindowPolicy	Preferences toggleWindowPolicy! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:12'!chooseDirtyBrowser	"Put up a list of browsers with unsubmitted edits and activate the one selected by the user, if any."	"ScheduledControllers screenController chooseDirtyBrowser"	ScheduledControllers findWindowSatisfying:		[:c | (c model isKindOf: Browser) and: [c model canDiscardEdits not]]. ! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!chooseDirtyWindow	"Put up a list of windows with unaccepted edits and let the user chose one to activate."	"ScheduledControllers screenController chooseDirtyWindow"	ScheduledControllers findWindowSatisfying:		[:c | c model canDiscardEdits not].! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!closeUnchangedWindows	"Close any window that doesn't have unaccepted input."	| clean |	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	clean _ ScheduledControllers scheduledControllers select:		[:c | c model canDiscardEdits and: [(c isKindOf: ScreenController) not]].	clean do: [:c | c closeAndUnscheduleNoTerminate].	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages'!collapseAll	"Collapses all open windows"	ScheduledControllers scheduledControllers do:		[:controller | controller == self ifFalse:			[controller view isCollapsed ifFalse:					[controller collapse.					controller view deEmphasize]]]! !!ScreenController methodsFor: 'menu messages'!commonRequests 	"Put up a popup of common requests, and perform whatever the user request.  2/1/96 sw"	Utilities offerCommonRequests! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 12/10/1999 11:29'!configureFonts	Preferences presentMvcFontConfigurationMenu! !!ScreenController methodsFor: 'menu messages'!editPreferences	"Open up a Preferences inspector.  2/7/96 sw"	Preferences openPreferencesInspector! !!ScreenController methodsFor: 'menu messages'!emergencyCollapse	"Emergency collapse of a selected window"	| controller |	(controller _ ScheduledControllers windowFromUser) notNil		ifTrue:			[controller collapse.			controller view deEmphasize]! !!ScreenController methodsFor: 'menu messages'!expandAll	"Reopens all collapsed windows"	ScheduledControllers scheduledControllers reverseDo:		[:controller | controller == self ifFalse:			[controller view isCollapsed				ifTrue:  [controller view expand]				ifFalse: [controller view displayDeEmphasized]]]! !!ScreenController methodsFor: 'menu messages'!fastWindows	StandardSystemView cachingBits		ifTrue: [StandardSystemView dontCacheBits]		ifFalse: [StandardSystemView doCacheBits]! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 2/3/2000 16:23'!fileForRecentLog	Smalltalk writeRecentToFile! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 1/16/2004 21:32'!fileOutChanges	ChangeSet current verboseFileOut.! !!ScreenController methodsFor: 'menu messages'!findWindow	"Put up a menu of all windows on the screen, and let the user select one.	 1/18/96 sw: the real work devolved to ControlManager>>findWindowSatisfying:"	ScheduledControllers findWindowSatisfying: [:c | true]! !!ScreenController methodsFor: 'menu messages' stamp: 'nk 6/17/2003 14:39'!fontSizeSummary	TextStyle fontSizeSummary! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 6/7/2003 19:49'!fullScreenOff	Display fullScreenMode: (LastScreenModeSelected _ false).	DisplayScreen checkForNewScreenSize.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 6/7/2003 19:49'!fullScreenOn	Display fullScreenMode: (LastScreenModeSelected _ true).	DisplayScreen checkForNewScreenSize.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'nk 2/15/2004 09:37'!garbageCollect	"Do a garbage collection, and report results to the user."	Utilities garbageCollectAndReport! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/20/1998 23:28'!jumpToProject	Project jumpToProject.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/23/2003 14:41'!lookForSlips	ChangeSet current lookForSlips! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/18/1999 20:54'!lookUpDefinition	Utilities lookUpDefinition! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 10:17'!newChangeSet	ChangeSorter newChangeSet! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/6/98 23:14'!openBrowser 	"Create and schedule a Browser view for browsing code."	Browser openBrowser! !!ScreenController methodsFor: 'menu messages'!openChangeManager	"Open a dual change sorter.  For looking at two change sets at once."	DualChangeSorter new open! !!ScreenController methodsFor: 'menu messages'!openCommandKeyHelp	"1/18/96 sw Open a window that explains command-keys"	Utilities openCommandKeyHelp! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/9/1999 12:30'!openFile	FileList openFileDirectly! !!ScreenController methodsFor: 'menu messages'!openFileList	"Create and schedule a FileList view for specifying files to access."	FileList open! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 1/31/2001 17:06'!openPackageBrowser 	"Create and schedule a Browser view for browsing code."	PackagePaneBrowser openBrowser! !!ScreenController methodsFor: 'menu messages' stamp: 'ssa 9/4/2008 15:11'!openProcessBrowser	"Create and schedule"	ProcessBrowser  open! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 4/24/2001 12:00'!openProject 	"Create and schedule a Project."	| proj |	Smalltalk at: #ProjectView ifPresent:		[:c | proj _ Project new.		c open: proj].! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 8/31/1998 16:18'!openSelectorBrowser	"Create and schedule a selector fragment window."	SelectorBrowser new open! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController methodsFor: 'menu messages'!openStandardWorkspace	"Open a standard, throwaway window chock full of useful expressions.  1/17/96 sw"	Utilities openStandardWorkspace! !!ScreenController methodsFor: 'menu messages' stamp: 'di 5/8/1998 12:49'!openTranscript 	"Create and schedule the System Transcript."	Transcript open! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 5/4/1998 17:25'!openWorkspace 	"Create and schedule workspace."	Workspace open! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 14:17'!quit	SmalltalkImage current		snapshot:			(self confirm: 'Save changes before quitting?' translated				orCancel: [^ self])		andQuit: true! !!ScreenController methodsFor: 'menu messages' stamp: 'ssa 9/3/2008 11:12'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Display extent = DisplayScreen actualScreenSize		ifFalse:			[DisplayScreen startUp.			ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/22/1998 06:45'!returnToPreviousProject	Project returnToPreviousProject.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 13:17'!saveAs	^ SmalltalkImage current saveAs! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/10/96'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	Utilities setAuthorInitials! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/26/96'!setDesktopColor	"Let the user choose a new color for the desktop.   Based on an idea by Georg Gollmann.   "	Preferences desktopColor: Color fromUser.	ScheduledControllers updateGray; restore! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 9/18/1999 20:01'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result _ (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption: 'Choose a display depth(it is currently ' , Display depth printString , ')') == nil ifFalse:		[Display newDepth: result]! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 14:17'!snapshot	SmalltalkImage current snapshot: true andQuit: false! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 14:17'!snapshotAndQuit	"Snapshot and quit without bother the user further.  2/4/96 sw"	SmalltalkImage current		snapshot: true		andQuit: true! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:01'!soundEnablingString	^ Preferences soundEnablingString! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 3/16/2000 18:26'!soundOnOrOff	Preferences setPreference: #soundsEnabled		toValue: Preferences soundsEnabled not! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:23'!staggerPolicyString	^ Preferences staggerPolicyString! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 9/30/2003 13:53'!vmStatistics	"Open a string view on a report of vm statistics"	(StringHolder new contents: SmalltalkImage current  vmStatisticsReportString)		openLabel: 'VM Statistics'! !!ScreenController methodsFor: 'cursor'!centerCursorInView	"Override so this doesn't happen when taking control"! !!ScreenController methodsFor: 'nested menus' stamp: 'BG 10/30/2003 21:19'!appearanceMenu 	"Answer the appearance menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#('system fonts...'			'full screen on'			'full screen off'			'set display depth...'			'set desktop color...' ) 		lines: #(1 3)		selections: #( configureFontsfullScreenOn fullScreenOff setDisplayDepth setDesktopColor)"ScreenController new appearanceMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'BG 10/30/2003 20:39'!changesMenu
	"Answer a menu for changes-related items"
	^ SelectionMenu labelList:
		#(	'simple change sorter'
			'dual change sorter'

			'file out current change set'
			'create new change set...'
			'browse changed methods'
			'check change set for slips'

		
			'browse recent submissions'
			'recently logged changes...'
			'recent log file...'
			)
		lines: #(2 6 )
		selections: #(
openSimpleChangeSorter openChangeManager
fileOutChanges newChangeSet browseChangedMessages lookForSlips
browseRecentSubmissions browseRecentLog fileForRecentLog)
"
ScreenController new changesMenu startUp
"! !!ScreenController methodsFor: 'nested menus' stamp: 'BG 11/2/2003 20:57'!helpMenu 
	"Answer the help menu to be put up as a screen submenu"

	^ SelectionMenu labelList:
		#(	'about this system...'
			'preferences...'

			'command-key help'
			'font size summary'
			'useful expressions'
			'view graphical imports'),

			(Array with: (Preferences soundsEnabled
							ifFalse: ['turn sound on']
							ifTrue: ['turn sound off'])) ,

		#(	'definition for...'
			'set author initials...'
			'vm statistics'
			'space left')
		lines: #(2 4 8)
		selections: #( aboutThisSystem 
editPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImports
 soundOnOrOff  lookUpDefinition setAuthorInitials vmStatistics garbageCollect)
"
ScreenController new helpMenu startUp
"! !!ScreenController methodsFor: 'nested menus' stamp: 'ssa 9/4/2008 15:11'!openMenu
	^ SelectionMenu labelList:
		#(	'browser'
			'package browser'
			'method finder'			'process browser'
			'workspace'
			'file list'
			'file...'
			'transcript'

			'simple change sorter'
			'dual change sorter'

			'mvc project'
			)
		lines: #(8 10 )
		selections: #(
openBrowser openPackageBrowser openSelectorBrowser openProcessBrowser openWorkspace openFileList openFile openTranscript 
openSimpleChangeSorter openChangeManager
openProject    )
"
ScreenController  new openMenu startUp
"! !!ScreenController methodsFor: 'nested menus' stamp: 'sma 3/11/2000 12:23'!popUpMenuFor: aSymbol	(self perform: aSymbol) invokeOn: self! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/13/1999 18:07'!presentAppearanceMenu	self popUpMenuFor: #appearanceMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'BG 10/28/2003 10:38'!projectScreenMenu
	"Answer the project screen menu."

	^ SelectionMenu labelList:
		#(	'previous project'
			'jump to project...'
			'restore display'

			'open...'
			'windows...'
			'changes...'
			'help...'
			'appearance...'
			'do...'

			'save'
			'save as...'
			'save and quit'
			'quit')
		lines: #(3 9)
		selections: #(
returnToPreviousProject jumpToProject restoreDisplay
presentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu presentAppearanceMenu commonRequests
snapshot saveAs snapshotAndQuit quit )
"
ScreenController new projectScreenMenu startUp
"! !!ScreenController methodsFor: 'nested menus' stamp: 'BG 10/28/2003 10:57'!windowMenu
	"Answer a menu for windows-related items.  "

	^ SelectionMenu labelList:
		#(	'find window...'
			'find changed browsers...'
			'find changed windows...'

			'collapse all windows'
			'expand all windows'
			'close unchanged windows' ) , 
			(Array
				with: self bitCachingString
				with: self staggerPolicyString)
		lines: #(3 6)
		selections: #(
findWindow chooseDirtyBrowser chooseDirtyWindow
collapseAll expandAll closeUnchangedWindows
fastWindows changeWindowPolicy)
"
ScreenController new windowMenu startUp
"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScreenController class	instanceVariableNames: ''!!ScreenController class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 09:28'!lastScreenModeSelected	^LastScreenModeSelected! !MouseMenuController subclass: #ScrollController	instanceVariableNames: 'scrollBar marker savedArea menuBar savedMenuBarArea'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!ScrollController commentStamp: '<historical>' prior: 0!I represent control for scrolling using a scrollBar. I am a MouseMenuController that creates a scrollBar, rather than menus. My subclasses add the button menus. I keep control as long as the cursor is inside the view or the scrollBar area.	A scrollBar is a rectangular area representing the length of the information being viewed. It contains an inner rectangle whose top y-coordinate represents the relative position of the information visible on the screen with respect to all of the information, and whose size represents the relative amount of that information visible on the screen. The user controls which part of the information is visible by pressing the red button. If the cursor is to the right of the inner rectangle, the window onto the visible information moves upward, if the cursor is to the left, the window moves downward, and if the cursor is inside, the inner rectangle is grabbed and moved to a desired position.!!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar _ Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker _ Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar _ Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar _ scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker _ marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea _ Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar _ Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'basic control sequence'!controlTerminate	super controlTerminate.	savedArea notNil 			ifTrue: 			[savedArea displayOn: Display at: scrollBar topLeft.			savedArea _ nil].! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:17'!controlActivity	self scrollByKeyboard ifTrue: [^ self].	self scrollBarContainsCursor		ifTrue: [self scroll]		ifFalse: [self normalActivity]! !!ScrollController methodsFor: 'control defaults' stamp: 'ar 3/24/2000 00:45'!isControlActive 	super isControlActive ifTrue: [^ true].	sensor blueButtonPressed ifTrue: [^ false].	^ (scrollBar inside merge: view insetDisplayBox) containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:31'!isControlWanted	^ self viewHasCursor! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:16'!normalActivity	super controlActivity! !!ScrollController methodsFor: 'scrolling'!anyButtonActivity	"deal with red button down in scrollBar beyond yellowLine"	self yellowButtonActivity! !!ScrollController methodsFor: 'scrolling'!downLine	"if cursor before downLine, display down cursor and scroll down on button down"	^scrollBar left + 6 ! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling'!scrollAmount	"Answer the number of bits of y-coordinate should be scrolled. This is a 	default determination based on the view's preset display transformation."	^((view inverseDisplayTransform: sensor cursorPoint)		- (view inverseDisplayTransform: scrollBar inside topCenter)) y! !!ScrollController methodsFor: 'scrolling' stamp: 'th 12/11/1999 16:57'!scrollByKeyboard	| keyEvent |	keyEvent _ sensor keyboardPeek.	keyEvent ifNil: [^ false].	(sensor controlKeyPressed or:[sensor commandKeyPressed]) ifFalse: [^ false].	keyEvent asciiValue = 30		ifTrue: 			[sensor keyboard.			self scrollViewDown ifTrue: [self moveMarker].			^ true].	keyEvent asciiValue = 31		ifTrue: 			[sensor keyboard.			self scrollViewUp ifTrue: [self moveMarker].			^ true].	^ false! !!ScrollController methodsFor: 'scrolling'!scrollView	"The scroll bar jump method was used so that the view should be 	updated to correspond to the location of the scroll bar gray area.	Return true only if scrolling took place."	^ self scrollView: self viewDelta! !!ScrollController methodsFor: 'scrolling'!scrollView: anInteger 	"Tell the reciever's view to scroll by anInteger amount.	Return true only if scrolling actually resulted."	(view scrollBy: 0 @ 				((anInteger min: view window top - view boundingBox top)						max: view window top - view boundingBox bottom))		ifTrue: [view clearInside; display.  ^ true]		ifFalse: [^ false]! !!ScrollController methodsFor: 'scrolling'!scrollViewDown	"Scroll the receiver's view down the default amount.	Return true only if scrolling actually took place."	^ self scrollView: self scrollAmount! !!ScrollController methodsFor: 'scrolling'!scrollViewUp	"Scroll the receiver's view up the default amount.	Return true only if scrolling actually took place."	^ self scrollView: self scrollAmount negated! !!ScrollController methodsFor: 'scrolling'!upDownLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!upLine	"if cursor beyond upLine, display up cursor and scroll up on button down"	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!viewDelta	"Answer an integer that indicates how much the view should be scrolled. 	The scroll bar has been moved and now the view must be so the amount 	to scroll is computed as a ratio of the current scroll bar position."	^view window top - view boundingBox top -		((marker top - scrollBar inside top) asFloat /			scrollBar inside height asFloat *				view boundingBox height asFloat) rounded! !!ScrollController methodsFor: 'scrolling'!yellowLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 16! !!ScrollController methodsFor: 'cursor'!changeCursor: aCursor 	"The current cursor should be set to be aCursor."	sensor currentCursor ~~ aCursor ifTrue: [aCursor show]! !!ScrollController methodsFor: 'cursor'!markerContainsCursor	"Answer whether the gray area inside the scroll bar area contains the 	cursor."	^marker inside containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'cursor'!menuBarContainsCursor	"Answer whether the cursor is anywhere within the menu bar area."	^ menuBar notNil and:			[menuBar containsPoint: sensor cursorPoint]! !!ScrollController methodsFor: 'cursor'!scrollBarContainsCursor	"Answer whether the cursor is anywhere within the scroll bar area."	^scrollBar containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'marker adjustment'!computeMarkerRegion	"Answer the rectangular area in which the gray area of the scroll bar 	should be displayed."	^0@0 extent: Preferences scrollBarWidth @			((view window height asFloat /						view boundingBox height *							scrollBar inside height)				 rounded min: scrollBar inside height)! !!ScrollController methodsFor: 'marker adjustment'!markerDelta	^ marker top 		- scrollBar inside top  		- ((view window top - view boundingBox top) asFloat 			/ view boundingBox height asFloat *				scrollBar inside height asFloat) rounded! !!ScrollController methodsFor: 'marker adjustment'!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker _ marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !!ScrollController methodsFor: 'marker adjustment'!moveMarker	"The view window has changed. Update the marker."	self moveMarker: self markerDelta negated anchorMarker: nil! !!ScrollController methodsFor: 'marker adjustment'!moveMarker: anInteger anchorMarker: anchorMarker	"Update the marker so that is is translated by an amount corresponding to 	a distance of anInteger, constrained within the boundaries of the scroll 	bar.  If anchorMarker ~= nil, display the border around the area where the	marker first went down."	Display fill: marker fillColor: scrollBar insideColor.	anchorMarker = nil		ifFalse: [Display border: anchorMarker width: 1 fillColor: Color gray].	marker _ marker translateBy: 0 @				((anInteger min: scrollBar inside bottom - marker bottom) max:					scrollBar inside top - marker top).	marker displayOn: Display! !!ScrollController methodsFor: 'marker adjustment'!moveMarkerTo: aRectangle 	"Same as markerRegion: aRectangle; moveMarker, except a no-op if the marker	 would not move."	(aRectangle height = marker height and: [self viewDelta = 0]) ifFalse:		[self markerRegion: aRectangle.		self moveMarker]! !!ScrollController methodsFor: 'private'!scrollAbsolute	| markerOutline oldY markerForm |	self changeCursor: Cursor rightArrow.	oldY _ -1.	sensor anyButtonPressed ifTrue: 	  [markerOutline _ marker deepCopy.	  markerForm _ Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  Display border: markerOutline width: 1 fillColor: Color gray.	  markerForm 		follow: 			[oldY ~= sensor cursorPoint y				ifTrue: 					[oldY _ sensor cursorPoint y.					marker _ marker translateBy: 					  0 @ ((oldY - marker center y 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).					self scrollView].				marker origin] 		while: [sensor anyButtonPressed].	  Display fill: markerOutline fillColor: scrollBar insideColor.	  self moveMarker]! !!ScrollController methodsFor: 'private'!scrollDown	| markerForm firstTime |	self changeCursor: Cursor down.	sensor anyButtonPressed ifTrue:	  [markerForm _ Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime _ true.	  markerForm 		follow: 			[self scrollViewDown ifTrue:				[marker _ marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime _ false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!ScrollController methodsFor: 'private'!scrollUp	| markerForm firstTime |	self changeCursor: Cursor up.	sensor anyButtonPressed ifTrue:	  [markerForm _ Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime _ true.	  markerForm 		follow: 			[self scrollViewUp ifTrue:				[marker _ marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime _ false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !CompositionScanner subclass: #SegmentScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!SegmentScanner methodsFor: 'as yet unclassified' stamp: 'ar 5/18/2000 16:48'!setFont	super setFont.	"Make a local copy of stop conditions so we don't modify the default"	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions _ stopConditions copy].	stopConditions at: Space asciiValue + 1 put: nil.! !PopUpMenu subclass: #SelectionMenu	instanceVariableNames: 'selections'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections	^ selections! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections: selectionArray	selections _ selectionArray! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object 	the selector corresponding to the menu item selected by the user. Return 	nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"Example:	(SelectionMenu labels: 'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sw 12/17/2001 17:26'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"	| index |	index _ super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.	(selections = nil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu methodsFor: 'invocation' stamp: 'sw 11/18/2002 16:24'!invokeOn: targetObject orSendTo: anObject	"Pop up the receiver, obtaining a selector; return the result of having the target object perform the selector.  If it dos not understand the selector, give the alternate object a chance"	| aSelector |	^ (aSelector _ self startUp) ifNotNil:		[(targetObject respondsTo: aSelector)			ifTrue:				[targetObject perform: aSelector]			ifFalse:				[anObject perform: aSelector]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SelectionMenu class	instanceVariableNames: ''!!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 11/8/1999 17:52'!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList _ OrderedCollection new.	lines _ OrderedCollection new.	selections _ OrderedCollection new.	anIndex _ 0.	anArray do:		[:anElement |			anElement size == 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size == 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex _ anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList lines: lines selections: selections	^ (self labelArray: labelList lines: lines) selections: selections! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList selections: selections	^ self		labelList: labelList		lines: #()		selections: selections! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:09'!labels: labels lines: linesArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string 	with embedded CRs, or a collection of strings."	(labels isKindOf: String)		ifTrue: [^ super labels: labels lines: linesArray]		ifFalse: [^ super labelArray: labels lines: linesArray]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:09'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	^ (self labels: labels lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!labels: labels selections: selectionsArray	"Answer an instance of me whose items are in labels, recording 	the given array of selections corresponding to the items in labels."	^ self		labels: labels		lines: #()		selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray	"Answer an instance of me whose labels and selections are identical."	^ self selections: selectionsArray lines: nil! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray lines: linesArray	"Answer an instance of me whose labels and selections are identical."	^ self		labelList: (selectionsArray collect: [:each | each asString])		lines: linesArray		selections: selectionsArray! !StringHolder subclass: #SelectorBrowser	instanceVariableNames: 'selectorIndex selectorList classListIndex classList'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 12/1/2000 10:38'!byExample	"The comment in the bottom pane"	false ifTrue: [MethodFinder methodFor: #( (4 3) 7  (0 5) 5  (5 5) 10)].		"to keep the method methodFor: from being removed from the system"	^ 'Type a fragment of a selector in the top pane.  Accept it.Or, use an example to find a method in the system.  Type receiver, args, and answer in the top pane with periods between the items.  3. 4. 7Or, in this pane, use examples to find a method in the system.  Select the line of code and choose "print it".  	MethodFinder methodFor: #( (4 3) 7  (0 5) 5  (5 5) 10).This will discover (data1 + data2).You supply inputs and answers and the system will find the method.  Each inner array is a list of inputs.  It contains the receiver and zero or more arguments.  For Booleans and any computed arguments, use brace notation.	MethodFinder methodFor: { {1. 3}. true.  {20. 10}. false}.This will discover the expressions (data1 < data2), (data2 > data1), and many others.	MethodFinder methodFor: { {''29 Apr 1999'' asDate}. ''Thursday''.  		{''30 Apr 1999'' asDate}. ''Friday'' }.This will discover the expression (data1 weekday)Receiver and arguments do not have to be in the right order.See MethodFinder.verify for more examples.'! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 3/29/1999 22:12'!byExample: newText	"Don't save it"	^ true! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 8/26/1998 14:20'!classList	^ classList! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 8/26/1998 14:23'!classListIndex	^ classListIndex! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'sw 10/9/1998 08:26'!classListIndex: anInteger	classListIndex _ anInteger.	classListIndex > 0 ifTrue:		[self dependents do:			[:dep | ((dep isKindOf: PluggableListView) and:				[dep setSelectionSelectorIs: #classListIndex:])					ifTrue: [dep controller controlTerminate]].		Browser fullOnClass: self selectedClass selector: self selectedMessageName.		"classListIndex _ 0"]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 8/26/1998 14:33'!classListSelectorTitle	^ 'Class List Menu'! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 5/22/2001 21:37'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens raw sorted |	contents _ aString.	classList _ #().  classListIndex _ 0.	selectorIndex _ 0.	tokens _ contents asString findTokens: ' .'.	selectorList _ Cursor wait showWhile: [		tokens size = 1 			ifTrue: [raw _ (Symbol selectorsContaining: contents asString).				sorted _ raw as: SortedCollection.				sorted sortBlock: [:x :y | x asLowercase <= y asLowercase].				sorted asArray]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'sd 4/16/2003 09:45'!implementors	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[self systemNavigation browseAllImplementorsOf: aSelector]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'di 11/9/1999 10:07'!initialExtent	^ 350@250! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/8/2001 18:21'!listFromResult: resultOC	"ResultOC is of the form #('(data1 op data2)' '(...)'). Answer a sorted array."	(resultOC first beginsWith: 'no single method') ifTrue: [^ #()].	^ resultOC sortBy: [:a :b | 		(a copyFrom: 6 to: a size) < (b copyFrom: 6 to: b size)].! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'md 11/14/2003 17:19'!markMatchingClasses	"If an example is used, mark classes matching the example instance with an asterisk."	| unmarkedClassList firstPartOfSelector receiverString receiver |	self flag: #mref.	"allows for old-fashioned style"	"Only 'example' queries can be marked."	(contents asString includes: $.) ifFalse: [^ self].	unmarkedClassList _ classList copy.	"Get the receiver object of the selected statement in the message list."	firstPartOfSelector _ (Scanner new scanTokens: (selectorList at: selectorIndex)) second.	receiverString _ (ReadStream on: (selectorList at: selectorIndex))						upToAll: firstPartOfSelector.	receiver _ Compiler evaluate: receiverString.	unmarkedClassList do: [ :classAndMethod | | class |		(classAndMethod isKindOf: MethodReference) ifTrue: [			(receiver isKindOf: classAndMethod actualClass) ifTrue: [				classAndMethod stringVersion: '*', classAndMethod stringVersion.			]		] ifFalse: [			class _ Compiler evaluate:					((ReadStream on: classAndMethod) upToAll: firstPartOfSelector).			(receiver isKindOf: class) ifTrue: [				classList add: '*', classAndMethod.				classList remove: classAndMethod			]		].	].! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 8/26/1998 14:19'!messageList	"Find all the selectors containing what the user typed in."	^ selectorList! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 8/26/1998 10:58'!messageListIndex	"Answer the index of the selected message selector."	^ selectorIndex! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'sd 4/19/2003 12:13'!messageListIndex: anInteger 	"Set the selected message selector to be the one indexed by anInteger. 	Find all classes it is in."	selectorIndex _ anInteger.	selectorIndex = 0		ifTrue: [^ self].	classList _ self systemNavigation allImplementorsOf: self selectedMessageName.	self markMatchingClasses.	classListIndex _ 0.	self changed: #messageListIndex.	"update my selection"	self changed: #classList! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'sma 2/6/2000 11:42'!messageListKey: aChar from: view	"Respond to a command key. Handle (m) and (n) here,	else defer to the StringHolder behaviour."	aChar == $m ifTrue: [^ self implementors].	aChar == $n ifTrue: [^ self senders].	super messageListKey: aChar from: view! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'BG 10/29/2003 00:38'!open	"Create a Browser that lets you type part of a selector, shows a list of selectors,	shows the classes of the one you chose, and spwns a full browser on it.		SelectorBrowser new open	"	| selectorListView typeInView topView classListView exampleView |	selectorIndex _ classListIndex _ 0.	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	typeInView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView window: (0@0 extent: 50@14);		askBeforeDiscardingEdits: false.	topView addSubView: typeInView.	selectorListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	selectorListView window: (0 @ 0 extent: 50 @ 46).	topView addSubView: selectorListView below: typeInView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil	"never anything selected"		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	classListView window: (0 @ 0 extent: 50 @ 60).	topView addSubView: classListView toRightOf: typeInView.	exampleView _ PluggableTextView on: self 			text: #byExample accept: #byExample:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	exampleView window: (0@0 extent: 100@40);		askBeforeDiscardingEdits: false.	topView addSubView: exampleView below: selectorListView.	topView label: 'Method Finder'.	"topView minimumSize: 350@250; maximumSize: 350@250."	topView subViews do: [:each | each controller].	topView controller open.! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/8/2001 18:37'!quickList	"Compute the selectors for the single example of receiver and args, in the very top pane" 	| data result resultArray newExp dataStrings mf dataObjects aa |	data _ contents asString.	"delete trailing period. This should be fixed in the Parser!!" 	[data last isSeparator] whileTrue: [data _ data allButLast]. 	data last = $. ifTrue: [data _ data allButLast]. 	"Eval"	mf _ MethodFinder new.	data _ mf cleanInputs: data.	"remove common mistakes"	dataObjects _ Compiler evaluate: '{', data, '}'. "#( data1 data2 result )" 	dataStrings _ (Compiler new parse: 'zort ' , data in: Object notifying: nil)				block statements allButLast collect:				[:node | String streamContents:					[:strm | (node isKindOf: MessageNode) ifTrue: [strm nextPut: $(].					node printOn: strm indent: 0.					(node isKindOf: MessageNode) ifTrue: [strm nextPut: $)].]].	dataObjects size < 2 ifTrue: [self inform: 'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment' withCRs. ^#()]. 	dataObjects _ Array with: dataObjects allButLast with: dataObjects last. "#( (data1 data2) result )" 	result _ mf load: dataObjects; findMessage.	(result first beginsWith: 'no single method') ifFalse: [		aa _ self testObjects: dataObjects strings: dataStrings.		dataObjects _ aa second.  dataStrings _ aa third].	resultArray _ self listFromResult: result. 	resultArray isEmpty ifTrue: [self inform: result first].	dataStrings size = (dataObjects first size + 1) ifTrue:		[resultArray _ resultArray collect: [:expression |		newExp _ expression.		dataObjects first withIndexDo: [:lit :i |			newExp _ newExp copyReplaceAll: 'data', i printString							with: (dataStrings at: i)].		newExp, ' --> ', dataStrings last]]. 	^ resultArray! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'bf 10/13/1999 11:58'!searchResult: anExternalSearchResult	self contents: ''.	classList _ #(). classListIndex _ 0.	selectorIndex _ 0.	selectorList _ self listFromResult: anExternalSearchResult. 	self changed: #messageList.	self changed: #classList.	Smalltalk isMorphic ifTrue: [self changed: #contents.]. ! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'RAA 5/29/2001 14:39'!selectedClass	"Answer the currently selected class."	| pairString |	self flag: #mref.	"allows for old-fashioned style"	classListIndex = 0 ifTrue: [^nil].	pairString _ classList at: classListIndex.	(pairString isKindOf: MethodReference) ifTrue: [		^pairString actualClass	].	(pairString includes: $*) ifTrue: [pairString _ pairString allButFirst].	MessageSet 		parse: pairString		toClassAndSelector: [:cls :sel | ^ cls].! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 8/27/1998 17:48'!selectedClassName	"Answer the name of the currently selected class."	classListIndex = 0 ifTrue: [^nil].	^ self selectedClass name! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'md 11/14/2003 17:21'!selectedMessageName	"Answer the name of the currently selected message."	| example tokens |	selectorIndex = 0 ifTrue: [^nil].	example _ selectorList at: selectorIndex.	tokens _ Scanner new scanTokens: example.	tokens size = 1 ifTrue: [^ tokens first].	tokens first == #'^' ifTrue: [^ nil].	(tokens second includes: $:) ifTrue: [^ example findSelector].	Symbol hasInterned: tokens second ifTrue: [:aSymbol | ^ aSymbol].	^ nil! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'mjg 8/19/1999 12:30'!selectorList: anExternalList	self contents: ''.	classList _ #(). classListIndex _ 0.	selectorIndex _ 0.	selectorList _ anExternalList.	self changed: #messageList.	self changed: #classList.	Smalltalk isMorphic ifTrue: [self changed: #contents.]. ! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'hh 1/20/2000 00:15'!selectorMenu: aMenu	^ aMenu labels:'senders (n)implementors (m)copy selector to clipboard'	lines: #()	selections: #(senders implementors copyName)! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'sw 9/2/1998 16:37'!selectorMenuTitle	^ self selectedMessageName ifNil: ['<no selection>']! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2003 21:44'!senders	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[self systemNavigation browseAllCallsOn: aSelector]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/18/2001 23:15'!testObjects: dataObjects strings: dataStrings	| dataObjs dataStrs selectors classes didUnmodifiedAnswer answerMod do ds result ddo dds |	"Try to make substitutions in the user's inputs and search for the selector again.1 no change to answer.2 answer Array -> OrderedCollection.2 answer Character -> String4 answer Symbol or String of len 1 -> Character	For each of these, try straight, and try converting args:Character -> StringSymbol or String of len 1 -> Character	Return array with result, dataObjects, dataStrings.  Don't ever do a find on the same set of data twice."dataObjs _ dataObjects.  dataStrs _ dataStrings.selectors _ {#asString. #first. #asOrderedCollection}.classes _ {Character. String. Array}.didUnmodifiedAnswer _ false.selectors withIndexDo: [:ansSel :ansInd | "Modify the answer object"	answerMod _ false.	do _ dataObjs copyTwoLevel.  ds _ dataStrs copy.	(dataObjs last isKindOf: (classes at: ansInd)) ifTrue: [		((ansSel ~~ #first) or: [dataObjs last size = 1]) ifTrue: [			do at: do size put: (do last perform: ansSel).	"asString"			ds at: ds size put: ds last, ' ', ansSel.			result _ MethodFinder new load: do; findMessage.			(result first beginsWith: 'no single method') ifFalse: [				"found a selector!!"				^ Array with: result first with: do with: ds].				answerMod _ true]].	selectors allButLast withIndexDo: [:argSel :argInd | "Modify an argument object"			"for args, no reason to do Array -> OrderedCollection.  Identical protocol."		didUnmodifiedAnswer not | answerMod ifTrue: [		ddo _ do copyTwoLevel.  dds _ ds copy.		dataObjs first withIndexDo: [:arg :ind |			(arg isKindOf: (classes at: argInd))  ifTrue: [				((argSel ~~ #first) or: [arg size = 1]) ifTrue: [					ddo first at: ind put: ((ddo first at: ind) perform: argSel).	"asString"					dds at: ind put: (dds at: ind), ' ', argSel.					result _ MethodFinder new load: ddo; findMessage.					(result first beginsWith: 'no single method') ifFalse: [						"found a selector!!"						^ Array with: result first with: ddo with: dds]	.						didUnmodifiedAnswer not & answerMod not ifTrue: [						didUnmodifiedAnswer _ true].					]]]]].	].^ Array with: 'no single method does that function' with: dataObjs with: dataStrs! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SelectorBrowser class	instanceVariableNames: ''!!SelectorBrowser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 11:01'!initialize	self registerInFlapsRegistry.	! !!SelectorBrowser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 11:03'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(SelectorBrowser			prototypicalToolWindow		'Method Finder'		'A tool for discovering methods by providing sample values for arguments and results')						forFlapNamed: 'Tools']! !!SelectorBrowser class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:40'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !LeafNode subclass: #SelectorNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!SelectorNode commentStamp: '<historical>' prior: 0!I am a parse tree leaf representing a selector.!!SelectorNode methodsFor: 'code generation'!emit: stack args: nArgs on: strm	self emit: stack		args: nArgs		on: strm		super: false! !!SelectorNode methodsFor: 'code generation'!emit: stack args: nArgs on: aStream super: supered	| index |	stack pop: nArgs.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:		["short send"		code < Send			ifTrue: [^ aStream nextPut: code "special"]			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7]) ifTrue: 		["extended (2-byte) send [131 and 133]"		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).		^ aStream nextPut: nArgs * 32 + index].	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:		["new extended (2-byte) send [134]"		aStream nextPut: SendLong2.		^ aStream nextPut: nArgs * 64 + index].	"long (3-byte) send"	aStream nextPut: DblExtDoAll.	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).	aStream nextPut: index! !!SelectorNode methodsFor: 'code generation' stamp: 'di 1/7/2000 12:32'!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code _ self code: (encoder sharableLitIndex: key) type: 5].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!SelectorNode methodsFor: 'printing' stamp: 'di 11/8/2000 10:04'!printOn: aStream indent: level 	aStream withStyleFor: #keyword		do: [key == nil				ifTrue: [aStream nextPutAll: '<key==nil>']				ifFalse: [aStream nextPutAll: key]]! !!SelectorNode methodsFor: 'inappropriate'!emitForEffect: stack on: strm	self shouldNotImplement! !!SelectorNode methodsFor: 'inappropriate'!emitForValue: stack on: strm	self shouldNotImplement! !!SelectorNode methodsFor: 'inappropriate'!sizeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'inappropriate'!sizeForValue: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'testing'!isPvtSelector	"Answer if this selector node is a private message selector."	^key isPvtSelector! !LinkedList subclass: #Semaphore	instanceVariableNames: 'excessSignals'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Semaphore commentStamp: '<historical>' prior: 0!I provide synchronized communication of a single bit of information (a "signal") between Processes. A signal is sent by sending the message signal and received by sending the message wait. If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.!!Semaphore methodsFor: 'initialize-release'!initSignals	"Consume any excess signals the receiver may have accumulated."	excessSignals _ 0.! !!Semaphore methodsFor: 'initialize-release'!terminateProcess	"Terminate the process waiting on this semaphore, if any."	self isEmpty ifFalse: [ self removeFirst terminate ].! !!Semaphore methodsFor: 'communication'!signal	"Primitive. Send a signal through the receiver. If one or more processes 	have been suspended trying to receive a signal, allow the first one to 	proceed. If no process is waiting, remember the excess signal. Essential. 	See Object documentation whatIsAPrimitive."	<primitive: 85>	self primitiveFailed	"self isEmpty    		ifTrue: [excessSignals _ excessSignals+1]    		ifFalse: [Processor resume: self removeFirstLink]"! !!Semaphore methodsFor: 'communication'!wait	"Primitive. The active Process must receive a signal through the receiver 	before proceeding. If no signal has been sent, the active Process will be 	suspended until one is sent. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 86>	self primitiveFailed	"excessSignals>0  		ifTrue: [excessSignals _ excessSignals-1]  		ifFalse: [self addLastLink: Processor activeProcess suspend]"! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'mir 9/22/2001 10:54'!critical: mutuallyExcludedBlock 	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue |	self wait.	[blockValue _ mutuallyExcludedBlock value]		ensure: [self signal].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/8/1998 11:16'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	self wait.	hasError _ false.	blockValue _ [mutuallyExcludedBlock value] ifError:[:msg :rcvr|		hasError _ true.		errMsg _ msg.		errRcvr _ rcvr].	hasError ifTrue:[		self signal.		^errorBlock value: errMsg value: errRcvr].	self signal.	^blockValue! !!Semaphore methodsFor: 'comparing' stamp: 'sma 4/22/2000 18:48'!= anObject	^ self == anObject! !!Semaphore methodsFor: 'comparing' stamp: 'sma 4/22/2000 18:48'!hash	^ self identityHash! !!Semaphore methodsFor: 'testing' stamp: 'ar 3/2/2001 16:51'!isSignaled	"Return true if this semaphore is currently signaled"	^excessSignals > 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Semaphore class	instanceVariableNames: ''!!Semaphore class methodsFor: 'instance creation'!forMutualExclusion	"Answer an instance of me that contains a single signal. This new 	instance can now be used for mutual exclusion (see the critical: message 	to Semaphore)."	^self new signal! !!Semaphore class methodsFor: 'instance creation'!new	"Answer a new instance of Semaphore that contains no signals."	^self basicNew initSignals! !Collection subclass: #SequenceableCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Abstract'!!SequenceableCollection commentStamp: '<historical>' prior: 0!I am an abstract superclass for collections that have a well-defined order associated with their elements. Thus each element is externally-named by integers referred to as indices.!!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:00'!after: target	"Answer the element after target.  Raise an error if target is not	in the receiver, or if there are no elements after it."	^ self after: target ifAbsent: [self errorNotFound: target]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:02'!after: target ifAbsent: exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| index |	index _ self indexOf: target.	^ index == 0		ifTrue: [exceptionBlock value]		ifFalse: [index = self size 			ifTrue: [self errorLastObject: target]			ifFalse: [self at: index + 1]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:34'!allButFirst	"Answer a copy of the receiver containing all but the first	element. Raise an error if there are not enough elements."	^ self allButFirst: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:35'!allButFirst: n	"Answer a copy of the receiver containing all but the first n	elements. Raise an error if there are not enough elements."	^ self copyFrom: n + 1 to: self size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:35'!allButLast	"Answer a copy of the receiver containing all but the last	element. Raise an error if there are not enough elements."	^ self allButLast: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:35'!allButLast: n	"Answer a copy of the receiver containing all but the last n	elements. Raise an error if there are not enough elements."	^ self copyFrom: 1 to: self size - n! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:33'!anyOne	^ self first! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:11'!at: index ifAbsent: exceptionBlock 	"Answer the element at my position index. If I do not contain an element 	at index, answer the result of evaluating the argument, exceptionBlock."	(index between: 1 and: self size) ifTrue: [^ self at: index].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'raok 11/22/2002 12:34'!at: index incrementBy: value	^self at: index put: (self at: index) + value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'apb 11/4/2000 22:51'!atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	"#('one' 'two' 'three' 'four') atAll: #(3 2 4)"	| newCollection |	newCollection _ self species ofSize: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:17'!atAll: aCollection put: anObject 	"Put anObject at every index specified by the elements of aCollection."	aCollection do: [:index | self at: index put: anObject].	^ anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:18'!atAll: indexArray putAll: valueArray	"Store the elements of valueArray into the slots	of this collection selected by indexArray."	indexArray with: valueArray do: [:index :value | self at: index put: value].	^ valueArray! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:45'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	| size |	(size _ self size) > 26 "first method faster from 27 accesses and on"		ifTrue: [self from: 1 to: size put: anObject]		ifFalse: [1 to: size do: [:index | self at: index put: anObject]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ajh 6/27/2002 17:53'!atLast: indexFromEnd	"Return element at indexFromEnd from the last position.	 atLast: 1, returns the last element"	^ self atLast: indexFromEnd ifAbsent: [self errorIndexOutOfRange]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ajh 6/27/2002 17:52'!atLast: indexFromEnd ifAbsent: block	"Return element at indexFromEnd from the last position.	 atLast: 1 ifAbsent: [] returns the last element"	^ self at: self size + 1 - indexFromEnd ifAbsent: block! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ajh 6/27/2002 18:10'!atLast: indexFromEnd put: obj	"Set the element at indexFromEnd from the last position.	 atLast: 1 put: obj, sets the last element"	^ self at: self size + 1 - indexFromEnd put: obj! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:32'!atPin: index 	"Return the index'th element of me if possible.	Return the first or last element if index is out of bounds."	index < 1 ifTrue: [^ self first].	index > self size ifTrue: [^ self last].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:50'!atRandom: aGenerator	"Answer a random element of the receiver.  Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers 	because only you use the generator.  Causes an error if self has no 	elements."	^ self at: (aGenerator nextInt: self size)! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:51'!atWrap: index 	"Answer the index'th element of the receiver.  If index is out of bounds,	let it wrap around from the end to the beginning until it is in bounds."	^ self at: index - 1 \\ self size + 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:52'!atWrap: index put: value	"Store value into the index'th element of the receiver.  If index is out	of bounds, let it wrap around from the end to the beginning until it 	is in bounds. Answer value."	^ self at: index  - 1 \\ self size + 1 put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:04'!before: target	"Answer the receiver's element immediately before target. Raise an	error if target is not an element of the receiver, or if there are no 	elements before it (i.e. it is the first element)."	^ self before: target ifAbsent: [self errorNotFound: target]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:06'!before: target ifAbsent: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| index |	index _ self indexOf: target.	^ index == 0		ifTrue: [exceptionBlock value]		ifFalse: [index == 1 			ifTrue: [self errorFirstObject: target]			ifFalse: [self at: index - 1]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 9/8/2000 11:23'!eighth	"Answer the eighth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 8! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:57'!fifth	"Answer the fifth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 5! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 6/2/2000 09:16'!first	"Answer the first element of the receiver.	Raise an error if the collection is empty."	self size = 0 ifTrue: [self errorEmptyCollection].	^ self at: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:31'!first: n	"Answer the first n elements of the receiver.	Raise an error if there are not enough elements."	^ self copyFrom: 1 to: n! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:58'!fourth	"Answer the fourth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 4! !!SequenceableCollection methodsFor: 'accessing' stamp: 'SqR 10/30/2000 22:06'!from: startIndex to: endIndex put: anObject	"Put anObject in all indexes between startIndex 	and endIndex. Very fast. Faster than to:do: for	more than 26 positions. Answer anObject"	| written toWrite thisWrite |	startIndex > endIndex ifTrue: [^self].	self at: startIndex put: anObject.	written _ 1.	toWrite _ endIndex - startIndex + 1.	[written < toWrite] whileTrue:		[			thisWrite _ written min: toWrite - written.			self 				replaceFrom: startIndex + written				to: startIndex + written + thisWrite - 1				with: self startingAt: startIndex.			written _ written + thisWrite		].	^anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:20'!identityIndexOf: anElement 	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer 0."	^self identityIndexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:21'!identityIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | (self at: i) == anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:46'!indexOf: anElement	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer 0."	^ self indexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:47'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the 	result of evaluating the argument, exceptionBlock."	^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:47'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	start to: self size do:		[:index |		(self at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing'!indexOfSubCollection: aSubCollection startingAt: anIndex 	"Answer the index of the receiver's first element, such that that element 	equals the first element of aSubCollection, and the next elements equal 	the rest of the elements of aSubCollection. Begin the search at element 	anIndex of the receiver. If no such match is found, answer 0."	^self		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	"Answer the index of the receiver's first element, such that that element 	equals the first element of sub, and the next elements equal 	the rest of the elements of sub. Begin the search at element 	start of the receiver. If no such match is found, answer the result of 	evaluating argument, exceptionBlock."	| first index |	sub isEmpty ifTrue: [^ exceptionBlock value].	first _ sub first.	start to: self size - sub size + 1 do:		[:startIndex |		(self at: startIndex) = first ifTrue:			[index _ 1.			[(self at: startIndex+index-1) = (sub at: index)]				whileTrue:				[index = sub size ifTrue: [^startIndex].				index _ index+1]]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:43'!integerAt: index	"Return the integer at the given index"	^self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:43'!integerAt: index put: value	"Return the integer at the given index"	^self at: index put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 6/2/2000 09:15'!last	"Answer the last element of the receiver.	Raise an error if the collection is empty."	| size |	(size _ self size) = 0 ifTrue: [self errorEmptyCollection].	^ self at: size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:30'!last: n	"Answer the last n elements of the receiver.  	Raise an error if there are not enough elements."	| size |	size _ self size.	^ self copyFrom: size - n + 1 to: size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 12/16/2001 01:06'!lastIndexOf: anElement	"Answer the index of the last occurence of anElement within the 	receiver. If the receiver does not contain anElement, answer 0."	^ self lastIndexOf: anElement startingAt: self size ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 12/16/2001 01:06'!lastIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of the last occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the	result of evaluating the argument, exceptionBlock."	^self lastIndexOf: anElement startingAt: self size ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 12/16/2001 01:05'!lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock	"Answer the index of the last occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the	result of evaluating the argument, exceptionBlock."	lastIndex to: 1 by: -1 do:		[:index |		(self at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'bf 10/13/1999 10:01'!middle	"Answer the middle element of the receiver."	self emptyCheck.	^ self at: self size // 2 + 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 9/7/2000 18:10'!ninth	"Answer the ninth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 9! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index _ self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index _ self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequenceableCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement 	"This destructively replaces elements from start to stop in the receiver. 	Answer the receiver itself. Use copyReplaceFrom:to:with: for 	insertion/deletion which may alter the size of the result."	replacement size = (stop - start + 1)		ifFalse: [self error: 'Size of replacement doesnt match'].	^self replaceFrom: start to: stop with: replacement startingAt: 1! !!SequenceableCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver 	starting at index, repStart, in the sequenceable collection, 	replacementCollection. Answer the receiver. No range checks are 	performed."	| index repOff |	repOff _ repStart - start.	index _ start - 1.	[(index _ index + 1) <= stop]		whileTrue: [self at: index put: (replacement at: repOff + index)]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:58'!second	"Answer the second element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 2! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 9/7/2000 18:11'!seventh	"Answer the seventh element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 7! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:59'!sixth	"Answer the sixth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 6! !!SequenceableCollection methodsFor: 'accessing'!swap: oneIndex with: anotherIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| element |	element _ self at: oneIndex.	self at: oneIndex put: (self at: anotherIndex).	self at: anotherIndex put: element! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:58'!third	"Answer the third element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 3! !!SequenceableCollection methodsFor: 'comparing' stamp: 'sma 5/12/2000 14:04'!= otherCollection 	"Answer true if the receiver is equivalent to the otherCollection.	First test for identity, then rule out different species and sizes of	collections. As a last resort, examine each element of the receiver	and the otherCollection."	self == otherCollection ifTrue: [^ true].	self species == otherCollection species ifFalse: [^ false].	^ self hasEqualElements: otherCollection! !!SequenceableCollection methodsFor: 'comparing' stamp: 'tk 12/6/2000 11:39'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	(size _ self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true! !!SequenceableCollection methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:39'!hash	| hash |	hash _ self species hash.	1 to: self size do: [:i | hash _ (hash + (self at: i) hash) hashMultiply].	^hash! !!SequenceableCollection methodsFor: 'converting' stamp: 'TAG 11/6/1998 15:55'!@ aCollection 	^ self with: aCollection collect: [:a :b | a @ b]! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:32'!asArray	"Answer an Array whose elements are the elements of the receiver."	^ Array withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:36'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver."	^ ByteArray withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 3/3/2001 20:06'!asColorArray	^ColorArray withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray _ FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray _ IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'djm 11/20/1998 05:44'!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream _ WriteStream on: (String new: 200).	self do: [:each |		(each isKindOf: String)			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray _ WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'raok 6/23/2003 12:51'!concatenation	|result index|	result _ Array new: (self inject: 0 into: [:sum :each | sum + each size]).	index _ 0.	self do: [:each | each do: [:item | result at: (index _ index+1) put: item]].	^result! !!SequenceableCollection methodsFor: 'converting' stamp: 'di 11/6/1998 09:35'!isSequenceable	^ true! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 12:51'!readStream	^ ReadStream on: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:56'!reverse	^ self reversed! !!SequenceableCollection methodsFor: 'converting' stamp: 'jm 4/27/98 04:09'!reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| n result src |	n _ self size.	result _ self species new: n.	src _ n + 1.	1 to: n do: [:i | result at: i put: (self at: (src _ src - 1))].	^ result! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 12:52'!writeStream	^ WriteStream on: self! !!SequenceableCollection methodsFor: 'copying' stamp: 'di 1/16/98 16:40'!, otherCollection 	"Concatenate two Strings or Collections."		^ self copyReplaceFrom: self size + 1		  to: self size		  with: otherCollection"#(2 4 6 8) , #(who do we appreciate)((2989 printStringBase: 16) copyFrom: 4 to: 6) , ' boy!!'"! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:05'!copyAfter: anElement	"Answer a copy of the receiver from after the first occurence	of anElement up to the end. If no such element exists, answer 	an empty copy."	^ self allButFirst: (self indexOf: anElement ifAbsent: [^ self copyEmpty])! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:05'!copyAfterLast: anElement	"Answer a copy of the receiver from after the last occurence	of anElement up to the end. If no such element exists, answer 	an empty copy."	^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self copyEmpty])! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:07'!copyEmpty	^ self species new: 0! !!SequenceableCollection methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize |	newSize _ stop - start + 1.	^(self species new: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:06'!copyLast: num	"Deprecated. Use #last:"	^ self last: num! !!SequenceableCollection methodsFor: 'copying'!copyReplaceAll: oldSubstring with: newSubstring 	"Default is not to do token matching.	See also String copyReplaceTokens:with:"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: false	"'How now brown cow?' copyReplaceAll: 'ow' with: 'ello'"	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Pile'"! !!SequenceableCollection methodsFor: 'copying' stamp: 'ar 10/16/2001 19:03'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver satisfying the following conditions: If 	stop is less than start, then this is an insertion; stop should be exactly 	start-1, start = 1 means insert before the first character, start = size+1 	means append after last character. Otherwise, this is a replacement; start 	and stop have to be within the receiver's bounds."	| newSequenceableCollection newSize endReplacement |	newSize _ self size - (stop - start + 1) + replacementCollection size.	endReplacement _ start - 1 + replacementCollection size.	newSequenceableCollection _ self species new: newSize.	start > 1 ifTrue:[		newSequenceableCollection			replaceFrom: 1			to: start - 1			with: self			startingAt: 1].	start <= endReplacement ifTrue:[		newSequenceableCollection			replaceFrom: start			to: endReplacement			with: replacementCollection			startingAt: 1].	endReplacement < newSize ifTrue:[		newSequenceableCollection			replaceFrom: endReplacement + 1			to: newSize			with: self			startingAt: stop + 1].	^newSequenceableCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:00'!copyUpTo: anElement 	"Answer all elements up to but not including anObject. If there	is no such object, answer a copy of the receiver."	^ self first: (self indexOf: anElement ifAbsent: [^ self copy]) - 1! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:02'!copyUpToLast: anElement	"Answer a copy of the receiver from index 1 to the last occurrence of 	anElement, not including anElement."	^ self first: (self lastIndexOf: anElement ifAbsent: [^ self copy]) - 1! !!SequenceableCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| newIC |	newIC _ self species new: self size + 1.	newIC 		replaceFrom: 1		to: self size		with: self		startingAt: 1.	newIC at: newIC size put: newElement.	^newIC! !!SequenceableCollection methodsFor: 'copying' stamp: 'ajh 9/27/2002 12:09'!copyWithFirst: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element."	| newIC |	newIC _ self species ofSize: self size + 1.	newIC 		replaceFrom: 2		to: self size + 1		with: self		startingAt: 1.	newIC at: 1 put: newElement.	^ newIC! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 15:38'!copyWithoutFirst	"Deprecatd. Return a copy of the receiver which doesn't include	the first element."	^ self allButFirst! !!SequenceableCollection methodsFor: 'copying' stamp: 'rhi 12/6/2001 14:04'!copyWithoutIndex: index	"Return a copy containing all elements except the index-th."	| copy |	copy := self species ofSize: self size - 1.	copy replaceFrom: 1 to: index-1 with: self startingAt: 1.	copy replaceFrom: index to: copy size with: self startingAt: index+1.	^ copy! !!SequenceableCollection methodsFor: 'copying' stamp: 'fcs 1/20/2002 16:03'!forceTo: length paddingStartWith: elem 	"Force the length of the collection to length, padding  	the beginning of the result if necessary with elem.  	Note that this makes a copy."	| newCollection padLen |	newCollection _ self species new: length.	padLen _ length - self size max: 0.	newCollection		from: 1		to: padLen		put: elem.	newCollection		replaceFrom: padLen + 1		to: ((padLen + self size) min: length)		with: self		startingAt:  1.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 4/22/2000 18:01'!forceTo: length paddingWith: elem	"Force the length of the collection to length, padding	if necessary with elem.  Note that this makes a copy."	| newCollection copyLen |	newCollection _ self species new: length.	copyLen _ self size min: length.	newCollection replaceFrom: 1 to: copyLen with: self startingAt: 1.	newCollection from: copyLen + 1 to: length put: elem.	^ newCollection! !!SequenceableCollection methodsFor: 'copying'!shallowCopy	^self copyFrom: 1 to: self size! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 5/12/2000 12:36'!shuffled	^ self shuffledBy: Collection randomForPicking"Examples:	($A to: $Z) shuffled"! !!SequenceableCollection methodsFor: 'copying' stamp: 'djp 10/23/1999 22:12'!shuffledBy: aRandom	| copy | 	copy _ self shallowCopy.	copy size to: 1 by: -1 do: 		[:i | copy swap: i with: ((1 to: i) atRandom: aRandom)].	^ copy! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 4/28/2000 18:34'!sortBy: aBlock	"Create a copy that is sorted.  Sort criteria is the block that accepts two arguments.	When the block is true, the first arg goes first ([:a :b | a > b] sorts in descending	order)."	^ (self asSortedCollection: aBlock) asOrderedCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ajh 8/6/2002 15:03'!allButFirstDo: block	2 to: self size do:		[:index | block value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ajh 8/6/2002 15:01'!allButLastDo: block	1 to: self size - 1 do:		[:index | block value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:41'!asDigitsToPower: anInteger do: aBlock	"Repeatedly value aBlock with a single Array.  Adjust the collection	so that aBlock is presented all (self size raisedTo: anInteger) possible 	combinations of the receiver's elements taken as digits of an anInteger long number."	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection _ Array new: anInteger.	self asDigitsAt: 1 in: aCollection do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:46'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new: self size.	1 to: self size do:		[:index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/1/2000 11:47'!collect: aBlock from: firstIndex to: lastIndex	"Refer to the comment in Collection|collect:."	| size result j |	size _ lastIndex - firstIndex + 1.	result _ self species new: size.	j _ firstIndex.	1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j _ j + 1].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:44'!collectWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexCollect: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:52'!combinations: kk atATimeDo: aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	" 'abcde' combinations: 3 atATimeDo: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection _ Array new: kk.	self combinationsAt: 1 in: aCollection after: 0 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating'!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:56'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	1 to: self size do:		[:index |		index = 1 ifFalse: [separatorBlock value].		elementBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 5/1/1999 05:01'!do: aBlock without: anItem	"Enumerate all elements in the receiver.	Execute aBlock for those elements that are not equal to the given item"	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | anItem = (self at: index) ifFalse:[aBlock value: (self at: index)]]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:43'!doWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexDo: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:53'!findBinary: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinary:[:arg| 11 - arg]	"	^self findBinary: aBlock ifNone: [self errorNotFound: aBlock]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:52'!findBinary: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test item |	low _ 1.	high _ self size.	[index _ high + low // 2.	low > high] whileFalse:[		test _ aBlock value: (item _ self at: index).		test = 0 			ifTrue:[^item]			ifFalse:[test > 0				ifTrue: [low _ index + 1]				ifFalse: [high _ index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:54'!findBinaryIndex: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinaryIndex:[:arg| 11 - arg]	"	^self findBinaryIndex: aBlock ifNone: [self errorNotFound: aBlock]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:54'!findBinaryIndex: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test |	low _ 1.	high _ self size.	[index _ high + low // 2.	low > high] whileFalse:[		test _ aBlock value: (self at: index).		test = 0 			ifTrue:[^index]			ifFalse:[test > 0				ifTrue: [low _ index + 1]				ifFalse: [high _ index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating'!findFirst: aBlock	"Return the index of my first element for which aBlock evaluates as true."	| index |	index _ 0.	[(index _ index + 1) <= self size] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating'!findLast: aBlock	"Return the index of my last element for which aBlock evaluates as true."	| index |	index _ self size + 1.	[(index _ index - 1) >= 1] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 18:11'!from: start to: stop do: aBlock	"Evaluate aBlock for all elements between start and stop (inclusive)."	start to: stop do: [:index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 18:13'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys (aka indices) and values."	1 to: self size do: [:index | aBlock value: index value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01'!pairsCollect: aBlock 	"Evaluate aBlock with my elements taken two at a time, and return an Array with the results"	^ (1 to: self size // 2) collect:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect:	[:a :b | b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01'!pairsDo: aBlock 	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"	1 to: self size // 2 do:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ward 7/28/97 09:41'!permutationsDo: aBlock	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy	so that aBlock is presented all (self size factorial) possible permutations."	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"	self shallowCopy permutationsStartingAt: 1 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 12/27/2000 09:53'!polynomialEval: thisX	| sum valToPower |	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	sum _ self first.	valToPower _ thisX.	2 to: self size do: [:ind | 		sum _ sum + ((self at: ind) * valToPower).		valToPower _ valToPower * thisX].	^ sum! !!SequenceableCollection methodsFor: 'enumerating'!reverseDo: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument, 	starting with the last element and taking each in sequence up to the 	first. For SequenceableCollections, this is the reverse of the enumeration 	for do:."	self size to: 1 by: -1 do: [:index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating'!reverseWith: aSequenceableCollection do: aBlock 	"Evaluate aBlock with each of the receiver's elements, in reverse order, 	along with the  	corresponding element, also in reverse order, from 	aSequencableCollection. "	self size ~= aSequenceableCollection size ifTrue: [^ self errorNoMatch].	self size		to: 1		by: -1		do: [:index | aBlock value: (self at: index)				value: (aSequenceableCollection at: index)]! !!SequenceableCollection methodsFor: 'enumerating'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	1 to: self size do: 		[:index |		(aBlock value: (self at: index))			ifTrue: [aStream nextPut: (self at: index)]].	^ aStream contents! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/1/2000 16:00'!upTo: anObject	"Deprecated. Use copyUpTo:"	^ self copyUpTo: anObject! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/3/1999 15:26'!with: otherCollection do: twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	1 to: self size do:		[:index |		twoArgBlock value: (self at: index)				value: (otherCollection at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 5/17/1998 13:34'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:35'!withIndexDo: elementAndIndexBlock 	"Just like with:do: except that the iteration index supplies the second argument to the block."	1 to: self size do:		[:index |		elementAndIndexBlock			value: (self at: index)			value: index]! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 7/30/97 12:42'!asDigitsAt: anInteger in: aCollection do: aBlock	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	self do: 		[:each | 		aCollection at: anInteger put: each.		anInteger = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self asDigitsAt: anInteger + 1 in: aCollection do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 13:57'!checkedAt: index	index > self size ifTrue: [self error: 'not enough elements'].	^ self at: index! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 7/30/97 12:42'!combinationsAt: jj in: aCollection after: nn do: aBlock	"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1."	"(1 to: 6) combinationsSize: 3 do: [:each | Transcript cr; show: each printString]"nn+1 to: self size do: [:index | 		aCollection at: jj put: (self at: index).		jj = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self combinationsAt: jj + 1 in: aCollection after: index do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 1/7/98 10:57'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isKindOf: String) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString _ self.	startSearch _ 1.	[(currentIndex _ aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex _ currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString _ aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch _ currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch _ currentIndex + 1]					ifFalse: [startSearch _ currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 18:06'!errorFirstObject: anObject	self error: 'specified object is first object'! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 18:03'!errorLastObject: anObject	self error: 'specified object is last object'! !!SequenceableCollection methodsFor: 'private'!errorOutOfBounds	self error: 'indices are out of bounds'! !!SequenceableCollection methodsFor: 'private' stamp: 'ward 7/28/97 09:38'!permutationsStartingAt: anInteger do: aBlock	"#(1 2 3 4) permutationsDo: [:each | Transcript cr; show: each printString]"	anInteger > self size ifTrue: [^self].	anInteger = self size ifTrue: [^aBlock value: self].	anInteger to: self size do:		[:i | self swap: anInteger with: i.		self permutationsStartingAt: anInteger + 1 do: aBlock.		self swap: anInteger with: i]! !!SequenceableCollection methodsFor: 'removing'!remove: oldObject ifAbsent: anExceptionBlock 	"SequencableCollections cannot implement removing."	self shouldNotImplement! !!SequenceableCollection methodsFor: 'testing' stamp: 'bp 2/23/2004 21:47'!beginsWith: aSequenceableCollection	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	aSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'bp 2/23/2004 21:48'!endsWith: aSequenceableCollection	| start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start _ self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'sma 5/12/2000 14:08'!includes: anObject	"Answer whether anObject is one of the receiver's elements."	^ (self indexOf: anObject) ~= 0! !!SequenceableCollection methodsFor: '*packageinfo-base' stamp: 'ab 9/17/2002 01:02'!do: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:			[:bar |			self withIndexDo:				[:each :i |				bar value: i.				aBlock value: each]]! !!SequenceableCollection methodsFor: '*connectors-enumerating' stamp: 'nk 12/30/2003 15:39'!groupsOf: n atATimeCollect: aBlock 	"Evaluate aBlock with my elements taken n at a time. Ignore any 	leftovers at the end. 	Allows use of a flattened  	array for things that naturally group into groups of n. 	If aBlock has a single argument, pass it an array of n items, 	otherwise, pass the items as separate arguments. 	See also pairsDo:"	| passArray args  |	passArray := aBlock numArgs = 1.	^(n		to: self size		by: n)		collect: [:index | 			args := (self copyFrom: index - n + 1 to: index) asArray.			passArray				ifTrue: [aBlock value: args]				ifFalse: [aBlock valueWithArguments: args]]! !!SequenceableCollection methodsFor: '*connectors-enumerating' stamp: 'nk 12/30/2003 15:37'!groupsOf: n atATimeDo: aBlock 	"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.	Allows use of a flattened 	array for things that naturally group into groups of n.	If aBlock has a single argument, pass it an array of n items,	otherwise, pass the items as separate arguments.	See also pairsDo:"	| passArray args |	passArray := (aBlock numArgs = 1).	n		to: self size		by: n		do: [:index | 			args := (self copyFrom: index - n + 1 to: index) asArray.			passArray ifTrue: [ aBlock value: args ]				ifFalse: [ aBlock valueWithArguments: args ]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SequenceableCollection class	instanceVariableNames: ''!!SequenceableCollection class methodsFor: 'stream creation'!streamContents: blockWithArg	| stream |	stream _ WriteStream on: (self new: 100).	blockWithArg value: stream.	^stream contents! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'di 6/20/97 09:07'!streamContents: blockWithArg limitedTo: sizeLimit	| stream |	stream _ LimitedWriteStream on: (self new: (100 min: sizeLimit)).	stream setLimit: sizeLimit limitBlock: [^ stream contents].	blockWithArg value: stream.	^ stream contents"String streamContents: [:s | 1000 timesRepeat: [s nextPutAll: 'Junk']] limitedTo: 25 'JunkJunkJunkJunkJunkJunkJ'"! !Collection subclass: #Set	instanceVariableNames: 'tally array'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!Set commentStamp: '<historical>' prior: 0!I represent a set of objects without duplicates.  I can hold anything that responds to#hash and #=, except for nil.  My instances will automatically grow, if necessary,Note that I rely on #=, not #==.  If you want a set using #==, use IdentitySet.Instance structure:  array	An array whose non-nil elements are the elements of the set,		and whose nil elements are empty slots.  There is always at least one nil.		In fact I try to keep my "load" at 75% or less so that hashing will work well.  tally	The number of elements in the set.  The array size is always greater than this.The core operation is #findElementOrNil:, which either finds the position where anobject is stored in array, if it is present, or finds a suitable position holding nil, ifits argument is not present in array,!!Set methodsFor: 'accessing' stamp: 'ar 4/11/2001 23:01'!atRandom: aGenerator	"Answer a random element of the receiver.  Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers 	because only you use the generator.  Causes an error if self has no 	elements."	| ind |	self emptyCheck.	ind _ aGenerator nextInt: array size.	ind to: array size do:[:i|		(array at: i) == nil ifFalse:[^array at: i]].	1 to: ind do:[:i|		(array at: i) == nil ifFalse:[^array at: i]].	self errorEmptyCollection.! !!Set methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:40'!capacity	"Answer the current capacity of the receiver."	^ array size! !!Set methodsFor: 'accessing' stamp: 'SqR 8/23/2000 13:51'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index |	^(index _ self scanFor: anObject) = 0		ifFalse: [array at: index]! !!Set methodsFor: 'accessing'!size	^ tally! !!Set methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:34'!someElement	"Deprecated. Use anyOne."	^ self anyOne! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:28'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:29'!add: newObject withOccurrences: anInteger	^ self add: newObject! !!Set methodsFor: 'converting' stamp: 'ar 11/20/1998 16:34'!asSet	^self! !!Set methodsFor: 'copying' stamp: 'sma 5/12/2000 14:54'!copy	^ self shallowCopy withArray: array shallowCopy! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:49'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newSet |	newSet _ Set new: self size.	array do: [:each | each ifNotNil: [newSet add: (aBlock value: each)]].	^ newSet! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 14:36'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: array size do:		[:index |		| each |		(each _ array at: index) ifNotNil: [aBlock value: each]]! !!Set methodsFor: 'enumerating'!doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index _ 0.	self do: [:item | aBlock2 value: item value: (index _ index+1)]! !!Set methodsFor: 'enumerating' stamp: 'jcg 6/7/2003 02:01'!union: aCollection	"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all."	^ self copy addAll: aCollection; yourself! !!Set methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 13:05'!comeFullyUpOnReload: smartRefStream	"Symbols have new hashes in this image."	self rehash.	"^ self"! !!Set methodsFor: 'private'!array	^ array! !!Set methodsFor: 'private'!atNewIndex: index put: anObject	array at: index put: anObject.	tally _ tally + 1.	self fullCheck! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:39'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index _ self scanFor: anObject.	index > 0 ifTrue: [^index].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:28'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex _ index.	length _ array size.	[oldIndex = length			ifTrue: [oldIndex _ 1]			ifFalse: [oldIndex _ oldIndex + 1].	(element _ self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex _ self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!Set methodsFor: 'private' stamp: 'di 11/4/97 20:11'!fullCheck	"Keep array at least 1/4 free for decent hash behavior"	array size - tally < (array size // 4 max: 1)		ifTrue: [self grow]! !!Set methodsFor: 'private'!grow	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements _ array.	array _ Array new: array size + self growSize.	tally _ 0.	oldElements do:		[:each | each == nil ifFalse: [self noCheckAdd: each]]! !!Set methodsFor: 'private'!growSize	^ array size max: 2! !!Set methodsFor: 'private'!init: n	"Initialize array to an array size of n"	array _ Array new: n.	tally _ 0! !!Set methodsFor: 'private'!keyAt: index	"May be overridden by subclasses so that fixCollisions will work"	^ array at: index! !!Set methodsFor: 'private'!noCheckAdd: anObject	array at: (self findElementOrNil: anObject) put: anObject.	tally _ tally + 1! !!Set methodsFor: 'private'!rehash	| newSelf |	newSelf _ self species new: self size.	self do: [:each | newSelf noCheckAdd: each].	array _ newSelf array! !!Set methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Set methodsFor: 'private'!swap: oneIndex with: otherIndex	"May be overridden by subclasses so that fixCollisions will work"	array swap: oneIndex with: otherIndex! !!Set methodsFor: 'private'!withArray: anArray	"private -- for use only in copy"	array _ anArray! !!Set methodsFor: 'removing' stamp: 'sma 5/12/2000 14:45'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self copy		remove: oldElement ifAbsent: [];		yourself! !!Set methodsFor: 'removing'!remove: oldObject ifAbsent: aBlock	| index |	index _ self findElementOrNil: oldObject.	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!Set methodsFor: 'testing' stamp: 'tk 11/8/2001 15:35'!= aSet	self == aSet ifTrue: [^ true].	"stop recursion"	(aSet isKindOf: Set) ifFalse: [^ false].	self size = aSet size ifFalse: [^ false].	self do: [:each | (aSet includes: each) ifFalse: [^ false]].	^ true! !!Set methodsFor: 'testing'!includes: anObject 	^ (array at: (self findElementOrNil: anObject)) ~~ nil! !!Set methodsFor: 'testing' stamp: 'sma 5/12/2000 14:46'!occurrencesOf: anObject 	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !!Set methodsFor: 'explorer' stamp: 'hg 9/7/2001 11:51'!hasContentsInExplorer	^self isEmpty not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Set class	instanceVariableNames: ''!!Set class methodsFor: 'instance creation'!new	^ self new: 4! !!Set class methodsFor: 'instance creation'!new: nElements	"Create a Set large enough to hold nElements without growing"	^ super new init: (self sizeFor: nElements)! !!Set class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection _ self new: aCollection size.	newCollection addAll: aCollection.	^ newCollection"	Set newFrom: {1. 2. 3}	{1. 2. 3} as: Set"! !!Set class methodsFor: 'instance creation'!sizeFor: nElements	"Large enough size to hold nElements with some slop (see fullCheck)"	nElements <= 0 ifTrue: [^ 1].	^ nElements+1*4//3! !Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!!SharedPool commentStamp: '<historical>' prior: 0!A shared pool represents a set of bindings which are accessible to all classes which import the pool in its 'pool dictionaries'. SharedPool is NOT a dictionary but rather a name space. Bindings are represented by 'class variables' - as long as we have no better way to represent them at least.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SharedPool class	instanceVariableNames: ''!!SharedPool class methodsFor: 'name lookup' stamp: 'ar 5/18/2003 17:46'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'name lookup' stamp: 'ar 5/18/2003 20:33'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'name lookup' stamp: 'ar 5/18/2003 18:14'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'name lookup' stamp: 'tpr 5/29/2003 18:12'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !Object subclass: #SharedQueue	instanceVariableNames: 'contentsArray readPosition writePosition accessProtect readSynch'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!SharedQueue commentStamp: '<historical>' prior: 0!I provide synchronized communication of arbitrary objects between Processes. An object is sent by sending the message nextPut: and received by sending the message next. If no object has been sent when a next message is sent, the Process requesting the object will be suspended until one is sent.!!SharedQueue methodsFor: 'accessing' stamp: 'NS 6/18/2002 11:04'!flush	"Throw out all pending contents"	accessProtect critical: [		readPosition _ 1.		writePosition _ 1.		"Reset the read synchronization semaphore"		readSynch initSignals].! !!SharedQueue methodsFor: 'accessing' stamp: 'NS 6/18/2002 11:15'!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."	| value newReadPos |	accessProtect critical: [		newReadPos _ writePosition.		writePosition-1 to: readPosition by: -1 do:			[:i | value _ contentsArray at: i.			contentsArray at: i put: nil.			(aBlock value: value) ifTrue: [				"We take an element out of the queue, and therefore, we need to decrement 				the readSynch signals"				readSynch wait.			] ifFalse: [				newReadPos _ newReadPos - 1.				contentsArray at: newReadPos put: value]].		readPosition _ newReadPos].	^value! !!SharedQueue methodsFor: 'accessing'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	| value |	readSynch wait.	accessProtect		critical: [readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value _ nil]					ifFalse: 						[value _ contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition _ readPosition + 1]].	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'di 10/1/2001 20:58'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	| value readPos |	accessProtect critical: [		value _ nil.		readPos _ readPosition.		[readPos < writePosition and: [value isNil]] whileTrue: [			value _ contentsArray at: readPos.			readPos _ readPos + 1.			(aBlock value: value) ifTrue: [				readPosition to: readPos - 1 do: [ :j |					contentsArray at: j put: nil.				].				readPosition _ readPos.			] ifFalse: [				value _ nil.			].		].		readPosition >= writePosition ifTrue: [readSynch initSignals].	].	^value"===q _ SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c _ OrderedCollection new.[	v _ q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing'!nextPut: value 	"Send value through the receiver. If a Process has been suspended 	waiting to receive a value through the receiver, allow it to proceed."	accessProtect		critical: [writePosition > contentsArray size						ifTrue: [self makeRoomAtEnd].				 contentsArray at: writePosition put: value.				 writePosition _ writePosition + 1].	readSynch signal.	^value! !!SharedQueue methodsFor: 'accessing'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, suspend the requesting process until one is."	| value |	accessProtect		critical: [readPosition >= writePosition					ifTrue: [readPosition _ 1.							writePosition _ 1.							value _ nil]					ifFalse: [value _ contentsArray at: readPosition]].	^value! !!SharedQueue methodsFor: 'accessing'!size	"Answer the number of objects that have been sent through the	receiver and not yet received by anyone."	^writePosition - readPosition! !!SharedQueue methodsFor: 'testing'!isEmpty	"Answer whether any objects have been sent through the receiver and 	not yet received by anyone."	^readPosition = writePosition! !!SharedQueue methodsFor: 'private'!init: size	contentsArray _ Array new: size.	readPosition _ 1.	writePosition _ 1.	accessProtect _ Semaphore forMutualExclusion.	readSynch _ Semaphore new! !!SharedQueue methodsFor: 'private' stamp: 'sma 4/22/2000 18:04'!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: [contentsArray _ contentsArray , (Array new: 10)]		ifFalse: 			[contentsSize _ writePosition - readPosition.			"BLT direction ok for this. Lots faster!!!!!!!!!!!! SqR!!!! 4/10/2000 10:47"			contentsArray				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition.			readPosition _ 1.			writePosition _ contentsSize + 1]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SharedQueue class	instanceVariableNames: ''!!SharedQueue class methodsFor: 'instance creation'!new	"Answer a new instance of SharedQueue that has 10 elements."	^self new: 10! !!SharedQueue class methodsFor: 'instance creation'!new: anInteger 	^super new init: anInteger! !Model subclass: #SimpleServiceEntry	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!SimpleServiceEntry commentStamp: '<historical>' prior: 0!I represent a serviceprovider : the service providerlabel : to be display in a menuselector : to do the serviceuseLineAfterstateSelector : a secondary selector (to be able to query state of the provider for example)description : a description for balloon for exampleargumentGetter : a selector to get additional arguments with (if selector requres them)buttonLabel : a short labelThe entire client interface (provided by FileList and other users of the registry)is this (browse #getArgumentsFrom: and the senders of #argumentGetter:):fullName (returns a String with the full filename)dirAndFileName (returns {directory. fileName})readOnlyStream (returns an open read-only stream)!!SimpleServiceEntry methodsFor: 'accessing' stamp: 'RAA 2/2/2002 08:14'!argumentGetter: aBlock	argumentGetter _ aBlock! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sw 2/15/2002 17:53'!buttonLabel	"Answer the label to be emblazoned on a button representing the service in a file list, for example"	^ buttonLabel ifNil: [label]! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'dgd 9/1/2003 12:16'!buttonLabel: aString 	"Set the receiver's buttonLabel, to be used on a button in a 	tool-pane; this is split out so that a more abbreviated wording 	can be deployed if desired"	buttonLabel := aString translated! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sd 1/31/2002 21:03'!description	"may be used for balloon or other"	^ description! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sd 1/31/2002 21:03'!description: aString	"may be used for balloon or other"	description := aString! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sd 1/31/2002 21:10'!extraSelector	"normally should not be used directly"	^stateSelector! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sd 1/31/2002 21:11'!extraSelector: aSymbol	stateSelector := aSymbol! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'hg 8/3/2000 13:06'!label	^label! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sd 1/31/2002 21:38'!provider	^ provider! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'dgd 9/1/2003 12:12'!provider: anObject label: aString selector: aSymbol 	"basic initialization message"	provider := anObject.	label := aString translated.	selector := aSymbol.	stateSelector := #none.	description := ''! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'sd 1/31/2002 21:09'!selector	"normally should not be used directly"	^selector! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'RAA 2/2/2002 08:31'!getArgumentsFrom: aProvider	argumentGetter ifNil: [^aProvider fullName].	^argumentGetter value: aProvider! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'nk 2/15/2004 16:15'!performServiceFor: anObject	"carry out the service I provide"	^selector numArgs = 0		ifTrue: [provider perform: selector]		ifFalse: [provider perform: selector with: (self getArgumentsFrom: anObject) ]! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'dgd 9/1/2003 12:13'!provider: anObject label: aString selector: aSymbol description: anotherString 	"basic initialization message"	self		provider: anObject		label: aString		selector: aSymbol.	stateSelector := #none.	description := anotherString translated! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'hg 8/1/2000 19:49'!requestSelector	"send me this message to ask me to perform my service"	^#performServiceFor:! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'nk 2/15/2004 16:16'!addServiceFor: served toMenu: aMenu	aMenu add: self label 		target: self 		selector: self requestSelector 		argument: served.	self useLineAfter ifTrue: [ aMenu addLine ].! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'hg 8/1/2000 19:53'!useLineAfter	^useLineAfter == true! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'hg 8/1/2000 19:54'!useLineAfter: aBoolean	useLineAfter _ aBoolean! !!SimpleServiceEntry methodsFor: 'extra' stamp: 'nk 6/8/2004 16:42'!performExtraFor: anObject	"carry out the extra service I provide"	"the stateSelector can be used to ask state of the provider to be reflected in button or other"	^stateSelector numArgs = 0		ifTrue: [provider perform: stateSelector]		ifFalse: [provider perform: stateSelector with: (self getArgumentsFrom: anObject) ]! !!SimpleServiceEntry methodsFor: 'extra' stamp: 'sd 1/31/2002 21:08'!requestExtraSelector	"send me this message to ask me to perform secondary service"	^#performExtraFor:! !!SimpleServiceEntry methodsFor: 'printing' stamp: 'nk 10/14/2003 10:04'!printOn: aStream	aStream nextPutAll: self class name; nextPutAll: ': ('.	self provider notNil		ifTrue: [aStream nextPutAll: provider printString].	aStream nextPutAll: ' --- '. 	self selector notNil		ifTrue: [aStream nextPutAll: selector asString].	aStream nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimpleServiceEntry class	instanceVariableNames: ''!!SimpleServiceEntry class methodsFor: 'instance creation' stamp: 'hg 8/1/2000 18:57'!provider: anObject label: aString selector: aSymbol	^self new provider: anObject label: aString selector: aSymbol! !!SimpleServiceEntry class methodsFor: 'instance creation' stamp: 'sd 1/31/2002 22:05'!provider: anObject label: aString selector: aSymbol description: anotherString	^self new provider: anObject label: aString selector: aSymbol description: anotherString! !!SimpleServiceEntry class methodsFor: 'instance creation' stamp: 'sw 2/17/2002 02:48'!provider: anObject label: aString selector: aSymbol description: anotherString buttonLabel: aLabel	"Answer a new service object with the given initializations.  This variant allows a custom button label to be provided, in order to preserve precious horizontal real-estate in the button pane, while still allowing more descriptive wordings in the popup menu"	^ self new provider: anObject label: aString selector: aSymbol description: anotherString; buttonLabel: aLabel; yourself! !Integer subclass: #SmallInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!SmallInteger commentStamp: '<historical>' prior: 0!My instances are 31-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!SmallInteger methodsFor: 'arithmetic' stamp: 'di 2/1/1999 21:29'!* aNumber 	"Primitive. Multiply the receiver by the argument and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 9>	^ super * aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'di 2/1/1999 21:31'!+ aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 1>	^ super + aNumber! !!SmallInteger methodsFor: 'arithmetic'!- aNumber 	"Primitive. Subtract the argument from the receiver and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 2>	^super - aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'hh 10/3/2000 11:47'!/ aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber isZero ifTrue: [^(ZeroDivide dividend: self) signal].	(aNumber isMemberOf: SmallInteger)		ifTrue: [^(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [^super / aNumber]! !!SmallInteger methodsFor: 'arithmetic' stamp: 'tk 11/30/2001 11:55'!// aNumber 	"Primitive. Divide the receiver by the argument and answer with the	result. Round the result down towards negative infinity to make it a	whole integer. Fail if the argument is 0 or is not a SmallInteger.	Essential. No Lookup. See Object documentation whatIsAPrimitive. "	<primitive: 12>	^ super // aNumber 	"Do with quo: if primitive fails"! !!SmallInteger methodsFor: 'arithmetic' stamp: 'tk 11/30/2001 11:53'!\\ aNumber 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided by	the argument Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 11>	^ super \\ aNumber 	"will use // to compute it if primitive fails"! !!SmallInteger methodsFor: 'arithmetic' stamp: 'LC 4/22/1998 14:21'!gcd: anInteger 	"See SmallInteger (Integer) | gcd:"	| n m |	n _ self.	m _ anInteger.	[n = 0]		whileFalse: 			[n _ m \\ (m _ n)].	^ m abs! !!SmallInteger methodsFor: 'arithmetic' stamp: 'sr 5/28/2000 04:41'!quo: aNumber 	"Primitive. Divide the receiver by the argument and answer with the 	result. Round the result down towards zero to make it a whole integer. 	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 13>	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	(aNumber isMemberOf: SmallInteger)		ifFalse: [^ super quo: aNumber].	(aNumber == -1 and: [self == self class minVal])		ifTrue: ["result is aLargeInteger" ^ self negated].	self primitiveFailed! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitAnd: arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 14>	self >= 0 ifTrue: [^ arg bitAnd: self].	^ (self bitInvert bitOr: arg bitInvert) bitInvert! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'di 4/30/1998 10:33'!bitOr: arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 15>	self >= 0 ifTrue: [^ arg bitOr: self].	^ arg < 0		ifTrue: [(self bitInvert bitAnd: arg bitInvert) bitInvert]		ifFalse: [(self bitInvert bitClear: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitShift: arg 	"Primitive. Answer an Integer whose value is the receiver's value shifted	left by the number of bits indicated by the argument. Negative arguments	shift right. The receiver is interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 17>	self >= 0 ifTrue: [^ super bitShift: arg].	^ arg >= 0		ifTrue: [(self negated bitShift: arg) negated]		ifFalse: [(self bitInvert bitShift: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitXor: arg 	"Primitive. Answer an Integer whose bits are the logical XOR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 16>	self >= 0 ifTrue: [^ arg bitXor: self].	^ arg < 0		ifTrue: [self bitInvert bitXor: arg bitInvert]		ifFalse: [(self bitInvert bitXor: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'SqR 8/3/2000 13:29'!hashMultiply	| low |	low _ self bitAnd: 16383.	^(16r260D * low + ((16r260D * (self bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384))			bitAnd: 16r0FFFFFFF! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:07'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to 	get the highest bit of the magnitude."	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].	^ self highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:08'!highBitOfMagnitude	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. This method is used for negative SmallIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	^ self abs highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'jm 2/19/98 12:11'!lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 4, then single bits.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| n result |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 1.	[ (n bitAnd: 16rF) = 0 ]		whileTrue: [			result := result + 4.			n := n bitShift: -4 ].	[ (n bitAnd: 1) = 0 ]		whileTrue: [			result := result + 1.			n := n bitShift: -1 ].	^ result! !!SmallInteger methodsFor: 'testing'!even	^(self bitAnd: 1) = 0! !!SmallInteger methodsFor: 'testing'!odd	^(self bitAnd: 1) = 1! !!SmallInteger methodsFor: 'comparing'!< aNumber 	"Primitive. Compare the receiver with the argument and answer with	true if the receiver is less than the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger. Essential. No Lookup. See	Object documentation whatIsAPrimitive."	<primitive: 3>	^super < aNumber! !!SmallInteger methodsFor: 'comparing'!<= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger. Optional. No Lookup.	See Object documentation whatIsAPrimitive. "	<primitive: 5>	^super <= aNumber! !!SmallInteger methodsFor: 'comparing'!= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive. "	<primitive: 7>	^super = aNumber! !!SmallInteger methodsFor: 'comparing'!> aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive."	<primitive: 4>	^super > aNumber! !!SmallInteger methodsFor: 'comparing'!>= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger. Optional. No Lookup.	See Object documentation whatIsAPrimitive."	<primitive: 6>	^super >= aNumber! !!SmallInteger methodsFor: 'comparing'!hash	^self! !!SmallInteger methodsFor: 'comparing'!identityHash	^self! !!SmallInteger methodsFor: 'comparing' stamp: 'di 9/27/97 20:32'!identityHashMappedBy: map	^ self! !!SmallInteger methodsFor: 'comparing'!~= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is not equal to the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive."	<primitive: 8>	^super ~= aNumber! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !!SmallInteger methodsFor: 'copying'!deepCopy! !!SmallInteger methodsFor: 'copying'!shallowCopy! !!SmallInteger methodsFor: 'copying' stamp: 'tk 8/19/1998 16:04'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!SmallInteger methodsFor: 'converting'!asFloat	"Primitive. Answer a Float that represents the value of the receiver.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 40>	self primitiveFailed! !!SmallInteger methodsFor: 'printing' stamp: 'gk 11/26/2003 10:27'!printOn: aStream base: base	"Refer to the comment in Integer|printOn:base:."	"SmallInteger maxVal printStringBase: 2"	| x i digits letters |	self < 0 ifTrue: [		aStream nextPut: $-.		^ self negated printOn: aStream base: base].	digits _ '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.	base = 10 ifFalse: [aStream print: base; nextPut: $r].	letters _ String new: 32.	x _ self.	i _ 33.	[x >= base] whileTrue: [		letters at: (i _ i - 1) put: (digits at: (x \\ base) + 1).		x _ x // base].	letters at: (i _ i - 1) put: (digits at: x + 1).	aStream nextPutAll: (letters copyFrom: i to: letters size)! !!SmallInteger methodsFor: 'printing' stamp: 'RAA 8/24/2001 13:59'!threeDigitName	| units answer |	self = 0 ifTrue: [^''].	units _ #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten' 		'eleven' 'twelve' 'thirteen' 'fourteen' 'fifteen' 'sixteen' 'seventeen' 		'eighteen' 'nineteen').	self > 99 ifTrue: [		answer _ (units at: self // 100),' hundred'.		(self \\ 100) = 0 ifFalse: [			answer _ answer,' ',(self \\ 100) threeDigitName		].		^answer	].	self < 20 ifTrue: [		^units at: self	].	answer _ #('twenty' 'thirty' 'forty' 'fifty' 'sixty' 'seventy' 'eighty' 'ninety')			at: self // 10 - 1.	(self \\ 10) = 0 ifFalse: [		answer _ answer,'-',(units at: self \\ 10)	].	^answer! !!SmallInteger methodsFor: 'printing' stamp: 'sw 10/26/2000 09:01'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.   For SmallIntegers, we can actually just use the receiver's own printString, though this is pretty strange in some ways."	^ self asString! !!SmallInteger methodsFor: 'system primitives'!asOop	"Answer an object pointer as an integer, return negative number for SmallInteger"	^ self! !!SmallInteger methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:28'!digitAt: n 	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."	n>4 ifTrue: [^ 0].	self < 0		ifTrue: 			[self = SmallInteger minVal ifTrue:				["Can't negate minVal -- treat specially"				^ #(0 0 0 64) at: n].			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !!SmallInteger methodsFor: 'system primitives' stamp: 'md 6/5/2003 10:42'!digitAt: n put: value 	"Fails. The digits of a small integer can not be modified."	self error: 'You can''t store in a SmallInteger'! !!SmallInteger methodsFor: 'system primitives'!digitLength	"Answer the number of indexable fields in the receiver. This value is the 	same as the largest legal subscript. Included so that a SmallInteger can 	behave like a LargePositiveInteger or LargeNegativeInteger."	(self < 16r100 and: [self > -16r100]) ifTrue: [^ 1].	(self < 16r10000 and: [self > -16r10000]) ifTrue: [^ 2].	(self < 16r1000000 and: [self > -16r1000000]) ifTrue: [^ 3].	^ 4! !!SmallInteger methodsFor: 'system primitives'!instVarAt: i 	"Small integer has to be specially handled."	i = 1 ifTrue: [^self].	self error: 'argument too big for small integer instVarAt:'! !!SmallInteger methodsFor: 'system primitives' stamp: 'tk 5/14/1999 20:54'!nextInstance	"SmallIntegers can't be enumerated this way.  There are a finite number of them from from (SmallInteger minVal) to (SmallInteger maxVal), but you'll have to enumerate them yourself with:	(SmallInteger minVal) to: (SmallInteger maxVal) do: [:integer | <your code here>].	"	self shouldNotImplement ! !!SmallInteger methodsFor: 'system primitives' stamp: 'je 10/22/2002 12:10'!nextObject	"SmallIntegers are immediate objects, and, as such, do not have successors in object memory."	self shouldNotImplement ! !!SmallInteger methodsFor: 'private'!fromString: str radix: radix	| maxdigit c val |	maxdigit _ 		radix + (radix > 10					ifTrue: [55 - 1]					ifFalse: [48 - 1]).	val _ 0.	1 to: str size do: 		[:i | 		c _ str at: i.		(c < 48 ifFalse: [c > maxdigit])			ifTrue: [^false].		val _ val * radix + (c <= 57							ifTrue: [c - 48]							ifFalse: 								[c < 65 ifTrue: [^false].								c - 55])].	^val! !!SmallInteger methodsFor: 'private' stamp: 'sr 6/8/2000 01:14'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted _ self.	bitNo _ 0.	[shifted < 16]		whileFalse: 			[shifted _ shifted bitShift: -4.			bitNo _ bitNo + 4].	[shifted = 0]		whileFalse: 			[shifted _ shifted bitShift: -1.			bitNo _ bitNo + 1].	^ bitNo! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmallInteger class	instanceVariableNames: ''!!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:17'!basicNew	self error: 'SmallIntegers can only be created by performing arithmetic'! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!new	self basicNew	"generates an error"! !!SmallInteger class methodsFor: 'constants'!maxVal	"Answer the maximum value for a SmallInteger."	^ 16r3FFFFFFF! !!SmallInteger class methodsFor: 'constants'!minVal	"Answer the minimum value for a SmallInteger."	^ -16r40000000! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:04'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToSmallIntegerObjectFrom: aNode on: aStream! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 10/5/1999 06:11'!ccg: cg generateCoerceToValueFrom: aNode on: aStream	cg generateCoerceToSmallIntegerValueFrom: aNode on: aStream! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:09'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asIntegerValueFrom: anInteger! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:20'!ccgCanConvertFrom: anObject	^anObject class == self! !Object subclass: #SmalltalkImage	instanceVariableNames: ''	classVariableNames: 'LastImageName LastQuitLogPosition LastStats SourceFileVersionString StartupStamp'	poolDictionaries: ''	category: 'System-Support'!!SmalltalkImage commentStamp: 'sd 7/2/2003 21:50' prior: 0!I represent the SmalltalkImage and partly the VM. Using my current instance you can 	- get the value of some VM parameters, system arguments, vm profiling,	endianess status, external objects,....	- save the image, manage sourcesAs you will notice browsing my code I'm a fat class having still too much responsibility.But this is life. sd-2 July 2003PS: if someone wants to split me go ahead.!!SmalltalkImage methodsFor: 'endian' stamp: 'sd 7/3/2003 22:05'!endianness	| bytes word blt |	"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte."	"SmalltalkImage current endianness"	bytes _ ByteArray withAll: #(0 0 0 0).  "(1 2 3 4) or (4 3 2 1)"	word _ WordArray with: 16r01020304.	blt _ (BitBlt toForm: (Form new hackBits: bytes)) 				sourceForm: (Form new hackBits: word).	blt combinationRule: Form over.  "store"	blt sourceY: 0; destY: 0; height: 1; width: 4.	blt sourceX: 0; destX: 0.	blt copyBits.  "paste the word into the bytes"	bytes first = 1 ifTrue: [^ #big].	bytes first = 4 ifTrue: [^ #little].	self error: 'Ted is confused'.! !!SmalltalkImage methodsFor: 'endian' stamp: 'sd 6/27/2003 23:25'!isBigEndian	^self endianness == #big! !!SmalltalkImage methodsFor: 'endian' stamp: 'sd 6/27/2003 23:25'!isLittleEndian	^self endianness == #little! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'sd 11/16/2003 11:58'!changeImageNameTo: aString		self imageName: aString.	LastImageName := self imageName! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'sd 11/16/2003 11:58'!changesName	"Answer the local name for the changes file corresponding to the image file name."	"Smalltalk changesName"	| imName |	imName := FileDirectory baseNameFor:		(FileDirectory localNameFor: self imageName).	^ imName, FileDirectory dot, 'changes'! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'tpr 12/15/2003 12:09'!fullNameForChangesNamed: aName	| newName |	newName := FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory changeSuffix.! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'tpr 12/15/2003 12:10'!fullNameForImageNamed: aName	| newName |	newName := FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory imageSuffix.! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'sd 9/24/2003 12:51'!imageName	"Answer the full path name for the current image."	"SmalltalkImage current imageName"	<primitive: 121>	self primitiveFailed! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'sd 10/11/2003 12:05'!imageName: newName	"Set the the full path name for the current image.  All further snapshots will use this."	<primitive: 121>	^ self primitiveFailed! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'sd 9/24/2003 12:43'!sourceFileVersionString	^ SourceFileVersionString! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'ssa 9/3/2008 14:28'!sourcesName	"Answer the full path to the version-stable source code"	^  SourceFileVersionString , FileDirectory dot , 'sources'! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'sd 9/24/2003 12:46'!vmPath	"Answer the path for the directory containing the Smalltalk virtual machine. Return the 	empty string if this primitive is not implemented."	"SmalltalkImage current vmPath"	<primitive: 142>	^ ''! !!SmalltalkImage methodsFor: 'preferences' stamp: 'sd 6/28/2003 17:33'!setPlatformPreferences	"Set some platform specific preferences on system startup"	| platform specs |	Preferences automaticPlatformSettings ifFalse:[^self].	platform _ self platformName.	specs _ 	#(						(soundStopWhenDone false)					(soundQuickStart false)			).	platform = 'Win32' ifTrue:[		specs _ #(						(soundStopWhenDone true)					(soundQuickStart false)				)].	platform = 'Mac OS' ifTrue:[		specs _ #(						(soundStopWhenDone false)					(soundQuickStart true)				)].	specs do:[:tuple|		Preferences setPreference: tuple first toValue: (tuple last == #true).	].! !!SmalltalkImage methodsFor: 'quit' stamp: 'sd 6/28/2003 17:32'!quitPrimitive	"Primitive. Exit to another operating system on the host machine, if one	exists. All state changes in the object space since the last snapshot are lost.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 113>	self primitiveFailed! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'tpr 12/15/2003 12:18'!getFileNameFromUser	| newName |	newName := FillInTheBlank		request: 'New File Name?' translated		initialAnswer: (FileDirectory localNameFor: self imageName).	newName isEmpty ifTrue: [^nil].	((FileDirectory default fileOrDirectoryExists: (self fullNameForImageNamed: newName)) or:	 [FileDirectory default fileOrDirectoryExists: (self fullNameForChangesNamed: newName)]) ifTrue: [		(self confirm: ('{1} already exists. Overwrite?' translated format: {newName})) ifFalse: [^nil]].	^newName! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'sd 11/16/2003 14:08'!readDocumentFile	"No longer used. Everything is now done in ProjectLauncher."	"I do not understand the above comment because this method is still called 		by other methods in the class SystemDictionary so I moved it here- sd - 16 Nov 03"		StartupStamp _ '----STARTUP----', Time dateAndTimeNow printString, ' as ', self imageName.! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'sd 11/16/2003 14:20'!shutDown	^ self closeSourceFiles! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'sd 11/16/2003 14:12'!snapshot: save andQuit: quit	^self snapshot: save andQuit: quit embedded: false! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'ssa 9/3/2008 11:13'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg _ String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming _ embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming _ false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self readDocumentFile].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'sd 11/16/2003 13:58'!snapshotEmbeddedPrimitive	<primitive: 247>	^nil "indicates error writing embedded image file"! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'sd 11/16/2003 13:59'!snapshotPrimitive	"Primitive. Write the current state of the object memory on a file in the	same format as the Smalltalk-80 release. The file can later be resumed,	returning you to this exact state. Return normally after writing the file.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 97>	^nil "indicates error writing image file"! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'NS 1/16/2004 15:34'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: StartupStamp asString; cr.	StartupStamp _ nil.	self forceChangesToDisk.! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 13:12'!closeSourceFiles	"Shut down the source files if appropriate.  1/29/96 sw: changed so that the closing and nilification only take place if the entry was a FileStream, thus allowing stringified sources to remain in the saved image file"	1 to: 2 do: [:i |		((SourceFiles at: i) isKindOf: FileStream)			ifTrue:				[(SourceFiles at: i) close.				SourceFiles at: i put: nil]]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'NS 1/27/2004 15:55'!event: anEvent	"Hook for SystemChangeNotifier"	(anEvent isRemoved and: [anEvent itemKind = SystemChangeNotifier classKind]) ifTrue: [		anEvent item acceptsLoggingOfCompilation 			ifTrue: [self logChange: 'Smalltalk removeClassNamed: #' , anEvent item name].	].	anEvent isDoIt 		ifTrue: [self logChange: anEvent item].	(anEvent isRemoved and: [anEvent itemKind = SystemChangeNotifier methodKind]) ifTrue: [		anEvent itemClass acceptsLoggingOfCompilation 			ifTrue: [self logChange: anEvent itemClass name , ' removeSelector: #' , anEvent itemSelector]].! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'ssa 9/3/2008 11:25'!forceChangesToDisk	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."	| changesFile |	changesFile _ SourceFiles at: 2.	(changesFile isKindOf: FileStream) ifTrue: [		changesFile flush.		true ifTrue:[			changesFile close.			changesFile open: changesFile name forWrite: true].		changesFile setToEnd.	].! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 14:02'!lastQuitLogPosition	^ LastQuitLogPosition! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 14:03'!lastQuitLogPosition: aNumber	"should be only use to ensure the transition from SystemDictionary to SmalltalkImage, then  	be removed"			LastQuitLogPosition := aNumber! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'NS 1/16/2004 15:32'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile _ SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 12:00'!openSourceFiles	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName _ self imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName.	StandardSourceFileArray install! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 12:21'!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	| newName |	newName _ self getFileNameFromUser.	newName isNil ifTrue: [^ self].	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 16:01'!saveChangesInFileNamed: aString	| fullChangesName |	fullChangesName _ (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullChangesName )) assureExistence.	FileDirectory default 		copyFileWithoutOverwriteConfirmationNamed: SmalltalkImage current changesName 		toFileNamed: fullChangesName.	Smalltalk setMacFileInfoOn: fullChangesName.! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 15:58'!saveImageInFileNamed: aString	| fullImageName |	fullImageName _ (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullImageName )) assureExistence.	self		changeImageNameTo: fullImageName;		closeSourceFiles;		openSourceFiles;  "so SNAPSHOT appears in new changes file"		saveImageSegments;		snapshot: true andQuit: false! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 13:29'!saveImageSegments	| haveSegs oldImageSegDir newImageSegDir |	haveSegs _ false.	Smalltalk at: #ImageSegment ifPresent: [:theClass | 		(haveSegs _ theClass instanceCount ~= 0) ifTrue: [			oldImageSegDir _ theClass segmentDirectory]].	haveSegs ifTrue: [		Smalltalk at: #ImageSegment ifPresent: [:theClass |			newImageSegDir _ theClass segmentDirectory.	"create the folder"			oldImageSegDir fileNames do: [:theName | "copy all segment files"				| imageSegmentName |				imageSegmentName _ oldImageSegDir pathName, FileDirectory slash, theName.				newImageSegDir 					copyFileWithoutOverwriteConfirmationNamed: imageSegmentName					toFileNamed: theName]]].! !!SmalltalkImage methodsFor: 'system attribute' stamp: 'md 10/26/2003 13:08'!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000...-1 - command line arguments that specify VM options 	0 - the full path name for currently executing VM 	(or, on some platforms, just the path name of the VM's directory) 	1 - full path name of this image 	2 - a Squeak document to open, if any 	3...1000 - command line arguments for Squeak programs 	1001 - this platform's operating system 	1002 - operating system version 	1003 - this platform's processor type	1004 - vm version"	<primitive: 149>	^ nil! !!SmalltalkImage methodsFor: 'system attribute' stamp: 'sd 6/27/2003 23:38'!platformName	"Return the name of the platform we're running on"	^self getSystemAttribute: 1001! !!SmalltalkImage methodsFor: 'vm parameters' stamp: 'sd 6/27/2003 23:47'!getVMParameters		"Answer an Array containing the current values of the VM's internal	parameter/metric registers.  Each value is stored in the array at the	index corresponding to its VM register.  (See #vmParameterAt: and	#vmParameterAt:put:.)"	"SmalltalkImage current getVMParameters"		<primitive: 254>	self primitiveFailed! !!SmalltalkImage methodsFor: 'vm parameters' stamp: 'sd 6/27/2003 23:27'!vmParameterAt: parameterIndex put: newValue	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Store newValue (a positive integer) into that	register and answer with the previous value that was stored there.	Fail if newValue is out of range, if parameterIndex has no corresponding	register, or if the corresponding register is read-only."	<primitive: 254>	self primitiveFailed! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'sd 7/2/2003 21:45'!textMarkerForShortReport	^  'Since last view	'! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'sd 9/30/2003 13:53'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount mcMisses mcHits icHits upTime sendCount tms tmSize upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params _ self getVMParameters.	oldSpaceEnd			_ params at: 1.	youngSpaceEnd		_ params at: 2.	memoryEnd			_ params at: 3.	fullGCs				_ params at: 7.	fullGCTime			_ params at: 8.	incrGCs				_ params at: 9.	incrGCTime			_ params at: 10.	tenureCount			_ params at: 11.	mcMisses			_ params at: 15.	mcHits				_ params at: 16.	icHits				_ params at: 17.	upTime _ Time millisecondClockValue.	sendCount _ mcMisses + mcHits + icHits.	tms _ TranslatedMethod allSubInstances.	tmSize _ tms inject: 0 into: [:sum :tm | sum + (tm size * 4)].	str _ WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats _ Array new: 6]ifNotNil: [	upTime2 _ upTime - (LastStats at: 1).	fullGCs2 _ fullGCs - (LastStats at: 2).	fullGCTime2 _ fullGCTime - (LastStats at: 3).	incrGCs2 _ incrGCs - (LastStats at: 4).	incrGCTime2 _ incrGCTime - (LastStats at: 5).	tenureCount2 _ tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	sendCount > 0 ifTrue: [		str	nextPutAll: 'sends			';			nextPutAll: sendCount asStringWithCommas; cr.		str	nextPutAll: '	full			';			nextPutAll: mcMisses asStringWithCommas;			nextPutAll: ' ('; print: ((mcMisses / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	m-cache	';			nextPutAll: mcHits asStringWithCommas;			nextPutAll: ' ('; print: ((mcHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	i-cache		';			nextPutAll: icHits asStringWithCommas;			nextPutAll: ' ('; print: ((icHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr].	icHits > 0 ifTrue: [		str	nextPutAll: 'methods			';			nextPutAll: tms size asStringWithCommas; nextPutAll: ' translated'; cr.		str	nextPutAll: '	size			';			nextPutAll: tmSize asStringWithCommas; nextPutAll: ' bytes, avg ';			print: ((tmSize / tms size) roundTo: 0.1); nextPutAll: ' bytes/method'; cr.		str	nextPutAll: '	memory		';			print: ((tmSize / youngSpaceEnd * 100) roundTo: 0.1); nextPutAll: '% of used, ';			print: ((tmSize / memoryEnd * 100) roundTo: 0.1); nextPutAll: '% of available'; cr].	^ str contents! !!SmalltalkImage methodsFor: 'private source file' stamp: 'sd 9/24/2003 12:42'!sourceFileVersionString: aString	SourceFileVersionString := aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmalltalkImage class	instanceVariableNames: 'current'!!SmalltalkImage class methodsFor: 'instance creation' stamp: 'sd 9/30/2003 14:28'!current	"Note that this could be implemented differently to avoid the test"	current isNil		ifTrue: [current := self basicNew].	^ current! !!SmalltalkImage class methodsFor: 'instance creation' stamp: 'sd 9/30/2003 13:39'!new	self error: 'Use current'.! !!SmalltalkImage class methodsFor: 'class initialization' stamp: 'NS 1/16/2004 16:12'!startUp	SystemChangeNotifier uniqueInstance notify: self current ofAllSystemChangesUsing: #event:.! !OrderedCollection subclass: #SortedCollection	instanceVariableNames: 'sortBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!SortedCollection commentStamp: '<historical>' prior: 0!I represent a collection of objects ordered by some property of the objects themselves. The ordering is specified in a BlockContext.!!SortedCollection methodsFor: 'accessing' stamp: 'sma 4/28/2000 17:47'!at: anInteger put: anObject	self shouldNotImplement! !!SortedCollection methodsFor: 'accessing' stamp: 'tk 3/28/1999 22:55'!median	"Return the middle element, or as close as we can get."	^ self at: self size + 1 // 2! !!SortedCollection methodsFor: 'accessing'!sortBlock	"Answer the blockContext which is the criterion for sorting elements of 	the receiver."	^sortBlock! !!SortedCollection methodsFor: 'accessing' stamp: 'stp 12/05/1999 07:09'!sortBlock: aBlock 	"Make the argument, aBlock, be the criterion for ordering elements of the 	receiver."	aBlock		ifNotNil: [sortBlock := aBlock fixTemps]		ifNil: [sortBlock := aBlock].	"The sortBlock must copy its home context, so as to avoid circularities!!"	"Therefore sortBlocks with side effects may not work right"	self size > 0 ifTrue: [self reSort]! !!SortedCollection methodsFor: 'adding' stamp: 'go 4/27/2000 13:19'!add: newObject	^ super insert: newObject before: (self indexForInserting: newObject)! !!SortedCollection methodsFor: 'adding' stamp: 'sma 4/28/2000 18:35'!addAll: aCollection	aCollection size > (self size // 3)		ifTrue:			[aCollection do: [:each | self addLast: each].			self reSort]		ifFalse: [aCollection do: [:each | self add: each]].	^ aCollection! !!SortedCollection methodsFor: 'adding' stamp: 'go 4/26/2000 17:26'!addFirst: newObject	self shouldNotImplement! !!SortedCollection methodsFor: 'adding' stamp: 'MPH 10/23/2000 13:31'!copyEmpty	"Answer a copy of the receiver without any of the receiver's elements."	^self species sortBlock: sortBlock! !!SortedCollection methodsFor: 'comparing'!= aSortedCollection	"Answer true if my and aSortedCollection's species are the same,	and if our blocks are the same, and if our elements are the same."	self species = aSortedCollection species ifFalse: [^ false].	sortBlock = aSortedCollection sortBlock		ifTrue: [^ super = aSortedCollection]		ifFalse: [^ false]! !!SortedCollection methodsFor: 'copying'!copy	| newCollection |	newCollection _ self species sortBlock: sortBlock.	newCollection addAll: self.	^newCollection! !!SortedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection _ OrderedCollection new: self size.	self do: [:each | newCollection addLast: (aBlock value: each)].	^ newCollection! !!SortedCollection methodsFor: 'private' stamp: 'stp 04/23/1999 05:36'!indexForInserting: newObject	| index low high |	low _ firstIndex.	high _ lastIndex.	sortBlock isNil		ifTrue: [[index _ high + low // 2.  low > high]			whileFalse: 				[((array at: index) <= newObject)					ifTrue: [low _ index + 1]					ifFalse: [high _ index - 1]]]		ifFalse: [[index _ high + low // 2.  low > high]			whileFalse: 				[(sortBlock value: (array at: index) value: newObject)					ifTrue: [low _ index + 1]					ifFalse: [high _ index - 1]]].	^low! !!SortedCollection methodsFor: 'private' stamp: 'go 4/26/2000 17:17'!insert: anObject before: spot	self shouldNotImplement! !!SortedCollection methodsFor: 'private' stamp: 'sma 4/28/2000 17:46'!reSort	self sort: firstIndex to: lastIndex! !!SortedCollection methodsFor: 'private' stamp: 'hg 12/17/2001 19:30'!should: a precede: b	^sortBlock ifNil: [a <= b] ifNotNil: [sortBlock value: a value: b]! !!SortedCollection methodsFor: 'private' stamp: 'hg 12/17/2001 20:22'!sort: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	(self should: di precede: dj)		ifFalse: 			[array swap: i with: j.			 tt _ di.			 di _ dj.			 dj _ tt].	n > 2		ifTrue:  "More than two elements."			[ij _ (i + j) // 2.  "ij is the midpoint of i and j."			 dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."			 (self should: di precede: dij)			   ifTrue: 				[(self should: dij precede: dj)				  ifFalse: 					[array swap: j with: ij.					 dij _ dj]]			   ifFalse:				[array swap: i with: ij.				 dij _ di].			n > 3			  ifTrue:  "More than three elements."				["Find k>i and l<j such that dk,dij,dl are in reverse order.				Swap k and l.  Repeat this procedure until k and l pass each other."				 k _ i.				 l _ j.				 [[l _ l - 1.  k <= l and: [self should: dij precede: (array at: l)]]				   whileTrue.  "i.e. while dl succeeds dij"				  [k _ k + 1.  k <= l and: [self should: (array at: k) precede: dij]]				   whileTrue.  "i.e. while dij succeeds dk"				  k <= l]				   whileTrue:					[array swap: k with: l]. 	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."				self sort: i to: l.				self sort: k to: j]]! !!SortedCollection methodsFor: 'topological sort' stamp: 'hg 1/2/2002 13:34'!sortTopologically	"Plenty of room for increased efficiency in this one."	| remaining result pick |	remaining _ self asOrderedCollection.	result _ OrderedCollection new.	[remaining isEmpty] whileFalse: [		pick _ remaining select: [:item |			remaining allSatisfy: [:anotherItem |				item == anotherItem or: [self should: item precede: anotherItem]]].		pick isEmpty ifTrue: [self error: 'bad topological ordering'].		result addAll: pick.		remaining removeAll: pick].	^self copySameFrom: result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SortedCollection class	instanceVariableNames: ''!!SortedCollection class methodsFor: 'instance creation' stamp: 'stp 04/23/1999 05:34'!new: anInteger 	"The default sorting function is a <= comparison on elements."	^(super new: anInteger) "sortBlock: [:x :y | x <= y]" 		"nil sortBlock OK"! !!SortedCollection class methodsFor: 'instance creation'!sortBlock: aBlock 	"Answer an instance of me such that its elements are sorted according to 	the criterion specified in aBlock."	^(super new: 10) sortBlock: aBlock! !AppRegistry subclass: #SoundService	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Applications'!!SoundService commentStamp: 'gk 2/24/2004 23:14' prior: 0!This is the AppRegistry class for the sound system.A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in this registry and can be accessed by "SoundService default". This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.!SequenceableCollection subclass: #SourceFileArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!SourceFileArray commentStamp: '<historical>' prior: 0!This class is an abstract superclass for source code access mechanisms. It defines the messages that need to be understood by those subclasses that store and retrieve source chunks on files, over the network or in databases.The first concrete subclass, StandardSourceFileArray, supports access to the traditional sources and changes files. Other subclasses might implement multiple source files for different applications, or access to a network source server.!]style[(254 23 184)f1,f1LStandardSourceFileArray Comment;,f1!!SourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:42'!at: index	self subclassResponsibility! !!SourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:43'!at: index put: aFileStream	self subclassResponsibility! !!SourceFileArray methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:28'!collect: aBlock	| copy |	copy _ self species new: self size.	1 to: self size do:[:i| copy at: i put: (aBlock value: (self at: i))].	^copy! !!SourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:43'!size	self subclassResponsibility! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 22:00'!fileIndexFromSourcePointer: anInteger	"Return the index of a source file corresponding to the given source pointer."	self subclassResponsibility! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 22:00'!filePositionFromSourcePointer: anInteger	"Return the position within a source file for the given source pointer."	self subclassResponsibility! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 22:01'!sourcePointerFromFileIndex: index andPosition: position	"Return a sourcePointer encoding the given file index and position"	self subclassResponsibility! !Path subclass: #Spline	instanceVariableNames: 'coefficients'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Paths'!!Spline commentStamp: '<historical>' prior: 0!I represent a collection of Points through which a cubic spline curve is fitted.!!Spline methodsFor: 'displaying'!computeCurve	"Compute an array for the coefficients."	| length extras |	length _ self size.	extras _ 0.	coefficients _ Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(self at: i) x asFloat]						ifFalse: [(self at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Display the receiver, a spline curve, approximated by straight line	segments."	| n line t x y x1 x2 x3 y1 y2 y3 |	collectionOfPoints size < 1 ifTrue: [self error: 'a spline must have at least one point'].	line _ Line new.	line form: self form.	line beginPoint: 		(x _ (coefficients at: 1) at: 1) rounded @ (y _ (coefficients at: 5) at: 1) rounded.	1 to: (coefficients at: 1) size - 1 do: 		[:i | 		"taylor series coefficients"		x1 _ (coefficients at: 2) at: i.		y1 _ (coefficients at: 6) at: i.		x2 _ ((coefficients at: 3) at: i) / 2.0.		y2 _ ((coefficients at: 7) at: i) / 2.0.		x3 _ ((coefficients at: 4) at: i) / 6.0.		y3 _ ((coefficients at: 8) at: i) / 6.0.		"guess n"		n _ 5 max: (x2 abs + y2 abs * 2.0 + ((coefficients at: 3)							at: i + 1) abs + ((coefficients at: 7)							at: i + 1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t _ j asFloat / n.			line endPoint: 				(x3 * t + x2 * t + x1 * t + x) rounded 							@ (y3 * t + y2 * t + y1 * t + y) rounded.			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			line beginPoint: line endPoint].		line beginPoint: 				(x _ (coefficients at: 1) at: i + 1) rounded 					@ (y _ (coefficients at: 5) at: i + 1) rounded.		line			displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm 	"Get the scaled and translated path of newKnots."	| newKnots newSpline |	newKnots _ aTransformation applyTo: self.	newSpline _ Spline new.	newKnots do: [:knot | newSpline add: knot].	newSpline form: self form.	newSpline		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Spline methodsFor: 'private'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coefficients) from	the Points in this Path (coefficients at: 1 and coefficients at: 5)."	| l v anArray |	l _ a size.	l < 2 ifTrue: [^self].	l > 2	  ifTrue:		[v _ Array new: l.		 v  at:  1 put: 4.0.		 anArray _ Array new: l.		 anArray  at:  1 put: (6.0 * ((a  at:  1) - ((a  at:  2) * 2.0) + (a  at:  3))).		 2 to: l - 2 do:			[:i | 			v  at:  i put: (4.0 - (1.0 / (v  at:  (i - 1)))).			anArray				at:  i 				put: (6.0 * ((a  at:  i) - ((a  at:  (i + 1)) * 2.0) + (a  at:  (i + 2)))						- ((anArray  at:  (i - 1)) / (v  at:  (i - 1))))].		 point2  at: (l - 1) put: ((anArray  at:  (l - 2)) / (v  at:  (l - 2))).		 l - 2 to: 2 by: 0-1 do: 			[:i | 			point2 				at: i 				put: ((anArray  at:  (i - 1)) - (point2  at:  (i + 1)) / (v  at:  (i - 1)))]].	point2 at: 1 put: (point2  at:  l put: 0.0).	1 to: l - 1 do:		[:i | point1 				at: i 				put: ((a at: (i + 1)) - (a  at:  i) - 						((point2  at:  i) * 2.0 + (point2  at:  (i + 1)) / 6.0)).		      point3 at: i put: ((point2  at:  (i + 1)) - (point2  at:  i))]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Spline class	instanceVariableNames: ''!!Spline class methodsFor: 'examples' stamp: '6/8/97 13:55 di'!example	"Designate points on the Path by clicking the red button. Terminate by	pressing any other button. A curve will be displayed, through the	selected points, using a long black form."	| splineCurve aForm flag|	aForm _ Form extent: 2@2.	aForm  fillBlack.	splineCurve _ Spline new.	splineCurve form: aForm.	flag _ true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: 				[splineCurve add: Sensor waitButton. 				 Sensor waitNoButton.				 aForm displayOn: Display at: splineCurve last]			ifFalse: [flag_false]].	splineCurve computeCurve.	splineCurve isEmpty 		ifFalse: [splineCurve displayOn: Display.				Sensor waitNoButton]. 	"Spline example"! !SelectionMenu subclass: #StandardFileMenu	instanceVariableNames: 'canTypeFileName pattern'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!StandardFileMenu commentStamp: '<historical>' prior: 0!I represent a SelectionMenu which operates like a modal dialog for selecting files, somewhat similar to the StandardFile dialogs in MacOS and Java Swing.Try for example, the following:	StandardFileMenu oldFile inspect	StandardFileMenu oldFileStream inspect	StandardFileMenu newFile inspect	StandardFileMenu newFileStream inspect!!StandardFileMenu methodsFor: 'menu building' stamp: 'di 5/12/2000 10:31'!directoryNamesString: aDirectory"Answer a string concatenating the directory name strings in aDirectory, each string followed by a '[...]' indicator, and followed by a cr."	^ String streamContents:		[:s | aDirectory directoryNames do: 				[:dn | s nextPutAll: dn withBlanksTrimmed , ' [...]'; cr]]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'tk 2/14/2000 14:58'!fileNamesString: aDirectory"Answer a string concatenating the file name strings in aDirectory, each string followed by a cr."	^String streamContents:		[:s | 			aDirectory fileNames do: 				[:fn |					(pattern match: fn) ifTrue: [						s nextPutAll: fn withBlanksTrimmed; cr]]]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'tk 2/14/2000 14:25'!makeFileMenuFor: aDirectory"Initialize an instance of me to operate on aDirectory"	| theMenu |	pattern ifNil: [pattern _ '*'].	Cursor wait showWhile: 		[self 			labels: 	(self menuLabelsString: aDirectory)			font: 	(MenuStyle fontAt: 1) 			lines: 	(self menuLinesArray: aDirectory).		theMenu _ self selections: (self menuSelectionsArray: aDirectory)].	^theMenu! !!StandardFileMenu methodsFor: 'menu building' stamp: 'acg 4/15/1999 21:57'!menuLabelsString: aDirectory"Answer a menu labels object corresponding to aDirectory"	^ String streamContents: 		[:s | 			canTypeFileName ifTrue: 				[s nextPutAll: 'Enter File Name...'; cr].			s nextPutAll: (self pathPartsString: aDirectory).			s nextPutAll: (self directoryNamesString: aDirectory).			s nextPutAll: (self fileNamesString: aDirectory).			s skip: -1]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'tpr 11/28/2003 15:12'!menuLinesArray: aDirectory"Answer a menu lines object corresponding to aDirectory"	| typeCount nameCnt dirDepth|	typeCount _ canTypeFileName 		ifTrue: [1] 		ifFalse: [0].	nameCnt _ aDirectory directoryNames size.	dirDepth _ aDirectory pathParts size.	^Array streamContents: [:s |		canTypeFileName ifTrue: [s nextPut: 1].		s nextPut: dirDepth + typeCount + 1.		s nextPut: dirDepth + nameCnt + typeCount + 1]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'di 5/12/2000 11:01'!menuSelectionsArray: aDirectory"Answer a menu selections object corresponding to aDirectory.  The object is an array corresponding to each item, each element itself constituting a two-element array, the first element of which contains a selector to operate on and the second element of which contains the parameters for that selector."	|dirSize|	dirSize _ aDirectory pathParts size.	^Array streamContents: [:s |		canTypeFileName ifTrue:			[s nextPut: (StandardFileMenuResult				directory: aDirectory				name: nil)].		s nextPut: (StandardFileMenuResult			directory: (FileDirectory root)			name: '').		aDirectory pathParts doWithIndex: 			[:d :i | s nextPut: (StandardFileMenuResult					directory: (self 						advance: dirSize - i						containingDirectoriesFrom: aDirectory)					name: '')].		aDirectory directoryNames do: 			[:dn |  s nextPut: (StandardFileMenuResult						directory: (FileDirectory on: (aDirectory fullNameFor: dn))						name: '')].		aDirectory fileNames do: 			[:fn | (pattern match: fn) ifTrue: [					s nextPut: (StandardFileMenuResult						directory: aDirectory						name: fn)]]]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'acg 4/15/1999 21:03'!pathPartsString: aDirectory"Answer a string concatenating the path parts strings in aDirectory, each string followed by a cr."	^String streamContents:		[:s | 			s nextPutAll: '[]'; cr.			aDirectory pathParts asArray doWithIndex: 				[:part :i |					s next: i put: $ .					s nextPutAll: part withBlanksTrimmed; cr]]! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'acg 4/15/1999 21:52'!confirmExistingFiles: aResult	|choice|	(aResult directory fileExists: aResult name) ifFalse: [^aResult].		choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: aResult name, 'already exists.'.	choice = 1 ifTrue: [		aResult directory 			deleteFileNamed: aResult name			ifAbsent: 				[^self startUpWithCaption: 'Can''t delete ', aResult name, 'Select another file'].		^aResult].	choice = 2 ifTrue: [^self startUpWithCaption: 'Select Another File'].	^nil ! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'dgd 9/21/2003 13:17'!getTypedFileName: aResult	| name |	name _ FillInTheBlank 		request: 'Enter a new file name' 		initialAnswer: ''.	name = '' ifTrue: [^self startUpWithCaption: 'Select a File:' translated].	name _ aResult directory fullNameFor: name.	^ StandardFileMenuResult			directory: (FileDirectory forFileName: name)			name: (FileDirectory localNameFor: name)! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'acg 9/28/1999 23:34'!startUpWithCaption: aString at: location	|result|	result _ super startUpWithCaption: aString at: location.	result ifNil: [^nil].	result isDirectory ifTrue:		[self makeFileMenuFor: result directory.		 self computeForm.		 ^self startUpWithCaption: aString at: location].	result isCommand ifTrue: 		[result _ self getTypedFileName: result.		result ifNil: [^nil]].	canTypeFileName ifTrue: [^self confirmExistingFiles: result].	^result	! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 00:32'!advance: anInteger containingDirectoriesFrom: aDirectory	| theDirectory |	theDirectory _ aDirectory.	1 to: anInteger do: [:i | theDirectory _ theDirectory containingDirectory].	^theDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 20:50'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: (MenuStyle leftFlush)! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 22:03'!newFileFrom: aDirectory	canTypeFileName _ true.	^self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'rww 9/23/2001 09:54'!newFileFrom: aDirectory withPattern: aPattern	canTypeFileName _ true.	pattern _ aPattern.	^self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 22:03'!oldFileFrom: aDirectory	canTypeFileName _ false.	^self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private'!oldFileFrom: aDirectory withPattern: aPattern	canTypeFileName _ false.	pattern _ aPattern.	^self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'tk 2/14/2000 14:24'!pattern: patString	" * for all files, or '*.cs' for changeSets, etc.  Just like fileLists"	pattern _ patString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardFileMenu class	instanceVariableNames: ''!!StandardFileMenu class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:14'!newFileMenu: aDirectory	Smalltalk isMorphic ifFalse: [^ PluggableFileList newFileMenu: aDirectory].	^ super new newFileFrom: aDirectory! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'rww 9/23/2001 09:56'!newFileMenu: aDirectory withPattern: aPattern	Smalltalk isMorphic ifFalse: [^ PluggableFileList newFileMenu: aDirectory].	^ super new newFileFrom: aDirectory withPattern: aPattern! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:15'!oldFileMenu: aDirectory	Smalltalk isMorphic ifFalse: [^ PluggableFileList oldFileMenu: aDirectory].	^ super new oldFileFrom: aDirectory! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'RAA 5/25/2000 09:30'!oldFileMenu: aDirectory withPattern: aPattern	Smalltalk isMorphic ifFalse: [^PluggableFileList oldFileMenu: aDirectory].	^super new oldFileFrom: aDirectory withPattern: aPattern! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!newFile	^self newFileFrom: (FileDirectory default)! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'dgd 9/21/2003 13:17'!newFileFrom: aDirectory	^(self newFileMenu: aDirectory)		startUpWithCaption: 'Select a File:' translated! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'acg 4/15/1999 22:18'!newFileStream	^self newFileStreamFrom: (FileDirectory default)! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!newFileStreamFrom: aDirectory	| sfmResult fileStream |	sfmResult _ self newFileFrom: aDirectory.	sfmResult ifNil: [^nil].	fileStream _ sfmResult directory newFileNamed: sfmResult name.	[fileStream isNil] whileTrue:		[sfmResult _ self newFileFrom: aDirectory.		sfmResult ifNil: [^nil].		fileStream _ sfmResult directory newFileNamed: sfmResult name].	^fileStream! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!oldFile	^self oldFileFrom: (FileDirectory default)! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'dgd 9/21/2003 13:17'!oldFileFrom: aDirectory	^(self oldFileMenu: aDirectory)		startUpWithCaption: 'Select a File:' translated! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'acg 4/15/1999 22:17'!oldFileStream	^self oldFileStreamFrom: (FileDirectory default)! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:27'!oldFileStreamFrom: aDirectory	| sfmResult fileStream |	sfmResult _ self oldFileFrom: aDirectory.	sfmResult ifNil: [^nil].	fileStream _ sfmResult directory oldFileNamed: sfmResult name.	[fileStream isNil] whileTrue:		[sfmResult _ self oldFileFrom: aDirectory.		sfmResult ifNil: [^nil].		fileStream _ sfmResult directory oldFileNamed: sfmResult name].	^fileStream! !Object subclass: #StandardFileMenuResult	instanceVariableNames: 'directory name'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!directory	^directory! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!directory: aDirectory	^directory _ aDirectory! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!name	^name! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!name: aString	^name _ aString! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'sw 6/9/1999 11:50'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' with directory: '.	directory printOn: aStream.	aStream nextPutAll: ' name: '.	name printOn: aStream"StandardFileMenu oldFile"! !!StandardFileMenuResult methodsFor: 'testing' stamp: 'acg 4/15/1999 09:05'!isCommand	^name isNil! !!StandardFileMenuResult methodsFor: 'testing' stamp: 'acg 4/15/1999 20:57'!isDirectory	^name = ''! !!StandardFileMenuResult methodsFor: 'private' stamp: 'acg 4/15/1999 08:42'!directory: aDirectory name: aString	directory _ aDirectory.	name _ aString.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardFileMenuResult class	instanceVariableNames: ''!!StandardFileMenuResult class methodsFor: 'instance creation' stamp: 'acg 4/15/1999 08:42'!directory: aDirectory name: aString	^super new directory: aDirectory name: aString! !FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'System-Files'!!StandardFileStream commentStamp: '<historical>' prior: 0!Provides a simple, platform-independent, interface to a file system.  This initial version ignores issues of Directories etc.  The instance-variable fallbackStream at the moment holds an instance of HFSMacFileStream, to bridge us to the new world while in the old.  The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 sw!!StandardFileStream methodsFor: 'open/close' stamp: 'ar 10/7/1998 14:43'!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		self unregister.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 2/6/2002 08:33'!closed	"Answer true if this file is closed."	^ fileID isNil or: [(self primSizeNoError: fileID) isNil]! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 16:20'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!StandardFileStream methodsFor: 'open/close'!open	"For compatibility with a few existing things.  2/14/96 sw"	^ self reopen! !!StandardFileStream methodsFor: 'open/close' stamp: 'ar 12/12/2001 15:58'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	"Changed to do a GC and retry before failing ar 3/21/98 17:25"	fileID _ StandardFileStream retryWithGC:[self primOpen: fileName writable: writeMode] 					until:[:id| id notNil] 					forFileNamed: fileName.	fileID ifNil: [^ nil].  "allows sender to detect failure"	self register.	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'open/close'!openReadOnly	"Open the receiver as a read-only file.  1/31/96 sw"	^ self open: name forWrite: false! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:58'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [self primCloseNoError: fileID].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'properties-setting'!ascii	"opposite of binary"	buffer1 _ String new: 1! !!StandardFileStream methodsFor: 'properties-setting'!binary	buffer1 _ ByteArray new: 1! !!StandardFileStream methodsFor: 'properties-setting'!isBinary	^ buffer1 class == ByteArray! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 11/4/1998 19:17'!isReadOnly	^ rwmode not! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readOnly	"Make this file read-only."	rwmode _ false.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:16'!directory	"Return the directory containing this file."	^ FileDirectory forFileName: self fullName! !!StandardFileStream methodsFor: 'access'!file	"Answer the object representing the receiver's file.  Need for compatibility with some calls -- check senders.  2/14/96 sw"	^ self! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!fullName	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access'!isDirectory	"Answer whether the receiver represents a directory.  For the post-transition case, uncertain what to do.  2/14/96 sw"	^ false! !!StandardFileStream methodsFor: 'access' stamp: 'ar 11/24/1998 14:00'!localName	^ name ifNotNil: [(name findTokens: FileDirectory pathNameDelimiter asString) last]! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!name	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'di 6/27/97 12:18'!peekFor: item 	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"	| next |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	(next _ self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	self skip: -1.	^ false! !!StandardFileStream methodsFor: 'access'!printOn: aStream	"Put a printed version of the receiver onto aStream.  1/31/96 sw"	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !!StandardFileStream methodsFor: 'access' stamp: 'ar 6/16/2002 18:58'!reset	self ensureOpen.	self position: 0.! !!StandardFileStream methodsFor: 'access'!size	"Answer the size of the file in characters.  2/12/96 sw"	^ self primSize: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 2/12/96'!atEnd	"Answer whether the receiver is at its end.  "	^ self primAtEnd: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'mir 2/25/2000 12:37'!basicNext	"Answer the next byte from this file, or nil if at the end of the file."	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [^ buffer1 at: 1]		ifFalse: [^ nil].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ls 8/23/2003 16:44'!findString: string	"Fast version of #upToAll: to find a String in a file starting from the beginning.	Returns the position and also sets the position there.	If string is not found 0 is returned and position is unchanged."	| pos buffer count oldPos sz |	oldPos _ self position.	self reset.	sz _ self size.	pos _ 0.	buffer _ String new: 2000.	[ buffer := self nextInto: buffer.	(count _ buffer findString: string) > 0		ifTrue: ["Found the string part way into buffer"			self position: pos.			self next: count - 1.			^self position ].	pos _ ((pos + 2000 - string size) min: sz).	self position: pos.	pos = sz] whileFalse.	"Never found it, and hit end of file"	self position: oldPos.	^0! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 2/6/2001 17:59'!flush	"Flush pending changes"	^self primFlush: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'mir 2/25/2000 12:37'!next	"Answer the next byte from this file, or nil if at the end of the file."	^ self basicNext! !!StandardFileStream methodsFor: 'read, write, position'!next: n	"Return a string with the next n characters of the filestream in it.  1/31/96 sw"	^ self nextInto: (buffer1 class new: n)! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 12/23/1999 15:02'!next: n into: aString startingAt: startIndex	"Read n bytes into the given string.	Return aString or a partial copy if less than	n elements have been read."	| count |	count _ self primRead: fileID into: aString				startingAt: startIndex count: n.	count = n		ifTrue:[^aString]		ifFalse:[^aString copyFrom: 1 to: startIndex+count-1]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 2/5/2000 21:43'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString basicSize.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 2/5/2000 21:58'!nextWordsInto: aBitmap	"Note: The file primitives automatically adjust for word based objects."	self next: aBitmap basicSize into: aBitmap startingAt: 1.	aBitmap restoreEndianness.	^ aBitmap! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'mir 2/25/2000 12:37'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next _ self basicNext.	self position: self position - 1.	^ next! !!StandardFileStream methodsFor: 'read, write, position'!position	"Return the receiver's current file position.  2/12/96 sw"	^ self primGetPosition: fileID! !!StandardFileStream methodsFor: 'read, write, position'!position: pos	"Set the receiver's position as indicated.  2/12/96 sw"	^ self primSetPosition: fileID to: pos! !!StandardFileStream methodsFor: 'read, write, position'!readOnlyCopy	^ StandardFileStream readOnlyFileNamed: self name! !!StandardFileStream methodsFor: 'read, write, position'!setToEnd	"Set the position of the receiver to the end of file.  1/31/96 sw"	self position: self size! !!StandardFileStream methodsFor: 'read, write, position'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file.  1/31/96 sw"	self position: self position + n! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'di 7/14/97 23:15'!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	pos _ self position.	buffer _ self next: 2000.	(count _ buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 12/22/1999 15:40'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream buffer |	buffer _ buffer1 species new: 1000.	newStream _ WriteStream on: (buffer1 species new: 100).	[self atEnd] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].	^ newStream contents! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 'primitiveFileAtEnd' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primClose: id	"Close this file."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/6/2001 17:58'!primFlush: id	"Flush pending changes to the disk"	| p |	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>	"In some OS's seeking to 0 and back will do a flush"	p _ self position.	self position: 0; position: p! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primGetPosition: id	"Get this files current position."	<primitive: 'primitiveFileGetPosition' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 'primitiveFileRead' module: 'FilePlugin'>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 'primitiveFileSetPosition' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSize: id	"Answer the size of this file."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!StandardFileStream methodsFor: 'registry' stamp: 'ar 3/21/98 17:23'!register	^self class register: self! !!StandardFileStream methodsFor: 'registry' stamp: 'ar 3/21/98 17:23'!unregister	^self class unregister: self! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 3/21/98 18:16'!actAsExecutor	super actAsExecutor.	name := nil.! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 10/7/1998 15:44'!finalize	self primCloseNoError: fileID.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardFileStream class	instanceVariableNames: ''!!StandardFileStream class methodsFor: 'file creation' stamp: 'TPR 8/13/1999 21:22'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: (self fullName: fileName) forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'tpr 10/21/2001 11:11'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir localName fullName f |	fullName _ self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: [f _ self new open: fullName forWrite: true.			^ f isNil				ifTrue: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]				ifFalse: [f]].	dir _ FileDirectory forFileName: fullName.	localName _ FileDirectory localNameFor: fullName.	dir		deleteFileNamed: localName		ifAbsent: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].	f _ self new open: fullName forWrite: true.	^ f isNil		ifTrue: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal]		ifFalse: [f]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'mpw 9/18/1999 00:05'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f _ self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'LC 10/24/2001 21:43'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| fullName |	fullName _ self fullName: fileName.	^(self isAFileNamed: fullName)		ifTrue: ["file already exists:"			(FileExistsException fileName: fullName fileClass: self) signal]		ifFalse: [self new open: fullName forWrite: true]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'mir 7/25/2000 16:39'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| fullName |	fullName _ self fullName: fileName.	^(self isAFileNamed: fullName)		ifTrue: [self new open: fullName forWrite: true]		ifFalse: ["File does not exist..."			(FileDoesNotExistException fileName: fullName) signal]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'mdr 12/5/2000 19:51'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| fullName f |	fullName _ self fullName: fileName.	f _ self new open: fullName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fullName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 12/12/2001 15:55'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt _ Registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:23'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!StandardFileStream class methodsFor: 'error handling' stamp: 'mir 2/28/2000 16:06'!fileDoesNotExistUserHandling: fullFileName	| selection newName |	selection _ (PopUpMenu labels:'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fullFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fullFileName forWrite: true].	selection = 2 ifTrue:		[ newName _ FillInTheBlank request: 'Enter a new file name'						initialAnswer:  fullFileName.		^ self oldFileNamed:			(self fullName: newName)].	self halt! !!StandardFileStream class methodsFor: 'error handling' stamp: 'mir 2/28/2000 15:24'!fileExistsUserHandling: fullFileName	| dir localName choice newName newFullFileName |	dir _ FileDirectory forFileName: fullFileName.	localName _ FileDirectory localNameFor: fullFileName.	choice _ (PopUpMenu		labels:'overwrite that file\choose another name\cancel' withCRs)		startUpWithCaption: localName, 'already exists.'.	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fullFileName forWrite: true].	choice = 2 ifTrue: [		newName _ FillInTheBlank request: 'Enter a new file name' initialAnswer: fullFileName.		newFullFileName _ self fullName: newName.		^ self newFileNamed: newFullFileName].	self error: 'Please close this to abort file opening'! !!StandardFileStream class methodsFor: 'error handling' stamp: 'tpr 10/18/2001 19:08'!readOnlyFileDoesNotExistUserHandling: fullFileName	| dir files choices selection newName fileName |	dir _ FileDirectory forFileName: fullFileName.	files _ dir fileNames.	fileName _ FileDirectory localNameFor: fullFileName.	choices _ fileName correctAgainst: files.	choices add: 'Choose another name'.	choices add: 'Cancel'.	selection _ (PopUpMenu labelArray: choices lines: (Array with: 5) )		startUpWithCaption: (FileDirectory localNameFor: fullFileName), 'does not exist.'.	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].	selection < (choices size - 1) ifTrue: [		newName _ (dir pathName , FileDirectory slash , (choices at: selection))].	selection = (choices size - 1) ifTrue: [		newName _ FillInTheBlank 							request: 'Enter a new file name' 							initialAnswer: fileName].	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].	^ self error: 'Could not open a file'! !SourceFileArray subclass: #StandardSourceFileArray	instanceVariableNames: 'files'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!StandardSourceFileArray commentStamp: '<historical>' prior: 0!This class implements the source file management behavior of traditional Squeak, with a sources file and a changes file. File positions are mapped such that those files can be up to 32MBytes in size.Structure: files		Array -- storing the actual source files!!StandardSourceFileArray methodsFor: 'initialize-release' stamp: 'hmm 4/25/2000 21:20'!initialize	files _ Array new: 2.	files at: 1 put: (SourceFiles at: 1).	files at: 2 put: (SourceFiles at: 2)! !!StandardSourceFileArray methodsFor: 'initialize-release' stamp: 'ar 5/17/2000 18:28'!initialize: nFiles	files _ Array new: nFiles! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/25/2000 21:20'!at: index	^files at: index! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/25/2000 21:20'!at: index put: aFile	files at: index put: aFile! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/25/2000 21:20'!size	^files size! !!StandardSourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 21:44'!fileIndexFromSourcePointer: anInteger	"Return the index of the source file which contains the source chunk addressed by anInteger"	"This implements the recent 32M source file algorithm"	| hi |	hi _ anInteger // 16r1000000.	^hi < 3		ifTrue: [hi]		ifFalse: [hi - 2]! !!StandardSourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 21:44'!filePositionFromSourcePointer: anInteger	"Return the position of the source chunk addressed by anInteger"	"This implements the recent 32M source file algorithm"	| hi lo |	hi _ anInteger // 16r1000000.	lo _ anInteger \\ 16r1000000.	^hi < 3		ifTrue: [lo]		ifFalse: [lo + 16r1000000]! !!StandardSourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 21:48'!sourcePointerFromFileIndex: index andPosition: position	| hi lo |	"Return a source pointer according to the new 32M algorithm"	((index between: 1 and: 2) and: [position between: 0 and: 16r1FFFFFF])		ifFalse: [self error: 'invalid source code pointer'].	hi _ index.	lo _ position.	lo >= 16r1000000 ifTrue: [		hi _ hi+2.		lo _ lo - 16r1000000].	^hi * 16r1000000 + lo! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardSourceFileArray class	instanceVariableNames: ''!!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'hmm 4/25/2000 21:19'!install	"Replace SourceFiles by an instance of me with the standard sources and changes files.	This only works if SourceFiles is either an Array or an instance of this class"	"StandardSourceFileArray install"	SourceFiles _ self new initialize! !!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'ar 5/17/2000 18:27'!new: nFiles	^self new initialize: nFiles.! !MouseMenuController subclass: #StandardSystemController	instanceVariableNames: 'status'	classVariableNames: 'HBorderCursor ScheduledBlueButtonMenu ScheduledBlueButtonMessages VBorderCursor'	poolDictionaries: ''	category: 'ST80-Support'!!StandardSystemController commentStamp: '<historical>' prior: 0!I am a controller for StandardSystemViews, that is, those views that are at the top level of a project in the system user interface. I am a kind of MouseMenuController that creates a blue button menu for moving, framing, collapsing, and closing ScheduledViews, and for selecting views under the view of my instance.!!StandardSystemController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 11:48'!initialize	super initialize.	status _ #inactive! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:01'!blueButtonActivity	ScheduledBlueButtonMenu ifNil: [^ super controlActivity].	ScheduledBlueButtonMenu invokeOn: self! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:20'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'control defaults'!isControlActive	status == #active ifFalse: [^ false].	sensor anyButtonPressed ifFalse: [^ true].	self viewHasCursor		ifTrue: [^ true]		ifFalse: [ScheduledControllers noteNewTop.				^ false]! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/15/2000 22:19'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame	or edit the label."	| box p |	p _ sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	((box _ view closeBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [self close. ^ self].			^ self].	((box _ view growBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed:					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].			^ self].	(((box _ view labelTextRegion expandBy: 1) containsPoint: p)			and: [Preferences clickOnLabelToEdit or: [sensor leftShiftDown]])		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [^ self label].			^ self].	self move! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 10/20/1999 09:52'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view isCollapsed ifFalse: [model modelWakeUpIn: view]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 5/11/1999 22:05'!controlTerminate	status == #closed		ifTrue: 			[view ~~ nil ifTrue: [view release].			ScheduledControllers unschedule: self.			^self].	view deEmphasize; cacheBits.	view isCollapsed ifFalse: [model modelSleep].! !!StandardSystemController methodsFor: 'menu messages'!chooseColor	"Allow the user to specify a new background color for the receiver's window.  5/6/96 sw.	 7/31/96 sw: use Color fromUser"	view backgroundColor: Color fromUser; uncacheBits; display! !!StandardSystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	model okToChange ifFalse: [^self].	status _ #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages'!collapse	"Get the receiver's view to change to a collapsed view on the screen."	view collapseToPoint: view chooseCollapsePoint! !!StandardSystemController methodsFor: 'menu messages'!expand	"The receiver's view was collapsed; open it again and ask the user to 	designate its rectangular area."	view expand; emphasize! !!StandardSystemController methodsFor: 'menu messages' stamp: 'jm 4/28/1998 06:57'!label	| newLabel |	newLabel _ FillInTheBlank		request: 'Edit the label, then type RETURN'		initialAnswer: view label.	newLabel isEmpty ifFalse: [view relabel: newLabel].! !!StandardSystemController methodsFor: 'menu messages'!move	"Ask the user to designate a new origin position for the receiver's view.	6/10/96 sw: tell the view that it has moved"	| oldBox | 	oldBox _ view windowBox.	view uncacheBits.	view align: view windowBox topLeft		with: view chooseMoveRectangle topLeft.	view displayEmphasized.	view moved.  "In case its model wishes to take note."	(oldBox areasOutside: view windowBox) do:		[:rect | ScheduledControllers restore: rect]! !!StandardSystemController methodsFor: 'menu messages'!reframe	^ view reframeTo: view getFrame! !!StandardSystemController methodsFor: 'menu messages'!toggleTwoTone	(view isMemberOf: StandardSystemView) ifTrue:		[^ view become: (view as: ColorSystemView)].	(view isMemberOf: ColorSystemView) ifTrue:		[^ view become: (view as: StandardSystemView)].! !!StandardSystemController methodsFor: 'menu messages'!under	"Deactive the receiver's scheduled view and pass control to any view that 	might be positioned directly underneath it and the cursor."	status _ #inactive! !!StandardSystemController methodsFor: 'scheduling' stamp: 'sw 9/30/97 22:04'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled 	views."	status _ #closed.	view erase.	view release.	ScheduledControllers unschedule: self; searchForActiveController! !!StandardSystemController methodsFor: 'scheduling'!closeAndUnscheduleNoErase	"Remove the scheduled view from the collection of scheduled views. Set 	its status to closed but do not erase."	status _ #closed.	view release.	ScheduledControllers unschedule: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 3/18/98 19:21'!closeAndUnscheduleNoTerminate	"Erase the receiver's view and remove it from the collection of scheduled views, but do not terminate the current process."	status _ #closed.	view erase.	view release.	ScheduledControllers unschedule: self.! !!StandardSystemController methodsFor: 'scheduling'!open	"Create an area on the screen in which the receiver's scheduled view can 	be displayed. Make it the active view."	view resizeInitially.	status _ #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling'!openDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view."	view align: view viewport center with: aPoint.	view translateBy:		(view displayBox amountToTranslateWithin: Display boundingBox).	status _ #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 10/22/97 08:16'!openNoTerminate	"Create an area in which the receiver's scheduled view can be displayed. 	Make it the active view. Do not terminate the currently active process."	view resizeInitially.	status _ #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!openNoTerminateDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view. Do not terminate the 	currently active process."	view resizeMinimumCenteredAt: aPoint.	status _ #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!status: aSymbol	status _ aSymbol! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side _ #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:22'!adjustWindowBorders 	| side noClickYet |	noClickYet _ true.	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #left) | (side = #right)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet _ false.				side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #top) | (side = #bottom)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet _ false.				side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:30'!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp _ sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	view subViews size <= 1 ifTrue: [^ self].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp _ sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box _ view windowBox]		ifFalse: [box _ (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController methodsFor: 'borders'!fullScreen	"Make the receiver's window occupy jes' about the full screen.  6/10/96 sw"	view fullScreen! !!StandardSystemController methodsFor: 'cursor'!labelHasCursor	"Answer true if the cursor is within the window's label"	^view labelContainsPoint: sensor cursorPoint! !!StandardSystemController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:12'!getPluggableYellowButtonMenu: shiftKeyState	^ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardSystemController class	instanceVariableNames: ''!!StandardSystemController class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 11:57'!initialize	"StandardSystemController initialize"	ScheduledBlueButtonMenu _ SelectionMenu		labels:'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7)	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !View subclass: #StandardSystemView	instanceVariableNames: 'labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize collapsedViewport expandedViewport labelBits windowBits bitsValid updatablePanes'	classVariableNames: 'CacheBits LabelStyle'	poolDictionaries: ''	category: 'ST80-Support'!!StandardSystemView commentStamp: '<historical>' prior: 0!I represent a view that has a label above its top left corner. The text in the label identifies the kind of view. In addition to a label, I add control over the maximum and minimum size of the display box of my instance. My default controller is StandardSystemController. The elements of ScheduledControllers, the sole instance of ControlManager, are usually controllers for instances of me.!!StandardSystemView methodsFor: 'initialize-release' stamp: 'sw 10/29/1999 12:58'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame _ Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented _ false.	minimumSize _ 50 @ 50.	maximumSize _ Display extent.	collapsedViewport _ nil.	expandedViewport _ nil.	bitsValid _ false.	updatablePanes _ #()! !!StandardSystemView methodsFor: 'initialize-release'!model: aModel	"Set the receiver's model.  For a Standard System View, we also at this time get the default background color set up.  7/30/96 sw"	super model: aModel.	self setDefaultBackgroundColor! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'jm 8/20/1998 18:29'!release	model windowIsClosing.	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release.! !!StandardSystemView methodsFor: 'testing'!containsPoint: aPoint 	"Refer to the comment in View|containsPoint:."	^(super containsPoint: aPoint) | (self labelContainsPoint: aPoint)! !!StandardSystemView methodsFor: 'testing'!isCollapsed	"Answer whether the receiver is collapsed (true) or expanded (false)."	^savedSubViews ~~ nil! !!StandardSystemView methodsFor: 'testing'!labelContainsPoint: aPoint 	"Answer TRUE if aPoint is in the label box."	^self labelDisplayBox containsPoint: aPoint! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:30'!closeBoxFrame	^ Rectangle origin: (self labelDisplayBox leftCenter + (10@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:29'!growBoxFrame	^ Rectangle origin: (self labelDisplayBox rightCenter + (-22@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access'!label	"Answer the string that appears in the receiver's label."	labelText isNil		ifTrue: [^ 'Untitled' copy]		ifFalse: [^ labelText asString]! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:44'!label: aString 	"Set aString to be the receiver's label."	labelText _ Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access'!labelColor	"Answer the color to use as the background for the receiver's label.  By default, this is the same as the background color of the window, but need not be.  7/16/96 sw"	^ self backgroundColor! !!StandardSystemView methodsFor: 'label access'!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label 	on the display screen."	^ labelFrame region		align: labelFrame topLeft		with: self windowOrigin! !!StandardSystemView methodsFor: 'label access'!labelFrame	^labelFrame! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:47'!labelHeight	^ ((LabelStyle fontAt: 1) height + 4) max: 20! !!StandardSystemView methodsFor: 'label access'!labelOffset	^ 0 @ (self labelHeight-2)! !!StandardSystemView methodsFor: 'label access' stamp: 'sr 3/26/2000 04:26'!labelText	^labelText! !!StandardSystemView methodsFor: 'label access'!labelTextRegion	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].	^ (labelText boundingBox			align: labelText boundingBox center			with: self labelDisplayBox center)		intersect: (self labelDisplayBox insetBy: 35@0)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 14:20'!noLabel	"A label of zero height indicates no label"	labelFrame height > 0		ifTrue: [labelFrame region: (labelFrame bottomLeft + (0@1) extent: labelFrame width@0).				labelFrame borderWidth: 0.				self uncacheBits]! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 1/19/2001 20:13'!setLabel: aLabel	"For compatibility with morphic"	self relabel: aLabel! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 13:35'!setLabelRegion	"Always follows view width"	labelFrame region: (0 @ 0 extent: self displayBox width @ self labelHeight).	labelFrame borderWidth: 2! !!StandardSystemView methodsFor: 'label access' stamp: 'sumim 2/8/2002 14:36'!setLabelTo: aString 	"Force aString to be the new label of the receiver, bypassing any logic about whether it is acceptable and about propagating information about the change."	| oldRegion oldWidth |	self label: aString.	self controller isControlActive ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized]! !!StandardSystemView methodsFor: 'size'!maximumSize	"Answer a point representing the maximum width and height of the 	receiver."	^maximumSize! !!StandardSystemView methodsFor: 'size'!maximumSize: aPoint 	"Set the argument, aPoint, to be the maximum width and height of the 	receiver."	maximumSize _ aPoint! !!StandardSystemView methodsFor: 'size'!minimumSize	"Answer a point representing the minimum width and height of the 	receiver."	^minimumSize! !!StandardSystemView methodsFor: 'size'!minimumSize: aPoint 	"Set the argument, aPoint, to be the minimum width and height of the 	receiver."	minimumSize _ aPoint! !!StandardSystemView methodsFor: 'framing' stamp: 'sr 3/26/2000 03:47'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm _ Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown _ Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown _ true]							ifFalse: [beenDown not]].		^ pt].	^ (RealEstateAgent assignCollapseFrameFor: self) origin.! !!StandardSystemView methodsFor: 'framing'!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm _ bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid _ false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f _ self getFrame.			bitsValid _ false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing'!chooseMoveRectangle	"Ask the user to designate a new window rectangle."	| offset p |	offset _ Sensor anyButtonPressed "Offset if draggin, eg, label"		ifTrue: [self windowBox topLeft - Sensor cursorPoint]		ifFalse: [0@0].	self isCollapsed		ifTrue: [^ self labelDisplayBox newRectFrom:					[:f | p _ Sensor cursorPoint + offset.					p _ (p max: 0@0) truncateTo: 8.					p extent: f extent]]		ifFalse: [^ self windowBox newRectFrom:					[:f | p _ Sensor cursorPoint + offset.					self constrainFrame: (p extent: f extent)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'BG 10/29/2003 09:46'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[model modelSleep.			(subViews ~~ nil and: [subViews size = 1 ])				ifTrue: [subViews first deEmphasizeView].			expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport _ self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!collapsedFrame	"Answer the rectangle occupied by this window when collapsed."	^ collapsedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 10/20/1999 09:46'!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUpIn: self]! !!StandardSystemView methodsFor: 'framing'!expandedFrame	"Answer the rectangle occupied by this window when expanded."	^ expandedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 8/15/97 17:18'!fullScreen	"Expand the receiver to fill the screen.  Let the model decide how big is full -- allows for flop-out scrollbar on left if desired"	self isCollapsed ifFalse:		[self reframeTo: model fullScreenSize]! !!StandardSystemView methodsFor: 'framing'!getFrame	"Ask the user to designate a rectangular area in which	the receiver should be displayed."	| minFrame |	minFrame _ Cursor origin showWhile: 		[(Sensor cursorPoint extent: self minimumSize) newRectFrom:			[:f | Sensor cursorPoint extent: self minimumSize]].	self maximumSize <= self minimumSize ifTrue: [^ minFrame].	^ Cursor corner showWhile:		[minFrame newRectFrom:			[:f | self constrainFrame: (f origin corner: Sensor cursorPoint)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 1/22/96'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ model initialExtent min: maximumSize max: minimumSize! !!StandardSystemView methodsFor: 'framing' stamp: 'RAA 6/14/2000 17:27'!initialFrame        "Find a plausible initial screen area for the receiver, taking into account user preference, the size needed, and other windows currently on the screen.  5/22/96 sw: let RealEstateAgent do it for us"        ^ RealEstateAgent initialFrameFor: self world: nil! !!StandardSystemView methodsFor: 'framing'!moved	"The user has moved the receiver; after a new view rectangle is chosen, this method is called to allow certain views to take note of the change.  6/10/96 sw" ! !!StandardSystemView methodsFor: 'framing'!newFrame: frameChangeBlock	self reframeTo: (self windowBox newRectFrom:		[:f | self constrainFrame: (frameChangeBlock value: f)])! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect _ aDisplayBox.	theMin _ 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport _ nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'BG 12/4/2003 13:14'!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  	Repaint difference after the change.  "	| oldBox newBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + self labelOffset				corner: newFrame corner.	self setWindow: nil.	self resizeTo: portRect.	self setLabelRegion.	newBox _ self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f _ self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing'!resizeInitially	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	self resizeTo: self initialFrame! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:12'!resizeMinimumCenteredAt: aPoint 	"Determine the rectangular area for the receiver, adjusted so that it is 	centered a position, aPoint."	| aRectangle |	aRectangle _ 0 @ 0 extent: self minimumSize.	aRectangle _ aRectangle align: aRectangle center with: aPoint.	self resizeTo: aRectangle! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:29'!resizeTo: aRectangle	"Resize this view to aRectangle"	"First get scaling right inside borders"	self window: (self window insetBy: borderWidth)		viewport: (aRectangle insetBy: borderWidth).	"Then ensure window maps to aRectangle"	window _ transformation applyInverseTo: aRectangle! !!StandardSystemView methodsFor: 'framing'!standardWindowOffset	^ Preferences standardWindowOffset! !!StandardSystemView methodsFor: 'framing'!windowBox	^ self displayBox merge: self labelDisplayBox! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/3/97 14:19'!windowOrigin	^ (self isCollapsed or: [labelFrame height = 0  "no label"])		ifTrue: [self displayBox topLeft]		ifFalse: [self displayBox topLeft - self labelOffset]! !!StandardSystemView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^StandardSystemController! !!StandardSystemView methodsFor: 'displaying'!cacheBits	| oldLabelState |	CacheBits ifFalse: [^ self uncacheBits].	(oldLabelState _ isLabelComplemented) ifTrue: [ self deEmphasize ].	self cacheBitsAsIs.	(isLabelComplemented _ oldLabelState) ifTrue: [ self emphasize ].! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsIs	CacheBits ifFalse: [^ self uncacheBits].	windowBits _ (self cacheBitsAsTwoTone and: [Display depth > 1])		ifTrue: [ColorForm					twoToneFromDisplay: self windowBox					using: windowBits					backgroundColor: self backgroundColor]		ifFalse: [Form fromDisplay: self windowBox using: windowBits].	bitsValid _ true.! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsTwoTone	^ true! !!StandardSystemView methodsFor: 'displaying'!deEmphasizeForDebugger	"Carefully de-emphasis this window because a debugger is being opened. Care must be taken to avoid invoking potentially buggy window display code that could cause a recursive chain of errors eventually resulting in a virtual machine crash. In particular, do not de-emphasize the subviews."	self deEmphasizeView.  "de-emphasize this top-level view"	self uncacheBits.	Smalltalk garbageCollectMost > 1000000 ifTrue: [		"if there is enough space, cache current window screen bits"		self cacheBitsAsIs].! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!deEmphasizeLabel	"Un-Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: false.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying'!display	isLabelComplemented		ifTrue: [self displayEmphasized]		ifFalse: [self displayDeEmphasized]! !!StandardSystemView methodsFor: 'displaying' stamp: 'hmm 7/21/1999 07:37'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	(bitsValid and: [controller ~~ ScheduledControllers activeController])		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [Display deferUpdates: true.				super display.				Display deferUpdates: false; forceToScreen: self windowBox.				CacheBits ifTrue: [self cacheBitsAsIs]]! !!StandardSystemView methodsFor: 'displaying'!displayEmphasized	"Display with label highlighted to indicate that it is active."	self displayDeEmphasized; emphasize.	isLabelComplemented _ true! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 5/15/1998 21:55'!displayLabelBackground: emphasized	"Clear or emphasize the inner region of the label"	| r1 r2 r3 c3 c2 c1 |	emphasized ifFalse:		["Just clear the label if not emphasized"		^ Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor].	r1 _ self labelDisplayBox insetBy: 2.	r2 _ r1 insetBy: 0@2.	r3 _ r2 insetBy: 0@3.	c3 _ self labelColor.	c2 _ c3 dansDarker.	c1 _ c2 dansDarker.	Display fill: r1 fillColor: c1.	Display fill: r2 fillColor: c2.	Display fill: r3 fillColor: c3. "	Here is the Mac racing stripe code	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)					with: (Form black pixelWordForDepth: Display depth).	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes."! !!StandardSystemView methodsFor: 'displaying'!displayLabelBoxes	"closeBox, growBox."	| aRect smallRect backColor |	aRect _ self closeBoxFrame.	backColor _ self labelColor.	Display fill: (aRect insetBy: -2) fillColor: backColor.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	aRect _ self growBoxFrame.	smallRect _ aRect origin extent: 7@7.	Display fill: (aRect insetBy: -2) fillColor: backColor.	aRect _ aRect insetOriginBy: 2@2 cornerBy: 0@0.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	Display fillBlack: smallRect.	Display fill: (smallRect insetBy: 1) fillColor: backColor! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/29/97 18:57'!displayOn: aPort	bitsValid ifFalse:		[^ Display clippingTo: aPort clipRect do: [super display]].	windowBits displayOnPort: aPort at: self windowOrigin! !!StandardSystemView methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:40'!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox _ self labelDisplayBox.	top _ labelDisplayBox top + 3.	bottom _ labelDisplayBox bottom - 3.	stripes _ Bitmap with: (Display pixelWordFor: self labelColor)			with: (Display pixelWordFor: Color black).	top even ifFalse: [stripes swap: 1 with: 2].	left _ labelDisplayBox left + 3.	box _ self closeBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self labelTextRegion.	right _ box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self growBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	right _ labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:14'!displayView	"Refer to the comment in View|displayView. "	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayBox width = labelFrame width ifFalse:		["recompute label width when window changes size"		self setLabelRegion].	(labelFrame align: labelFrame topLeft with: self windowOrigin)		insideColor: self labelColor;		displayOn: Display.	self displayLabelText! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!emphasizeLabel	"Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: true.	self displayLabelBoxes.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/30/97 11:07'!erase	"Clear the display box of the receiver to be gray, as the screen background."	| oldValid |	CacheBits		ifTrue:			[oldValid _ bitsValid.			bitsValid _ false.			ScheduledControllers restore: self windowBox without: self.			bitsValid _ oldValid]		ifFalse:			[ScheduledControllers restore: self windowBox without: self]! !!StandardSystemView methodsFor: 'displaying' stamp: 'RAA 6/14/2000 17:27'!makeMeVisible        | newLoc portRect |        ((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))                containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].        "window not on screen (probably due to reframe) -- move it now"        newLoc _ self isCollapsed                ifTrue: [RealEstateAgent assignCollapsePointFor: self]                ifFalse: [(RealEstateAgent initialFrameFor: self world: nil) topLeft].        portRect _ newLoc + self labelOffset                                extent: self windowBox extent - self labelOffset.        self resizeTo: portRect.        self setLabelRegion.! !!StandardSystemView methodsFor: 'displaying'!uncacheBits	windowBits _ nil.	bitsValid _ false.! !!StandardSystemView methodsFor: 'displaying'!windowBits	^ windowBits! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented _ false]! !!StandardSystemView methodsFor: 'deEmphasizing'!emphasizeView 	"Refer to the comment in View|emphasizeView."	self emphasizeLabel! !!StandardSystemView methodsFor: 'clipping box access'!clippingBox	"Answer the rectangular area in which the receiver can show its label."	^self isTopView		ifTrue: [self labelDisplayBox]		ifFalse: [super insetDisplayBox]! !!StandardSystemView methodsFor: 'clipping box access' stamp: 'BG 12/5/2003 11:13'!constrainFrame: aRectangle	"Constrain aRectangle, to the minimum and maximum size	for this window"   | adjustmentForLabel |   adjustmentForLabel := 0 @ (labelFrame height  - labelFrame borderWidth).	^ aRectangle origin extent:		((aRectangle extent max: minimumSize + adjustmentForLabel)		      min: maximumSize + adjustmentForLabel).! !!StandardSystemView methodsFor: 'private'!setTransformation: aTransformation 	"Override to support label size changes "	super setTransformation: aTransformation.	self label: self label! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen _ 0.	subViews do:		[:sub | box _ sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub _ sub.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 12:57'!setUpdatablePanesFrom: getSelectors	| aList aPane |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList _ OrderedCollection new.	getSelectors do:		[:sel | aPane _ self subViewSatisfying:				[:pane | (pane isKindOf: PluggableListView) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].	updatablePanes _ aList asArray! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:20'!updatablePanes	"Answer the list of panes, in order, which might be sent the #verifyContents message upon window activation or expansion."	^ updatablePanes ifNil: [updatablePanes _ #()]! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 1/11/2000 15:30'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self setLabelTo: model labelString].	^ super update: aSymbol! !!StandardSystemView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		updatablePanes ifNil: [updatablePanes _ #()].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardSystemView class	instanceVariableNames: ''!!StandardSystemView class methodsFor: 'class initialization'!cachingBits	^ CacheBits! !!StandardSystemView class methodsFor: 'class initialization'!doCacheBits	"StandardSystemView doCacheBits - Enable fast window repaint feature"	CacheBits _ true.	ScheduledControllers unCacheWindows.	ScheduledControllers restore! !!StandardSystemView class methodsFor: 'class initialization'!dontCacheBits	"StandardSystemView dontCacheBits - Disable fast window repaint feature.	Return true iff bits were cached, ie if space was been recovered"	CacheBits ifFalse: [^ false].	CacheBits _ false.	ScheduledControllers unCacheWindows.	^ true! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 23:42'!initialize		"StandardSystemView initialize"	self doCacheBits.	self setLabelStyle! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'nk 7/11/2004 21:11'!setLabelStyle	| aFont |	"StandardSystemView setLabelStyle"	aFont _ Preferences windowTitleFont.	LabelStyle _ TextStyle fontArray: { aFont }.	LabelStyle gridForFont: 1 withLead: 0! !!StandardSystemView class methodsFor: 'instance creation' stamp: 'ssa 8/15/2008 17:42'!model: aModel label: aString minimumSize: aPoint	^self new		model: aModel;		label: aString;		minimumSize: aPoint;		yourself! !ChangeSetCategory subclass: #StaticChangeSetCategory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!StaticChangeSetCategory commentStamp: '<historical>' prior: 0!StaticChangeSetCategory is a user-defined change-set category that has in it only those change sets specifically placed there.!!StaticChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/11/2001 16:10'!acceptsManualAdditions	"Answer whether the user is allowed manually to manipulate the contents of the change-set-category."	^ true! !!StaticChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/11/2001 16:00'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ elementDictionary includesKey: aChangeSet name! !!StaticChangeSetCategory methodsFor: 'add' stamp: 'sw 4/11/2001 15:58'!addChangeSet: aChangeSet	"Add the change set manually"	self elementAt: aChangeSet name put: aChangeSet! !!StaticChangeSetCategory methodsFor: 'updating' stamp: 'sw 4/11/2001 16:36'!reconstituteList	"Reformulate the list.  Here, since we have a manually-maintained list, at this juncture we only make sure change-set-names are still up to date, and we purge moribund elements"	|  survivors |	survivors _ elementDictionary select: [:aChangeSet | aChangeSet isMoribund not].	self clear.	(survivors asSortedCollection: [:a :b | a name <= b name]) reverseDo:		[:aChangeSet | self addChangeSet: aChangeSet]! !Form subclass: #StaticForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!StaticForm commentStamp: '<historical>' prior: 0!An optimization for Nebraska - a StaticForm does not change once created so it may be cached on the remote end.!!StaticForm methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 09:59'!isStatic	^true! !Object subclass: #Stopwatch	instanceVariableNames: 'timespans state'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!!Stopwatch commentStamp: '<historical>' prior: 0!A Stopwatch maintains a collection of timespans.!!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 23:12'!activate	self isSuspended ifTrue:		[self timespans add: 			(Timespan starting: DateAndTime now duration: Duration zero).		self state: #active]! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 23:45'!duration	| ts last |	self isSuspended 		ifTrue:			[ (ts _ self timespans) isEmpty ifTrue: 				[ ts _ { Timespan starting: DateAndTime now duration: Duration zero } ] ]		ifFalse:			[ last _ self timespans last.			ts _ self timespans allButLast				add: (last duration: (DateAndTime now - last start); yourself);				yourself ].			^ (ts collect: [ :t | t duration ]) sum! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 11:21'!end	^ self timespans last next! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:48'!isActive	^ self state = #active! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:48'!isSuspended	^ self state = #suspended! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 13:25'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self state;		nextPut: $:;		print: self duration;		nextPut: $).! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 11:54'!reset	self suspend.	timespans _ nil.! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 23:18'!start	^ self timespans first start! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:47'!state	^ state ifNil: [ state _ #suspended ]! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:46'!state: aSymbol	state _ aSymbol! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 23:13'!suspend	| ts |	self isActive ifTrue:		[ ts _ self timespans last.		ts duration: (DateAndTime now - ts start).		self state: #suspended]! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:44'!timespans	^ timespans ifNil: [ timespans _ OrderedCollection new ]! !Object subclass: #Stream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!Stream commentStamp: '<historical>' prior: 0!I am an abstract class that represents an accessor for a sequence of objects. This sequence is referred to as my "contents".!!Stream methodsFor: 'accessing' stamp: 'nk 2/24/2001 17:31'!binary! !!Stream methodsFor: 'accessing'!contents	"Answer all of the contents of the receiver."	self subclassResponsibility! !!Stream methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:07'!flush	"Do nothing by default"! !!Stream methodsFor: 'accessing' stamp: 'nk 4/29/2004 10:38'!localName	^'a stream'! !!Stream methodsFor: 'accessing'!next	"Answer the next object accessible by the receiver."	self subclassResponsibility! !!Stream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger number of objects accessible by the receiver."	| aCollection |	aCollection _ OrderedCollection new.	anInteger timesRepeat: [aCollection addLast: self next].	^aCollection! !!Stream methodsFor: 'accessing'!next: anInteger put: anObject 	"Make anObject be the next anInteger number of objects accessible by the 	receiver. Answer anObject."	anInteger timesRepeat: [self nextPut: anObject].	^anObject! !!Stream methodsFor: 'accessing'!nextMatchAll: aColl    "Answer true if next N objects are the ones in aColl,     else false.  Advance stream of true, leave as was if false."    | save |    save _ self position.    aColl do: [:each |       (self next) = each ifFalse: [            self position: save.            ^ false]        ].    ^ true! !!Stream methodsFor: 'accessing'!nextMatchFor: anObject 	"Gobble the next object and answer whether it is equal to the argument, 	anObject."	^anObject = self next! !!Stream methodsFor: 'accessing'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	self subclassResponsibility! !!Stream methodsFor: 'accessing'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	aCollection do: [:v | self nextPut: v].	^aCollection! !!Stream methodsFor: 'accessing' stamp: 'nk 4/29/2004 10:40'!openReadOnly	^self! !!Stream methodsFor: 'accessing' stamp: 'ajh 7/31/2001 20:34'!printOn: stream	super printOn: stream.	stream space.	self contents printOn: stream.! !!Stream methodsFor: 'accessing' stamp: 'nk 4/29/2004 10:41'!readOnly	^self! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements _ OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!Stream methodsFor: 'testing'!atEnd	"Answer whether the receiver can access any more objects."	self subclassResponsibility! !!Stream methodsFor: 'testing'!closed	^true! !!Stream methodsFor: 'testing' stamp: 'ar 12/23/1999 15:43'!isStream	"Return true if the receiver responds to the stream protocol"	^true! !!Stream methodsFor: 'testing' stamp: 'ar 5/17/2001 19:07'!nextWordsPutAll: aCollection	"Write the argument a word-like object in big endian format on the receiver.	May be used to write other than plain word-like objects (such as ColorArray)."	aCollection class isPointers | aCollection class isWords not 		ifTrue: [^self error: aCollection class name,' is not word-like'].	1 to: aCollection basicSize do:[:i|		self nextNumber: 4 put: (aCollection basicAt: i).	].	^aCollection! !!Stream methodsFor: 'enumerating'!do: aBlock 	"Evaluate aBlock for each of the objects accessible by receiver."	[self atEnd]		whileFalse: [aBlock value: self next]! !!Stream methodsFor: 'printing' stamp: 'sma 6/1/2000 09:56'!print: anObject	"Have anObject print itself on the receiver."	anObject printOn: self! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 17:13'!printHtml: anObject	anObject printHtmlOn: self! !!Stream methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:48'!write:encodedObject	^encodedObject putOn:self.! !!Stream methodsFor: 'alternate syntax' stamp: 'RAA 6/20/2000 12:52'!dialect	^#ST80		"in case a regular stream is used to print parse nodes"! !!Stream methodsFor: 'alternate syntax' stamp: 'RAA 6/20/2000 12:54'!withStyleFor: elementType do: aBlock	^aBlock value		"in case a regular stream is used to print parse nodes"">>(Compiler new compile: 'blah ^self' in: String notifying: nil ifFail: []) printString<<"! !!Stream methodsFor: 'as yet unclassified' stamp: 'RAA 9/11/2000 19:12'!sleep	"an FTP-based stream might close the connection here"! !!Stream methodsFor: 'file open/close' stamp: 'mir 8/10/1999 12:04'!close! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Stream class	instanceVariableNames: ''!!Stream class methodsFor: 'instance creation'!new	self error: 'Streams are created with on: and with:'! !AbstractFont subclass: #StrikeFont	instanceVariableNames: 'characterToGlyphMap xTable glyphs name type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize'	classVariableNames: 'DefaultStringScanner'	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!StrikeFont commentStamp: 'dew 1/1/2004 20:58' prior: 0!I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.--------------------------------The "AccuFont" StrikeFonts by Doug Easterbrook were added to the Squeak image for the 3.7 release.  The following acknowledgement must remain in the image (in this class comment) as long as the Accufonts are in the image:>Doug Easterbrook>Arts Management Systems Ltd.>mailto:doug@artsman.com>http://www.artsman.com>Phone (403) 215-5701    Fax (403) 215-5704!!StrikeFont methodsFor: 'accessing'!ascent	"Answer the receiver's maximum extent of characters above the baseline."	^ascent! !!StrikeFont methodsFor: 'accessing' stamp: 'di 9/1/2000 17:17'!baseKern	"Return the base kern value to be used for all characters."	(emphasis noMask: 2) ifTrue: [^ 0].	^ ((self height-1-self ascent+4)//4 max: 0)  "See makeItalicGlyphs"		+ (((self ascent-5+4)//4 max: 0))! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 5/23/2000 12:52'!characterToGlyphMap	^characterToGlyphMap ifNil:[characterToGlyphMap _ self createCharacterToGlyphMap].! !!StrikeFont methodsFor: 'accessing'!descent	"Answer the receiver's maximum extent of characters below the baseline."	^descent! !!StrikeFont methodsFor: 'accessing' stamp: 'di 9/2/2000 13:06'!descentKern	"Return the kern delta for descenders."	(emphasis noMask: 2) ifTrue: [^ 0].	^ (self height-1-self ascent+4)//4 max: 0  "See makeItalicGlyphs"! !!StrikeFont methodsFor: 'accessing'!familyName	^self name withoutTrailingDigits.! !!StrikeFont methodsFor: 'accessing' stamp: 'tk 6/26/1998 16:45'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	^Array with: name		with: self height		with: emphasis	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 9/21/2000 11:53'!fontNameWithPointSize	^self name withoutTrailingDigits, ' ', self pointSize printString! !!StrikeFont methodsFor: 'accessing'!glyphs	"Answer a Form containing the bits representing the characters of the 	receiver."	^glyphs! !!StrikeFont methodsFor: 'accessing'!height	"Answer the height of the receiver, total of maximum extents of 	characters above and below the baseline."	^self ascent + self descent! !!StrikeFont methodsFor: 'accessing'!lineGrid	^ ascent + descent! !!StrikeFont methodsFor: 'accessing'!maxAscii	"Answer the integer that is the last Ascii character value of the receiver."	^maxAscii! !!StrikeFont methodsFor: 'accessing'!maxWidth	"Answer the integer that is the width of the receiver's widest character."	^maxWidth! !!StrikeFont methodsFor: 'accessing'!minAscii	"Answer the integer that is the first Ascii character value of the receiver."	^minAscii! !!StrikeFont methodsFor: 'accessing' stamp: 'ls 3/27/2000 19:54'!name	"Answer the receiver's name."	^name ifNil: ['(unnamed)']! !!StrikeFont methodsFor: 'accessing'!name: aString	"Set the receiver's name."	name _ aString! !!StrikeFont methodsFor: 'accessing' stamp: 'sw 1/18/2000 20:54'!pointSize	^ pointSize! !!StrikeFont methodsFor: 'accessing' stamp: 'nk 6/17/2003 14:26'!textStyle	^ TextStyle actualTextStyles detect:		[:aStyle | aStyle fontArray includes: self] ifNone: [nil]! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 12/31/2001 01:15'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ aCharacter asciiValue.	(ascii >= minAscii and:[ascii <= maxAscii]) ifFalse: [ascii _ maxAscii + 1].	^ (xTable at: ascii + 2) - (xTable at: ascii + 1)! !!StrikeFont methodsFor: 'accessing'!xTable	"Answer an Array of the left x-coordinate of characters in glyphs."	^xTable! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:11'!characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm 	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii destPoint bb leftX rightX sourceRect |	destPoint _ aPoint.	bb _ BitBlt current toForm: Display.	anInterval do: 		[:i | 		ascii _ (sourceString at: i) asciiValue.		(ascii < minAscii or: [ascii > maxAscii])			ifTrue: [ascii _ maxAscii].		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		sourceRect _ leftX@0 extent: (rightX-leftX) @ self height.		bb copyFrom: sourceRect in: glyphs to: destPoint.		destPoint _ destPoint + ((rightX-leftX)@0)].	^ destPoint! !!StrikeFont methodsFor: 'displaying'!displayLine: aString at: aPoint 	"Display the characters in aString, starting at position aPoint."	self characters: (1 to: aString size)		in: aString		displayAt: aPoint		clippedBy: Display boundingBox		rule: Form over		fillColor: nil! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 15:09'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."	aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 15:08'!installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColor	^aDisplayContext 		installStrikeFont: self		foregroundColor: foregroundColor 		backgroundColor: backgroundColor! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 12/31/2001 00:55'!widthOfString: aString from: firstIndex to: lastIndex	"Measure the length of the given string between start and stop index"	DefaultStringScanner 		ifNil:[DefaultStringScanner _ CharacterScanner new initializeStringMeasurer].	^DefaultStringScanner measureString: aString inFont: self from: firstIndex to: lastIndex! !!StrikeFont methodsFor: 'emphasis' stamp: 'ar 5/28/2000 12:11'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt current toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].! !!StrikeFont methodsFor: 'emphasis'!emphasis: code 	"Set the integer code for synthetic bold, itallic, underline, and strike-out, 	where bold=1, italic=2, underlined=4, and struck out=8."	emphasis _ code! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 9/3/2000 13:22'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy ensureCleanBold name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFont methodsFor: 'emphasis'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g _ glyphs deepCopy.	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 10/31/97 13:18'!makeCondensedGlyphs	"Make a condensed set of glyphs with same widths.	NOTE: this has been superceded by kerning -- should not get called"	| g newXTable x x1 w |	g _ glyphs deepCopy.	newXTable _ Array new: xTable size.	newXTable at: 1 put: (x _ xTable at: 1).	1 to: xTable size-1 do:		[:i | x1 _ xTable at: i.  w _ (xTable at: i+1) - x1.		w > 1 ifTrue: [w _ w-1].  "Shrink every character wider than 1"		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.		newXTable at: i+1 put: (x _ x + w)].	xTable _ newXTable.	glyphs _ g"(TextStyle default fontAt: 1) copy makeCondensedGlyphs	displayLine: 'The quick brown fox jumps over the lazy dog'	at: Sensor cursorPoint"! !!StrikeFont methodsFor: 'emphasis' stamp: 'BG 10/6/2002 13:20'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right.	In the process, characters would overlap, so we widen them all first.	"	| extraWidth newGlyphs newXTable x newX w extraOnLeft |  	extraOnLeft _ (self height-1-self ascent+4)//4 max: 0.	extraWidth _ ((self ascent-5+4)//4 max: 0) + extraOnLeft.	newGlyphs _ Form extent: (glyphs width + (maxAscii + 1 - minAscii*extraWidth)) @ glyphs height.	newXTable _ xTable copy.	"Copy glyphs into newGlyphs with room on left and right for overlap."	minAscii to: maxAscii+1 do:		[:ascii | x _ xTable at: ascii+1.  w _ (xTable at: ascii+2) - x.		newX _ newXTable at: ascii+1.		newGlyphs copy: ((newX + extraOnLeft) @ 0 extent: w @ glyphs height)			from: x @ 0 in: glyphs rule: Form over.		newXTable at: ascii+2 put: newX + w + extraWidth].			glyphs _ newGlyphs. 	xTable _ newXTable.	"Slide the bitmaps left and right for synthetic italic effect."	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		glyphs copy: (1@0 extent: glyphs width @ (self ascent - y))			from: 0@0 in: glyphs rule: Form over].	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		glyphs copy: (0@y extent: glyphs width @ glyphs height)			from: 1@y in: glyphs rule: Form over].! !!StrikeFont methodsFor: 'emphasis'!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis' stamp: 'nk 3/15/2004 18:46'!releaseCachedState	self reset.! !!StrikeFont methodsFor: 'emphasis' stamp: 'sma 12/30/1999 15:02'!reset	"Reset the cache of derivative emphasized fonts"	| style font |	derivativeFonts _ Array new: 32.	#('B' 'I' 'BI') doWithIndex:		[:tag :index | 		(style _ TextStyle named: self familyName) ifNotNil:			[(font _ style fontArray				detect: [:each | each name = (self name , tag)]				ifNone: [nil]) ifNotNil: [derivativeFonts at: index put: font]]]! !!StrikeFont methodsFor: 'file in/out' stamp: 'sma 6/1/2000 09:32'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self name;		space;		print: self height;		nextPut: $)! !!StrikeFont methodsFor: 'file in/out' stamp: 'sma 12/30/1999 14:20'!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "Drop filename extension"	file _ FileStream readOnlyFileNamed: fileName.	file binary.	[self readFromStrike2Stream: file] ensure: [file close]! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:53'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type _ file nextInt32.  type = 2 ifFalse: [file close. self error: 'not strike2 format'].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	pointSize _ file nextInt32.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 3/27/2000 14:25'!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii _ character asciiValue.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii _ maxAscii + 1].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 8/30/2000 10:00'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	ascii < minAscii ifTrue: [^ self error: 'Cant store characters below min ascii'].	ascii > maxAscii ifTrue:		[(self confirm:'This font does not accomodate ascii values higher than ' , maxAscii printString , '.Do you wish to extend it permanently to handle values up to ' , ascii printString)			ifTrue: [self extendMaxAsciiTo: ascii]			ifFalse: [^ self error: 'No change made']].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		xTable _ xTable copy.		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle defaultFont.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 8/30/2000 10:15'!ensureCleanBold 	"This ensures that all character glyphs have at least one pixel of white space on the right	so as not to cause artifacts in neighboring characters in bold or italic."	| wider glyph |	emphasis = 0 ifFalse: [^ self].	minAscii to: maxAscii do:		[:i | glyph _ self characterFormAt: (Character value: i).		(glyph copy: (glyph boundingBox topRight - (1@0)					corner: glyph boundingBox bottomRight)) isAllWhite ifFalse:			[wider _ Form extent: (glyph width + 1)@glyph height.			glyph displayOn: wider.			self characterFormAt: (Character value: i) put: wider]]."StrikeFont allInstancesDo: [:f | f ensureCleanBold].(StrikeFont familyName: 'NewYork' size: 21) ensureCleanBold.StrikeFont shutDown.  'Flush synthetic fonts'."! !!StrikeFont methodsFor: 'character shapes' stamp: 'ar 5/23/2000 12:48'!extendMaxAsciiTo: newMax	"Extend the range of this font so that it can display glyphs up to newMax."	(newMax+3) <= xTable size ifTrue: [^ self].  "No need to extend."	xTable size = (maxAscii+3) ifFalse:		[^ self error: 'This font is not well-formed.'].	"Insert a bunch of zero-width characters..."	xTable _ (xTable copyFrom: 1 to: maxAscii+2) ,			((maxAscii+1 to: newMax) collect: [:i | xTable at: maxAscii+2]) ,			{ xTable at: maxAscii+3 }.	maxAscii _ newMax.	self fillZeroWidthSlots.	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 3/27/2000 16:10'!fillZeroWidthSlots	| nullGlyph |	"Note: this is slow because it copies the font once for every replacement."	nullGlyph _ (Form extent: 1@glyphs height) fillGray.	"Now fill the empty slots with narrow box characters."	minAscii to: maxAscii do:		[:i | (self widthOf: (Character value: i)) = 0 ifTrue:			[self characterFormAt: (Character value: i) put: nullGlyph]].! !!StrikeFont methodsFor: 'copying' stamp: 'tk 8/19/1998 16:15'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!StrikeFont methodsFor: 'private' stamp: 'ar 5/18/2000 18:13'!createCharacterToGlyphMap	"Private. Create the character to glyph mapping for a font that didn't have any before. This is basically equivalent to what the former setStopCondition did, only based on indexes."	| map |	map _ Array new: 256.	0 to: minAscii - 1 do:[:i| map at: i + 1 put: maxAscii + 1].	minAscii to: maxAscii do:[:i| map at: i + 1 put: i].	maxAscii + 1 to: 255 do:[:i| map at: i + 1 put: maxAscii + 1].	^map! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StrikeFont class	instanceVariableNames: ''!!StrikeFont class methodsFor: 'examples'!example	"Displays a line of text on the display screen at the location of the cursor.	Example depends on the strike font file, 'TimesRoman10.strike'. existing."	(StrikeFont new readFromStrike2: 'NewYork12.sf2')		displayLine: 'A line of 12-pt text in New York style' at: Sensor cursorPoint	 	"StrikeFont example."! !!StrikeFont class methodsFor: 'examples' stamp: 'nop 2/11/2001 13:35'!readStrikeFont2Family: familyName 	"StrikeFont readStrikeFont2Family: 'Lucida'"	"This utility reads all available .sf2 StrikeFont files for a given family from  	the current directory. It returns an Array, sorted by size, suitable for handing 	to TextStyle newFontArray: ."	"For this utility to work as is, the .sf2 files must be named 'familyNN.sf2'."	| fileNames strikeFonts fontArray |	fileNames _ FileDirectory default fileNamesMatching: familyName , '##.sf2'.	strikeFonts _ fileNames collect: [:fname | StrikeFont new readFromStrike2: fname].	strikeFonts do: [ :font | font reset ].	strikeFonts _ strikeFonts asSortedCollection: [:a :b | a height < b height].	fontArray _ strikeFonts asArray.	^ fontArray"TextConstants at: #Lucida put: (TextStyle fontArray: (StrikeFont 	readStrikeFont2Family: 'Lucida'))."! !!StrikeFont class methodsFor: 'derivative font caching' stamp: 'tk 6/24/1999 11:45'!shutDown  "StrikeFont shutDown"	"Deallocate synthetically derived copies of base fonts to save space"	self allSubInstancesDo: [:sf | sf reset]! !!StrikeFont class methodsFor: 'accessing' stamp: 'nk 6/17/2003 15:15'!actualFamilyNames	"Answer a sorted list of actual family names, without the Default aliases"	^(self familyNames copyWithoutAll: #(DefaultTextStyle DefaultFixedTextStyle)) asOrderedCollection! !!StrikeFont class methodsFor: 'accessing' stamp: 'sma 12/30/1999 13:53'!familyName: aName size: aSize	"Answer a font (or the default font if the name is unknown) in the specified size."	^ ((TextStyle named: aName asSymbol) ifNil: [TextStyle default]) fontOfSize: aSize! !!StrikeFont class methodsFor: 'accessing' stamp: 'sma 12/30/1999 13:48'!familyNames	^ (TextConstants select: [:each | each isKindOf: TextStyle]) keys asSortedCollection! !ArrayedCollection variableByteSubclass: #String	instanceVariableNames: ''	classVariableNames: 'AsciiOrder CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder HtmlEntities LowercasingTable Tokenish UppercasingTable'	poolDictionaries: ''	category: 'Collections-Text'!!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters, compactly encoded as 8-bit bytes.String support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!]style[(269 13 2 18 72 24 2 43)f1,f1LString match:;,f1,f1LString contractTo:;,f1,f1LSequenceableCollection ,;,f1,f1LSequenceableCollection copyReplaceAll:with:;!!String methodsFor: 'accessing'!at: index 	"Primitive. Answer the Character stored in the field of the receiver	indexed by the argument. Fail if the index argument is not an Integer or	is out of bounds. Essential. See Object documentation whatIsAPrimitive."	<primitive: 63>	^Character value: (super at: index)! !!String methodsFor: 'accessing' stamp: 'wod 6/16/1998 15:24'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [				index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'ar 12/27/1999 13:44'!byteAt: index	<primitive: 60>	^(self at: index) asciiValue! !!String methodsFor: 'accessing' stamp: 'ar 12/27/1999 13:44'!byteAt: index put: value	<primitive: 61>	self at: index put: value asCharacter.	^value! !!String methodsFor: 'accessing' stamp: 'ar 3/3/2001 16:17'!byteSize	^self size! !!String methodsFor: 'accessing' stamp: 'sw 12/6/2001 16:08'!do: aBlock toFieldNumber: aNumber	"Considering the receiver as a holder of tab-delimited fields, evaluate aBlock on behalf of a field in this string"	| start end index |	start _ 1.	index _ 1.	[start <= self size] whileTrue: 		[end _ self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end _ end - 1.		aNumber = index ifTrue:			[aBlock value: (self copyFrom: start  to: end).			^ self].		index _ index + 1.		start _ end + 2]"1 to: 6 do:	[:aNumber |		'fred	charlie	elmo		wimpy	friml' do:			[:aField | Transcript cr; show: aField] toFieldNumber: aNumber]"! !!String methodsFor: 'accessing'!endsWithDigit	"Answer whether the receiver's final character represents a digit.  3/11/96 sw"	^ self size > 0 and: [self last isDigit]! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 11:09'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min _ self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim class == Character 			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind _ self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min _ min min: ind].	^ min! !!String methodsFor: 'accessing' stamp: 'dew 11/15/2000 15:02'!findBetweenSubStrs: delimiters	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'ls 3/19/2000 16:43'!findCloseParenthesisFor: startIndex	"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest."	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 "	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 "	| pos nestLevel |	pos := startIndex+1.	nestLevel := 1.	[ pos <= self size ] whileTrue: [		(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].		(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].		nestLevel = 0 ifTrue: [ ^pos ].		pos := pos + 1.	].	^self size + 1! !!String methodsFor: 'accessing'!findDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."	start to: self size do: [:i |		delimiters do: [:delim | delim = (self at: i) ifTrue: [^ i]]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'ar 4/11/1999 22:15'!findString: subString	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^self findString: subString startingAt: 1.! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43'!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^ self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:45'!findString: key startingAt: start caseSensitive: caseSensitive	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."	caseSensitive	ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]	ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]! !!String methodsFor: 'accessing' stamp: 'tk 8/10/2000 09:14'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens _ OrderedCollection new.	separators _ delimiters class == Character 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: separators startingAt: keyStop.		keyStop _ self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 09:50'!findTokens: delimiters includes: subString	"Divide self into pieces using delimiters.  Return the piece that includes subString anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive)."^ (self findTokens: delimiters) 	detect: [:str | (str includesSubString: subString)] 	ifNone: [nil]! !!String methodsFor: 'accessing' stamp: 'tk 6/19/97 10:05'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop _ self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'tk 6/2/2001 12:12'!findWordStart: key startingAt: start	| ind |	"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned."	ind _ start.	[ind _ self findSubstring: key in: self startingAt: ind matchTable: CaseInsensitiveOrder.	ind = 0 ifTrue: [^ 0].	"not found"	ind = 1 ifTrue: [^ 1].	"First char is the start of a word"	(self at: ind-1) isSeparator] whileFalse: [ind _ ind + 1].	^ ind	"is a word start"! !!String methodsFor: 'accessing' stamp: 'sw 8/12/97 12:37'!includesSubString: subString	^ (self findString: subString startingAt: 1) > 0! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:53'!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'accessing' stamp: 'di 9/1/1999 18:28'!indexOf: aCharacter	(aCharacter class == Character) ifFalse: [^ 0].	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: 1! !!String methodsFor: 'accessing' stamp: 'di 9/1/1999 18:28'!indexOf: aCharacter  startingAt: start	(aCharacter class == Character) ifFalse: [^ 0].	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'di 9/1/1999 18:28'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter class == Character) ifFalse: [ ^ aBlock value ].	ans _ String indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:20'!indexOfAnyOf: aCharacterSet	"returns the index of the first character in the given set.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  ifAbsent: aBlock	"returns the index of the first character in the given set.  Returns the evaluation of aBlock if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1  ifAbsent: aBlock! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  startingAt: start	"returns the index of the first character in the given set, starting from start.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: start  ifAbsent: [ 0 ]! !!String methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:27'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ String findFirstInString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0 		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'RAH 4/25/2000 19:49'!indexOfSubCollection: sub 	#Collectn.	"Added 2000/04/08 For ANSI <sequenceReadableCollection> protocol."	^ self		indexOfSubCollection: sub		startingAt: 1		ifAbsent: [0]! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 17:02'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index _ self findSubstring: sub in: self startingAt: start matchTable: CaseSensitiveOrder.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'nk 2/21/2001 21:26'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a _ aSignature first.	b _ aSignature second.	c _ aSignature third.	d _ aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!String methodsFor: 'accessing'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position.  1/15/96 sw:  Inefficient first stab at this"	| cr aChar answer |	cr _ Character cr.	answer _ ''.	1 to: self size do:		[:i | 			aChar _ self at: i.			aChar == cr				ifTrue:					[i > anIndex						ifTrue:							[^ answer]						ifFalse:							[answer _ '']]				ifFalse:					[answer _ answer copyWith: aChar]].	^ answer! !!String methodsFor: 'accessing' stamp: 'md 11/14/2003 17:26'!lineCount	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"	| cr count |	cr _ Character cr.	count _ 1  min: self size.	1 to: self size do:		[:i | (self at: i) == cr ifTrue: [count _ count + 1]].	^ count"'FredtheBear' lineCount"! !!String methodsFor: 'accessing'!lineNumber: anIndex	"Answer a string containing the characters in the given line number.  5/10/96 sw"	| crString pos finalPos |	crString _ String with: Character cr.	pos _ 0.	1 to: anIndex - 1 do:		[:i | pos _ self findString: crString startingAt: pos + 1.			pos == 0 ifTrue: [^ nil]].	finalPos _ self findString: crString startingAt: pos + 1.	finalPos == 0 ifTrue: [finalPos _ self size + 1].	^ self copyFrom: pos + 1 to: finalPos - 1"'FredtheBear' lineNumber: 3"! !!String methodsFor: 'accessing' stamp: 'ls 9/10/1998 22:27'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start _ 1.	[ start <= self size ] whileTrue: [		end _ self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end _ end - 1.		aBlock value: (self copyFrom: start  to: end).		start _ end + 2. ].! !!String methodsFor: 'accessing' stamp: 'BJP 6/12/2000 18:53'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii _ start-1.	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any _ false.		delimiters do: [:delim |			delim class == Character 				ifTrue: [(self at: ii) == delim ifTrue: [any _ true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind _ 0.						this _ true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this _ false].							ind _ ind + 1].						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]							ifTrue: [any _ false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing'!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		delimiters detect: [:delim | delim = (self at: i)]				ifNone: [^ i]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'sw 4/23/1998 10:53'!startsWithDigit	"Answer whether the receiver's first character represents a digit"	^ self size > 0 and: [self first isDigit]! !!String methodsFor: 'accessing' stamp: 'sw 12/6/2001 21:30'!tabDelimitedFieldsDo: aBlock	"Considering the receiver as a holder of tab-delimited fields, evaluate execute aBlock with each field in this string.  The separatilng tabs are not included in what is passed to aBlock"	| start end |	"No senders but was useful enough in earlier work that it's retained for the moment."	start _ 1.	[start <= self size] whileTrue: 		[end _ self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end _ end - 1.		aBlock value: (self copyFrom: start  to: end).		start _ end + 2]"'fred	charlie	elmo		2' tabDelimitedFieldsDo: [:aField | Transcript cr; show: aField]"! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:16'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 1! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:17'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'tk 10/17/2001 14:06'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString species == String ifFalse: [		aString isText ifTrue: [^ self = aString string].		^ false].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:17'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 3! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:18'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) >= 2! !!String methodsFor: 'comparing'!alike: aString 	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."	| i j k minSize bonus |	minSize _ (j _ self size) min: (k _ aString size).	bonus _ (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].	i _ 1.	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]		whileTrue: [ i _ i + 1 ].	[(j > 0) and: [(k > 0) and:		[((super at: j) bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]			whileTrue: [ j _ j - 1.  k _ k - 1. ].	^ i - 1 + self size - j + bonus. ! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: CaseSensitiveOrder) = 1! !!String methodsFor: 'comparing' stamp: 'sw 4/19/1999 12:11'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	^ (self compare: self with: aString collated: CaseInsensitiveOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'di 9/20/1998 14:33'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'tk 9/5/2000 10:42'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| count |	count _ self size min: aString size.	1 to: count do: [:i | 		(self at: i) == (aString at: i) ifFalse: [			^ i - 1]].	^ count! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:41'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	^ self compare: self with: aString collated: CaseInsensitiveOrder! !!String methodsFor: 'comparing' stamp: 'go 2/11/98 14:59'!crc16	"Compute a 16 bit cyclic redundancy check."	| crc |	crc := 0.	self do: [:c |		crc := (crc bitShift: -8) bitXor: (		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)			 at: ((crc bitXor: c asciiValue) bitAnd: 16rFF) + 1) ].	^crc! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| extra |	(extra _ self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: CaseSensitiveOrder) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'ar 11/19/1998 21:48'!endsWithAnyOf: aCollection	aCollection do:[:suffix|		(self endsWith: suffix) ifTrue:[^true].	].	^false! !!String methodsFor: 'comparing' stamp: 'SqR 8/13/2002 10:52'!hash	"#hash is implemented, because #= is implemented"	^ByteArray		hashBytes: self		startingWith: self species hash! !!String methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!String methodsFor: 'comparing' stamp: 'tk 3/8/2001 16:49'!howManyMatch: string 	"Count the number of characters that match up in self and aString."	| count shorterLength |		count  _  0 .	shorterLength  _  ((self size ) min: (string size ) ) .	(1 to: shorterLength  do: [:index |		 (((self at: index ) = (string at: index )  ) ifTrue: [count  _  (count + 1 ) .			]   ).		]   ).	^  count 		! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:37'!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:19'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	^ (self compare: self with: aString collated: CaseInsensitiveOrder) = 2! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:28'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i _ keyStart.	j _ textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i _ i+1.  j _ j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch _ true.				matchStart _ i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch _ false.				matchStart _ i].	"Now determine the match string"	matchEnd _ self size.	(ii _ self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd _ ii-1].	(ii _ self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd _ matchEnd min: ii-1].	matchStr _ self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj _ text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j _ j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'copying'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!String methodsFor: 'copying'!deepCopy	"DeepCopy would otherwise mean make a copy of the character;  since 	characters are unique, just return a shallowCopy."	^self shallowCopy! !!String methodsFor: 'copying' stamp: 'di 2/15/98 22:54'!padded: leftOrRight to: length with: char	leftOrRight = #left ifTrue:		[^ (String new: (length - self size max: 0) withAll: char) , self].	leftOrRight = #right ifTrue:		[^ self , (String new: (length - self size max: 0) withAll: char)].! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a collection, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/9/1998 12:17'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a point, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a string, convert us both to	numbers, and return the printString of the result."	^ (rcvr asNumber perform: selector with: self asNumber) printString! !!String methodsFor: 'converting' stamp: 'sw 9/1/2000 10:39'!asCharacter	"Answer the receiver's first character, or '' if none.  Idiosyncratic, provisional."	^ self size > 0 ifTrue: [self first] ifFalse: [$]! !!String methodsFor: 'converting' stamp: 'brp 8/23/2003 23:58'!asDate	"Many allowed forms, see Date>>#readFrom:"	^ Date fromString: self! !!String methodsFor: 'converting' stamp: 'brp 7/27/2003 17:28'!asDateAndTime

	"Convert from UTC format" 	^ DateAndTime fromString: self! !!String methodsFor: 'converting'!asDisplayText	"Answer a DisplayText whose text string is the receiver."	^DisplayText text: self asText! !!String methodsFor: 'converting' stamp: 'brp 5/16/2003 11:59'!asDuration
	"convert from [nnnd]hh:mm:ss[.nanos] format. [] implies optional elements"

	^ Duration fromString: self
! !!String methodsFor: 'converting'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	^FileDirectory checkName: self fixErrors: true! !!String methodsFor: 'converting' stamp: 'acg 9/11/1999 15:43'!asFourCode	|result|	self size = 4 ifFalse: [^self error: 'must be exactly four characters'].	result _ self inject: 0 into: [:val :each | 256 * val + each asciiValue].	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^result! !!String methodsFor: 'converting' stamp: 'nk 2/21/2001 20:06'!asHex	| stream |	stream _ WriteStream on: (String new: self size * 2).	self do: [ :ch | stream nextPutAll: ch hex ].	^stream contents! !!String methodsFor: 'converting' stamp: 'sma 3/11/2000 17:25'!asHtml	"Do the basic character conversion for HTML.  Leave all original return 	and tabs in place, so can conver back by simply removing bracked 	things. 4/4/96 tk"	| temp |	temp _ self copyReplaceAll: '&' with: '&amp;'.	HtmlEntities keysAndValuesDo:		[:entity :char |		char = $& ifFalse:			[temp _ temp copyReplaceAll: char asString with: '&' , entity , ';']].	temp _ temp copyReplaceAll: '	' with: '	<IMG SRC="tab.gif" ALT="    ">'.	temp _ temp copyReplaceAll: '' with: '<BR>'.	^ temp"	'A<&>B' asHtml"! !!String methodsFor: 'converting' stamp: 'ls 9/5/1998 01:19'!asIRCLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase, where 'lowercase' is by IRC's definition"	^self collect: [ :c | c asIRCLowercase ]! !!String methodsFor: 'converting' stamp: 'sw 9/5/2000 09:03'!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString _ self select: [:el | el isAlphaNumeric].	firstLetterPosition _ aString findFirst: [:ch | ch isLetter].	aString _ firstLetterPosition == 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar _ shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !!String methodsFor: 'converting' stamp: 'sw 9/1/2000 10:40'!asInteger 	"Answer the Integer created by interpreting the receiver as the string representation of an integer.  Answer nil if no digits, else find the first digit and then all consecutive digits after that"	| startPosition tail endPosition |	startPosition _ self findFirst: [:ch | ch isDigit].	startPosition == 0 ifTrue: [^ nil].	tail _ self copyFrom: startPosition to: self size.	endPosition _ tail findFirst: [:ch | ch isDigit not].	endPosition == 0 ifTrue: [endPosition _ tail size + 1].	^ Number readFromString: (tail copyFrom: 1 to: endPosition - 1)"'1796exportFixes-tkMX' asInteger'1848recentLogFile-sw'  asInteger'donald' asInteger'abc234def567' asInteger"! !!String methodsFor: 'converting' stamp: 'sw 5/3/1998 23:19'!asLegalSelector	| toUse |	toUse _ ''.	self do:		[:char | char isAlphaNumeric ifTrue: [toUse _ toUse copyWith: char]].	(self size == 0 or: [self first isLetter not])		ifTrue:		[toUse _ 'v', toUse].	^ toUse withFirstCharacterDownshifted"'234znak 43 ) 2' asLegalSelector"! !!String methodsFor: 'converting' stamp: 'sma 6/12/2000 11:40'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^ self copy asString translateToLowercase! !!String methodsFor: 'converting'!asNumber 	"Answer the Number created by interpreting the receiver as the string 	representation of a number."	^Number readFromString: self! !!String methodsFor: 'converting'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack _ pack * 256 + next asInteger ].! !!String methodsFor: 'converting'!asParagraph	"Answer a Paragraph whose text string is the receiver."	^Paragraph withText: self asText! !!String methodsFor: 'converting' stamp: 'sw 8/3/2002 04:32'!asSignedInteger	"Answer the Integer created by interpreting the receiver as the string representation of an integer, possibly with a leading minus sign.  Answer nil if no digits, else find the first digit and then all consecutive digits after that"	| startPosition tail endPosition |	startPosition _ self findFirst: [:ch | ch isDigit or: [ch == $-]].	startPosition == 0 ifTrue: [^ nil].	tail _ self copyFrom: startPosition to: self size.	endPosition _ tail findFirst: [:ch | ch isDigit not and: [ch ~~ $-]].	endPosition == 0 ifTrue: [endPosition _ tail size + 1].	^ Number readFromString: (tail copyFrom: 1 to: endPosition - 1)"'znak -58 to wit' asSignedInteger"! !!String methodsFor: 'converting' stamp: 'ls 10/28/2003 12:24'!asSmalltalkComment	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"	^String streamContents:  [ :str |		| quoteCount first |		str nextPut: $".			quoteCount := 0.		first := true.		self do: [ :char |			char = $"				ifTrue: [					first ifFalse: [						str nextPut: char.						quoteCount := quoteCount + 1 ] ]				ifFalse: [					quoteCount odd ifTrue: [						"add a quote to even the number of quotes in a row"						str nextPut: $" ].					quoteCount := 0.					str nextPut: char ].			first := false ]. 		quoteCount odd ifTrue: [			"check at the end"			str nextPut: $". ].		str nextPut: $".	].	! !!String methodsFor: 'converting' stamp: 'jm 5/14/1998 10:40'!asString	"Answer this string."	^ self! !!String methodsFor: 'converting' stamp: 'RAA 5/28/2001 06:19'!asStringOrText	"Answer this string."	^ self! !!String methodsFor: 'converting'!asSymbol	"Answer the unique Symbol whose characters are the characters of the 	string."	^Symbol intern: self! !!String methodsFor: 'converting'!asText	"Answer a Text whose string is the receiver."	^Text fromString: self! !!String methodsFor: 'converting' stamp: 'brp 8/24/2003 00:01'!asTime	"Many allowed forms, see Time>>readFrom:"	^ Time fromString: self.! !!String methodsFor: 'converting' stamp: 'brp 8/24/2003 00:02'!asTimeStamp	"Convert from obsolete TimeStamp format"
	^ TimeStamp fromString: self! !!String methodsFor: 'converting' stamp: 'tk 4/13/2002 09:13'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in _ ReadStream on: self.	out _ WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char _ in next) = $&						ifTrue: [rest _ in upTo: $;.								did _ out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								rest = 'deg' ifTrue: [out nextPut: $].								rest = 'quot' ifTrue: [out nextPut: $"].								did = out position ifTrue: [									self error: 'unknown encoded HTML char'.									"Please add it to this method"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!String methodsFor: 'converting' stamp: 'SqR 6/13/2000 20:10'!asUppercase	"Answer a String made up from the receiver whose characters are all 	uppercase."	^self copy asString translateToUppercase! !!String methodsFor: 'converting' stamp: 'ls 7/15/1998 18:40'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: 'converting' stamp: 'di 2/2/98 12:59'!askIfAddStyle: priorMethod req: requestor	^ self   "we are a string with no text style"! !!String methodsFor: 'converting' stamp: 'ls 9/10/1998 08:48'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting'!compressWithTable: tokens	"Return a string with all substrings that occur in tokens replaced	by a character with ascii code = 127 + token index.	This will work best if tokens are sorted by size.	Assumes this string contains no characters > 127, or that they	are intentionally there and will not interfere with this process."	| str null finalSize start result ri c ts |	null _ Character value: 0.	str _ self copyFrom: 1 to: self size.  "Working string will get altered"	finalSize _ str size.	tokens doWithIndex:		[:token :tIndex |		start _ 1.		[(start _ str findString: token startingAt: start) > 0]			whileTrue:			[ts _ token size.			((start + ts) <= str size				and: [(str at: start + ts) = $  and: [tIndex*2 <= 128]])				ifTrue: [ts _ token size + 1.  "include training blank"						str at: start put: (Character value: tIndex*2 + 127)]				ifFalse: [str at: start put: (Character value: tIndex + 127)].			str at: start put: (Character value: tIndex + 127).			1 to: ts-1 do: [:i | str at: start+i put: null].			finalSize _ finalSize - (ts - 1).			start _ start + ts]].	result _ String new: finalSize.	ri _ 0.	1 to: str size do:		[:i | (c _ str at: i) = null ifFalse: [result at: (ri _ ri+1) put: c]].	^ result! !!String methodsFor: 'converting' stamp: 'di 1/16/98 16:33'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize _ smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting'!correctAgainst: wordList	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"	| results |	results _ self correctAgainst: wordList continuedFrom: nil.	results _ self correctAgainst: nil continuedFrom: results.	^ results! !!String methodsFor: 'converting' stamp: 'ar 5/1/1999 05:01'!correctAgainst: wordList continuedFrom: oldCollection	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."	^ wordList isNil		ifTrue: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifFalse: [ self correctAgainstEnumerator: [ :action | wordList do: action without: nil]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting'!correctAgainstDictionary: wordDict continuedFrom: oldCollection	"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."	^ wordDict isNil		ifTrue: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifFalse: [ self correctAgainstEnumerator: [ :action | wordDict keysDo: action ]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting' stamp: 'ls 8/12/1998 23:31'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	| encodedStream |	encodedStream _ WriteStream on: (String new).		self do: [ :c |		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [			encodedStream nextPut: $%.			encodedStream nextPut: (c asciiValue // 16) asHexDigit.			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.		]	].	^encodedStream contents. ! !!String methodsFor: 'converting' stamp: 'tk 12/12/2001 15:11'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens level n |	sel _ self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel _ sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens _ sel findTokens: Character separators.		sel _ String streamContents:			[:s | level _ 0.			possibleParens do:				[:token |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n _ token occurrencesOf: $( ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $[ ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $] ) > 0 ifTrue: [level _ level - n].							(n _ token occurrencesOf: $) ) > 0 ifTrue: [level _ level - n]]]]].	sel isEmpty ifTrue: [^ nil].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!String methodsFor: 'converting' stamp: 'sw 8/20/1999 10:23'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size == 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit _ (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit _ self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'di 4/22/2000 16:05'!keywords	"Answer an array of the keywords that compose the receiver."	| kwd char keywords |	keywords _ Array streamContents:		[:kwds | kwd _ WriteStream on: (String new: 16).		1 to: self size do:			[:i |			kwd nextPut: (char _ self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		kwd isEmpty ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords _ keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords _ keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'converting' stamp: 'sw 5/30/2000 14:58'!numericSuffix	^ self stemAndNumericSuffix last"'abc98' numericSuffix'98abc' numericSuffix"! !!String methodsFor: 'converting' stamp: 'dgd 9/6/2003 18:48'!onlyLetters	"answer the receiver with only letters"	^ self select:[:each | each isLetter]! !!String methodsFor: 'converting' stamp: 'sma 5/20/2000 17:17'!romanNumber	| value v1 v2 |	value _ v1 _ v2 _ 0.	self reverseDo:		[:each |		v1 _ #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).		v1 >= v2			ifTrue: [value _ value + v1]			ifFalse: [value _ value - v1].		v2 _ v1].	^ value! !!String methodsFor: 'converting'!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely _ self copyUpTo: $..	^ likely size == 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'converting' stamp: 'di 9/24/1999 12:31'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.	'43Sam' ==> #(43 'Sam').  'Try90' ==> #('Try' 90)	BUT NOTE: 'Sam' ==> #('Sam' 0), and '90' ==> #('' 90)  ie, (<string> <integer>)."	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 				with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting'!stemAndNumericSuffix	"Parse the receiver into a string-valued stem and a numeric-valued suffix.  6/7/96 sw"	| stem suffix position |	stem _ self.	suffix _ 0.	position _ 1.	[stem endsWithDigit and: [stem size > 1]] whileTrue:		[suffix _  stem last digitValue * position + suffix.		position _ position * 10.		stem _ stem copyFrom: 1 to: stem size - 1].	^ Array with: stem with: suffix"'Fred2305' stemAndNumericSuffix"! !!String methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!subStrings	"Answer an array of the substrings that compose the receiver."	#Collectn.	"Added 2000/04/08 For ANSI <readableString> protocol."	^ self substrings! !!String methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!subStrings: separators 	"Answer an array containing the substrings in the receiver separated 	by the elements of separators."	| char result sourceStream subString |	#Collectn.	"Changed 2000/04/08 For ANSI <readableString> protocol."	(separators allSatisfy: [:element | element isKindOf: Character])		ifFalse: [^ self error: 'separators must be Characters.'].	sourceStream := ReadStream on: self.	result := OrderedCollection new.	subString := String new.	[sourceStream atEnd]		whileFalse: 			[char := sourceStream next.			(separators includes: char)				ifTrue: [subString notEmpty						ifTrue: 							[result add: subString copy.							subString := String new]]				ifFalse: [subString := subString , (String with: char)]].	subString notEmpty ifTrue: [result add: subString copy].	^ result asArray! !!String methodsFor: 'converting' stamp: 'ls 1/3/1999 13:36'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result _ WriteStream on: (Array new: 10).	end _ 0.	"find one substring each time through this loop"	[ 		"find the beginning of the next substring"		beginning _ self indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: [ nil ].		beginning ~~ nil ] 	whileTrue: [		"find the end"		end _ self indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ self size + 1 ].		end _ end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'sw 11/25/96'!surroundedBySingleQuotes	"Answer the receiver with leading and trailing quotes.  "	^ $' asString, self, $' asString! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 10:31'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	String translate: self  from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'ls 8/18/1998 07:44'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'SqR 6/13/2000 20:10'!translateToUppercase	"Translate all characters to lowercase, in place"	self translateWith: UppercasingTable! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:30'!translateWith: table	"translate the characters in the string by the given table, in place"	^self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting'!truncateTo: smallSize	"return myself or a copy shortened to smallSize.  1/18/96 sw"	^ self size <= smallSize		ifTrue:			[self]		ifFalse:			[self copyFrom: 1 to: smallSize]! !!String methodsFor: 'converting' stamp: 'sw 9/2/1998 17:09'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'sw 10/26/2000 10:00'!unparenthetically	"If the receiver starts with (..( and ends with matching )..), strip them"	| curr |	curr _ self.	[((curr first == $() and: [curr last == $)])] whileTrue:		[curr _ curr copyFrom: 2 to: (curr size - 1)].	^ curr"'((fred the bear))' unparenthetically"		! !!String methodsFor: 'converting' stamp: 'bolot 11/3/1999 17:35'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	| trimmed lastBlank |	trimmed _ self withBlanksTrimmed.	^String streamContents: [:stream |		lastBlank _ false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank _ c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!String methodsFor: 'converting' stamp: 'jm 5/14/1998 10:26'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first |	first _ self findFirst: [:c | c isSeparator not].	first = 0 ifTrue: [^ ''].  "no non-separator character"	^ self		copyFrom: first		to: (self findLast: [:c | c isSeparator not])	" ' abc  d   ' withBlanksTrimmed"! !!String methodsFor: 'converting' stamp: 'sw 6/6/2002 18:24'!withFirstCharacterDownshifted	"Answer an object like the receiver but with first character downshifted if necesary"	"'MElViN' withFirstCharacterDownshifted"	"#Will withFirstCharacterDownshifted"	| answer |	self isEmpty ifTrue: [^ self].	answer _ self isString				ifTrue: ["don't change receiver"					self copy]				ifFalse: [self asString].	answer at: 1 put: (answer at: 1) asLowercase.	^ self isString		ifTrue: [answer]		ifFalse: [answer as: self class]! !!String methodsFor: 'converting' stamp: 'tk 3/28/1999 22:44'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	listOfLines _ OrderedCollection new.	currentLast _ 0.	[currentLast < self size] whileTrue:		[currentStart _ currentLast + 1.		putativeLast _ (currentStart + aNumber - 1) min: self size.		putativeLine _ self copyFrom: currentStart to: putativeLast.		(crPosition _ putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast _ currentStart + crPosition - 1.			putativeLine _ self copyFrom: currentStart to: putativeLast].		currentLast _ putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast _ putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString _ listOfLines first.	2 to: listOfLines size do:		[:i | resultString _ resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'converting' stamp: 'ls 8/20/1998 10:43'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	| out pos textEnd |	self isEmpty ifTrue: [ ^self ].	out _ WriteStream on: (String new: self size).	pos _ 1.   "current position in a scan through aString"	"handle the case of initial separators"	self first isSeparator ifTrue: [		out nextPut: Character space.		pos _ self indexOfAnyOf: CSNonSeparators ifAbsent: [ self size + 1 ] ].	"central loop: handle a segment of text, followed possibly by a segment of whitespace"	[ pos <= self size ] whileTrue: [ 		"handle a segment of text..."		textEnd _ self 			indexOfAnyOf: CSSeparators			startingAt: pos 			ifAbsent: [ self size + 1 ].		textEnd _ textEnd - 1.		out nextPutAll: (self copyFrom: pos to: textEnd).		pos _ textEnd + 1.		pos <= self size ifTrue: [			pos _ self 				indexOfAnyOf: CSNonSeparators				startingAt: pos				ifAbsent: [ self size + 1 ].			out nextPut: Character space  ] ].	^out contents! !!String methodsFor: 'converting' stamp: 'sw 1/8/1999 14:45'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit _ (self findFirst: [:m | m isDigit not and: [m ~~ $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'bf 11/24/1998 19:58'!withoutTrailingBlanks	"Return a copy of the receiver from which trailing blanks have been trimmed."	| last |	last _ self findLast: [:c | c isSeparator not].	last = 0 ifTrue: [^ ''].  "no non-separator character"	^ self copyFrom: 1 to: last	" ' abc  d   ' withoutTrailingBlanks"! !!String methodsFor: 'converting'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit _ (self findFirst: [:m | m isDigit or: [m == $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1   to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: 'displaying'!displayOn: aDisplayMedium	"Display the receiver on the given DisplayMedium.  5/16/96 sw"	self displayOn: aDisplayMedium at: 0 @ 0! !!String methodsFor: 'displaying' stamp: 'sw 2/5/2002 20:33'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."	self displayOn: aDisplayMedium at: aPoint textColor: Color black! !!String methodsFor: 'displaying' stamp: 'sw 2/5/2002 20:33'!displayOn: aDisplayMedium at: aPoint textColor: aColor	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"	(self asDisplayText foregroundColor: (aColor ifNil: [Color black]) backgroundColor: Color white)		displayOn: aDisplayMedium at: aPoint! !!String methodsFor: 'displaying' stamp: 'RAA 5/15/2000 11:00'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	^ProgressInitiationException 		display: self		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!String methodsFor: 'printing' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	"Number String Boolean player collection sound color etc"	^ #String! !!String methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:22'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do:		[:i |		aStream print: (x _ self at: i).		x == $' ifTrue: [aStream print: x]].	aStream print: $'! !!String methodsFor: 'printing'!isLiteral	^true! !!String methodsFor: 'printing' stamp: 'sma 6/1/2000 09:48'!printOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	self storeOn: aStream! !!String methodsFor: 'printing'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x _ self at: i).		x == $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!String methodsFor: 'printing'!stringRepresentation	"Answer a string that represents the receiver.  For most objects this is simply its printString, but for strings themselves, it's themselves, to avoid the superfluous extra pair of quotes.  6/12/96 sw"	^ self ! !!String methodsFor: 'private' stamp: 'di 12/1/2000 14:55'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices scoreMin results score maxChoices |	scoreMin _ self size // 2 min: 3.	maxChoices _ 10.	oldCollection isNil		ifTrue: [ choices _ SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices _ oldCollection ].	wordBlock isNil		ifTrue:			[ results _ OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score _ self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].			results _ choices ].	^ results! !!String methodsFor: 'private' stamp: 'dgd 8/27/2003 19:42'!evaluateExpression: aString parameters: aCollection 	"private - evaluate the expression aString with  	aCollection as the parameters and answer the  	evaluation result as an string"	| index |	index := ('0' , aString) asNumber.	index isZero		ifTrue: [^ '[invalid subscript: {1}]' format: {aString}].	index > aCollection size		ifTrue: [^ '[subscript is out of bounds: {1}]' format: {aString}].	^ (aCollection at: index) asString! !!String methodsFor: 'private' stamp: 'dgd 8/27/2003 19:41'!getEnclosedExpressionFrom: aStream 	"private - get the expression enclosed between '{' and 	'}' and remove all the characters from the stream"	| result currentChar |	result := String new writeStream.	[aStream atEnd 		or: [(currentChar := aStream next) == $}]]		whileFalse: [result nextPut: currentChar].	^ result contents withBlanksTrimmed! !!String methodsFor: 'private'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!String methodsFor: 'private'!stringhash	^self hash! !!String methodsFor: 'system primitives' stamp: 'ar 2/3/2001 16:12'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	self var: #string1 declareC: 'unsigned char *string1'.	self var: #string2 declareC: 'unsigned char *string2'.	self var: #order declareC: 'unsigned char *order'.	len1 _ string1 size.	len2 _ string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 _ order at: (string1 basicAt: i) + 1.		c2 _ order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String methodsFor: 'system primitives' stamp: 'ar 2/3/2001 16:13'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!String methodsFor: 'system primitives' stamp: 'di 12/3/2000 09:34'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess start ix |	self size = 0 ifTrue: [^ -1].	firstChar _ self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		["Fast reject if any chars are non-alphanumeric"		(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1].		"Fast colon count"		numColons _ 0.  start _ 1.		[(ix _ self findSubstring: ':' in: self startingAt: start matchTable: CaseSensitiveOrder) > 0]			whileTrue:				[numColons _ numColons + 1.				start _ ix + 1].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess _ 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess _ 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!String methodsFor: 'Celeste'!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !!String methodsFor: 'internet' stamp: 'sma 3/11/2000 20:40'!isoToSqueak	^ self collect: [:each | each isoToSqueak]! !!String methodsFor: 'internet' stamp: 'JO 9/2/2002 11:54'!isoToUtf8	"Convert ISO 8559-1 to UTF-8"	| s v |	s _ WriteStream on: (String new: self size).	self do: [:c |		v _ c asciiValue.		(v > 128)			ifFalse: [s nextPut: c]			ifTrue: [				s nextPut: (192+(v >> 6)) asCharacter.				s nextPut: (128+(v bitAnd: 63)) asCharacter]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'BG 10/29/2003 08:20'!replaceHtmlCharRefs        | pos ampIndex scIndex special specialValue outString outPos newOutPos |        outString _ String new: self size.        outPos _ 0.        pos _ 1.                [ pos <= self size ] whileTrue: [                 "read up to the next ampersand"                ampIndex _ self indexOf: $& startingAt: pos ifAbsent: [0].                                ampIndex = 0 ifTrue: [                        pos = 1 ifTrue: [ ^self ] ifFalse: [ ampIndex _ self size+1 ] ].                newOutPos _ outPos + ampIndex - pos.                outString                        replaceFrom: outPos + 1                        to: newOutPos                        with: self                        startingAt: pos.                outPos _ newOutPos.                pos _ ampIndex.                ampIndex <= self size ifTrue: [                        "find the $;"                        scIndex _ self indexOf: $; startingAt: ampIndex ifAbsent: [ self size + 1 ].                        special _ self copyFrom: ampIndex+1 to: scIndex-1.                               specialValue _ "HtmlEntity valueOfHtmlEntity: special" 16r32.                         specialValue                                ifNil: [                                        "not a recognized entity.  wite it back"								  scIndex > self size ifTrue: [ scIndex _ self size ].                                        newOutPos _ outPos + scIndex - ampIndex + 1.                                        outString                                                replaceFrom: outPos+1                                                to: newOutPos                                                with: self                                                startingAt: ampIndex.                                        outPos _ newOutPos.]                                ifNotNil: [                                        outPos _ outPos + 1.                                        outString at: outPos put: specialValue isoToSqueak.].                                                pos _ scIndex + 1. ]. ].        ^outString copyFrom: 1 to: outPos! !!String methodsFor: 'internet' stamp: 'bf 3/9/2000 16:46'!squeakToIso	^self collect: [:c | c squeakToIso ]! !!String methodsFor: 'internet' stamp: 'RAA 2/6/2001 09:37'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| ans c asciiVal pos oldPos specialChars |	ans _ WriteStream on: String new.	oldPos _ 1.	specialChars _ '+%' asCharacterSet.	[pos _ self indexOfAnyOf: specialChars startingAt: oldPos. pos > 0]	whileTrue: [		ans nextPutAll: (self copyFrom: oldPos to: pos - 1).		c _ self at: pos.		c = $+ ifTrue: [ans nextPut: $ ] ifFalse: [			(c = $% and: [pos + 2 <= self size]) ifTrue: [				asciiVal _ (self at: pos+1) asUppercase digitValue * 16 +					(self at: pos+2) asUppercase digitValue.				pos _ pos + 2.				asciiVal > 255 ifTrue: [^self].	"not really an escaped string"				ans nextPut: (Character value: asciiVal)]			ifFalse: [ans nextPut: c]].		oldPos _ pos+1].	ans nextPutAll: (self copyFrom: oldPos to: self size).	^ ans contents! !!String methodsFor: 'internet' stamp: 'JO 9/2/2002 11:59'!utf8ToIso	"Only UTF-8 characters that maps to 8-bit ISO-8559-1 values are converted. Others raises an error"	| s i c v c2 v2 |	s _ WriteStream on: (String new: self size).		i _ 1.	[i <= self size] whileTrue: [		c _ self at: i. i_i+1.		v _ c asciiValue.		(v > 128)			ifFalse: [ s nextPut: c ]			ifTrue: [((v bitAnd: 252) == 192)				ifFalse: [self error: 'illegal UTF-8 ISO character']				ifTrue: [					(i > self size) ifTrue: [ self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].					c2 _ self at: i. i_i+1.					v2 _ c2 asciiValue.					((v2 bitAnd: 192) = 128) ifFalse: [self error: 'illegal 2nd UTF-8 char']. 					s nextPut: ((v2 bitAnd: 63) bitOr: ((v << 6) bitAnd: 192)) asCharacter]]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:17'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr _ Character cr.	lf _ Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'ls 10/27/1998 00:52'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf input c crlf inPos outPos outString lineEndPos newOutPos |	cr _ Character cr.	lf _ Character linefeed.	crlf _ CharacterSet new.	crlf add: cr; add: lf.	inPos _ 1.	outPos _ 1.	outString _ String new: self size.	[ lineEndPos _ self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos _ outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos _ newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos _ lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos _ lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos _ outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !!String methodsFor: 'internet' stamp: 'ls 7/1/1998 02:26'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote _ self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'testing' stamp: 'RAA 6/21/1999 11:28'!hasContentsInExplorer	^false! !!String methodsFor: 'testing' stamp: 'djp 10/26/1999 21:25'!isAllDigits	"whether the receiver is composed entirely of digits"	self do: [:c | c isDigit ifFalse: [^ false]].	^ true! !!String methodsFor: 'testing' stamp: 'ls 7/4/1998 19:17'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'testing' stamp: 'sma 6/15/2000 15:48'!isString	^ true! !!String methodsFor: 'testing' stamp: 'sw 11/5/1998 17:41'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: 'paragraph support' stamp: 'RAA 8/30/1998 15:20'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	reader _ ReadStream on: self.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = self size | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!* arg	^ arg adaptToString: self andSend: #*! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!+ arg	^ arg adaptToString: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!- arg	^ arg adaptToString: self andSend: #-! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!/ arg	^ arg adaptToString: self andSend: #/! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!// arg	^ arg adaptToString: self andSend: #//! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!\\ arg	^ arg adaptToString: self andSend: #\\! !!String methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:17'!byteEncode:aStream	^aStream writeString:self.! !!String methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 23:02'!putOn:aStream	^aStream nextPutAll:self.! !!String methodsFor: 'encoding' stamp: 'RAA 7/22/2000 08:52'!getInteger32: location	| integer |	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	"^IntegerPokerPlugin doPrimitive: #getInteger"	"the following is about 7x faster than interpreting the plugin if not compiled"	integer := 		((self byteAt: location) bitShift: 24) +		((self byteAt: location+1) bitShift: 16) +		((self byteAt: location+2) bitShift: 8) +		(self byteAt: location+3).	integer > 1073741824 ifTrue: [		^1073741824 - integer ].	^integer! !!String methodsFor: 'encoding' stamp: 'RAA 7/31/2000 16:06'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER _ PUTCOUNTER + 1."	integer _ anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self byteAt: location+3 put: (integer \\ 256).	self byteAt: location+2 put: (integer bitShift: -8) \\ 256.	self byteAt: location+1 put: (integer bitShift: -16) \\ 256.	self byteAt: location put: (integer bitShift: -24) \\ 256."Smalltalk at: #PUTCOUNTER put: 0"! !!String methodsFor: 'user interface' stamp: 'ajh 9/25/2002 13:10'!asExplorerString	^ self printString! !!String methodsFor: 'user interface' stamp: 'sw 8/10/2001 10:41'!openInWorkspaceWithTitle: aTitle	"Open up a workspace with the receiver as its contents, with the given title"	(Workspace new contents: self) openLabel: aTitle! !!String methodsFor: 'Camp Smalltalk' stamp: 'jp 3/17/2003 10:04'!sunitAsSymbol
 
        ^self asSymbol! !!String methodsFor: 'Camp Smalltalk' stamp: 'jp 3/17/2003 10:04'!sunitMatch: aString
 
        ^self match: aString! !!String methodsFor: 'Camp Smalltalk' stamp: 'jp 3/17/2003 10:04'!sunitSubStrings
 
        ^self substrings! !!String methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:13'!escapeEntities	^ String streamContents: [:s | self do: [:c | s nextPutAll: c escapeEntities]]! !!String methodsFor: 'translating' stamp: 'BG 8/18/2004 15:12'!translated	"answer the receiver translated to the default language"	^self! !!String methodsFor: 'formatting' stamp: 'dgd 8/27/2003 19:49'!format: aCollection 	"format the receiver with aCollection  	 	simplest example:  	'foo {1} bar' format: {Date today}.	 	complete example:  	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.  	"	| result stream |	result := String new writeStream.	stream := self readStream.	[stream atEnd]		whileFalse: [| currentChar | 			currentChar := stream next.			currentChar == ${				ifTrue: [| expression | 					expression := self getEnclosedExpressionFrom: stream.					result						nextPutAll: (self evaluateExpression: expression parameters: aCollection)]				ifFalse: [					currentChar == $\						ifTrue: [stream atEnd								ifFalse: [result nextPut: stream next]]						ifFalse: [result nextPut: currentChar]]].	^ result contents! !!String methodsFor: '*versionnumber' stamp: 'svp 6/18/2002 16:12'!asVersion
	"Answer a VersionNumber"

	^VersionNumber fromString: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!String class	instanceVariableNames: ''!!String class methodsFor: 'instance creation' stamp: 'jm 5/6/1998 18:39'!cr	"Answer a string containing a single carriage return character."	^ self with: Character cr! !!String class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 22:29'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'instance creation' stamp: 'ar 8/17/2001 18:19'!crlfcrlf	^self crlf , self crlf.! !!String class methodsFor: 'instance creation'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s |	s _ self new: 4.	s at: 1 put: (aLong digitAt: 4) asCharacter.	s at: 2 put: (aLong digitAt: 3) asCharacter.	s at: 3 put: (aLong digitAt: 2) asCharacter.	s at: 4 put: (aLong digitAt: 1) asCharacter.	^s"String fromPacked: 'TEXT' asPacked"! !!String class methodsFor: 'instance creation' stamp: 'di 1/14/98 10:26'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."		^ aString copyFrom: 1 to: aString size! !!String class methodsFor: 'instance creation' stamp: 'ar 3/15/2001 22:47'!lf	"Answer a string containing a single carriage return character."	^ self with: Character lf! !!String class methodsFor: 'instance creation'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| outStream char done |	outStream _ WriteStream on: (String new: 16).	"go to first quote"	inStream skipTo: $'.	done _ false.	[done or: [inStream atEnd]]		whileFalse: 			[char _ inStream next.			char = $'				ifTrue: 					[char _ inStream next.					char = $'						ifTrue: [outStream nextPut: char]						ifFalse: [done _ true]]				ifFalse: [outStream nextPut: char]].	^outStream contents! !!String class methodsFor: 'instance creation' stamp: 'sw 6/15/1999 22:59'!tab	"Answer a string containing a single tab character."	^ self with: Character tab! !!String class methodsFor: 'instance creation' stamp: 'ar 12/17/2001 01:24'!value: anInteger	^self with: (Character value: anInteger)! !!String class methodsFor: 'examples'!example	"To see the string displayed at the cursor point, execute this expression	and select a point by pressing a mouse button."	'this is some text' displayOn: Display at: Sensor waitButton! !!String class methodsFor: 'initialization' stamp: 'di 12/3/2000 09:06'!initialize   "String initialize"	| order |	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder _ ByteArray new: 256 withAll: 255.	order _ -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order _ order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable _ String withAll: (Character allCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable _ String withAll: (Character allCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish _ String withAll: (Character allCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!String class methodsFor: 'initialization' stamp: 'CdG 1/8/2004 15:17'!initializeHtmlEntities	"String initializeHtmlEntities"	HtmlEntities _ (Dictionary new: 128)		at: 'amp'	put: $&;		at: 'lt'		put: $<;		at: 'gt'		put: $>;		at: 'quot'	put: $";		at: 'euro'	put: Character euro;		yourself.	#('nbsp' 'iexcl' 'cent' 'pound' 'curren' 'yen' 'brvbar' 'sect' 'uml' 'copy' 'ordf' 'laquo' 'not' 'shy' 'reg' 'hibar' 'deg' 'plusmn' 'sup2' 'sup3' 'acute' 'micro' 'para' 'middot' 'cedil' 'sup1' 'ordm' 'raquo' 'frac14' 'frac12' 'frac34' 'iquest' 'Agrave' 'Aacute' 'Acirc' 'Atilde' 'Auml' 'Aring' 'AElig' 'Ccedil' 'Egrave' 'Eacute' 'Ecirc' 'Euml' 'Igrave' 'Iacute' 'Icirc' 'Iuml' 'ETH' 'Ntilde' 'Ograve' 'Oacute' 'Ocirc' 'Otilde' 'Ouml' 'times' 'Oslash' 'Ugrave' 'Uacute' 'Ucirc' 'Uuml' 'Yacute' 'THORN' 'szlig' 'agrave' 'aacute' 'acirc' 'atilde' 'auml' 'aring' 'aelig' 'ccedil' 'egrave' 'eacute' 'ecirc' 'euml' 'igrave' 'iacute' 'icirc' 'iuml' 'eth' 'ntilde' 'ograve' 'oacute' 'ocirc' 'otilde' 'ouml' 'divide' 'oslash' 'ugrave' 'uacute' 'ucirc' 'uuml' 'yacute' 'thorn' 'yuml' ) withIndexDo: [:each :index | 		"filter out base characters CdG 1/8/2004 15:17"		| char |		char _ (index + 159) asCharacter isoToSqueak. 		char >= (Character value: 128) ifTrue: [			HtmlEntities at: each put: char]]! !!String class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:12'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i _ start.	stringSize _ aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i _ i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!String class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:13'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'ar 9/28/2001 04:35'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize _ aString size.	hash _ speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash _ hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low _ hash bitAnd: 16383.		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!String class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:12'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned char *aString'.	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!String class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 00:21'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isBytes')! !!String class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:10'!ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString! !Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!StringHolder commentStamp: '<historical>' prior: 0!I am a kind of Model that includes a piece of text.  In some cases, the text can be edited, and in some the text is a method.Categories 'code pane menu' and 'message list menu' are messages that may be called by my menus when the text is a method, and when some pane is a list of methods.  Other of my subclasses may ignore these two catagories altogether.!!StringHolder methodsFor: 'initialize-release'!defaultContents	^''! !!StringHolder methodsFor: 'initialize-release' stamp: 'jm 3/24/98 17:56'!initialize	"Initialize the state of the receiver with its default contents."	contents _ self defaultContents.! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 12/22/1998 00:16'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	self openLabel: aString andTerminate: true! !!StringHolder methodsFor: 'initialize-release' stamp: 'BG 10/28/2003 20:43'!openLabel: aString andTerminate: terminateBoolean	"Create a standard system view of the model, me, a StringHolder and open it.; do not terminate the active process if in mvc"	| topView codeView |	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self 			text: #contents accept: #acceptContents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	"self contents size > 0 ifTrue: [			codeView hasUnacceptedEdits: true].  Is it already saved or not??"	terminateBoolean		ifTrue:			[topView controller open]		ifFalse:			[topView controller openNoTerminate]! !!StringHolder methodsFor: 'accessing' stamp: 'di 5/19/1998 15:34'!acceptContents: aString 	"Set aString to be the contents of the receiver.  Return true cuz happy"	self contents: aString.	^ true! !!StringHolder methodsFor: 'accessing'!contents	"Answer the contents that the receiver is holding--presumably a string."	^contents! !!StringHolder methodsFor: 'accessing' stamp: 'sw 1/12/1999 11:47'!contents: textOrString 	"Set textOrString to be the contents of the receiver."	contents _ textOrString "asString"! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/3/98 22:50'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/9/2000 23:59'!noteAcceptanceOfCodeFor: aSelector	"A method has possibly been submitted for the receiver with aSelector as its selector; If the receiver wishes to take soem action here is a chance for it to do so"! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/1/2000 11:04'!reformulateList	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/6/2000 17:48'!reformulateListNoting: newSelector	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"	^ self reformulateList! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 14:59'!selectedClassName	"I may know what class is currently selected"	self selectedClass ifNotNil: [^ self selectedClass name].	^ nil! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:01'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:22'!selectedMessageName	^ nil! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents _ aStringOrText! !!StringHolder methodsFor: 'code pane menu' stamp: 'sw 11/8/1999 17:56'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu _ shifted		ifTrue:			[ParagraphEditor shiftedYellowButtonMenu]		ifFalse:			[ParagraphEditor yellowButtonMenu].	^ aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'code pane menu' stamp: 'tk 4/6/98 11:43'!showBytecodes	"We don't know how to do this"	^ self changed: #flash! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 9/7/1999 11:27'!spawn: contentsString	(Workspace new contents: contentsString) openLabel: 'Workspace'! !!StringHolder methodsFor: 'evaluation'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!StringHolder methodsFor: 'evaluation'!doItReceiver	"Answer the object that should be informed of the result of evaluating a 	text selection."	^nil! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/15/2003 22:46'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aClass aName method filteredList |	(aName _ self selectedMessageName) ifNotNil: [		method _ (aClass _ self selectedClassOrMetaClass) compiledMethodAt: aName.		filteredList _ method messages reject: 			[:each | #(new initialize = ) includes: each].		self systemNavigation browseAllImplementorsOfList: filteredList asSortedCollection			 title: 'All messages sent in ', aClass name, '.', aName]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 16:11'!browseClass	"Open an class browser on this class and method"	self selectedClassOrMetaClass ifNotNil: [		Browser newOnClass: self selectedClassOrMetaClass 			selector: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'tpr 12/17/2003 15:43'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		self systemNavigation browseAllCallsOnClass: cls theNonMetaClass]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/15/2003 16:11'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	cls _ self selectedClass.	cls ifNotNil: [self systemNavigation  browseClassVarRefs: cls]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/15/2003 16:11'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls _ self selectedClass.	cls		ifNotNil: [self systemNavigation  browseClassVariables: cls]! !!StringHolder methodsFor: 'message list menu' stamp: 'RAA 5/28/2001 11:09'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	| aClass |	(Smalltalk isMorphic and: [Smalltalk includesKey: #Lexicon]) ifFalse: [^ self spawnFullProtocol].	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(Smalltalk at: #Lexicon) new openOnClass: aClass inWorld: ActiveWorld showingSelector: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 19:42'!browseInstVarDefs 	| cls |	(cls _ self selectedClassOrMetaClass) ifNotNil: [self systemNavigation browseInstVarDefs: cls]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/15/2003 16:11'!browseInstVarRefs	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	cls _ self selectedClassOrMetaClass.	cls		ifNotNil: [self systemNavigation  browseInstVarRefs: cls]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 08:42'!browseLocalImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:localTo:		to: self systemNavigation		with: { self selectedClass }! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 20:41'!browseLocalSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all implementors	of the message chosen in or below the selected class"	self getSelectorAndSendQuery: #browseAllCallsOn:localTo:		to: self systemNavigation		with: { self selectedClass }! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 08:45'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf: to: self systemNavigation! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 09:28'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 20:40'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self getSelectorAndSendQuery: #browseAllCallsOn: to: self systemNavigation! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/29/2003 20:20'!browseUnusedMethods	| classes unsent messageList cls |	(cls _ self selectedClass)		ifNil: [^ self].	classes _ Array with: cls with: cls class.	unsent _ Set new.	classes		do: [:c | unsent addAll: c selectors].	unsent _ self systemNavigation allUnSentMessagesIn: unsent.	messageList _ OrderedCollection new.	classes		do: [:c | (c selectors				select: [:s | unsent includes: s]) asSortedCollection				do: [:sel | messageList add: c name , ' ' , sel]].	self systemNavigation browseMessageList: messageList name: 'Unsent Methods in ' , cls name! !!StringHolder methodsFor: 'message list menu' stamp: 'nk 1/7/2004 10:20'!browseVersions	"Create and schedule a Versions Browser, showing all versions of the 	currently selected message. Answer the browser or nil."	| selector class | 	(selector _ self selectedMessageName)		ifNil:[ self inform: 'Sorry, only actual methods have retrievable versions.'. ^nil ]		ifNotNil: [(MessageSet isPseudoSelector: selector)				ifTrue: ["Eliminates Definition and Hierarchy"					^ self classCommentIndicated						ifTrue: [ ClassCommentVersionsBrowser browseCommentOf: self selectedClass. nil ]].			class _ self selectedClassOrMetaClass.			^VersionsBrowser				browseVersionsOf: (class compiledMethodAt: selector)				class: self selectedClass				meta: class isMeta				category: (class organization categoryOfElement: selector)				selector: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 19:14'!buildMessageBrowser	"Create and schedule a message browser."	self selectedMessageName ifNil: [^ self].	Browser openMessageBrowserForClass: self selectedClassOrMetaClass 		selector: self selectedMessageName editString: nil! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 1/16/2004 21:14'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	self systemNavigation		spawnHierarchyForClass: self selectedClassOrMetaClass "OK if nil"		selector: self selectedMessageName! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 5/8/2000 02:16'!classListKey: aChar from: view 	"Respond to a Command key.  I am a model with a list of classes and a 	code pane, and I also have a listView that has a list of methods.  The 	view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findMethod].	aChar == $r ifTrue: [^ self recent].	aChar == $h ifTrue: [^ self spawnHierarchy].	aChar == $x ifTrue: [^ self removeClass].	^ self messageListKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'ar 1/15/2001 18:39'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString asText]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 8/5/2002 16:53'!copySelector	"Copy the selected selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 7/1/2001 08:24'!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!StringHolder methodsFor: 'message list menu' stamp: 'di 5/6/1998 17:03'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName _ self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 09:23'!inspectInstances	"Inspect all instances of the selected class."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[myClass theNonMetaClass inspectAllInstances]. ! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 09:00'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil: [		aClass theNonMetaClass inspectSubInstances].! !!StringHolder methodsFor: 'message list menu' stamp: 'nb 6/17/2003 12:25'!makeIsolatedCodePane	| msgName |	(msgName _ self selectedMessageName) ifNil: [^ Beeper beep].	MethodHolder makeIsolatedCodePaneForClass: self selectedClassOrMetaClass selector: msgName! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 08:45'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel _ self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: self systemNavigation].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: self systemNavigation].	"The following require a class selection"	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage]].	^ self arrowKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 12/28/2000 11:49'!messageListSelectorTitle	| selector aString aStamp aSize |	(selector _ self selectedMessageName)		ifNil:			[aSize _ self messageList size.			^ (aSize == 0 ifTrue: ['no'] ifFalse: [aSize printString]), ' message', (aSize == 1 ifTrue: [''] ifFalse: ['s'])]		ifNotNil:			[Preferences timeStampsInMenuTitles				ifFalse:	[^ nil].			aString _ selector truncateWithElipsisTo: 28.			^ (aStamp _ self timeStamp) size > 0				ifTrue:					[aString, String cr, aStamp]				ifFalse:					[aString]]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 1/16/2004 21:10'!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	self systemNavigation 			methodHierarchyBrowserForClass: self selectedClassOrMetaClass 			selector: self selectedMessageName! !!StringHolder methodsFor: 'message list menu' stamp: 'BG 10/29/2003 09:40'!offerMenuFrom: menuRetriever shifted: aBoolean	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	Smalltalk isMorphic		ifTrue:			[]		ifFalse:			[aMenu _ CustomMenu new.			self perform: menuRetriever with: aMenu with: aBoolean.			aMenu invokeOn: self]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/16/2003 08:52'!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName _ self selectedMessageName) ifNil: [^ self].	mr _ MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	self systemNavigation 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!StringHolder methodsFor: 'message list menu' stamp: 'RAA 12/10/1999 09:36'!packageListKey: aChar from: view	"Respond to a Command key in the package pane in the PackageBrowser"	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 18:16'!printOutMessage	"Write a file with the text of the selected message, for printing by a web browser"	self selectedMessageName ifNotNil: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName							asHtml: true]! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 5/23/2003 14:42'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotation! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/28/1999 12:34'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self contentsChanged! !!StringHolder methodsFor: 'message list menu' stamp: 'nb 6/17/2003 12:25'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Beeper beep].	changeRecords second fileIn.	self contentsChanged! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 4/15/2003 16:11'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages _ method messages) size == 0])		 ifTrue: [^ aBlock value: selector].	(messages size == 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	self systemNavigation 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!StringHolder methodsFor: 'message list menu' stamp: 'nk 11/15/2002 12:23'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findClass].	aChar == $x ifTrue: [^ self removeSystemCategory].	^ self classListKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 12/6/2000 21:01'!timeStamp	"Answer the time stamp for the chosen class and method, if any, else an empty string"	|  selector  aMethod |	(selector _ self selectedMessageName) ifNotNil:		[self selectedClassOrMetaClass 			ifNil:				[^ String new]			ifNotNil:				[aMethod _ self selectedClassOrMetaClass compiledMethodAt: selector ifAbsent: [nil].				aMethod ifNotNil: [^ Utilities timeStampForMethod: aMethod]]].	^ String new! !!StringHolder methodsFor: 'optional panes' stamp: 'sw 1/24/2001 21:25'!wantsAnnotationPane	"Answer whether the receiver, seen in some browser window, would like to have the so-called  annotationpane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences annotationPanes! !!StringHolder methodsFor: 'optional panes' stamp: 'sw 1/24/2001 18:57'!wantsOptionalButtons	"Answer whether the receiver, seen in some browser window, would like to have the so-called optional button pane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences optionalButtons! !!StringHolder methodsFor: 'user edits' stamp: 'di 4/21/1998 11:30'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!StringHolder methodsFor: 'user edits' stamp: 'tk 4/13/1998 23:07'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringHolder class	instanceVariableNames: ''!!StringHolder class methodsFor: 'class initialization'!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace _ StringHolder new"	"StringHolder initialize"! !!StringHolder class methodsFor: 'instance creation' stamp: 'tk 5/4/1998 17:32'!open	(Smalltalk at: #Workspace) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!StringHolder class methodsFor: 'instance creation' stamp: 'tk 5/4/1998 16:41'!openLabel: aString	self new openLabel: aString! !ParagraphEditor subclass: #StringHolderController	instanceVariableNames: ''	classVariableNames: 'CodeYellowButtonMenu CodeYellowButtonMessages'	poolDictionaries: ''	category: 'ST80-Support'!!StringHolderController commentStamp: '<historical>' prior: 0!I represent a ParagraphEditor for a single paragraph of text, omitting alignment commands. I provide items in the yellow button menu so that the text selection can be evaluated and so that the contents of the model can be stored or restored.	doIt	evaluate the text selection as an expression	printIt	same as doIt but insert a description of the result after the selection	accept	store the contents of the StringHolder into the model	cancel	store the contents of the model into the StringHolder!!StringHolderController methodsFor: 'accessing' stamp: 'di 6/21/2001 10:32'!changeText: aText	"The paragraph to be edited is changed to aText."	paragraph text: aText.	self resetState.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self selectAndScroll.	self deselect! !!StringHolderController methodsFor: 'accessing'!model: aModel	super model: aModel.	view displayContents == nil		ifFalse: [self changeParagraph: view displayContents]! !!StringHolderController methodsFor: 'edit flag' stamp: 'di 10/9/1998 15:41'!hasUnacceptedEdits: aBoolean	^ view hasUnacceptedEdits: aBoolean! !!StringHolderController methodsFor: 'edit flag' stamp: 'tk 4/13/1998 23:09'!userHasEdited	"Note that the user has edited my text."	view hasUnacceptedEdits: true! !!StringHolderController methodsFor: 'edit flag' stamp: 'tk 4/13/1998 23:08'!userHasNotEdited	"Note that my text is free of user edits."	model clearUserEditFlag! !!StringHolderController methodsFor: 'menu messages' stamp: 'jm 3/18/98 20:53'!accept 	"Refer to the comment in ParagraphEditor|accept."	super accept.	model contents: paragraph string.	self userHasNotEdited.! !!StringHolderController methodsFor: 'menu messages' stamp: 'jm 3/18/98 20:54'!cancel 	"Refer to the comment in ParagraphEditor|cancel."	super cancel.	self userHasNotEdited.! !!StringHolderController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:14'!performMenuMessage: aSelector	"Intercept #again so the model does not get locked by keying the search text."	| hadEdits |	hadEdits _ view canDiscardEdits not.	super performMenuMessage: aSelector.	(hadEdits not and:	 [aSelector == #again and:	 [(UndoMessage sends: #undoAgain:andReselect:typedKey:) and:	 [UndoMessage arguments at: 3]]])		ifTrue: [self userHasNotEdited].! !!StringHolderController methodsFor: 'compiler access'!bindingOf: aString	^model bindingOf: aString! !!StringHolderController methodsFor: 'private' stamp: 'jm 3/18/98 20:43'!closeTypeIn	"Note edit if something actually was typed."	beginTypeInBlock ~~ nil ifTrue: [self userHasEdited].	super closeTypeIn.! !!StringHolderController methodsFor: 'private' stamp: 'jm 3/18/98 20:45'!zapSelectionWith: aText	"Note edit except during typeIn, which notes edits at close."	super zapSelectionWith: aText.	beginTypeInBlock == nil ifTrue: [self userHasEdited].! !View subclass: #StringHolderView	instanceVariableNames: 'displayContents hasUnacceptedEdits askBeforeDiscardingEdits'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Support'!!StringHolderView commentStamp: '<historical>' prior: 0!I am a View of a String that is an aspect of a more structured object. This String should not be changed by any editing unless the user issues the accept command. Thus my instances provide a working copy of the String. This copy is edited. When the user issues the accept command, the String is copied from the working version; or if the user issues the cancel command, the working version is restored from the String. StringHolderController is my default controller. It is initialized specially by passing the string viewed which is then converted to a Paragraph for editing.!!StringHolderView methodsFor: 'initialize-release' stamp: 'jm 3/24/98 14:39'!initialize 	"Refer to the comment in View|initialize."	super initialize.	displayContents _ '' asParagraph.	hasUnacceptedEdits _ false.	askBeforeDiscardingEdits _ true.! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 14:38'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 22:58'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 17:49'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 17:17'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value."	hasUnacceptedEdits _ aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'dgd 9/21/2003 17:42'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated) ifTrue: [model clearUserEditFlag].		^ self].	stripes _ (Form extent: 16@16 fromStipple: 16r36C9) bits.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel _ self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !!StringHolderView methodsFor: 'updating' stamp: 'di 4/21/1998 11:30'!update: aSymbol	"Refer to the comment in View|update:."	aSymbol == #wantToChange ifTrue: [^ self promptForCancel].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #flash ifTrue: [^ controller flash].	self updateDisplayContents! !!StringHolderView methodsFor: 'updating'!updateDisplayContents	"Make the text that is displayed be the contents of the receiver's model."	self editString: model contents.	self displayView! !!StringHolderView methodsFor: 'controller access'!defaultController 	"Refer to the comment in View|defaultController."	^self defaultControllerClass newParagraph: displayContents! !!StringHolderView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^StringHolderController! !!StringHolderView methodsFor: 'controller access'!displayContents	^displayContents! !!StringHolderView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self insetDisplayBox ~= displayContents clippingRectangle])		ifTrue:  "Recompose the text if the window changed"				[self positionDisplayContents. 				(self controller isKindOf: ParagraphEditor)					ifTrue: [controller recomputeSelection]].	super display! !!StringHolderView methodsFor: 'displaying' stamp: 'hmm 6/18/2000 19:24'!displayView 	"Refer to the comment in View|displayView."	Display deferUpdatesIn: self displayBox while: [		self clearInside.		(self controller isKindOf: ParagraphEditor)			ifTrue: [controller display]			ifFalse: [displayContents display]]! !!StringHolderView methodsFor: 'displaying'!lock	"Refer to the comment in view|lock.  Must do at least what display would do to lock the view."	(self isUnlocked and: [self insetDisplayBox ~= displayContents clippingRectangle])		ifTrue:  "Recompose the text if the window changed"				[self positionDisplayContents. 				(self controller isKindOf: ParagraphEditor)					ifTrue: [controller recomputeSelection]].	super lock! !!StringHolderView methodsFor: 'displaying'!positionDisplayContents	"Presumably the text being displayed changed so that the wrapping box 	and clipping box should be reset."	displayContents 		wrappingBox: (self insetDisplayBox insetBy: 6 @ 0)		clippingBox: self insetDisplayBox! !!StringHolderView methodsFor: 'model access'!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	displayContents _ Paragraph withText: aString asText		style: TextStyle default copy		compositionRectangle: (self insetDisplayBox insetBy: 6 @ 0)		clippingRectangle: self insetDisplayBox		foreColor: self foregroundColor backColor: self backgroundColor.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !!StringHolderView methodsFor: 'model access' stamp: 'sma 5/28/2000 23:25'!getMenu: shiftKeyState	^ nil! !!StringHolderView methodsFor: 'model access'!model: aLockedModel 	"Refer to the comment in View|model:." 	super model: aLockedModel.	self editString: model contents! !!StringHolderView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	(self controller isKindOf: ParagraphEditor)	 	ifTrue: [controller deselect]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringHolderView class	instanceVariableNames: ''!!StringHolderView class methodsFor: 'instance creation'!container	"Answer an instance of me with a new instance of StringHolder as the 	model."	^self container: StringHolder new! !!StringHolderView class methodsFor: 'instance creation'!container: aContainer 	"Answer an instance of me whose model is aContainer. Give it a 2-dot 	border."	| aCodeView |	aCodeView _ self new model: aContainer.	aCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	^aCodeView! !!StringHolderView class methodsFor: 'instance creation'!open	"Create a standard system view of a workspace on the screen."	self open: Workspace new label: 'Workspace'! !!StringHolderView class methodsFor: 'instance creation'!open: aStringHolder 	"Create a standard system view of the argument, aStringHolder, as viewed 	by an instance of me. The view has label 'StringHolder'."	self open: aStringHolder label: 'StringHolder'! !!StringHolderView class methodsFor: 'instance creation' stamp: 'BG 10/28/2003 20:43'!open: aStringHolder label: labelString 	"NOTE this should be in the model class, and all senders so redirected,	in order that the view class can be discarded in a morphic world."	"Create a standard system view of the model, aStringHolder, as viewed by 	an instance of me. The label of the view is aString."	| aStringHolderView topView |	aStringHolderView _ self container: aStringHolder.	topView _ StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: labelString.	topView minimumSize: 100 @ 50.	topView controller open! !Model subclass: #Switch	instanceVariableNames: 'on onAction offAction'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!Switch commentStamp: '<historical>' prior: 0!I represent a selection setting and actions to take depending on a change in the setting. An instance has three attributes: state, which is either on or off; on action; and off action. The on and off actions are blocks of code that execute whenever the instance changes state. I am typically used as a menu item in conjunction with a SwitchView and a SwitchController.1/24/96 sw: made this a subclass of Model, for faster dependents handling!!Switch methodsFor: 'state'!clear	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent. The receiver's off action is 	NOT executed."	self isOn		ifTrue: 			[on _ false.			self changed]! !!Switch methodsFor: 'state'!isOff	"Answer whether the receiver is set off or not."	^on not! !!Switch methodsFor: 'state'!isOn	"Answer whether the receiver is set on or not."	^on! !!Switch methodsFor: 'state'!set	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent. The receiver's on action is 	NOT executed."	self isOff		ifTrue: 			[on _ true.			self changed]! !!Switch methodsFor: 'state'!switch	"Change the state of the receiver from 'on' to 'off' or from 'off' to 'on' (see 	Switch|turnOn, Switch|turnOff)."	self isOn		ifTrue: [self turnOff]		ifFalse: [self turnOn]! !!Switch methodsFor: 'state'!turnOff	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent and the receiver's off action is 	executed."	self isOn		ifTrue: 			[on _ false.			self changed.			self doAction: offAction]! !!Switch methodsFor: 'state'!turnOn	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent and the receiver's on action is 	executed."	self isOff		ifTrue: 			[on _ true.			self changed.			self doAction: onAction]! !!Switch methodsFor: 'action'!doAction: anAction 	"Execute anAction if it is non-nil."	anAction == nil ifFalse: [anAction value]! !!Switch methodsFor: 'action'!offAction: anAction 	"Set the off action of the receiver to anAction."	offAction _ anAction fixTemps! !!Switch methodsFor: 'action'!onAction: anAction 	"Set the on action of the receiver to anAction."	onAction _ anAction fixTemps! !!Switch methodsFor: 'private'!initializeOff	on _ false. 	onAction _ nil.	offAction _ nil! !!Switch methodsFor: 'private'!initializeOn	on _ true. 	onAction _ nil.	offAction _ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Switch class	instanceVariableNames: ''!!Switch class methodsFor: 'instance creation'!new	"Answer an instance of me such that the on and off actions are set to nil	('no action'), and the state is set to 'off'."	^self newOff! !!Switch class methodsFor: 'instance creation'!newOff	"Answer an instance of me such that the on and off actions are set to nil 	('no action'), and the state is set to 'off'."	^super new initializeOff! !!Switch class methodsFor: 'instance creation'!newOn	"Answer an instance of me such that the on and off actions are set to nil 	('no action'), and the state is set to 'on'."	^super new initializeOn! !String variableByteSubclass: #Symbol	instanceVariableNames: ''	classVariableNames: 'NewSymbols OneCharacterSymbols SymbolTable'	poolDictionaries: ''	category: 'Collections-Text'!!Symbol commentStamp: '<historical>' prior: 0!I represent Strings that are created uniquely. Thus, someString asSymbol == someString asSymbol.!!Symbol methodsFor: 'accessing'!at: anInteger put: anObject 	"You cannot modify the receiver."	self errorNoModification! !!Symbol methodsFor: 'accessing' stamp: 'sma 2/5/2000 12:32'!precedence	"Answer the receiver's precedence, assuming it is a valid Smalltalk	message selector or 0 otherwise.  The numbers are 1 for unary,	2 for binary and 3 for keyword selectors."	self size = 0 ifTrue: [^ 0].	self first isLetter ifFalse: [^ 2].	self last = $: ifTrue: [^ 3].	^ 1! !!Symbol methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart	self errorNoModification! !!Symbol methodsFor: 'comparing' stamp: 'di 4/11/2000 16:18'!= another	"Use == between two symbols..."	self == another ifTrue: [^ true].  "Was == "	another class == Symbol ifTrue: [^ false].  "Was not == "	"Otherwise use string =..."	^ super = another! !!Symbol methodsFor: 'comparing' stamp: 'pm 9/23/97 09:36'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying'!copy	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying'!shallowCopy	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Symbol methodsFor: 'converting'!asString 	"Refer to the comment in String|asString."	| newString |	newString _ String new: self size.	1 to: self size do: [:index | newString at: index put: (self at: index)].	^newString! !!Symbol methodsFor: 'converting'!asSymbol 	"Refer to the comment in String|asSymbol."! !!Symbol methodsFor: 'converting' stamp: 'sw 1/28/98 18:18'!capitalized	^ self asString capitalized asSymbol! !!Symbol methodsFor: 'printing' stamp: 'sw 8/19/1999 11:30'!isOrientedFill	"Needs to be implemented here because symbols can occupy 'color' slots of morphs."	^ false! !!Symbol methodsFor: 'printing' stamp: 'di 4/25/2000 12:32'!storeOn: aStream 	aStream nextPut: $#.	(Scanner isLiteralSymbol: self)		ifTrue: [aStream nextPutAll: self]		ifFalse: [super storeOn: aStream]! !!Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of the two selective flush methods needs to be used.	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 119>! !!Symbol methodsFor: 'private'!errorNoModification	self error: 'symbols can not be modified.'! !!Symbol methodsFor: 'private'!species	^String! !!Symbol methodsFor: 'private'!string: aString	1 to: aString size do: [:j | super at: j put: (aString at: j)].	^self  ! !!Symbol methodsFor: 'private'!stringhash	^super hash! !!Symbol methodsFor: 'filter streaming' stamp: 'mpw 1/1/1901 00:20'!byteEncode:aStream	^aStream writeSymbol:self.! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:32'!isInfix	"Answer whether the receiver is an infix message selector."	^ self precedence == 2! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:34'!isKeyword	"Answer whether the receiver is a message keyword."	^ self precedence == 3! !!Symbol methodsFor: 'testing' stamp: 'di 4/25/2000 12:32'!isLiteral	"Answer whether the receiver is a valid Smalltalk literal."	^ true! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:13'!isPvtSelector	"Answer whether the receiver is a private message selector, that is,	begins with 'pvt' followed by an uppercase letter, e.g. pvtStringhash."	^ (self beginsWith: 'pvt') and: [self size >= 4 and: [(self at: 4) isUppercase]]! !!Symbol methodsFor: 'testing' stamp: 'md 4/30/2003 15:31'!isSymbol	^ true ! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:34'!isUnary	"Answer whether the receiver is an unary message selector."	^ self precedence == 1! !!Symbol methodsFor: 'user interface' stamp: 'sma 11/12/2000 11:46'!asExplorerString	^ self printString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Symbol class	instanceVariableNames: ''!!Symbol class methodsFor: 'access' stamp: 'RAA 5/29/2001 14:34'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList _ OrderedCollection new.	(size _ aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii _ aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	aString first isLetter ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList _ selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'RAA 5/29/2001 14:35'!thatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol that starts with leadingCharacters.	Symbols beginning with a lower-case letter handled directly here.	Ignore case after first char.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Alt-q (Command-q) routines"	| size firstMatch key |	size _ leadingCharacters size.	size = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].	firstMatch _ leadingCharacters at: 1.	size > 1 ifTrue: [key _ leadingCharacters copyFrom: 2 to: size].	self allSymbolTablesDo: [:each |			each size >= size ifTrue:				[					((each at: 1) == firstMatch and:						[key == nil or:							[(each findString: key startingAt: 2 caseSensitive: false) = 2]])								ifTrue: [^each]				]		] after: skipSym.	^nil"Symbol thatStarts: 'sf' skipping: nil""Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:""Symbol thatStarts: 'candidate' skipping: nil"! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 5/29/2001 08:21'!allSymbolTablesDo: aBlock	NewSymbols do: aBlock.	SymbolTable do: aBlock.! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 5/29/2001 14:35'!allSymbolTablesDo: aBlock after: aSymbol	NewSymbols do: aBlock after: aSymbol.	SymbolTable do: aBlock after: aSymbol.! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 12/17/2000 18:05'!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)"	| oldSize |	Smalltalk garbageCollect.	oldSize _ SymbolTable array size.	SymbolTable growTo: SymbolTable size * 4 // 3 + 100.	^oldSize printString,'  ',(oldSize - SymbolTable array size) printString, ' slot(s) reclaimed'! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 5/29/2001 09:04'!initialize	"Symbol initialize"	Symbol rehash.	OneCharacterSymbols _ nil.	OneCharacterSymbols _ (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].	Smalltalk addToShutDownList: self.! !!Symbol class methodsFor: 'instance creation' stamp: 'RAA 5/29/2001 08:10'!intern: aStringOrSymbol	^(self lookup: aStringOrSymbol)		ifNil:			[				NewSymbols add:					((aStringOrSymbol isKindOf: Symbol)						ifTrue: [aStringOrSymbol]						ifFalse: [(self new: aStringOrSymbol size) string: aStringOrSymbol])			]! !!Symbol class methodsFor: 'instance creation' stamp: 'raa 5/26/2001 09:54'!internCharacter: aCharacter	OneCharacterSymbols ifNil: [^self intern: aCharacter asString].	^OneCharacterSymbols at: aCharacter asciiValue + 1! !!Symbol class methodsFor: 'instance creation' stamp: 'RAA 5/29/2001 08:09'!lookup: aStringOrSymbol	^(SymbolTable like: aStringOrSymbol) ifNil: [		NewSymbols like: aStringOrSymbol	]! !!Symbol class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ (aCollection as: String) asSymbol"	Symbol newFrom: {$P. $e. $n}	{$P. $e. $n} as: Symbol"! !!Symbol class methodsFor: 'instance creation' stamp: 'di 10/11/1999 00:02'!readFrom: strm  "Symbol readFromString: '#abc'"	strm peek = $# ifFalse: [self error: 'Symbols must be introduced by #'].	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 08:23'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol), 	otherwise supply the symbol to symBlock and return true."	| symbol |	^(symbol _ self lookup: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol. true]! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 14:33'!possibleSelectorsFor: misspelled 	"Answer an ordered collection of possible corrections	for the misspelled selector in order of likelyhood"	| numArgs candidates lookupString best binary short long first ss |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].	first _ lookupString first.	short _ lookupString size - (lookupString size // 4 max: 3) max: 2.	long _ lookupString size + (lookupString size // 4 max: 3).	"First assemble candidates for detailed scoring"	candidates _ OrderedCollection new.	self allSymbolTablesDo: [:s | (((ss _ s size) >= short	"not too short"			and: [ss <= long			"not too long"					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"			and: [s numArgs = numArgs])	"and numArgs is the same"			ifTrue: [candidates add: s]].	"Then further prune these by correctAgainst:"	best _ lookupString correctAgainst: candidates.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].	^ best! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 08:01'!rehash		"Symbol rehash"	"Rebuild the hash table, reclaiming unreferenced Symbols."	SymbolTable _ WeakSet withAll: self allInstances.	NewSymbols _ WeakSet new.! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 09:04'!shutDown: aboutToQuit	SymbolTable addAll: NewSymbols.	NewSymbols _ WeakSet new.! !StringHolder subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger doitFlag'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!SyntaxError commentStamp: '<historical>' prior: 0!I represent syntax error report for syntax errors encountered when filing in class descriptions from a non-interactive source such as an external file. As a StringHolder, the string to be viewed is the method code or expression containing the error.The user may fix the error and accept the method to continue the fileIn.!!SyntaxError methodsFor: 'initialization' stamp: 'jm 5/3/1998 14:36'!category: aSymbol	"Record the message category of method being compiled. This is used when the user corrects the error and accepts."	category _ aSymbol.! !!SyntaxError methodsFor: 'initialization' stamp: 'tk 5/6/1999 13:28'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Scanner classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,`~`' asSet.	badChar _ aString detect: [:aChar | (types at: aChar asciiValue) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents _ badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SyntaxError methodsFor: 'message list' stamp: 'tk 4/19/1999 08:08'!list	"Answer an array of one element made up of the class name, message category, and message selector in which the syntax error was found. This is the single item in the message list of a view/browser on the receiver."	selector ifNil: [^ Array with: (class name, '  ', category, '  ', '<none>')].	^ Array with: (class name, '  ', category, '  ', selector)! !!SyntaxError methodsFor: 'message list' stamp: 'jm 5/3/1998 13:48'!listIndex	"There is always exactly one element in my list and it is always selected."	^ 1! !!SyntaxError methodsFor: 'menu' stamp: 'RAA 12/1/2000 14:24'!debug	"Show the stack of the process leading to this syntax editor, typically showing the stack of the compiler as called from fileIn."	debugger openFullNoSuspendLabel: 'Stack of the Syntax Error'.	Smalltalk isMorphic ifFalse: [Processor terminateActive].! !!SyntaxError methodsFor: 'menu' stamp: 'jm 5/3/1998 14:22'!listMenu: aMenu	^ aMenu labels:'proceeddebug calling processbrowse full'	lines: #()	selections: #(proceed debug browseMethodFull)! !!SyntaxError methodsFor: 'menu' stamp: 'di 5/5/1998 00:06'!proceed	"The user has has edited and presumably fixed the syntax error and the filein can now proceed."	debugger proceed: self topView.! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:36'!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	doitFlag	ifTrue: [Compiler new evaluate: aString in: nil to: nil						notifying: aController ifFail: [^ false]]	ifFalse: [(class compile: aString classified: category						notifying: aController) ifNil: [^ false]].	aController hasUnacceptedEdits: false.	self proceed! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:51'!notify: error at: location in: source	"Open a syntax error view, inserting the given error message into the given source at the given location. This message is sent to the 'requestor' when the parser or compiler finds a syntax error."	| aClass aString |	aClass _ thisContext sender receiver encoder classEncoding.	aString _		source contents			copyReplaceFrom: location			to: location - 1			with: error.	self setClass: aClass		code: aString		debugger: (Debugger context: thisContext)		doitFlag: false.	self class open: self.! !!SyntaxError methodsFor: 'text menu support' stamp: 'jm 5/3/1998 14:15'!selectedClass	"Answer the class in which the syntax error occurred."	^ class! !!SyntaxError methodsFor: 'text menu support' stamp: 'jm 5/3/1998 14:33'!selectedClassOrMetaClass	"Answer the class of the method being compiled."	^ class! !!SyntaxError methodsFor: 'text menu support' stamp: 'jm 5/3/1998 14:17'!selectedMessageName	"Answer the selector of the method being compiled."	^ selector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SyntaxError class	instanceVariableNames: ''!!SyntaxError class methodsFor: 'instance creation' stamp: 'di 5/6/1998 20:58'!buildMVCViewOn: aSyntaxError	"Answer an MVC view on the given SyntaxError."	| topView aListView aCodeView |	topView _ StandardSystemView new		model: aSyntaxError;		label: 'Syntax Error';		minimumSize: 380@220.	aListView _ PluggableListView on: aSyntaxError		list: #list		selected: #listIndex		changeSelected: nil		menu: #listMenu:.	aListView window: (0@0 extent: 380@20).	topView addSubView: aListView.	aCodeView _ PluggableTextView on: aSyntaxError		text: #contents		accept: #contents:notifying:		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	aCodeView window: (0@0 extent: 380@200).	topView addSubView: aCodeView below: aListView.	^ topView! !!SyntaxError class methodsFor: 'instance creation' stamp: 'BG 10/29/2003 08:05'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"		topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !Notification subclass: #SyntaxErrorNotification	instanceVariableNames: 'inClass code doitFlag debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Extensions'!!SyntaxErrorNotification methodsFor: 'accessing' stamp: 'LC 1/6/2002 13:50'!messageText	^ super messageText		ifNil: [messageText _ self syntaxError contents]! !!SyntaxErrorNotification methodsFor: 'accessing' stamp: 'LC 1/6/2002 13:44'!setClass: aClass code: codeString debugger: aDebugger doitFlag: aBoolean	inClass _ aClass.	code _ codeString.	debugger _ aDebugger.	doitFlag _ aBoolean ! !!SyntaxErrorNotification methodsFor: 'accessing' stamp: 'LC 1/6/2002 13:45'!syntaxError	^ SyntaxError new		setClass: inClass		code: code		debugger: debugger		doitFlag: doitFlag! !!SyntaxErrorNotification methodsFor: 'exceptionDescription' stamp: 'LC 1/6/2002 13:47'!defaultAction	| s |	s _ self syntaxError.	^ s class open: s! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SyntaxErrorNotification class	instanceVariableNames: ''!!SyntaxErrorNotification class methodsFor: 'exceptionInstantiator' stamp: 'LC 1/6/2002 13:52'!inClass: aClass withCode: codeString doitFlag: doitFlag 	^ (self new		setClass: aClass		code: codeString		debugger: (Debugger context: thisContext)		doitFlag: doitFlag) signal! !Object subclass: #SystemChangeNotifier	instanceVariableNames: 'eventSource silenceLevel'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'System-Change Notification'!!SystemChangeNotifier methodsFor: 'initialize' stamp: 'NS 1/26/2004 20:41'!initialize	eventSource := SystemEventManager new.	silenceLevel _ 0.! !!SystemChangeNotifier methodsFor: 'private' stamp: 'rw 7/10/2003 15:15'!notify: anObject ofEvents: eventsCollection using: oneArgumentSelector	"Notifies an object of any events in the eventsCollection. Send it back a message #oneArgumentSelector, with as argument the particular system event instance."	eventsCollection do: [:eachEvent |		eventSource when: eachEvent send: oneArgumentSelector to: anObject]! !!SystemChangeNotifier methodsFor: 'private' stamp: 'NS 1/26/2004 20:41'!trigger: event	self isBroadcasting ifTrue: [event trigger: eventSource]"	| caughtExceptions |	caughtExceptions := OrderedCollection new.	self isBroadcasting ifTrue: [		[(eventSource actionForEvent: event eventSelector) valueWithArguments: (Array with: event)] on: Exception do: [:exc | caughtExceptions add: exc]].	caughtExceptions do: [:exc | exc resignalAs: exc class new]"! !!SystemChangeNotifier methodsFor: 'private-event lists' stamp: 'rw 7/29/2003 15:14'!allSystemEvents	^AbstractEvent systemEvents! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'rw 7/29/2003 15:12'!class: aClass recategorizedFrom: oldCategory to: newCategory 	self trigger: (RecategorizedEvent 				class: aClass				category: newCategory				oldCategory: oldCategory)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'rw 7/29/2003 15:11'!classAdded: aClass inCategory: aCategoryName 	self trigger: (AddedEvent class: aClass category: aCategoryName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/26/2004 09:37'!classCommented: aClass	"A class with the given name was commented in the system."	self trigger: (CommentedEvent class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/20/2004 19:37'!classDefinitionChangedFrom: oldClass to: newClass	self trigger: (ModifiedClassDefinitionEvent classDefinitionChangedFrom: oldClass to: newClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/16/2004 15:10'!classRemoved: aClass fromCategory: aCategoryName 	self trigger: (RemovedEvent class: aClass category: aCategoryName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 12:19'!classRenamed: aClass from: oldClassName to: newClassName inCategory: aCategoryName 	self trigger: (RenamedEvent 				class: aClass				category: aCategoryName				oldName: oldClassName				newName: newClassName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 12:48'!classReorganized: aClass	self trigger: (ReorganizedEvent class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/19/2004 09:47'!evaluated: expression context: aContext	self trigger: (DoItEvent 				expression: expression				context: aContext)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:24'!methodAdded: aMethod selector: aSymbol inClass: aClass requestor: requestor	"A method with the given selector was added to aClass, but not put in a protocol."	self trigger: (AddedEvent				method: aMethod 				selector: aSymbol				class: aClass				requestor: requestor)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:24'!methodAdded: aMethod selector: aSymbol inProtocol: aCategoryName class: aClass requestor: requestor	"A method with the given selector was added to aClass in protocol aCategoryName."	self trigger: (AddedEvent				method: aMethod				selector: aSymbol				protocol: aCategoryName				class: aClass				requestor: requestor)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:41'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor	self trigger: (ModifiedEvent					methodChangedFrom: oldMethod					to: newMethod					selector: aSymbol 					inClass: aClass					requestor: requestor)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/28/2004 11:11'!methodRemoved: aMethod selector: aSymbol inProtocol: protocol class: aClass 	"A method with the given selector was removed from the class."	self trigger: (RemovedEvent				method: aMethod 				selector: aSymbol				protocol: protocol				class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 4/7/2004 13:35'!selector: selector recategorizedFrom: oldCategory to: newCategory inClass: aClass	self trigger: (RecategorizedEvent 				method: (aClass compiledMethodAt: selector ifAbsent: [nil])				protocol: newCategory				class: aClass				oldProtocol: oldCategory)! !!SystemChangeNotifier methodsFor: 'public' stamp: 'NS 1/28/2004 11:29'!doSilently: aBlock	"Perform the block, and ensure that no system notification are broadcasted while doing so."	| result |	silenceLevel := silenceLevel + 1.	[result := aBlock value] ensure: [silenceLevel > 0 ifTrue: [silenceLevel := silenceLevel - 1]].	^ result.! !!SystemChangeNotifier methodsFor: 'public' stamp: 'NS 1/26/2004 20:41'!isBroadcasting	^ silenceLevel = 0! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/29/2003 17:01'!noMoreNotificationsFor: anObject	"Stop sending system notifications to an object."	eventSource removeActionsWithReceiver: anObject! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/10/2003 12:00'!notify: anObject ofAllSystemChangesUsing: oneArgumentSelector 	"Notifies an object of any system changes."	self 		notify: anObject		ofEvents: self allSystemEvents		using: oneArgumentSelector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemChangeNotifier class	instanceVariableNames: ''!!SystemChangeNotifier class methodsFor: 'instance creation' stamp: 'rw 6/28/2003 09:41'!new	^self error: self instanceCreationErrorString! !!SystemChangeNotifier class methodsFor: 'private' stamp: 'NS 1/27/2004 16:23'!createInstance	^self basicNew initialize! !!SystemChangeNotifier class methodsFor: 'private' stamp: 'rw 6/28/2003 09:41'!instanceCreationErrorString	^'This is a singleton implementation, so you are not allowed to create instances yourself. Use #uniqueInstance to access the instance.'! !!SystemChangeNotifier class methodsFor: 'public' stamp: 'NS 1/27/2004 16:23'!uniqueInstance	UniqueInstance ifNil: [UniqueInstance := self createInstance].	^UniqueInstance! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:31'!categoryKind	^ AbstractEvent categoryKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:31'!classKind	^ AbstractEvent classKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:32'!expressionKind	^ AbstractEvent expressionKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:31'!methodKind	^ AbstractEvent methodKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:32'!protocolKind	^ AbstractEvent protocolKind! !IdentityDictionary subclass: #SystemDictionary	instanceVariableNames: 'cachedClassNames'	classVariableNames: 'LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore MemoryHogs ShutDownList SpecialSelectors StartUpList StartupStamp VersionString'	poolDictionaries: ''	category: 'System-Support'!!SystemDictionary commentStamp: '<historical>' prior: 0!I represent a special dictionary that supports protocol for asking questions about the structure of the system. Other than class names, I contain (print this)...	Smalltalk keys select: [:k | ((Smalltalk at: k) isKindOf: Class) not]			thenCollect: [:k | k -> (Smalltalk at: k) class]!!SystemDictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 21:56'!organization	"Return the organizer for the receiver"	^SystemOrganization! !!SystemDictionary methodsFor: 'class names' stamp: 'di 3/26/2000 09:06'!classNamed: className 	"className is either a class name or a class name followed by ' class'.	Answer the class or metaclass it names"	| meta baseName baseClass |	(className endsWith: ' class')		ifTrue: [meta _ true.				baseName _ className copyFrom: 1 to: className size - 6]		ifFalse: [meta _ false.				baseName _ className].	baseClass _ Smalltalk at: baseName asSymbol ifAbsent: [^ nil].	meta		ifTrue: [^ baseClass class]		ifFalse: [^ baseClass]! !!SystemDictionary methodsFor: 'class names' stamp: 'di 11/16/1999 12:44'!classNames	"Answer a SortedCollection of all class names."	| names |	cachedClassNames == nil ifTrue:		[names _ OrderedCollection new: self size.		self do: 			[:cl | (cl isInMemory and: [(cl isKindOf: Class) and: [(cl name beginsWith: 'AnObsolete') not]])				ifTrue: [names add: cl name]].		cachedClassNames _ names asSortedCollection].	^ cachedClassNames! !!SystemDictionary methodsFor: 'class names' stamp: 'di 2/16/2000 10:28'!flushClassNameCache	"Smalltalk flushClassNameCache"	"Forse recomputation of the cached list of class names."	cachedClassNames _ nil! !!SystemDictionary methodsFor: 'class names' stamp: 'NS 1/27/2004 12:08'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 9/5/97 18:30'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'class names' stamp: 'rr 3/11/2004 15:18'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 10/28/96'!renameClassNamed: oldName as: newName	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: oldName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Class-rename for ', oldName, ' ignored because ', oldName, ' does not exist.'.			^ self].	oldClass rename: newName! !!SystemDictionary methodsFor: 'dictionary access'!at: aKey put: anObject 	"Override from Dictionary to check Undeclared and fix up	references to undeclared variables."	| index element |	(self includesKey: aKey) ifFalse: 		[self declare: aKey from: Undeclared.		self flushClassNameCache].	super at: aKey put: anObject.	^ anObject! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/21/1999 12:00'!atOrAbove: key ifAbsent: absentBlock	"Compatibility with environment protocol."	^ self at: key ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 13:43'!atOrBelow: key ifAbsent: absentBlock	"Compatibility with environment protocol."	^ self at: key ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 20:36'!environmentForCategory: catName	"Default response for non-partitioned systems"	^ Smalltalk! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/21/1999 12:00'!includesKeyOrAbove: key	"Compatibility with environment protocol."	self atOrAbove: key ifAbsent: [^ false].	^ true! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/19/1999 21:17'!scopeFor: varName from: lower envtAndPathIfFound: envtAndPathBlock	"Null compatibility with partitioning into environments."	(self includesKey: varName)		ifTrue: [^ envtAndPathBlock value: self value: String new]		ifFalse: [^ nil]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'BG 4/23/2004 14:38'!condenseChanges		"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name)! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'BG 2/17/2005 23:30'!condenseSources	"Move all the changes onto a compacted sources file."	"Smalltalk condenseSources"	| f classCount dir newVersionString |	Utilities fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --'	categories, which mess up the process."	dir := FileDirectory default.	newVersionString := FillInTheBlank request: 'Please designate the versionfor the new source code file...' initialAnswer: SmalltalkImage current sourceFileVersionString.	newVersionString		ifNil: [^ self].	newVersionString = SmalltalkImage current sourceFileVersionString		ifTrue: [^ self error: 'The new source file must not be the same as the old.'].	SmalltalkImage current sourceFileVersionString: newVersionString.	"Write all sources with fileIndex 1"	f := FileStream newFileNamed: SmalltalkImage current sourcesName.	f header; timeStamp.	'Condensing Sources File...'		displayProgressAt: Sensor cursorPoint		from: 0		to: self classNames size		during: [:bar | 			classCount := 0.			self				allClassesDo: [:class | 					bar value: (classCount := classCount + 1).					class						fileOutOn: f						moveSource: true						toFile: 1]].	f trailer; close.	"Make a new empty changes file"	SmalltalkImage current closeSourceFiles.	dir rename: SmalltalkImage current changesName toBe: SmalltalkImage current changesName , '.old'.	(FileStream newFileNamed: SmalltalkImage current changesName) header; timeStamp; close.	SmalltalkImage current lastQuitLogPosition:  0.	self setMacFileInfoOn: SmalltalkImage current changesName.	self setMacFileInfoOn: SmalltalkImage current sourcesName.	SmalltalkImage current openSourceFiles.	self inform: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sd 4/17/2003 20:59'!forgetDoIts		"Smalltalk forgetDoIts"	 "get rid of old DoIt methods"	self systemNavigation allBehaviorsDo:		[:cl | cl forgetDoIts]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jm 5/22/1998 11:37'!obsoleteClasses   "Smalltalk obsoleteClasses inspect"	"NOTE:  Also try inspecting comments below"	| obs c |	obs _ OrderedCollection new.  Smalltalk garbageCollect.	Metaclass allInstancesDo:		[:m | c _ m soleInstance.		(c ~~ nil and: ['AnOb*' match: c name asString])			ifTrue: [obs add: c]].	^ obs asArray"Likely in a ClassDict or Pool...(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray""Obsolete class refs or super pointer in last lit of a method...| n l found |Smalltalk browseAllSelect:	[:m | found _ false.	1 to: m numLiterals do:		[:i | (((l _ m literalAt: i) isMemberOf: Association)				and: [(l value isKindOf: Behavior)				and: ['AnOb*' match: l value name]])			ifTrue: [found _ true]].	found]"! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 3/1/2001 01:09'!reclaimDependents	"No-opped due to weak dictionary in use"	Smalltalk garbageCollect! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'nk 11/12/2003 10:28'!imageName	"Answer the full path name for the current image."	"Smalltalk imageName"	^ self deprecated: 'Use SmalltalkImage current imageName'		block: [SmalltalkImage current imageName]! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'nk 11/12/2003 10:29'!imageName: newName	"Set the the full path name for the current image.  All further snapshots will use this."	^ self deprecated: 'Use SmalltalkImage current imageName'		block: [ SmalltalkImage current imageName ]! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'BG 12/5/2003 19:30'!sourcesName	"Answer the full path to the version-stable source code"	self deprecatedExplanation: 'Use SmalltalkImage current sourcesName'.	" ^ SourceFileVersionString , FileDirectory dot , 'sources' "! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'nk 11/12/2003 10:35'!vmPath	"Answer the path for the directory containing the Smalltalk virtual machine. Return the empty string if this primitive is not implemented."	"Smalltalk vmPath"	^ self deprecated: 'Use SmalltalkImage current vmPath'		block: [SmalltalkImage current vmPath]! !!SystemDictionary methodsFor: 'memory space'!bytesLeft	"Answer the number of bytes of space available. Does a full garbage collection."	^ self garbageCollect! !!SystemDictionary methodsFor: 'memory space' stamp: 'ar 2/25/2001 17:55'!bytesLeft: aBool	"Return the amount of available space. If aBool is true, include possibly available swap space. If aBool is false, include possibly available physical memory. For a report on the largest free block currently availabe within Squeak memory but not counting extra memory use #primBytesLeft."	<primitive: 112>	^self primBytesLeft! !!SystemDictionary methodsFor: 'memory space' stamp: 'ar 2/25/2001 18:00'!bytesLeftString	"Return a string describing the amount of memory available"	| availInternal availPhysical availTotal |	self garbageCollect.	availInternal _ self primBytesLeft.	availPhysical _ self bytesLeft: false.	availTotal _ self bytesLeft: true.	(availTotal > (availInternal + 10000)) "compensate for mini allocations inbetween"		ifFalse:[^availInternal asStringWithCommas, ' bytes available'].	^String streamContents:[:s|		s nextPutAll: availInternal asStringWithCommas, 	' bytes (internal) '; cr.		s nextPutAll: availPhysical asStringWithCommas,	' bytes (physical) '; cr.		s nextPutAll: availTotal asStringWithCommas, 	' bytes (total)     '].! !!SystemDictionary methodsFor: 'memory space' stamp: 'ar 2/11/2001 02:36'!garbageCollect	"Primitive. Reclaims all garbage and answers the number of bytes of available space."	Object flushDependents.	Object flushEvents.	^self primitiveGarbageCollect! !!SystemDictionary methodsFor: 'memory space'!garbageCollectMost	"Primitive. Reclaims recently created garbage (which is usually most of it) fairly quickly and answers the number of bytes of available space."	<primitive: 131>	^ self primBytesLeft! !!SystemDictionary methodsFor: 'memory space'!installLowSpaceWatcher	"Start a process to watch for low-space conditions."	"Smalltalk installLowSpaceWatcher"	self primSignalAtBytesLeft: 0.  "disable low-space interrupts"	LowSpaceProcess == nil ifFalse: [LowSpaceProcess terminate].	LowSpaceProcess _ [self lowSpaceWatcher] newProcess.	LowSpaceProcess priority: Processor lowIOPriority.	LowSpaceProcess resume.! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 8/18/2000 16:49'!lowSpaceThreshold 	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."	thisContext isPseudoContext		ifTrue: [^ 400000  "Enough for JIT compiler"]		ifFalse: [^ 200000  "Enough for interpreter"]! !!SystemDictionary methodsFor: 'memory space' stamp: 'BG 10/30/2003 20:41'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	| free |	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	self memoryHogs isEmpty ifFalse: [		free := self bytesLeft.		self memoryHogs do: [ :hog | hog freeSomeSpace ].		self bytesLeft > free ifTrue: [ ^ self installLowSpaceWatcher ]].	Smalltalk isMorphic			ifTrue: []			ifFalse: [ScheduledControllers interruptName: 'Space is low']! !!SystemDictionary methodsFor: 'memory space' stamp: 'nk 10/28/2000 20:37'!lowSpaceWatcherProcess	^LowSpaceProcess! !!SystemDictionary methodsFor: 'memory space' stamp: 'sma 4/22/2000 19:03'!memoryHogs	"Answer the list of objects to notify with #freeSomeSpace if memory gets full."	^ MemoryHogs ifNil: [MemoryHogs _ OrderedCollection new]! !!SystemDictionary methodsFor: 'memory space'!okayToProceedEvenIfSpaceIsLow	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."	self garbageCollectMost > self lowSpaceThreshold ifTrue: [^ true].  "quick"	self garbageCollect > self lowSpaceThreshold ifTrue: [^ true].  "work harder"	^ self confirm:'WARNING: There is not enough space to start the low space watcher.If you proceed, you will not be warned again, and the system mayrun out of memory and crash. If you do proceed, you can start thelow space notifier when more space becomes available simply byopening and then closing a debugger (e.g., by hitting Cmd-period.)Do you want to proceed?'! !!SystemDictionary methodsFor: 'memory space'!primBytesLeft	"Primitive. Answer the number of bytes available for new object data.	Not accurate unless preceded by		Smalltalk garbageCollectMost (for reasonable accuracy), or		Smalltalk garbageCollect (for real accuracy).	See Object documentation whatIsAPrimitive."	<primitive: 112>	^ 0! !!SystemDictionary methodsFor: 'memory space'!primLowSpaceSemaphore: aSemaphore	"Primitive. Register the given Semaphore to be signalled when the	number of free bytes drops below some threshold. Disable low-space	interrupts if the argument is nil."	<primitive: 124>	self primitiveFailed! !!SystemDictionary methodsFor: 'memory space'!primSignalAtBytesLeft: numBytes	"Tell the interpreter the low-space threshold in bytes. When the free	space falls below this threshold, the interpreter will signal the low-space	semaphore, if one has been registered.  Disable low-space interrupts if the	argument is zero.  Fail if numBytes is not an Integer."	<primitive: 125>	self primitiveFailed! !!SystemDictionary methodsFor: 'memory space' stamp: 'ar 2/11/2001 02:16'!primitiveGarbageCollect	"Primitive. Reclaims all garbage and answers the number of bytes of available space."	<primitive: 130>	^ self primBytesLeft! !!SystemDictionary methodsFor: 'memory space'!signalLowSpace	"Signal the low-space semaphore to alert the user that space is running low."	LowSpaceSemaphore signal.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'nk 11/12/2003 10:19'!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000...-1 - command line arguments that specify VM options 	0 - the full path name for currently executing VM 	(or, on some platforms, just the path name of the VM's directory) 	1 - full path name of this image 	2 - a Squeak document to open, if any 	3...1000 - command line arguments for Squeak programs 	1001 - this platform's operating system 	1002 - operating system version 	1003 - this platform's processor type	1004 - vm version"	^self deprecated: 'Use SmalltalkImage current getSystemAttribute: attributeID '		block: [SmalltalkImage current getSystemAttribute: attributeID ]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'nk 11/12/2003 10:27'!getVMParameters	"Smalltalk getVMParameters"	"Answer an Array containing the current values of the VM's internal	parameter/metric registers.  Each value is stored in the array at the	index corresponding to its VM register.  (See #vmParameterAt: and	#vmParameterAt:put:.)"	^self deprecated: 'Use SmalltalkImage current getVMParameters'		block: [SmalltalkImage current getVMParameters] .! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'BG 10/30/2003 20:40'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: []			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tk 10/16/2001 19:24'!logError: errMsg inContext: aContext to: aFilename	"Log the error message and a stack trace to the given file."	| ff |	FileDirectory default deleteFileNamed: aFilename ifAbsent: [].	(ff _ FileStream fileNamed: aFilename) ifNil: [^ self "avoid recursive errors"].  	ff nextPutAll: errMsg; cr.	aContext errorReportOn: ff.	ff close.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'md 12/12/2003 17:02'!platformName	"Return the name of the platform we're running on"	self deprecated: 'Use SmalltalkImage current platformName'.	^self getSystemAttribute: 1001! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'MPH 10/24/2000 14:27'!setMacFileInfoOn: aString	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: aString		type: 'STch'		creator: 'FAST'.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'nk 11/12/2003 10:35'!vmParameterAt: parameterIndex put: newValue	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Store newValue (a positive integer) into that	register and answer with the previous value that was stored there.	Fail if newValue is out of range, if parameterIndex has no corresponding	register, or if the corresponding register is read-only."	^ self deprecated: 'Use SmalltalkImage current vmParameterAt: parameterIndex put: newValue'		block: [SmalltalkImage current vmParameterAt: parameterIndex put: newValue]! !!SystemDictionary methodsFor: 'printing' stamp: 'sma 6/1/2000 09:53'!printElementsOn: aStream	aStream nextPutAll:'(lots of globals)'! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sd 4/17/2003 21:15'!allClasses  	"Return all the class defines in the Smalltalk SystemDictionary"	"Smalltalk allClasses"	^ self classNames collect: [:name | self at: name]! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sd 4/17/2003 21:18'!allClassesDo: aBlock	"Evaluate the argument, aBlock, for each class in the system."	(self classNames collect: [:name | self at: name]) do: aBlock! !!SystemDictionary methodsFor: 'retrieving' stamp: 'BG 11/1/2003 14:06'!allSentMessagesWithout: classesAndMessagesPair	"Answer the set of selectors which are sent somewhere in the system, computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors literals hasMenuFromArray |	sent _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	Cursor execute showWhile: 		[self classNames do: 			[:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{(self at: cName). (self at: cName) class}]) do:				[:cl | (absentSelectors isEmpty						ifTrue: [cl selectors]						ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: 					[:sel | "Include all sels, but not if sent by self"                         literals := (cl compiledMethodAt: sel) literals.                         hasMenuFromArray :=                          (literals includes: #addList:) | (literals includes: #fromArray:) .					 literals  do: 						[:m | 						(m isMemberOf: Symbol) ifTrue:  "might be sent"							[m == sel ifFalse: [sent add: m]].						(m isMemberOf: Array) ifTrue:  "might be performed"							[m do: [:x | (x isMemberOf: Symbol) ifTrue:								             [x == sel ifFalse: [sent add: x]].                                               (hasMenuFromArray and: [x isMemberOf: Array])                                                 ifTrue: [x do: [:y | (y isMemberOf: Symbol) ifTrue:								             [y == sel ifFalse: [sent add: y]].]]                                 ]       ].   ]]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			sent add: (self specialSelectorAt: index)]].	Smalltalk presumedSentMessages do: [:sel | sent add: sel].	^ sent! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 9/26/1999 14:54'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		anObj isInMemory ifTrue: [			(anObj pointsTo: anObject) ifTrue: [				"exclude the results collector and contexts in call chain"				((anObj ~~ results collector) and:				 [(anObj ~~ objectsToExclude) and:				 [(anObj ~~ thisContext) and:				 [(anObj ~~ thisContext sender) and:				 [anObj ~~ thisContext sender sender]]]])					 ifTrue: [ results add: anObj ].			]].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 1/7/2004 15:39'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	"wod 11/3/1998: zap the organization before rather than after condensing changes."	 | oldCodeString argsAndTemps oldMethods newMethods m bTotal bCount |	(self confirm:'This method will preserve most temp names(up to about 400 characters) while allowingthe sources file to be discarded.-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, choose Yes.If you have any doubts, you may choose Noto back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	self systemNavigation allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	self systemNavigation allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "			[:cl |  bar value: (bCount _ bCount + 1).			cl selectors do: [:selector |				m _ cl compiledMethodAt: selector.				m fileIndex > 0 ifTrue:				[oldCodeString _ cl sourceCodeAt: selector.				argsAndTemps _ (cl compilerClass new					parse: oldCodeString in: cl notifying: nil)					tempNames.				oldMethods addLast: m.				newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	self systemNavigation allBehaviorsDo: [:b | b zapOrganization].	Smalltalk condenseChanges.	Preferences disable: #warnIfNoSourcesFile."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'ssa 10/8/2008 13:14'!majorShrinkClassesToLeave	| manual categoryNames classNames classNameSets |	manual := #(True False ReadOnlyVariableBinding SystemOrganizer ClassOrganizer View Switch Button EndOfStream ValueHolder EventSensorConstants ChronologyConstants InstructionPrinter Color Form ColorForm DisplayMedium DisplayObject Rectangle Point  Pen OrderedCollection Array SortedCollection Dictionary Association SequenceableCollection Collection String Text DisplayText ArrayedCollection Object GIFReadWriter ImageReadWriter 	"Benchmark BinaryChoice "  ChangeSet ChangeSorter DualChangeSorter ChangeList Inspector BasicInspector CompiledMethodInspector DictionaryInspector OrderedCollectionInspector).	categoryNames := "(SystemOrganization categoriesMatching:'RVM-*'), "					(SystemOrganization categoriesMatching:'PluggableGauges*'), 					(SystemOrganization categoriesMatching:'Tools-FileList'),					(SystemOrganization categoriesMatching:'Tools-Browser'),					(SystemOrganization categoriesMatching:'Kernel-ST80 Remnants'), 					(SystemOrganization categoriesMatching:'ST80-Framework'), 					(SystemOrganization categoriesMatching:'ST80-Support'), 					(SystemOrganization categoriesMatching:'ST80-Pluggable Views'), 					(SystemOrganization categoriesMatching:'ST80-Views'), 					(SystemOrganization categoriesMatching:'ST80-Editors'), 					(SystemOrganization categoriesMatching:'Tools-Process Browser').	classNameSets := categoryNames collect:[:each| SystemOrganization listAtCategoryNamed: each].	classNames := OrderedCollection new.	classNameSets do:[:set| set do:[:n| classNames add: n]].	^(manual, classNames) asSet asOrderedCollection! !!SystemDictionary methodsFor: 'shrinking' stamp: 'ssa 9/3/2008 12:00'!majorShrinkClassesToZap	^#(BDFFontReader 		InstanceBrowser 		Lexicon 		TarArchiveMember 		CRLookupResult	"	PluggableDictionary		 PluggableSet "		MimeConverter		QuotedPrintableMimeConverter		RFC2047MimeConverter		AbstractLauncher		AutoStart		AcornFileDirectory		 " AssertionFailure "		CachedHTTPRequest 		CachingCodeLoader		CodeLoader		CanvasEncoder		EToyVectorVocabulary		EToyVocabulary        	FileList2		FontCache		FTPConnectionException		FullVocabulary		HTTPClient		HTTPLoader		HTTPRequest 		HtmlFileStream		"MacFileDirectory"		"MacHFSPlusFileDirectory"		PluginHTTPRequest		SUnitNameResolver		ScreenedVocabulary		ScriptNameType		SoundType		StringType		SymbolListType		TestCase		TestFailure		TestResource		TestResult		TestRunner		TestSuite		TestCaseDebugger		TestViaMethodCall		TextSqkPageLink		TextSqkProjectLink		TextURL 		UnknownType		Verifier		VerifierOfProperty		Vocabulary		BooleanType		ButtonPhaseType		ColorType		DataType		GraphicType		MenuType		NumberType		PlayerType)! !!SystemDictionary methodsFor: 'shrinking' stamp: 'BG 11/26/2003 19:09'!postMajorShrink   | oldDicts  newDicts |	SystemOrganization removeEmptyCategories.	Smalltalk allClassesDo: [:c | c compactOrganization]. 	Smalltalk garbageCollect.	'Rehashing method dictionaries . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: MethodDictionary instanceCount		during: [:bar |			oldDicts _ MethodDictionary allInstances.			newDicts _ Array new: oldDicts size.			oldDicts withIndexDo: [:d :index | 				bar value: index.				newDicts at: index put: d rehashWithoutBecome.			].			oldDicts elementsExchangeIdentityWith: newDicts.		].	oldDicts _ newDicts _ nil.	Project rebuildAllProjects.	ChangeSet current initialize.	"seems to take more than one try to gc all the weak refs in SymbolTable"	3 timesRepeat: [		Smalltalk garbageCollect.		Symbol compactSymbolTable.	].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'ssa 9/3/2008 13:42'!presumedSentMessages   | sent |"Smalltalk presumedSentMessages"	"The following should be preserved for doIts, etc"	sent _ IdentitySet new.	#( 	"menu messages from Debugger>>contextStackMenu: aMenu shifted: shifted"	fullStack restart proceed doStep stepIntoBlock send where peelToFirstbrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFull fileOutMessage shiftedYellowButtonActivity	"menu messages from Preferences>>presentMvcFontConfigurationMenu"	chooseSystemFont chooseListFont chooseMenuFont chooseWindowTitleFont chooseCodeFont restoreDefaultFonts	"others"		rehashWithoutBecome compactSymbolTable rebuildAllProjects		browseAllSelect: printSpaceAnalysis lastRemoval		scrollBarValue: scrollBarMenuButtonPressed: 		withSelectionFrom:  to: removeClassNamed: instVarNamed:put:		breakDependents          maximumSize: redButtonMenu:redButtonMessages:		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib		newDepth: restoreAfter: forgetDoIts zapAllMethods obsoleteClasses		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		renameClassNamed:as:  " this method is used in change sets "		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:    " subclass creation: "		variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		weakSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher unusedClasses		widthOfString: widthOfString:from:to: clipHeight clipHeight: 		clipWidth clipWidth: clipX clipX: clipY clipY:           newDay:monthIndex:year: abandon pixelForValueAt:put:          magnifyBy: replaceColor:withColor: dotOfSize:  "DisplayScreen> " fullBoundingBox          originFromUser:     " finalization "          toFinalizeSend:to:with:	" StrikeFont> "		maxAscii minAscii maxWidth firstIndent:          restIndent: rightIndent: newFontArray: fontArray:          readStrikeFont2Family:  familySizeFace writeAsStrike2Named:	"  Paragraph  "		compositionRectangle:    " Form: these methods are meeded for gif creation "		colorReduced colorsUsed   " protocol from Pen class: "		inkBrush simplePressurePen testMouseTracking testTabletTracking   " two methods that are hidden from the method tracer "		method: preamble:		inspectElement		inspectSelection inspectBasic fileOutAllChangeSets fillAggregateChangeSet   " convenience methods in True and False: "		and:and: and:and:and: and:and:and:and:		or:or: or:or:or: or:or:or:or:  " mics "     	pairsDo: font:  notEmpty   " ExternalEvent class: "		registerClient:     ) do:		[:sel | sent add: sel].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sent add: sel].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sent add: sel]. Smalltalk majorShrinkClassesToLeave do:  [:symbol | sent addAll: (Smalltalk at: symbol) selectors;                 addAll: (Smalltalk at: symbol) class selectors.].	^ sent! !!SystemDictionary methodsFor: 'shrinking' stamp: 'BG 11/26/2003 14:35'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages"	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem].		Smalltalk removeAllUnSentMessages > 0] whileTrue." 	"Remove all implementations of unsent messages."	| sels n |	sels _ SystemNavigation default allUnSentMessages.	"The following should be preserved for doIts, etc"	#(		rehashWithoutBecome compactSymbolTable rebuildAllProjects	"needed even after #majorShrink is pulled"					browseAllSelect: printSpaceAnalysis lastRemoval		scrollBarValue: scrollBarMenuButtonPressed: 		withSelectionFrom:  to: removeClassNamed:		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib		newDepth: restoreAfter: forgetDoIts zapAllMethods obsoleteClasses		removeAllUnSentMessages condenseChanges condenseSources abandonSources removeUnreferencedKeys postMajorShrink offerShiftedClassListMenu offerUnshiftedClassListMenu         font1 font2 font3 font4		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher unusedClasses) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. self systemNavigation allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self systemNavigation allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	^ sels size! !!SystemDictionary methodsFor: 'shrinking' stamp: 'sma 6/18/2000 11:34'!removeSelector: descriptor	"Safely remove a selector from a class (or metaclass). If the class	or the method doesn't exist anymore, never mind and answer nil.	This method should be used instead of 'Class removeSelector: #method'	to omit global class references."	| class sel |	class _ Smalltalk at: descriptor first ifAbsent: [^ nil].	(descriptor size > 2 and: [descriptor second == #class])		ifTrue:			[class _ class class.			sel _ descriptor third]		ifFalse: [sel _ descriptor second].	^ class removeSelector: sel! !!SystemDictionary methodsFor: 'shrinking' stamp: 'sd 4/29/2003 19:06'!unusedClasses	"Enumerates all classes in the system and returns a list of those that are 	apparently unused. A class is considered in use if it (a) has subclasses 	or (b) is referred to by some method or (c) has its name in use as a 	literal. "	"Smalltalk unusedClasses asSortedCollection"	^ self systemNavigation allUnusedClassesWithout: {{}. {}}! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/19/1999 22:36'!add: aClass toList: startUpOrShutDownList after: predecessor	"Add the name of aClass to the startUp or shutDown list.	Add it after the name of predecessor, or at the end if predecessor is nil."	| name earlierName |	name _ aClass name.	(self at: name ifAbsent: [nil]) == aClass ifFalse:		[self error: name , ' cannot be found in Smalltalk dictionary.'].	predecessor == nil		ifTrue: ["No-op if alredy in the list."				(startUpOrShutDownList includes: name) ifFalse:					[startUpOrShutDownList == StartUpList						ifTrue: ["Add to end of startUp list"								startUpOrShutDownList addLast: name]						ifFalse: ["Add to front of shutDown list"								startUpOrShutDownList addFirst: name]]]		ifFalse: ["Add after predecessor, moving it if already there."				earlierName _ predecessor name.				(self at: earlierName) == predecessor ifFalse:					[self error: earlierName , ' cannot be found in Smalltalk dictionary.'].				(startUpOrShutDownList includes: earlierName) ifFalse:					[self error: earlierName , ' cannot be found in the list.'].				startUpOrShutDownList remove: name ifAbsent:[].				startUpOrShutDownList add: name after: earlierName]! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/4/1999 15:38'!addToShutDownList: aClass	"This will add a ref to this class at the BEGINNING of the shutDown list."	self addToShutDownList: aClass after: nil! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/3/1999 22:04'!addToShutDownList: aClass after: predecessor	self add: aClass toList: ShutDownList after: predecessor! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/4/1999 15:37'!addToStartUpList: aClass	"This will add a ref to this class at the END of the startUp list."	self addToStartUpList: aClass after: nil! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/3/1999 22:04'!addToStartUpList: aClass after: predecessor	self add: aClass toList: StartUpList after: predecessor! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'RAA 6/14/2000 17:21'!isMorphic        "Answer true if the user interface is running in Morphic rathern than         MVC.  By convention the gloabl variable World is set to nil when MVC is         running.  ScheduledControllers could be set to nil when Morphic is         running, but this symmetry is not yet in effect."        ^ World ~~ nil "or: [RequestCurrentWorldNotification signal notNil]"! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/16/1999 20:12'!processShutDownList: quitting	"Send #shutDown to each class that needs to wrap up before a snapshot."	self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/16/1999 20:12'!processStartUpList: resuming	"Send #startUp to each class that needs to run initialization after a snapshot."	self send: #startUp: toClassesNamedIn: StartUpList with: resuming.! !!SystemDictionary methodsFor: 'snapshot and quit'!quitPrimitive	"Primitive. Exit to another operating system on the host machine, if one	exists. All state changes in the object space since the last snapshot are lost.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 113>	self primitiveFailed! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/3/1999 22:22'!removeFromShutDownList: aClass	ShutDownList remove: aClass name ifAbsent: []! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/3/1999 22:22'!removeFromStartUpList: aClass	StartUpList remove: aClass name ifAbsent: []! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 3/7/2001 01:26'!send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument	"Send the message #startUp: or #shutDown: to each class named in the list.	The argument indicates if the system is about to quit (for #shutDown:) or if	the image is resuming (for #startUp:).	If any name cannot be found, then remove it from the list."	| removals class |	removals _ OrderedCollection new.	startUpOrShutDownList do:		[:name |		class _ self at: name ifAbsent: [nil].		class == nil			ifTrue: [removals add: name]			ifFalse: [class isInMemory ifTrue:						[class perform: startUpOrShutDown with: argument]]].	"Remove any obsolete entries, but after the iteration"	startUpOrShutDownList removeAll: removals! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sd 9/30/2003 13:47'!setGCParameters	"Adjust the VM's default GC parameters to avoid premature tenuring."	SmalltalkImage current  vmParameterAt: 5 put: 4000.  "do an incremental GC after this many allocations"	SmalltalkImage current  vmParameterAt: 6 put: 2000.  "tenure when more than this many objects survive the GC"! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'md 12/12/2003 17:03'!setPlatformPreferences	"Set some platform specific preferences on system startup"	self deprecated: 'Use SmalltalkImage current setPlatformPreferences'. 	! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sd 11/16/2003 13:14'!shutDown	^ SmalltalkImage current closeSourceFiles! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'BG 10/29/2003 09:55'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	Object flushDependents.	Object flushEvents.	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString, ' ', (FileDirectory default localNameFor: self imageName).		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		self assureStartupStampLogged.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming _ embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming _ false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming == true ifTrue: [self clearExternalObjects].	self processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self readDocumentFile].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'JMM 11/21/2000 21:02'!snapshotEmbeddedPrimitive	<primitive: 247>	^nil "indicates error writing embedded image file"! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 7/22/2000 14:34'!snapshotPrimitive	"Primitive. Write the current state of the object memory on a file in the	same format as the Smalltalk-80 release. The file can later be resumed,	returning you to this exact state. Return normally after writing the file.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 97>	^nil "indicates error writing image file"! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 2/15/1999 16:18'!aboutThisSystem 	"Identify software version"	^ self inform: self systemInformationString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'NS 1/16/2004 15:37'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	self deprecated: 'Use SmalltalkImage current assureStartupStampLogged'.	SmalltalkImage current assureStartupStampLogged.	"	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: StartupStamp asString; cr.	StartupStamp _ nil.	self forceChangesToDisk."! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sd 5/23/2003 14:42'!currentChangeSetString	"Smalltalk currentChangeSetString"	^ 'Current Change Set: ', ChangeSet current name! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 9/10/1999 15:52'!currentProjectDo: aBlock	"So that code can work after removal of Projects"	Smalltalk at: #Project ifPresent:		[:projClass | aBlock value: projClass current].! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'mir 5/1/2001 18:20'!datedVersion	"Answer the version of this release."	^SystemVersion current datedVersion! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'tk 1/24/2000 23:01'!endianness	| bytes word blt |	"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte."	"Smalltalk endianness"	bytes _ ByteArray withAll: #(0 0 0 0).  "(1 2 3 4) or (4 3 2 1)"	word _ WordArray with: 16r01020304.	blt _ (BitBlt toForm: (Form new hackBits: bytes)) 				sourceForm: (Form new hackBits: word).	blt combinationRule: Form over.  "store"	blt sourceY: 0; destY: 0; height: 1; width: 4.	blt sourceX: 0; destX: 0.	blt copyBits.  "paste the word into the bytes"	bytes first = 1 ifTrue: [^ #big].	bytes first = 4 ifTrue: [^ #little].	self error: 'Ted is confused'.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'ssa 9/3/2008 11:25'!forceChangesToDisk	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."	| changesFile |	changesFile _ SourceFiles at: 2.	(changesFile isKindOf: FileStream) ifTrue: [		changesFile flush.		true ifTrue:[			changesFile close.			changesFile open: changesFile name forWrite: true].		changesFile setToEnd.	].! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'md 12/12/2003 17:02'!isBigEndian	self deprecated: 'Use SmalltalkImage current isBigEndian'.	^self endianness == #big! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'md 12/12/2003 17:02'!isLittleEndian	self deprecated: 'Use SmalltalkImage current isLittleEndian'.	^self endianness == #little! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'mir 5/1/2001 18:02'!lastUpdateString	"Smalltalk lastUpdateString"	^'latest update: #', SystemVersion current highestUpdate printString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'NS 1/16/2004 15:38'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."		self deprecated: 'Use SmalltalkImage current logChange:'.	SmalltalkImage current logChange: aStringOrText.		"	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].	(changesFile _ SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: aString.	self forceChangesToDisk."! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sd 7/2/2003 22:11'!systemInformationString	"Identify software version"	^ SystemVersion current version, String cr, self lastUpdateString, String cr, self currentChangeSetString"	(eToySystem _ self at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString _ aString, 'Squeak-Central version: ', eToySystem version, ' of ', eToySystem versionDate]."! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'mir 5/1/2001 18:19'!timeStamp: aStream 	"Writes system version and current time on stream aStream."	| dateTime |	dateTime _ Time dateAndTimeNow.	aStream nextPutAll: 'From ', Smalltalk datedVersion, ' [', Smalltalk lastUpdateString, '] on ', (dateTime at: 1) printString,						' at ', (dateTime at: 2) printString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'md 12/12/2003 17:03'!version	"Answer the version of this release."	self deprecated: 'Use SystemVersion current version'.	^SystemVersion current version! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 2/3/2000 15:58'!writeRecentCharacters: nCharacters toFileNamed: aFilename	"Schedule an editable text view on the last n characters of changes."	| changes |	changes _ SourceFiles at: 2.	changes setToEnd; skip: nCharacters negated.	(FileStream newFileNamed: aFilename) nextPutAll: (changes next: nCharacters); close; open; edit! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 2/3/2000 16:17'!writeRecentToFile	| numChars aDirectory aFileName |	"Smalltalk writeRecentToFile"	aDirectory _ FileDirectory default.	aFileName _ Utilities keyLike: 'squeak-recent.01' withTrailing: '.log' satisfying:		[:aKey | (aDirectory includesKey: aKey) not].	numChars _ ChangeList getRecentLocatorWithPrompt: 'copy logged source as far back as...'.	numChars ifNotNil:		[Smalltalk writeRecentCharacters: numChars toFileNamed: aFileName]! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 20:36'!clearExternalObjects	"Clear the array of objects that have been registered for use in non-Smalltalk code."	"Smalltalk clearExternalObjects"	ExternalSemaphoreTable clearExternalObjects! !!SystemDictionary methodsFor: 'special objects'!compactClassesArray  "Smalltalk compactClassesArray"	"Return the array of 31 classes whose instances may be	represented compactly"	^ Smalltalk specialObjectsArray at: 29! !!SystemDictionary methodsFor: 'special objects'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	1 to: self specialSelectorSize do:		[:index | 		(self specialSelectorAt: index) == aLiteral			ifTrue: [aBlock value: index + 16rAF. ^true]].	^false! !!SystemDictionary methodsFor: 'special objects' stamp: 'tpr 7/25/2003 12:30'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Squeak virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray |	newArray _ Array new: 50.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user interrupt Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes"	newArray at: 36 put: (self specialObjectsArray at: 36). 						"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 37 put: nil.	newArray at: 38 put: (self specialObjectsArray at: 38). 						"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil:[Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (Smalltalk at: #ExternalAddress ifAbsent:[nil]).	newArray at: 45 put: (Smalltalk at: #ExternalStructure ifAbsent:[nil]).	newArray at: 46 put: (Smalltalk at: #ExternalData ifAbsent:[nil]).	newArray at: 47 put: (Smalltalk at: #ExternalFunction ifAbsent:[nil]).	newArray at: 48 put: (Smalltalk at: #ExternalLibrary ifAbsent:[nil]).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 20:39'!registerExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	^ExternalSemaphoreTable registerExternalObject: anObject! !!SystemDictionary methodsFor: 'special objects'!specialNargsAt: anInteger 	"Answer the number of arguments for the special selector at: anInteger."	^ (self specialObjectsArray at: 24) at: anInteger * 2! !!SystemDictionary methodsFor: 'special objects'!specialObjectsArray  "Smalltalk specialObjectsArray at: 1"	<primitive: 129>	^ self primitiveFailed! !!SystemDictionary methodsFor: 'special objects'!specialSelectorAt: anInteger 	"Answer the special message selector from the interleaved specialSelectors array."	^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1! !!SystemDictionary methodsFor: 'special objects'!specialSelectorSize	"Answer the number of special selectors in the system."	^ (self specialObjectsArray at: 24) size // 2! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 20:40'!unregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered."	ExternalSemaphoreTable unregisterExternalObject: anObject! !!SystemDictionary methodsFor: 'copying' stamp: 'sw 11/21/2001 15:08'!assureUniClass	"Assure that the receiver has a uniclass.  Or rather, in this case, stop short of fulfilling such a request"	self error: 'We do not want uniclasses descending from here'! !!SystemDictionary methodsFor: 'copying' stamp: 'tk 10/20/2000 11:35'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!SystemDictionary methodsFor: 'deprecated' stamp: 'md 12/12/2003 17:03'!swapBytesIn: aNonPointerThing from: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	| hack blt |	self deprecated: 'Use Bitmap class>>swapBytesIn: aNonPointerThing from: start to: stop instead'.	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: aNonPointerThing.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:23'!changeImageNameTo: aString	self deprecated: 'Use SmalltalkImage current changeImageNameTo: aString'.	SmalltalkImage current imageName: aString.	LastImageName _ SmalltalkImage current imageName! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:26'!changesName	"Answer the local name for the changes file corresponding to the image file name."	"Smalltalk changesName"	| imName |	self deprecated: 'Use SmalltalkImage current changesName'.	imName _ FileDirectory baseNameFor:		(FileDirectory localNameFor: SmalltalkImage current imageName).	^ imName, FileDirectory dot, 'changes'! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:26'!closeSourceFiles	"Shut down the source files if appropriate.  1/29/96 sw: changed so that the closing and nilification only take place if the entry was a FileStream, thus allowing stringified sources to remain in the saved image file"	self deprecated: 'Use SmalltalkImage current closeSourceFiles'.	1 to: 2 do: [:i |		((SourceFiles at: i) isKindOf: FileStream)			ifTrue:				[(SourceFiles at: i) close.				SourceFiles at: i put: nil]]! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:09'!fullNameForChangesNamed: aName	| newName |	self deprecated: 'Use SmalltalkImage current fullNameForChangesNamed: aName'.	newName _ FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory changeSuffix.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:10'!fullNameForImageNamed: aName	| newName |	self deprecated: 'Use SmalltalkImage current fullNameForImageNamed: aName'.	newName _ FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory imageSuffix.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:19'!getFileNameFromUser	| newName |	self deprecated: 'Use SmalltalkImage current getFileNameFromUser'.	newName _ FillInTheBlank		request: 'New File Name?' translated		initialAnswer: (FileDirectory localNameFor: SmalltalkImage current imageName).	newName = '' ifTrue: [^nil].	((FileDirectory default fileOrDirectoryExists: (SmalltalkImage current fullNameForImageNamed: newName)) or:	 [FileDirectory default fileOrDirectoryExists: (SmalltalkImage current fullNameForChangesNamed: newName)]) ifTrue: [		(self confirm: ('{1} already exists. Overwrite?' translated format: {newName})) ifFalse: [^nil]].	^newName! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!lastQuitLogPosition	self deprecated: 'Use SmalltalkImage current lastQuitLogPosition'.	^ LastQuitLogPosition! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!openSourceFiles		self deprecated: 'Use SmalltalkImage current lastQuitLogPosition'.		SmalltalkImage current imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName _ SmalltalkImage current imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: SmalltalkImage current sourcesName		andChanges: SmalltalkImage current changesName		forImage: LastImageName.	StandardSourceFileArray install! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!readDocumentFile	"No longer used. Everything is now done in ProjectLauncher."		self deprecated: 'Use SmalltalkImage current readDocumentFile'.	StartupStamp _ '----STARTUP----', Time dateAndTimeNow printString, ' as ', SmalltalkImage current imageName.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:21'!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	| newName |	self deprecated: 'Use SmalltalkImage current saveAs'.	newName _ SmalltalkImage current getFileNameFromUser.	newName isNil ifTrue: [^ self].	(SourceFiles at: 2) ifNotNil:		[SmalltalkImage current closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (SmalltalkImage current fullNameForChangesNamed: newName)].	SmalltalkImage current saveImageInFileNamed: (SmalltalkImage current fullNameForImageNamed: newName)! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!saveChangesInFileNamed: aString		self deprecated: 'Use SmalltalkImage current saveChangesInFileNamed: aString'.	FileDirectory default 		copyFileWithoutOverwriteConfirmationNamed: SmalltalkImage current changesName 		toFileNamed: aString.	self	setMacFileInfoOn: aString.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!saveImageInFileNamed: aString	self deprecated: 'Use SmalltalkImage current saveImageInFileNamed: aString'.	SmalltalkImage current 		changeImageNameTo: (FileDirectory default fullNameFor: aString).	SmalltalkImage current	closeSourceFiles.	SmalltalkImage current openSourceFiles.  "so SNAPSHOT appears in new changes file"	SmalltalkImage current 		saveImageSegments.	SmalltalkImage current snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!saveImageSegments	| haveSegs oldImageSegDir newImageSegDir |	self deprecated: 'Use SmalltalkImage current saveImageSegments'.	haveSegs _ false.	Smalltalk at: #ImageSegment ifPresent: [:theClass | 		(haveSegs _ theClass instanceCount ~= 0) ifTrue: [			oldImageSegDir _ theClass segmentDirectory]].	haveSegs ifTrue: [		Smalltalk at: #ImageSegment ifPresent: [:theClass |			newImageSegDir _ theClass segmentDirectory.	"create the folder"			oldImageSegDir fileNames do: [:theName | "copy all segment files"				| imageSegmentName |				imageSegmentName _ oldImageSegDir pathName, FileDirectory slash, theName.				newImageSegDir 					copyFileWithoutOverwriteConfirmationNamed: imageSegmentName					toFileNamed: theName]]].! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'sd 11/16/2003 14:27'!snapshot: save andQuit: quit	self deprecated: 'Use SmalltalkImage current snapshot: save andQuit: quit'.	^self snapshot: save andQuit: quit embedded: false! !!SystemDictionary methodsFor: 'browsing' stamp: 'BG 10/30/2003 21:12'!browseMethodsWhoseNamesContain: aString	"Launch a tool which shows all methods whose names contain the given string; case-insensitive.	1/16/1996 sw, at the dawn of Squeak: this was the classic implementation that provided the underpinning for the 'method names containing it' (cmd-shift-W) feature that has always been in Squeak -- the feature that later inspired the MethodFinder (aka SelectorBrowser).	sw 7/27/2001:	Switched to showing a MessageNames tool rather than a message-list browser, if in Morphic."	| aList |	aList _ Symbol selectorsContaining: aString.			aList size > 0 ifTrue:				[self browseAllImplementorsOfList: aList asSortedCollection title: 'Methods whose names contain ''', aString, '''']	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemDictionary class	instanceVariableNames: ''!!SystemDictionary class methodsFor: 'initialization' stamp: 'BG 8/18/2004 15:09'!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		Delay		FileDirectory  "Enables file stack dump and opens sources."		"ShortIntegerArray"		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		DisplayScreen		Form		ControlManager		StrikeFont		Color		FileDirectory		Delay		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !EventManager subclass: #SystemEventManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!SystemEventManager methodsFor: 'events-accessing' stamp: 'rw 7/20/2003 17:02'!actionSequenceForEvent: anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequenceTrappingErrors new])            asActionSequenceTrappingErrors! !Object subclass: #SystemNavigation	instanceVariableNames: 'browserClass hierarchyBrowserClass'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'System-Support'!!SystemNavigation commentStamp: 'sd 4/15/2003 22:30' prior: 0!I support the navigation of the system. I act as a facade but as I could require some stateor different way of navigating the system all my behavior are on the instance side!!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 08:53'!browseAllAccessesTo: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	"self new browseAllAccessesTo: 'contents' from: Collection."		| coll |	coll _ OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsAccess: instVarName) do: [:sel |				sel == #DoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		].	].	^ self 		browseMessageList: coll 		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/29/2003 12:23'!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to 	aLiteral. For example, SystemNavigation new browseAllCallsOn: #open:label:."	(aLiteral isKindOf: LookupKey)		ifTrue: [^ self				browseMessageList: (self allCallsOn: aLiteral) asSortedCollection				name: 'Users of ' , aLiteral key				autoSelect: aLiteral key].	self		browseMessageList: (self allCallsOn: aLiteral) asSortedCollection		name: 'Senders of ' , aLiteral		autoSelect: aLiteral keywords first! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 11:44'!browseAllCallsOn: aLiteral localTo: aClass	"Create and schedule a message browser on each method in or below the given class that refers to	aLiteral. For example, Smalltalk browseAllCallsOn: #open:label:."	aClass ifNil: [ ^self inform: 'no selected class' ].	(aLiteral isKindOf: LookupKey)		ifTrue: [self browseMessageList: (aClass allLocalCallsOn: aLiteral) asSortedCollection					name: 'Users of ' , aLiteral key, ' local to ', aClass name					autoSelect: aLiteral key]		ifFalse: [self browseMessageList: (aClass allLocalCallsOn: aLiteral) asSortedCollection					name: 'Senders of ' , aLiteral, ' local to ', aClass name					autoSelect: aLiteral keywords first]! !!SystemNavigation methodsFor: 'browse' stamp: 'tpr 12/17/2003 16:01'!browseAllCallsOnClass: aClass	"Create and schedule a message browser on each method that refers to 	aClass. For example, SystemNavigation new browseAllCallsOnClass: Object."	self		browseMessageList: aClass allCallsOn asSortedCollection		name: 'Users of class ' , aClass theNonMetaClass name		autoSelect: aClass theNonMetaClass name! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/19/2003 12:15'!browseAllImplementorsOf: selector 	"Create and schedule a message browser on each method that implements 	the message whose selector is the argument, selector. For example,  	Smalltalk browseAllImplementorsOf: #at:put:."	^ self		browseMessageList: (self allImplementorsOf: selector)		name: 'Implementors of ' , selector! !!SystemNavigation methodsFor: 'browse' stamp: 'nk 6/26/2003 22:31'!browseAllImplementorsOf: selector localTo: aClass	"Create and schedule a message browser on each method in or below the given class	that implements the message whose selector is the argument, selector. For example, 	SystemNavigation new browseAllImplementorsOf: #at:put: localTo: Dictionary."	aClass ifNil: [ ^self inform: 'no class selected' ].	^self browseMessageList: (self allImplementorsOf: selector localTo: aClass)		name: 'Implementors of ' , selector, ' local to ', aClass name! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/19/2003 12:15'!browseAllImplementorsOfList: selectorList title: aTitle 	"Create and schedule a message browser on each method that implements 	the message whose selector is in the argument selectorList. For 	example,  	self new browseAllImplementorsOf: #(at:put: size).  	1/16/96 sw: this variant adds the title argument.  	1/24/96 sw: use a SortedCollection  	2/1/96 sw: show normal cursor"	| implementorLists flattenedList |	implementorLists _ selectorList				collect: [:each | self allImplementorsOf: each].	flattenedList _ SortedCollection new.	implementorLists		do: [:each | flattenedList addAll: each].	Cursor normal show.	^ self browseMessageList: flattenedList name: aTitle! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 11:39'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock	"Bring up a list inspector on the objects that point to anObject.	If there are none, then evaluate aBlock on anObject.  "	| aList shortName |	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^ aBlock value: anObject].	shortName _ (anObject name ifNil: [anObject printString]) contractTo: 20.	OrderedCollectionInspector openOn: aList withEvalPane: false		withLabel: 'Objects pointing to ', shortName.! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/29/2003 20:43'!browseAllSelect: aBlock 	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result. For example,  	SystemNavigation new browseAllSelect: [:method | method numLiterals >  	10]."	^ self		browseMessageList: (self allMethodsSelect: aBlock)		name: 'selected messages'! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/29/2003 20:44'!browseAllSelect: aBlock name: aName autoSelect: autoSelectString 	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result. Do not return an  	#DoIt traces."	"self new browseAllSelect: [:method | method numLiterals > 10] name:  	'Methods with more than 10 literals' autoSelect: 'isDigit'"	^ self		browseMessageList: (self allMethodsNoDoitsSelect: aBlock)		name: aName		autoSelect: autoSelectString! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 08:53'!browseAllStoresInto: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."		"self new browseAllStoresInto: 'contents' from: Collection."	| coll |	coll _ OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsStoreInto: instVarName) do: [:sel |				sel == #DoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		].	].	^ self		browseMessageList: coll 		name: 'Stores into ' , instVarName 		autoSelect: instVarName! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 08:53'!browseClassCommentsWithString: aString	"Smalltalk browseClassCommentsWithString: 'my instances' "	"Launch a message list browser on all class comments containing aString as a substring."	| caseSensitive suffix list |	suffix _ (caseSensitive _ Sensor shiftPressed)		ifTrue: [' (case-sensitive)']		ifFalse: [' (use shift for case-sensitive)'].	list _ Set new.	Cursor wait showWhile: [		Smalltalk allClassesDo: [:class | 			(class organization classComment asString findString: aString 							startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [								list add: (									MethodReference new										setStandardClass: class										methodSymbol: #Comment								)							]		]	].	^ self 		browseMessageList: list asSortedCollection		name: 'Class comments containing ' , aString printString , suffix		autoSelect: aString! !!SystemNavigation methodsFor: 'browse' stamp: 'md 10/22/2003 16:20'!browseClassVarRefs: aClass	"Put up a menu offering all class variable names; if the user chooses one, open up a message-list browser on all methods 	that refer to the selected class variable"	| lines labelStream vars allVars index owningClasses |	lines _ OrderedCollection new.	allVars _ OrderedCollection new.	owningClasses _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	aClass withAllSuperclasses reverseDo:		[:class |		vars _ class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index _ (PopUpMenu labels: labelStream contents lines: lines) startUp.	index = 0 ifTrue: [^ self].	self browseAllCallsOn:		((owningClasses at: index) classPool associationAt: (allVars at: index))! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 3/28/2003 18:49'!browseClassVariables: aClass	aClass classPool inspectWithLabel: 'Class Variables in ' , aClass name! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 22:24'!browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "	"Launch a class-list list browser on all classes whose names containg aString as a substring."	| suffix aList |	suffix _ caseSensitive				ifTrue: [' (case-sensitive)']				ifFalse: [' (use shift for case-sensitive)'].	aList _ OrderedCollection new.	Cursor wait		showWhile: [Smalltalk				allClassesDo: [:class | (class name includesSubstring: aString caseSensitive: caseSensitive)						ifTrue: [aList add: class name]]].	aList size > 0		ifTrue: [ClassListBrowser new initForClassesNamed: aList asSet asSortedArray title: 'Classes whose names contain ' , aString , suffix]! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 16:08'!browseInstVarDefs: aClass	"Copied from browseInstVarRefs.  Should be consolidated some day. 7/29/96 di	7/30/96 sw: did the consolidation"	"Change to use SystemNavigation  27 March 2003 sd"	aClass chooseInstVarThenDo:			[:aVar | self browseAllStoresInto: aVar from: aClass]! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 16:08'!browseInstVarRefs: aClass	"1/16/96 sw: moved here from Browser so that it could be used from a variety of places.	 7/30/96 sw: call chooseInstVarThenDo: to get the inst var choice"	aClass chooseInstVarThenDo: 		[:aVar | self browseAllAccessesTo: aVar from: aClass]! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 09:18'!browseMessageList: messageList name: label 	"Create and schedule a MessageSet browser on messageList."	^ self   		browseMessageList: messageList 		name: label 		autoSelect: nil! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 08:48'!browseMessageList: messageList name: labelString autoSelect: autoSelectString	| title aSize |	"Create and schedule a MessageSet browser on the message list."	messageList size = 0 ifTrue: 		[^ (PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no' , labelString].	title _ (aSize _ messageList size) > 1		ifFalse:	[labelString]		ifTrue:	[ labelString, ' [', aSize printString, ']'].	MessageSet 		openMessageList: messageList 		name: title 		autoSelect: autoSelectString! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 22:46'!browseMethodsWhoseNamesContain: aString	"Launch a tool which shows all methods whose names contain the given string; case-insensitive.	1/16/1996 sw, at the dawn of Squeak: this was the classic implementation that provided the underpinning for the 'method names containing it' (cmd-shift-W) feature that has always been in Squeak -- the feature that later inspired the MethodFinder (aka SelectorBrowser).	sw 7/27/2001:	Switched to showing a MessageNames tool rather than a message-list browser, if in Morphic."	| aList |	Smalltalk isMorphic		ifFalse:			[aList _ Symbol selectorsContaining: aString.			aList size > 0 ifTrue:				[self browseAllImplementorsOfList: aList asSortedCollection title: 'Methods whose names contain ''', aString, '''']]		ifTrue:			[(MessageNames methodBrowserSearchingFor: aString) openInWorld]	! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/20/2003 14:11'!browseMethodsWithSourceString: aString 	"SystemNavigation new browseMethodsWithSourceString: 'SourceString'"	"Launch a browser on all methods whose source code contains aString as 	a substring."	| caseSensitive suffix |	suffix _ (caseSensitive _ Sensor shiftPressed)				ifTrue: [' (case-sensitive)']				ifFalse: [' (use shift for case-sensitive)'].	^ self		browseMessageList: (self allMethodsWithSourceString: aString matchCase: caseSensitive)		name: 'Methods containing ' , aString printString , suffix		autoSelect: aString! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 22:28'!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-insensitive, unless the shift key is pressed, in which case the search is case-sensitive."	'string for testing'.	^ self browseMethodsWithString: aString matchCase: Sensor shiftPressed	"SystemNavigation new browseMethodsWithString: 'Testing' matchCase: false"	"SystemNavigation new browseMethodsWithString: 'Testing' matchCase: true"! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 07:51'!browseMethodsWithString: aString matchCase: caseSensitive	"Launch a browser on all methods that contain string literals with aString as a substring. Make the search case-sensitive or insensitive as dictated by the caseSensitive boolean parameter"	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: aString caseSensitive: caseSensitive]]]		name:  'Methods with string ', aString printString, (caseSensitive ifTrue: [' (case-sensitive)'] ifFalse: [' (case-insensitive)'])		autoSelect: aString.! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 20:32'!browseObsoleteReferences  	"self new browseObsoleteReferences"	| references |	references _ OrderedCollection new.	(LookupKey allSubInstances select:		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:		['AnOb*' match: x value class name]]) 		do: [:x | references addAll: (self allCallsOn: x)].	self  		browseMessageList: references 		name: 'References to Obsolete Classes'! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 1/16/2004 21:09'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	"SystemNavigation default 		methodHierarchyBrowserForClass: ParagraphEditor 		selector: #isControlActive"		| list tab stab aClassNonMeta isMeta theClassOrMeta |	aClass ifNil: [^ self].	sel ifNil: [^ self].	aClassNonMeta _ aClass theNonMetaClass.	isMeta _ aClassNonMeta ~~ aClass.	list _ OrderedCollection new.	tab _ ''.	aClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	aClassNonMeta allSubclassesWithLevelDo:		[:cl :level |		theClassOrMeta _ isMeta ifTrue: [cl class] ifFalse: [cl].		(theClassOrMeta includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , theClassOrMeta name, ' ', sel]]	 	startingLevel: 0.	self browseMessageList: list name: 'Inheritance of ' , sel! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 1/16/2004 21:13'!spawnHierarchyForClass: aClass selector: aSelector	"Create and schedule a new class hierarchy browser on the requested class/selector."	"SystemNavigation default spawnHierarchyForClass: SmallInteger selector: #hash"		| newBrowser |	(aClass == nil)  ifTrue: [^ self].	(newBrowser _ Browser new) setClass: aClass selector: aSelector.	newBrowser spawnHierarchy.! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/17/2003 19:22'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: ProtoObject.	ProtoObject allSubclassesDoGently: aBlock.		"don't bring in ImageSegments"	"Classes outside the ProtoObject hierarchy"	Class subclassesDo: [:aClass |		(aClass == ProtoObject class			or: [aClass isInMemory not			or: [aClass isMeta not]]) ifFalse:			["Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDoGently: aBlock]].! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 11:48'!allCallsOn: aLiteral 	"Answer a Collection of all the methods that call on aLiteral even deeply embedded in 	literal array."	"self new browseAllCallsOn: #open:label:."	| aCollection special thorough aList byte |	aCollection _ OrderedCollection new.	special _ Smalltalk				hasSpecialSelector: aLiteral				ifTrueSetByte: [:b | byte _ b].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait		showWhile: [self				allBehaviorsDo: [:class | 					aList _ thorough								ifTrue: [class										thoroughWhichSelectorsReferTo: aLiteral										special: special										byte: byte]								ifFalse: [class										whichSelectorsReferTo: aLiteral										special: special										byte: byte].					aList						do: [:sel | sel == #DoIt								ifFalse: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 3/28/2003 17:44'!allCallsOn: aSymbol from: aClass	"Answer a SortedCollection of all the methods that call on aSymbol."	| aSortedCollection special byte |	aSortedCollection _ SortedCollection new.	special _ aClass environment hasSpecialSelector: aSymbol ifTrueSetByte: [:b | byte _ b ].	aClass withAllSubclassesDo: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte) do: [:sel |			sel == #DoIt ifFalse: [				aSortedCollection add: (					MethodReference new						setStandardClass: class 						methodSymbol: sel				)			]		]	].	^aSortedCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/17/2003 21:31'!allClasses	"currently returns all the classes defined in Smalltalk but could be customized 	for dealing with environments and in such a case would return on really all the classes"	^ Smalltalk allClasses	! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/17/2003 21:31'!allClassesDo: aBlock	"currently returns all the classes defined in Smalltalk but could be customized 	for dealing with environments and  in such a case would work on really all the classes"	^ Smalltalk allClassesDo: aBlock	! !!SystemNavigation methodsFor: 'query' stamp: 'nb 5/6/2003 16:57'!allClassesImplementing: aSelector  	"Answer an Array of all classes that implement the message aSelector."	| aCollection |	aCollection _ ReadWriteStream on: Array new.	self allBehaviorsDo:		[:class | (class includesSelector: aSelector)			ifTrue: [aCollection nextPut: class]].	^ aCollection contents! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 18:55'!allGlobalRefsWithout: classesAndMessagesPair 	"Answer a set of symbols that may be refs to Global names. In some  	sense we should only need the associations, but this will also catch, eg,  	HTML tag types. This method computes its result in the absence of  	specified classes and messages."	"may be a problem if namespaces are introduced as for the moment  	only Smalltalk is queried. sd 29/4/03"	| globalRefs absentClasses absentSelectors |	globalRefs _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | (absentSelectors isEmpty								ifTrue: [cl selectors]								ifFalse: [cl selectors copyWithoutAll: absentSelectors])								do: [:sel | "Include all capitalized symbols for good 									measure"									(cl compiledMethodAt: sel) literals										do: [:m | 											((m isMemberOf: Symbol)													and: [m size > 0															and: [m first isUppercase]])												ifTrue: [globalRefs add: m].											(m isMemberOf: Array)												ifTrue: [m														do: [:x | ((x isMemberOf: Symbol)																	and: [x size > 0																			and: [x first isUppercase]])																ifTrue: [globalRefs add: x]]].											m isVariableBinding												ifTrue: [m key														ifNotNil: [globalRefs add: m key]]]]]]].	^ globalRefs! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 18:55'!allImplementedMessagesWithout: classesAndMessagesPair 	"Answer a Set of all the messages that are implemented in the system,  	computed in the absence of the supplied classes and messages. Note this  	reports messages that are in the absent selectors set."	| messages absentClasses |	messages _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:. "sd 29/04/03" 	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | messages addAll: cl selectors]]].	^ messages! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/23/2003 22:31'!allImplementorsOf: aSelector 	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| aCollection |	aCollection _ SortedCollection new.	Cursor wait		showWhile: [self				allBehaviorsDo: [:class | (class includesSelector: aSelector)						ifTrue: [aCollection								add: (MethodReference new setStandardClass: class methodSymbol: aSelector)]]].	^ aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/20/2003 14:14'!allImplementorsOf: aSelector  localTo: aClass	"Answer a SortedCollection of all the methods that implement the message 	aSelector in, above, or below the given class."	| aSet cls |	aSet _ Set new.	cls _ aClass theNonMetaClass.	Cursor wait showWhile: [		cls withAllSuperAndSubclassesDoGently:			[:class |			(class includesSelector: aSelector)				ifTrue: [aSet add: class name, ' ', aSelector]].		cls class withAllSuperAndSubclassesDoGently:			[:class |			(class includesSelector: aSelector)				ifTrue: [aSet add: class name, ' ', aSelector]]	].	^aSet asSortedCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:42'!allMethodsNoDoitsSelect: aBlock 	"Like allSelect:, but strip out Doits"	| aCollection |	aCollection _ SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (sel ~~ #DoIt									and: [aBlock											value: (class compiledMethodAt: sel)])								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:41'!allMethodsSelect: aBlock 	"Answer a SortedCollection of each method that, when used as the block  	argument to aBlock, gives a true result."	| aCollection |	aCollection _ SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (aBlock									value: (class compiledMethodAt: sel))								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/20/2003 14:11'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"	| list classCount adder |	list _ Set new.	adder _ [ :mrClass :mrSel | list add: ( MethodReference new											setStandardClass: mrClass											methodSymbol: mrSel)].'Searching all source code...'displayProgressAt: Sensor cursorPointfrom: 0 to: Smalltalk classNames sizeduring:	[:bar | classCount _ 0.	Smalltalk allClassesDo:		[:class | bar value: (classCount _ classCount + 1).		(Array with: class with: class class) do:			[:cl | 				cl selectorsDo: [:sel | 					((cl sourceCodeAt: sel) findString: aString 						startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [							sel == #DoIt ifFalse: [adder value: cl value: sel]]].				(cl organization classComment asString findString: aString 						startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [							adder value: cl value: #Comment].			]]].	^ list asSortedCollection! !!SystemNavigation methodsFor: 'query' stamp: 'sd 5/5/2003 09:18'!allSelectorsWithAnyImplementorsIn: selectorList 	"Answer the subset of the given list which represent method selectors 	which have at least one implementor in the system."	| good |	good _ OrderedCollection new.	self allBehaviorsDo: [:class | selectorList				do: [:aSelector | (class includesSelector: aSelector)						ifTrue: [good add: aSelector]]].	^ good asSet asSortedArray" 	SystemNavigation new selectorsWithAnyImplementorsIn: #( contents 	contents: nuts)	"! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:12'!allSentMessages	"Answer the set of selectors which are sent somewhere in the system."	^ self  allSentMessagesWithout: {{}. {}}! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 19:10'!allSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors which are sent somewhere in the system,  	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | (absentSelectors isEmpty								ifTrue: [cl selectors]								ifFalse: [cl selectors copyWithoutAll: absentSelectors])								do: [:sel | "Include all sels, but not if sent by self"									(cl compiledMethodAt: sel) literals										do: [:m | 											(m isMemberOf: Symbol)												ifTrue: ["might be sent"													m == sel														ifFalse: [sent add: m]].											(m isMemberOf: Array)												ifTrue: ["might be performed"													m														do: [:x | (x isMemberOf: Symbol)																ifTrue: [x == sel																		ifFalse: [sent add: x]]]]]]]].			"The following may be sent without being in any literal frame"			1				to: Smalltalk specialSelectorSize				do: [:index | sent						add: (Smalltalk specialSelectorAt: index)]].	Smalltalk presumedSentMessages		do: [:sel | sent add: sel].	^ sent! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:12'!allUnSentMessages	"SystemNavigation new allUnSentMessages"	"Answer the set of selectors that are implemented by some object in the  	system but not sent by any."	^ self allUnSentMessagesWithout: {{}. {}}! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:13'!allUnSentMessagesIn: selectorSet 	"Answer the subset of selectorSet which are not sent anywhere in the 	system. "	^ selectorSet copyWithoutAll: self allSentMessages! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 19:19'!allUnSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors that are implemented but not sent, computed  	in the absence of the supplied classes and messages."	^ (self  allImplementedMessagesWithout: classesAndMessagesPair)		copyWithoutAll: (self  allSentMessagesWithout: classesAndMessagesPair)! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 13:07'!allUnreferencedClassVariablesOf: aClass	"Answer a list of the names of all the receiver's unreferenced class  	vars, including those defined in superclasses"	| aList |	aList _ OrderedCollection new.	aClass withAllSuperclasses		reverseDo: [:aSuperClass | aSuperClass classVarNames				do: [:var | (self allCallsOn: (aSuperClass classPool associationAt: var)) isEmpty						ifTrue: [aList add: var]]].	^ aList! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 19:06'!allUnusedClassesWithout: classesAndMessagesPair 	"Enumerates all classes in the system and returns a list of those that are 	apparently unused. A class is considered in use if it (a) has subclasses  	or (b) is referred to by some method or (c) has its name in use as a  	literal."	"SystemNavigation new unusedClasses"	| unused cl |	unused _ Smalltalk classNames asIdentitySet				copyWithoutAll: (self allGlobalRefsWithout: classesAndMessagesPair).	^ unused		reject: [:cName | 			cl _ Smalltalk at: cName.			cl subclasses isEmpty not				or: [cl inheritsFrom: FileDirectory]]! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/20/2003 14:27'!numberOfImplementorsOf: aSelector 	"Answer a count of the implementors of the given selector found in the  	system"	"self new numberOfImplementorsOf: #contents.  	self new numberOfImplementorsOf: #nobodyImplementsThis.  	self new numberOfimplementorsOf: #numberOfImplementorsOf:."	| aCount |	aCount _ 0.	self		allBehaviorsDo: [:class | (class includesSelector: aSelector)				ifTrue: [aCount _ aCount + 1]].	^ aCount! !!SystemNavigation methodsFor: 'ui' stamp: 'sd 4/29/2003 11:59'!confirmRemovalOf: aSelector on: aClass 	"Determine if it is okay to remove the given selector. Answer 1 if it  	should be removed, 2 if it should be removed followed by a senders  	browse, and 3 if it should not be removed."	| count aMenu answer caption allCalls |	allCalls _ self allCallsOn: aSelector.	(count _ allCalls size) == 0		ifTrue: [^ 1].	"no senders -- let the removal happen without warning"	count == 1		ifTrue: [(allCalls first actualClass == aClass					and: [allCalls first methodSymbol == aSelector])				ifTrue: [^ 1]].	"only sender is itself"	aMenu _ PopUpMenu labels: 'Remove itRemove, then browse sendersDon''t remove, but show me those sendersForget it -- do nothing -- sorry I asked'.	caption _ 'This message has ' , count printString , ' sender'.	count > 1		ifTrue: [caption _ caption copyWith: $s].	answer _ aMenu startUpWithCaption: caption.	answer == 3		ifTrue: [self				browseMessageList: allCalls				name: 'Senders of ' , aSelector				autoSelect: aSelector keywords first].	answer == 0		ifTrue: [answer _ 3].	"If user didn't answer, treat it as cancel"	^ answer min: 3! !!SystemNavigation methodsFor: 'ui' stamp: 'sd 4/15/2003 15:34'!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock	"Show a sorted menu of the given selectors, preceded by firstItem, and all	abbreviated to 40 characters.  Evaluate choiceBlock if a message is chosen."	^ self showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock withCaption: nil! !!SystemNavigation methodsFor: 'ui' stamp: 'sd 4/15/2003 15:35'!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock withCaption: aCaption	"Show a sorted menu of the given selectors, preceded by firstItem, and all abbreviated to 40 characters.  Use aCaption as the menu title, if it is not nil.  Evaluate choiceBlock if a message is chosen."	| index menuLabels sortedList aMenu |	sortedList _ selectorCollection asSortedCollection.	menuLabels _ String streamContents: 		[:strm | strm nextPutAll: (firstItem contractTo: 40).		sortedList do: [:sel | strm cr; nextPutAll: (sel contractTo: 40)]].	aMenu _ PopUpMenu labels: menuLabels lines: #(1).	index _ aCaption ifNotNil: [aMenu startUpWithCaption: aCaption] ifNil: [aMenu startUp].	index = 1 ifTrue: [choiceBlock value: firstItem].	index > 1 ifTrue: [choiceBlock value: (sortedList at: index - 1)]! !!SystemNavigation methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 15:47'!browseClass: aBehavior	| targetClass |	self browserClass ifNil: [self error: 'No browser installed:'].	targetClass := aBehavior isMeta				ifTrue: [aBehavior theNonMetaClass]				ifFalse: [aBehavior ].	self browserClass newOnClass: targetClass! !!SystemNavigation methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 15:51'!browseHierarchy: aBehavior	| targetClass |	self hierarchyBrowserClass ifNil: [self error: 'No hierarchy browser installed:'].	targetClass := aBehavior isMeta				ifTrue: [aBehavior theNonMetaClass]				ifFalse: [aBehavior ].	self hierarchyBrowserClass newFor: targetClass! !!SystemNavigation methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 15:46'!browserClass	browserClass ifNil: [browserClass := self defaultBrowserClass].	^browserClass! !!SystemNavigation methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 15:50'!defaultBrowserClass	^self class environment at: #Browser ifAbsent:[]! !!SystemNavigation methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 15:49'!defaultHierarchyBrowserClass	^self class environment at: #HierarchyBrowser ifAbsent:[]! !!SystemNavigation methodsFor: '*tools-browser' stamp: 'mu 3/11/2004 15:50'!hierarchyBrowserClass	hierarchyBrowserClass ifNil: [hierarchyBrowserClass := self defaultHierarchyBrowserClass].	^hierarchyBrowserClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemNavigation class	instanceVariableNames: ''!!SystemNavigation class methodsFor: 'as yet unclassified' stamp: 'dvf 8/23/2003 12:25'!default	Default isNil ifTrue: [Default _ self new].	^Default! !Categorizer subclass: #SystemOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!SystemOrganizer commentStamp: '<historical>' prior: 0!My instances provide an organization for the classes in the system, just as a ClassOrganizer organizes the messages within a class. The only difference is the methods for fileIn/Out.!!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 8/16/2000 10:03'!fileOut  "SystemOrganization fileOut"	(FileStream newFileNamed:		(FileDirectory default nextNameFor: 'SystemOrganization' extension: 'st'))		nextPutAll: 'SystemOrganization changeFromCategorySpecs: #('; cr;		print: SystemOrganization;  "ends with a cr"		nextPutAll: ')!!'; cr;		close.! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 19:01'!fileOutCategory: category 	"Store on the file named category (a string) concatenated with '.st' all the 	classes associated with the category."	^ self fileOutCategory: category asHtml: false! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'jf 2/7/2004 17:24'!fileOutCategory: category asHtml: useHtml	"FileOut all the classes in the named system category."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: category asFileName, '.html') asHtml]		ifFalse: [FileStream newFileNamed: category asFileName , '.st'].	self fileOutCategory: category on: fileStream initializing: true.	fileStream close! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:28'!fileOutCategory: category on: aFileStream 	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools."	^self fileOutCategory: category on: aFileStream initializing: true! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:28'!fileOutCategory: category on: aFileStream initializing: aBool	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools."	| first poolSet tempClass classes |	classes _ (self superclassOrder: category).	poolSet _ Set new.	classes do: 		[:class | class sharedPools do: [:eachPool | poolSet add: eachPool]].	poolSet size > 0 ifTrue:		[tempClass _ Class new.		tempClass shouldFileOutPools ifTrue:			[poolSet _ poolSet select: [:aPool | tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].	first _ true.	classes do: 		[:class | 		first			ifTrue: [first _ false]			ifFalse: [aFileStream cr; nextPut: Character newPage; cr].		class			fileOutOn: aFileStream			moveSource: false			toFile: 0			initializing: false].	aBool ifTrue:[classes do:[:cls| cls fileOutInitializerOn: aFileStream]].! !!SystemOrganizer methodsFor: 'fileIn/Out'!superclassOrder: category 	"Answer an OrderedCollection containing references to the classes in the 	category whose name is the argument, category (a string). The classes 	are ordered with superclasses first so they can be filed in."	| list |	list _ 		(self listAtCategoryNamed: category asSymbol) 			collect: [:title | Smalltalk at: title].	^ChangeSet superclassOrder: list! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 3/3/2001 16:07'!categoriesMatching: matchString	"Return all matching categories"	^ self categories select: [:c | matchString match: c]! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 3/3/2001 16:08'!removeCategoriesMatching: matchString	"Remove all matching categories with their classes"	(self categoriesMatching: matchString) do:		[:c | self removeSystemCategory: c]! !!SystemOrganizer methodsFor: 'remove' stamp: 'jm 5/20/1998 19:38'!removeMissingClasses	"Remove any class names that are no longer in the Smalltalk dictionary. Used for cleaning up after garbage collecting user-generated classes."	"SystemOrganization removeMissingClasses"	elementArray copy do: [:el |		(Smalltalk includesKey: el) ifFalse: [self removeElement: el]].! !!SystemOrganizer methodsFor: 'remove' stamp: 'jf 8/1/2003 09:02'!removeSystemCategory: category	"remove all the classes associated with the category"	(self superclassOrder: category) reverseDo: [:class | class removeFromSystem].	self removeCategory: category.! !!SystemOrganizer methodsFor: 'private' stamp: 'rw 7/31/2003 17:23'!ifClassOrganizerDo: aBlock	"Do nothing, since this is not a class organizer"! !Object subclass: #SystemVersion	instanceVariableNames: 'version date highestUpdate updates'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'System-Support'!!SystemVersion methodsFor: 'accessing'!date	^date! !!SystemVersion methodsFor: 'accessing' stamp: 'mir 5/1/2001 18:19'!datedVersion	"Answer the version of this release."	^ self version asString , ' of ' , self date printString! !!SystemVersion methodsFor: 'accessing' stamp: 'mir 3/29/2001 18:03'!highestUpdate	| sortedUpdates |	highestUpdate ifNil: [		sortedUpdates _ self updates asSortedCollection.		highestUpdate _ (sortedUpdates isEmpty			ifTrue: [0]			ifFalse: [sortedUpdates last])].	^highestUpdate! !!SystemVersion methodsFor: 'accessing'!unregisterUpdate: update	self updates remove: update ifAbsent: []! !!SystemVersion methodsFor: 'accessing'!updates	^updates! !!SystemVersion methodsFor: 'accessing'!version	^version! !!SystemVersion methodsFor: 'initialize'!initialize	version _ 'No version set'.	date _ Date today.	updates _ Set new.! !!SystemVersion methodsFor: 'printing' stamp: 'mir 5/1/2001 18:20'!printOn: stream	stream		nextPutAll: self datedVersion;		nextPutAll: ' update ' , self highestUpdate printString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemVersion class	instanceVariableNames: ''!!SystemVersion class methodsFor: 'accessing'!current	Current ifNil: [Current _ SystemVersion new].	^Current! !VariableNode subclass: #TempVariableNode	instanceVariableNames: 'isAnArg hasRefs hasDefs scope'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!TempVariableNode commentStamp: '<historical>' prior: 0!I am a parse tree leaf representing a temporary variable!!TempVariableNode methodsFor: 'initialize-release'!isArg: aBoolean	isAnArg _ aBoolean.	isAnArg ifTrue: [hasDefs _ true]! !!TempVariableNode methodsFor: 'initialize-release'!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	name _ varName.	self key: varName		index: i		type: type.	isAnArg _ hasDefs _ hasRefs _ false.	scope _ level! !!TempVariableNode methodsFor: 'initialize-release'!nowHasDef	hasDefs _ true! !!TempVariableNode methodsFor: 'initialize-release'!nowHasRef	hasRefs _ true! !!TempVariableNode methodsFor: 'initialize-release'!scope: level	"Note scope of temporary variables.	Currently only the following distinctions are made:		0	outer level: args and user-declared temps		1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	scope _ level! !!TempVariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	isAnArg ifTrue: [^ location]			ifFalse: [^ -1]! !!TempVariableNode methodsFor: 'testing'!isTemp	^ true! !!TempVariableNode methodsFor: 'testing'!isUndefTemp	^ hasDefs not! !!TempVariableNode methodsFor: 'testing'!isUnusedTemp	^ hasRefs not! !!TempVariableNode methodsFor: 'testing'!scope	^ scope! !!TempVariableNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printOn: aStream indent: level 	aStream withStyleFor: #temporaryVariable			do: [aStream nextPutAll: name]! !ArrayedCollection subclass: #Text	instanceVariableNames: 'string runs'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Collections-Text'!!Text commentStamp: '<historical>' prior: 0!I represent a character string that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set of TextAttributes with each character in its character string.  These attributes may be font numbers, emphases such as bold or italic, or hyperling actions.  Font numbers are interpreted relative to whatever textStyle appears, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.  Each of my instances has	string		a String	runs		a RunArray!]style[(148 9 97 13 237 9 163 6 10 8)f1,f1LTextStyle Comment;,f1,f1LTextAttribute Hierarchy;,f1,f1LParagraph Comment;,f1,f1LString Comment;,f1,f1LRunArray Comment;!!Text methodsFor: 'accessing' stamp: 'tk 9/4/2000 16:04'!append: stringOrText	self replaceFrom: string size + 1				to: string size with: stringOrText! !!Text methodsFor: 'accessing'!at: index	^string at: index! !!Text methodsFor: 'accessing'!at: index put: character	^string at: index put: character! !!Text methodsFor: 'accessing' stamp: 'gm 2/15/2003 14:59'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs := IdentitySet new.	runs withStartStopAndValueDo: 			[:start :stop :attribs | 			attribs 				do: [:attrib | attrib anchoredMorph ifNotNil: [morphs add: attrib anchoredMorph]]].	^morphs select: [:m | m isMorph]! !!Text methodsFor: 'accessing' stamp: 'gm 2/15/2003 14:59'!embeddedMorphsFrom: start to: stop 	"return the list of morphs embedded in me"	| morphs |	morphs := IdentitySet new.	runs 		runsFrom: start		to: stop		do: 			[:attribs | 			attribs 				do: [:attr | attr anchoredMorph ifNotNil: [morphs add: attr anchoredMorph]]].	^morphs select: [:m | m isMorph]! !!Text methodsFor: 'accessing'!findString: aString startingAt: start 	"Answer the index of subString within the receiver, starting at index 	start. If the receiver does not contain subString, answer 0."	^string findString: aString asString startingAt: start! !!Text methodsFor: 'accessing' stamp: 'di 11/23/1998 11:53'!findString: aString startingAt: start caseSensitive: caseSensitive	"Answer the index of subString within the receiver, starting at index 	start. If the receiver does not contain subString, answer 0."	^string findString: aString asString startingAt: start caseSensitive: caseSensitive! !!Text methodsFor: 'accessing' stamp: 'tk 9/6/2000 12:33'!lineCount	^ string lineCount! !!Text methodsFor: 'accessing' stamp: 'ar 12/27/2001 00:03'!prepend: stringOrText	self replaceFrom: 1 to: 0 with: stringOrText! !!Text methodsFor: 'accessing' stamp: 'BG 6/8/2003 16:18'!rangeOf: attribute startingAt: index"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index.  "   ^string size = 0      ifTrue: [index to: index - 1]	 ifFalse: [runs rangeOf: attribute startingAt: index]! !!Text methodsFor: 'accessing' stamp: 'md 12/12/2003 17:03'!rangeOf: attribute startingAt: index forStyle: aTextStyle"aTextStyle is not really needed, it is kept for compatibility with an earlier method version "	self deprecated: 'Use Text>>rangeOf:startingAt: instead.'.	^self rangeOf: attribute startingAt: index! !!Text methodsFor: 'accessing' stamp: 'tk 12/30/97 07:17'!replaceFrom: start to: stop with: aText	| txt |	txt _ aText asText.	"might be a string"	string _ string copyReplaceFrom: start to: stop with: txt string.	runs _ runs copyReplaceFrom: start to: stop with: txt runs! !!Text methodsFor: 'accessing'!size	^string size! !!Text methodsFor: 'accessing'!string	"Answer the string representation of the receiver."	^string! !!Text methodsFor: 'comparing' stamp: 'tk 10/19/2001 17:48'!= other	"Am I equal to the other Text or String?  	***** Warning ***** Two Texts are considered equal if they have the same characters in them.  They might have completely different emphasis, fonts, sizes, text actions, or embedded morphs.  If you need to find out if one is a true copy of the other, you must do (text1 = text2 and: [text1 runs = text2 runs])."	other isText ifTrue:	["This is designed to run fast even for megabytes"				^ string == other string or: [string = other string]].	other isString ifTrue: [^ string == other or: [string = other]].	^ false! !!Text methodsFor: 'comparing' stamp: 'tk 10/17/2001 14:12'!hash	"#hash is implemented, because #= is implemented.  We are now equal to a string with the same characters.  Hash must reflect that."	^ string hash! !!Text methodsFor: 'comparing' stamp: 'tk 9/6/2000 11:59'!howManyMatch: aString	^ self string howManyMatch: aString! !!Text methodsFor: 'comparing'!isText	^ true! !!Text methodsFor: 'copying'!copy	^ self class new setString: string copy setRuns: runs copy! !!Text methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copied subrange of the receiver."	| realStart realStop |	stop > self size		ifTrue: [realStop _ self size]		"handle selection at end of string"		ifFalse: [realStop _ stop].	start < 1		ifTrue: [realStart _ 1]			"handle selection before start of string"		ifFalse: [realStart _ start].	^Text 		string: (string copyFrom: realStart to: realStop)		runs: (runs copyFrom: realStart to: realStop)! !!Text methodsFor: 'copying'!copyReplaceFrom: start to: stop with: aText	^self shallowCopy replaceFrom: start to: stop with: aText! !!Text methodsFor: 'copying' stamp: 'tk 1/7/98 10:58'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!Text methodsFor: 'copying' stamp: 'di 11/9/97 17:13'!deepCopy	^ self copy "Both string and runs are assumed to be read-only"! !!Text methodsFor: 'converting'!asDisplayText	"Answer a DisplayText whose text is the receiver."	^DisplayText text: self! !!Text methodsFor: 'converting'!asNumber	"Answer the number created by interpreting the receiver as the textual 	representation of a number."	^string asNumber! !!Text methodsFor: 'converting'!asParagraph	"Answer a Paragraph whose text is the receiver."	^Paragraph withText: self! !!Text methodsFor: 'converting'!asString	"Answer a String representation of the textual receiver."	^string! !!Text methodsFor: 'converting' stamp: 'RAA 5/28/2001 06:19'!asStringOrText		"Answer the receiver itself."	^self! !!Text methodsFor: 'converting'!asText		"Answer the receiver itself."	^self! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:20'!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!Text methodsFor: 'converting' stamp: 'bf 3/9/2000 18:25'!isoToSqueak	^ self class new setString: string isoToSqueak setRuns: runs copy! !!Text methodsFor: 'converting' stamp: 'ar 12/17/2001 00:38'!removeAttributesThat: removalBlock replaceAttributesThat: replaceBlock by: convertBlock	"Enumerate all attributes in the receiver. Remove those passing removalBlock and replace those passing replaceBlock after converting it through convertBlock"	| added removed new |	"Deliberately optimized for the no-op default."	added _ removed _ nil.	runs withStartStopAndValueDo: [ :start :stop :attribs | 		attribs do: [ :attrib |			(removalBlock value: attrib) ifTrue:[				removed ifNil:[removed _ WriteStream on: #()].				removed nextPut: {start. stop. attrib}.			] ifFalse:[				(replaceBlock value: attrib) ifTrue:[					removed ifNil:[removed _ WriteStream on: #()].					removed nextPut: {start. stop. attrib}.					new _ convertBlock value: attrib.					added ifNil:[added _ WriteStream on: #()].					added nextPut: {start. stop. new}.				].			].		].	].	(added == nil and:[removed == nil]) ifTrue:[^self].	"otherwise do the real work"	removed ifNotNil:[removed contents do:[:spec|		self removeAttribute: spec last from: spec first to: spec second]].	added ifNotNil:[added contents do:[:spec|		self addAttribute: spec last from: spec first to: spec second]].! !!Text methodsFor: 'converting' stamp: 'dvf 10/1/2003 02:58'!replaceFrom: start to: stop with: replacement startingAt: repStart 
	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. Do it to both the string and the runs."

	| rep newRepRuns |
	rep _ replacement asText.	"might be a string"
	string replaceFrom: start to: stop with: rep string startingAt: repStart.
	newRepRuns _ rep runs copyFrom: repStart to: repStart + stop - start.	runs _ runs copyReplaceFrom: start to: stop with: newRepRuns! !!Text methodsFor: 'converting' stamp: 'BG 6/8/2003 16:38'!reversed

	"Answer a copy of the receiver with element order reversed."

	^ self class string: string reversed runs: runs reversed.

  "  It is assumed that  self size = runs size  holds. "! !!Text methodsFor: 'converting' stamp: 'bf 3/9/2000 18:25'!squeakToIso	^ self class new setString: string squeakToIso setRuns: runs copy! !!Text methodsFor: 'converting' stamp: 'nk 9/16/2003 16:46'!withSqueakLineEndings	"Answer a copy of myself in which all sequences of <CR><LF> or <LF> have been changed to <CR>"	| newText |	(string includes: Character lf) ifFalse: [ ^self copy ].	newText _ self copyReplaceAll: String crlf with: String cr asTokens: false.	(newText asString includes: Character lf) ifFalse: [ ^newText ].	^newText copyReplaceAll: String lf with: String cr asTokens: false.! !!Text methodsFor: 'emphasis'!addAttribute: att 	^ self addAttribute: att from: 1 to: self size! !!Text methodsFor: 'emphasis'!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])! !!Text methodsFor: 'emphasis' stamp: 'ar 12/17/2001 23:48'!alignmentAt: characterIndex ifAbsent: aBlock	| attributes emph |	self size = 0 ifTrue: [^aBlock value].	emph _ nil.	attributes _ runs at: characterIndex.	attributes do:[:att | (att isKindOf: TextAlignment) ifTrue:[emph _ att]].	^ emph ifNil: aBlock ifNotNil:[emph alignment]! !!Text methodsFor: 'emphasis'!allBold 	"Force this whole text to be bold."	string size = 0 ifTrue: [^self].	self makeBoldFrom: 1 to: string size! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 12:30'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this"	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes _ runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'ar 12/17/2001 01:17'!attributesAt: characterIndex do: aBlock	"Answer the code for characters in the run beginning at characterIndex."	"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this"	self size = 0 ifTrue:[^self].	(runs at: characterIndex) do: aBlock! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 11:32'!attributesAt: characterIndex forStyle: aTextStyle	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: aTextStyle defaultFontIndex)].  "null text tolerates access"	attributes _ runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'di 4/1/1999 15:17'!emphasisAt: characterIndex	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes emph |	self size = 0 ifTrue: [^ 0].	"null text tolerates access"	emph _ 0.	attributes _ runs at: characterIndex.	attributes do: 		[:att | emph _ emph bitOr: att emphasisCode].	^ emph	! !!Text methodsFor: 'emphasis' stamp: 'di 11/10/97 13:36'!find: attribute	"Return the first interval over which this attribute applies"	| begin end |	begin _ 0.	runs withStartStopAndValueDo:		[:start :stop :attributes |		(attributes includes: attribute)			ifTrue: [begin = 0 ifTrue: [begin _ start].					end _ stop]			ifFalse: [begin > 0 ifTrue: [^ begin to: end]]].	begin > 0 ifTrue: [^ begin to: end].	^ nil! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 10:58'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle defaultFont].	"null text tolerates access"	attributes _ runs at: characterIndex.	font _ aTextStyle defaultFont.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font! !!Text methodsFor: 'emphasis'!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes _ runs at: characterIndex.	fontNumber _ 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber _ att fontNumber]].	^ fontNumber	! !!Text methodsFor: 'emphasis'!makeBoldFrom: start to: stop	^ self addAttribute: TextEmphasis bold from: start to: stop! !!Text methodsFor: 'emphasis' stamp: 'ar 6/28/2003 00:06'!makeSelectorBold	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser i |	string size = 0 ifTrue: [^ self].	i _ 0.	[(string at: (i _ i + 1)) isSeparator] whileTrue.	(string at: i) = $[ ifTrue: [^ self].  "block, no selector"	(parser _ Compiler parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis' stamp: 'sma 2/5/2000 12:03'!makeSelectorBoldIn: aClass	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser |	string size = 0 ifTrue: [^self].	(parser _ aClass parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis'!removeAttribute: att from: start to: stop 	"Remove the attribute over the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | attributes copyWithout: att])! !!Text methodsFor: 'emphasis'!runLengthFor: characterIndex 	"Answer the count of characters remaining in run beginning with 	characterIndex."	^runs runLengthAt: characterIndex! !!Text methodsFor: 'printing' stamp: 'sma 6/1/2000 09:49'!printOn: aStream	self printNameOn: aStream.	aStream nextPutAll: ' for '; print: string! !!Text methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(Text string: ';		store: string;		nextPutAll: ' runs: ';		store: runs;		nextPut: $)! !!Text methodsFor: 'private'!runs	^runs! !!Text methodsFor: 'private'!setString: aString setRuns: anArray	string _ aString.	runs _ anArray! !!Text methodsFor: 'private' stamp: 'tk 12/16/97 14:14'!setString: aString setRunsChecking: aRunArray	"Check runs and do the best you can to make them fit..."	string _ aString.	"check the runs"	aRunArray ifNil: [^ aString asText].	(aRunArray isKindOf: RunArray) ifFalse: [^ aString asText].	aRunArray runs size = aRunArray values size ifFalse: [^ aString asText].	(aRunArray values includes: #()) ifTrue: [^ aString asText].	"not allowed?"	aRunArray size = aString size ifFalse: [^ aString asText].		runs _ aRunArray.! !!Text methodsFor: 'attributes' stamp: 'tk 2/27/2001 08:20'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	(Preferences browseWithPrettyPrint and: [Preferences colorWhenPrettyPrinting])		ifTrue: [self couldDeriveFromPrettyPrinting ifTrue: [^ self asString]].	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old _ priorMethod getSourceFromFile].	(old == nil or: [old unembellished])		ifTrue:			[tell _ 'This method contains style for the first time (e.g. bold or colored text).Do you really want to save the style info?'.			answ _ (PopUpMenu labels: 'Save method with styleSave method simply')						startUpWithCaption: tell.			answ = 2 ifTrue: [^ self asString]]! !!Text methodsFor: 'attributes' stamp: 'tk 11/1/2001 14:37'!basicType	"Answer a symbol representing the inherent type I hold"	"Number String Boolean player collection sound color etc"	^ #Text! !!Text methodsFor: 'attributes' stamp: 'sw 11/16/1999 22:33'!couldDeriveFromPrettyPrinting	"Return true if the receiver has any TextAttributes that are functional rather than simply appearance-related"	runs values do:		[:emphArray | emphArray do:			[:emph | emph couldDeriveFromPrettyPrinting ifFalse: [^ false]]].	^ true! !!Text methodsFor: 'attributes' stamp: 'sw 12/7/1999 12:31'!unembellished 	"Return true if the only emphases are the default font and bold"	| font1 bold |	font1 _ TextFontChange defaultFontChange.	bold _ TextEmphasis bold.	Preferences ignoreStyleIfOnlyBold ifFalse:		["Ignore font1 only or font1-bold followed by font1-plain"		^ (runs values = (Array with: (Array with: font1)))		or: [runs values = (Array with: (Array with: font1 with: bold) 								with: (Array with: font1))]].	"If preference is set, then ignore any combo of font1 and bold"	runs withStartStopAndValueDo:		[:start :stop :emphArray |		emphArray do:			[:emph | (font1 = emph or: [bold = emph]) ifFalse: [^ false]]].	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Text class	instanceVariableNames: ''!!Text class methodsFor: 'class initialization' stamp: 'sw 5/23/2001 14:11'!initTextConstants 	"Initialize constants shared by classes associated with text display, e.g., 	Space, Tab, Cr, Bs, ESC."		"1/24/96 sw: in exasperation and confusion, changed cmd-g mapping from 231 to 232 to see if I could gain any relief?!!"	| letter varAndValue tempArray width |	"CtrlA..CtrlZ, Ctrla..Ctrlz"	letter _ $A. 	#(		212 230 228 196 194 226 241 243 214 229 200 217 246 			245 216 202 210 239 211 240 197 198 209 215 242 231	 		1 166 228 132 130 12 232 179 150 165 136 153 182 			14 15 138 17 18 19 11 21 134 145 151 178 167 ) do:		[:kbd |		TextConstants at: ('Ctrl', letter asSymbol) asSymbol put: kbd asCharacter.		letter _ letter == $Z ifTrue: [$a] ifFalse: [(letter asciiValue + 1) asCharacter]].	varAndValue _ #(		Space	32		Tab		9		CR		13		Enter	3		BS		8		BS2		158		ESC		160		Clear 	173	).	varAndValue size odd ifTrue: [self error: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i) asCharacter].	varAndValue _ #(		CtrlDigits 			(159 144 143 128 127 129 131 180 149 135)		CtrlOpenBrackets	(201 7 218 249 219 15)			"lparen gottn by ctrl-_ = 201; should be 213 but can't type that on Mac"			"location of non-character stop conditions"		EndOfRun	257		CrossedX	258			"values for alignment"		LeftFlush	0		RightFlush	1		Centered	2		Justified	3			"subscripts for a marginTabsArray tuple"		LeftMarginTab	1		RightMarginTab	2			"font faces"		Basal	0		Bold	1		Italic	2			"in case font doesn't have a width for space character"			"some plausible numbers-- are they the right ones?"		DefaultSpace			4		DefaultTab				24		DefaultLineGrid			16		DefaultBaseline			12		DefaultFontFamilySize	3	"basal, bold, italic"	).	varAndValue size odd ifTrue: [self error: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i)].	TextConstants at: #DefaultRule	put: Form over.	TextConstants at: #DefaultMask	put: Color black.	width _ Display width max: 720.	tempArray _ Array new: width // DefaultTab.	1 to: tempArray size do:		[:i | tempArray at: i put: DefaultTab * i].	TextConstants at: #DefaultTabsArray put: tempArray.	tempArray _ Array new: (width // DefaultTab) // 2.	1 to: tempArray size do:		[:i | tempArray at: i put: (Array with: (DefaultTab*i) with: (DefaultTab*i))].	TextConstants at: #DefaultMarginTabsArray put: tempArray."Text initTextConstants "! !!Text class methodsFor: 'class initialization'!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextConstants at: #CaretForm put:				(Form extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -3@0).	self initTextConstants! !!Text class methodsFor: 'instance creation' stamp: 'sw 12/6/1999 14:14'!fromString: aString 	"Answer an instance of me whose characters are those of the argument, aString."	^ self string: aString attribute: (TextFontChange fontNumber: TextStyle default defaultFontIndex)! !!Text class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 06:54'!fromUser	"Answer an instance of me obtained by requesting the user to type a string."	"Text fromUser"	^ self fromString:		(FillInTheBlank request: 'Enter text followed by carriage return')! !!Text class methodsFor: 'instance creation'!new: stringSize	^self fromString: (String new: stringSize)! !!Text class methodsFor: 'instance creation'!streamContents: blockWithArg 	| stream |	stream _ TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents! !!Text class methodsFor: 'instance creation'!string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute."	^self string: aString attributes: (Array with: att)! !!Text class methodsFor: 'instance creation'!string: aString attributes: atts	"Answer an instance of me whose characters are those of aString.	atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)! !!Text class methodsFor: 'instance creation'!string: aString emphasis: emphasis	"This is an old method that is mainly used by old applications"	emphasis isNumber ifTrue:		[self halt: 'Numeric emphasis is not supported in Squeak'.		"But if you proceed, we will do our best to give you what you want..."		^ self string: aString runs: (RunArray new: aString size withAll: 			(Array with: (TextFontChange new fontNumber: emphasis)))].	^ self string: aString attributes: emphasis! !!Text class methodsFor: 'private' stamp: 'di 10/31/97 11:22'!addAttribute: att toArray: others 	"Add a new text attribute to an existing set"	"NOTE: The use of reset and set in this code is a specific	hack for merging TextKerns."	att reset.	^ Array streamContents:		[:strm | others do:			[:other | (att dominates: other) ifFalse: [strm nextPut: other]].		att set ifTrue: [strm nextPut: att]]! !!Text class methodsFor: 'private'!string: aString runs: anArray 	^self basicNew setString: aString setRuns: anArray! !TextAttribute subclass: #TextAction	instanceVariableNames: ''	classVariableNames: 'Purple'	poolDictionaries: ''	category: 'Collections-Text'!!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:44'!analyze: aString	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:3+4<3+4>Click Here<3+4><3+4>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim param show |	b1 _ aString indexOf: $<.	b2 _ aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		param _ self validate: aString.		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].	"Two parts"	trim _ aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] ifFalse: [param]]			ifFalse: ["at the front"				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				show _ nil]].	^ Array with: param with: show! !!TextAction methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !!TextAction methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:11'!dominatedByCmd0	"Cmd-0 should turn off active text"	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Purple! !!TextAction methodsFor: 'as yet unclassified' stamp: 'DSM 3/30/1999 13:15'!info	^ 'no hidden info'! !!TextAction methodsFor: 'as yet unclassified'!mayActOnClick	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:48'!validate: aString	"any format is OK with me"	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextAction class	instanceVariableNames: ''!!TextAction class methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!initialize   "TextAction initialize"	Purple _ Color r: 0.4 g: 0 b: 1.0! !TextAttribute subclass: #TextAlignment	instanceVariableNames: 'alignment'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/15/2001 23:33'!= other 	^ (other class == self class) 		and: [other alignment = alignment]! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/15/2001 23:33'!alignment	^alignment! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/15/2001 23:33'!alignment: aNumber	alignment _ aNumber.! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/16/2001 00:20'!dominates: other	"There can be only one..."	^self class == other class! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/15/2001 23:34'!emphasizeScanner: scanner	"Set the emphasist for text scanning"	scanner setAlignment: alignment.! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 9/9/2003 22:03'!hash	"#hash is re-implemented because #= is re-implemented"	^ alignment hash! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/16/2001 01:55'!writeScanOn: strm	strm nextPut: $a.	alignment printOn: strm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextAlignment class	instanceVariableNames: ''!!TextAlignment class methodsFor: 'instance creation' stamp: 'ar 12/15/2001 23:36'!centered	^self new alignment: 2! !!TextAlignment class methodsFor: 'instance creation' stamp: 'ar 12/15/2001 23:36'!justified	^self new alignment: 3! !!TextAlignment class methodsFor: 'instance creation' stamp: 'ar 12/15/2001 23:35'!leftFlush	^self new alignment: 0! !!TextAlignment class methodsFor: 'instance creation' stamp: 'ar 12/15/2001 23:35'!rightFlush	^self new alignment: 1! !Object subclass: #TextAttribute	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextAttribute commentStamp: 'tk 7/22/2002 18:33' prior: 0!Tells a piece of text to be a certain way.Select text, press Command-6, choose a attribute.  If selected text is of the form 	Hi There<Smalltalk beep>the part in angle brackets is saved for action, and the Hi There appears in the paragraph.  If selection has no angle brackets, use the whole thing as both the text and the action.TextDoIt  --  eval as a Smalltalk expression (the part in angle brackets)TextLink -- Show a method, class comment, class hierarchy, or class defintion.	<Point extent:>, <Point Comment>, <Point Hierarchy>, or <Point Defintion> are what you type.TextURL -- Show the web page. <www.disney.com>These attributes of text need to be stored on the disk in a regular file-out.  It is done in this form: 	Hi There   	in the text, and a Run containing   dSmalltalk beep;;	Click here to see the extent:   	in the text, and a Run containing   method LPoint extent:;See RunArray class scanFrom: where decoding is done.!]style[(903 24 25)f1,f1LRunArray class scanFrom:;,f1!!TextAttribute methodsFor: 'as yet unclassified'!actOnClickFor: model	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'ar 9/22/2001 16:00'!actOnClickFor: model in: aParagraph	^self actOnClickFor: model! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'ar 9/22/2001 16:08'!actOnClickFor: model in: aParagraph at: clickPoint	^self actOnClickFor: model in: aParagraph! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'ar 9/22/2001 16:22'!actOnClickFor: model in: aParagraph at: clickPoint editor: editor	^self actOnClickFor: model in: aParagraph at: clickPoint! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'ar 12/16/2001 23:18'!anchoredMorph	"If one hides here, return it"	^nil! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:25'!couldDeriveFromPrettyPrinting	"Answer whether the receiver is a kind of attribute that could have been generated by doing polychrome pretty-printing of a method without functional text attributes."	^ true! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:09'!dominatedByCmd0	"Subclasses may override if cmd-0 should turn them off"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!dominates: another	"Subclasses may override condense multiple attributes"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 4/1/1999 15:16'!emphasisCode	"Subclasses may override to add bold, italic, etc"	^ 0! !!TextAttribute methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Subclasses may override to set, eg, font, color, etc"! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:46'!forFontInStyle: aTextStyle do: aBlock	"No action is the default.  Overridden by font specs"! !!TextAttribute methodsFor: 'as yet unclassified'!mayActOnClick	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 11/10/97 14:05'!mayBeExtended	"A quality that may be overridden by subclasses, such as TextAnchors, that really only apply to a single character"	^ true! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:03'!reset	"Allow subclasses to prepare themselves for merging attributes"! !!TextAttribute methodsFor: 'as yet unclassified'!set	"Respond true to include this attribute (as opposed to, eg, a bold	emphasizer that is clearing the property"	^ true! !TextAttribute subclass: #TextColor	instanceVariableNames: 'color'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextColor commentStamp: '<historical>' prior: 0!A TextColor encodes a text color change applicable over a given range of text.!!TextColor methodsFor: 'accessing'!color	^ color! !!TextColor methodsFor: 'accessing'!color: aColor	color _ aColor! !!TextColor methodsFor: 'comparing' stamp: 'di 10/31/97 11:19'!= other 	^ (other class == self class) 		and: [other color = color]! !!TextColor methodsFor: 'comparing' stamp: 'sma 3/24/2000 10:51'!hash	^ color hash! !!TextColor methodsFor: 'printing' stamp: 'sma 3/24/2000 10:51'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' code: '; print: color! !!TextColor methodsFor: 'scanning' stamp: 'di 10/31/97 11:20'!dominates: other	^ other class == self class! !!TextColor methodsFor: 'scanning'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: color! !!TextColor methodsFor: 'scanning' stamp: 'tk 12/16/97 09:47'!writeScanOn: strm	"Two formats.  c125000255 or cblue;"	| nn str |	strm nextPut: $c.	(nn _ color name) ifNotNil: [		(self class respondsTo: nn) ifTrue: [			^ strm nextPutAll: nn; nextPut: $;]].	(Array with: color red with: color green with: color blue) do: [:float |		str _ '000', (float * 255) asInteger printString.		strm nextPutAll: (str copyFrom: str size-2 to: str size)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextColor class	instanceVariableNames: ''!!TextColor class methodsFor: 'constants'!black	^ self new color: Color black! !!TextColor class methodsFor: 'constants'!blue	^ self new color: Color blue! !!TextColor class methodsFor: 'constants'!cyan	^ self new color: Color cyan! !!TextColor class methodsFor: 'constants' stamp: 'ajh 9/10/2002 02:26'!gray	^ self new color: Color gray! !!TextColor class methodsFor: 'constants'!green	^ self new color: Color green! !!TextColor class methodsFor: 'constants'!magenta	^ self new color: Color magenta! !!TextColor class methodsFor: 'constants'!red	^ self new color: Color red! !!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50'!white 	^ self new color: Color white! !!TextColor class methodsFor: 'constants'!yellow	^ self new color: Color yellow! !!TextColor class methodsFor: 'instance creation'!color: aColor	^ self new color: aColor! !!TextColor class methodsFor: 'instance creation' stamp: 'sma 3/24/2000 10:49'!scanFrom: strm	"read a color in the funny format used by Text styles on files. c125000255 or cblue;"	| r g b |	strm peek isDigit		ifTrue:			[r _ (strm next: 3) asNumber.			g _ (strm next: 3) asNumber.			b _ (strm next: 3) asNumber.			^ self color: (Color r: r g: g b: b range: 255)].	"A name of a color"	^ self color: (Color perform: (strm upTo: $;) asSymbol)! !Object subclass: #TextDiffBuilder	instanceVariableNames: 'realSrc realDst srcMap dstMap srcLines dstLines srcPos dstPos added removed shifted runs matches multipleMatches patchSequence'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!TextDiffBuilder methodsFor: 'printing' stamp: 'nk 4/24/2004 08:48'!printPatchSequence: seq on: aStream 	seq do: 		[:assoc | 		aStream			withAttributes: (self attributesOf: assoc key)			do: [aStream nextPutAll: assoc value; cr]]! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:15'!destString: aString 	realDst _ self split: aString asString.	dstLines _ OrderedCollection new.	dstMap _ OrderedCollection new.	realDst		doWithIndex: [:line :realIndex | 			dstLines				add: (self formatLine: line).			dstMap add: realIndex].	dstPos _ PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines		doWithIndex: [:line :index | (dstPos includesKey: line)				ifTrue: [(dstPos at: line)						add: index.					multipleMatches _ true]				ifFalse: [dstPos						at: line						put: (OrderedCollection with: index)]]! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'nk 1/7/2004 09:24'!formatLine: aString	^aString copyWithout: Character lf! !!TextDiffBuilder methodsFor: 'initialize'!from: sourceString to: destString	self sourceString: sourceString.	self destString: destString.! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:15'!sourceString: aString 	realSrc _ self split: aString asString.	srcLines _ OrderedCollection new.	srcMap _ OrderedCollection new.	realSrc		doWithIndex: [:line :realIndex | 			srcLines				add: (self formatLine: line).			srcMap add: realIndex].	srcPos _ PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines		doWithIndex: [:line :index | (srcPos includesKey: line)				ifTrue: [(srcPos at: line)						add: index.					multipleMatches _ true]				ifFalse: [srcPos						at: line						put: (OrderedCollection with: index)]]! !!TextDiffBuilder methodsFor: 'initialize'!split: aString	^self split: aString by: self splitCharacter! !!TextDiffBuilder methodsFor: 'testing'!hasMultipleMatches	^multipleMatches == true! !!TextDiffBuilder methodsFor: 'creating patches'!buildDisplayPatch	^Text streamContents:[:stream|		self printPatchSequence: self buildPatchSequence on: stream.	]! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'RAA 5/2/2001 23:35'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht fr n-m matches"	matches := TwoLevelDictionary new.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:57'!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index@index2 put: line]	].	srcLines doWithIndex:[:line :index|		(dstPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index2@index put: line]	].! !!TextDiffBuilder methodsFor: 'creating patches'!collectRunFrom: todo startingWith: startIndex into: run	| next start |	start := startIndex.	self remove: start from: todo.	run add: (matches at: start).	"Search downwards"	next := start.	[next := next + (1@1).	todo includes: next] whileTrue:[		run addLast: (matches at: next).		self remove: next from: todo].	"Search upwards"	next := start.	[next := next - (1@1).	todo includes: next] whileTrue:[		run addFirst: (matches at: next).		self remove: next from: todo.		start := next. "To use the first index"	].	^start! !!TextDiffBuilder methodsFor: 'creating patches'!detectShiftedRuns	| sortedRuns lastY run shiftedRuns |	runs size < 2 ifTrue: [^ nil].	shiftedRuns _ OrderedCollection new.	sortedRuns _ SortedCollection sortBlock: [:a1 :a2 | a1 key x < a2 key x].	runs associationsDo: [:assoc | sortedRuns add: assoc].	lastY _ sortedRuns first key y.	2 to: sortedRuns size do:[:i | 		run _ sortedRuns at: i.		run key y > lastY			ifTrue: [lastY _ run key y]			ifFalse: [shiftedRuns add: run]].	^ shiftedRuns! !!TextDiffBuilder methodsFor: 'creating patches'!generatePatchSequence	| ps |	ps := OrderedCollection new: srcLines size.	srcLines size timesRepeat:[ps add: nil].	self incorporateMatchesInto: ps.	self incorporateRemovalsInto: ps.	self incorporateAddsInto: ps.	^ps! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'di 3/15/1999 14:01'!incorporateAddsInto: aPatchSequence	"Incorporate adds"	| lastMatch lastIndex index |	added ifNil:[^self].	added := added sortBy:[:a1 :a2| a1 key < a2 key].	lastMatch := 1.	lastIndex := 0.	1 to: added size do:[:i|		index := (added at: i) key.		[index > lastMatch] whileTrue:[			[lastIndex := lastIndex + 1.			(aPatchSequence at: lastIndex) key == #match] whileFalse.			lastMatch := lastMatch + 1.		].		aPatchSequence add: #insert->(added at: i) value afterIndex: lastIndex.		lastIndex := lastIndex + 1.		lastMatch := lastMatch + 1.	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateMatchesInto: aPatchSequence	"Incorporate matches"	| index |	runs associationsDo:[:assoc|		index := assoc key y.		assoc value do:[:line|			self assert:[(aPatchSequence at: index) isNil].			aPatchSequence at: index put: (#match -> line).			index := index + 1.		].	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateRemovalsInto: aPatchSequence	"Incorporate removals"	| index |	removed ifNil:[^self].	removed do:[:assoc|		index := assoc key.		self assert:[(aPatchSequence at: index) isNil].		aPatchSequence at: index put: #remove -> assoc value.	].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'RAA 5/2/2001 23:41'!processDiagonals	^self processDiagonalsFrom: matches twoLevelKeys! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'RAA 5/2/2001 23:17'!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := PluggableDictionary new.	runList hashBlock: self pointHashBlock.	runList equalBlock: self pointEqualBlock.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches'!processShiftedRuns	| key |	shifted isNil ifTrue:[^self].	shifted do:[:assoc|		key := assoc key.		assoc value doWithIndex:[:line :idx|			removed add: (key y + idx - 1) -> line.			added add: (key x + idx - 1) -> line].		runs removeKey: assoc key.	].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 17:26'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy _ srcPos copy.	srcPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	dstPosCopy _ dstPos copy.	dstPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private' stamp: 'nk 4/24/2004 08:48'!attributesOf: type	"Private.	Answer the TextAttributes that are used to display text of the given type."	^type caseOf: {		[#insert] -> [ {TextColor red} ].		[#remove] -> [ {TextEmphasis struckOut. TextColor blue}].	} otherwise: [ {TextEmphasis normal} ].! !!TextDiffBuilder methodsFor: 'private' stamp: 'RAA 5/2/2001 22:56'!pointEqualBlock	^[ :a :b | a x = b x and: [a y = b y]] fixTemps! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:35'!pointHashBlock	^[:pt| (pt x bitShift: 12) + pt y] fixTemps! !!TextDiffBuilder methodsFor: 'private' stamp: 'RAA 5/2/2001 23:28'!remove: pointKey from: aSet	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	aSet removeAllXAndY: pointKey.! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:26'!split: aString by: splitChar	| lines index nextIndex |	lines := OrderedCollection new.	index _ 1.	[index <= aString size] whileTrue:[		nextIndex _ aString 						indexOf: splitChar 						startingAt: index 						ifAbsent:[aString size+1].		lines add: (aString copyFrom: index to: nextIndex-1).		index _ nextIndex+1].	^lines! !!TextDiffBuilder methodsFor: 'private'!splitCharacter	^Character cr! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/24/1998 13:41'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[ stringSize < 3 				ifTrue:[(string at: 1) asInteger +						((string at: string size) asInteger bitShift: 8)]				ifFalse:[	(string at: 1) asInteger +						((string at: stringSize // 3 + 1) asInteger bitShift: 4) +						((string at: stringSize // 2 + 1) asInteger bitShift: 8) +						((string at: stringSize * 2 // 3 + 1) asInteger bitShift: 12) +						((string at: stringSize) asInteger bitShift: 16)]]] fixTemps! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextDiffBuilder class	instanceVariableNames: ''!!TextDiffBuilder class methodsFor: 'instance creation'!buildDisplayPatchFrom: srcString to: dstString	^(self from: srcString to: dstString) buildDisplayPatch! !!TextDiffBuilder class methodsFor: 'instance creation' stamp: 'sw 5/19/2001 10:52'!buildDisplayPatchFrom: srcString to: dstString inClass: srcClass prettyDiffs: prettyBoolean	"Build a display patch for mapping via diffs from srcString to dstString in the given class.  If prettyBoolean is true, do the diffing for pretty-printed forms"	^ ((srcClass notNil and: [prettyBoolean])		ifTrue: [PrettyTextDiffBuilder				from: srcString				to: dstString				inClass: srcClass]		ifFalse: [self from: srcString to: dstString]) buildDisplayPatch! !!TextDiffBuilder class methodsFor: 'instance creation'!from: srcString to: dstString	^self new from: srcString to: dstString! !TextAction subclass: #TextDoIt	instanceVariableNames: 'evalString'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!actOnClickFor: anObject	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	Compiler evaluate: evalString for: anObject logged: false.	^ true ! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:46'!analyze: aString	| list |	list _ super analyze: aString.	evalString _ list at: 1.	^ list at: 2! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!evalString: str	evalString _ str ! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ evalString! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:46'!writeScanOn: strm	strm nextPut: $d; nextPutAll: evalString; nextPutAll: ';;'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextDoIt class	instanceVariableNames: ''!!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 20:28'!evalString: str	^ self new evalString: str! !!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:06'!scanFrom: strm	"read a doit in the funny format used by Text styles on files. d10 factorial;;  end with two semicolons"	| pos end doit |	pos _ strm position.	[strm skipTo: $;. strm peek == $;] whileFalse.	end _ strm position - 1.	strm position: pos.	doit _ strm next: end-pos.	strm skip: 2.  ";;"	^ self evalString: doit! !TextAttribute subclass: #TextEmphasis	instanceVariableNames: 'emphasisCode setMode'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextEmphasis commentStamp: '<historical>' prior: 0!A TextEmphasis, encodes a characteristic applicable to all fonts.  The encoding is as follows:	1	bold	2	itallic	4	underlined	8	narrow	16	struck out!!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other emphasisCode = emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:11'!dominatedByCmd0	"Cmd-0 should turn off emphasis"	^ true! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:13'!dominates: other	(emphasisCode = 0 and: [other dominatedByCmd0]) ifTrue: [^ true].	^ (other class == self class)		and: [emphasisCode = other emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode	^ emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode: int	emphasisCode _ int.	setMode _ true! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:57'!emphasizeScanner: scanner	"Set the emphasist for text scanning"	scanner addEmphasis: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'ar 9/9/2003 22:03'!hash	"#hash is re-implemented because #= is re-implemented"	^emphasisCode hash! !!TextEmphasis methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!set	^ setMode and: [emphasisCode ~= 0]! !!TextEmphasis methodsFor: 'as yet unclassified'!turnOff	setMode _ false! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:28'!writeScanOn: strm	emphasisCode = 1 ifTrue: [strm nextPut: $b].	emphasisCode = 2 ifTrue: [strm nextPut: $i].	emphasisCode = 0 ifTrue: [strm nextPut: $n].	emphasisCode = 16 ifTrue: [strm nextPut: $=].	emphasisCode = 4 ifTrue: [strm nextPut: $u].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextEmphasis class	instanceVariableNames: ''!!TextEmphasis class methodsFor: 'as yet unclassified'!bold	^ self new emphasisCode: 1! !!TextEmphasis class methodsFor: 'as yet unclassified'!italic	^ self new emphasisCode: 2! !!TextEmphasis class methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:05'!narrow	^ TextKern kern: -1! !!TextEmphasis class methodsFor: 'as yet unclassified'!normal	^ self new emphasisCode: 0! !!TextEmphasis class methodsFor: 'as yet unclassified'!struckOut	^ self new emphasisCode: 16! !!TextEmphasis class methodsFor: 'as yet unclassified'!underlined	^ self new emphasisCode: 4! !TextAttribute subclass: #TextFontChange	instanceVariableNames: 'fontNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextFontChange commentStamp: '<historical>' prior: 0!A TextFontChange encodes a font change applicable over a given range of text.  The font number is interpreted relative to the textStyle governing display of this text.!!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other fontNumber = fontNumber]! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:20'!dominates: other	^ other class == self class! !!TextFontChange methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the font for text display"	scanner setFont: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber	^ fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber: int	fontNumber _ int! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:46'!forFontInStyle: aTextStyle do: aBlock	aBlock value: (aTextStyle fontAt: fontNumber)! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'ar 9/9/2003 22:03'!hash	"#hash is re-implemented because #= is re-implemented"	^fontNumber hash! !!TextFontChange methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' font: '; print: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:22'!writeScanOn: strm	strm nextPut: $f.	fontNumber printOn: strm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextFontChange class	instanceVariableNames: ''!!TextFontChange class methodsFor: 'as yet unclassified' stamp: 'sw 12/6/1999 17:52'!defaultFontChange	"Answer a TextFontChange that represents the default font"	^ self new fontNumber: TextStyle default defaultFontIndex! !!TextFontChange class methodsFor: 'as yet unclassified'!font1	^ self new fontNumber: 1! !!TextFontChange class methodsFor: 'as yet unclassified'!font2	^ self new fontNumber: 2! !!TextFontChange class methodsFor: 'as yet unclassified'!font3	^ self new fontNumber: 3! !!TextFontChange class methodsFor: 'as yet unclassified'!font4	^ self new fontNumber: 4! !!TextFontChange class methodsFor: 'as yet unclassified'!fontNumber: n	^ self new fontNumber: n! !TextFontChange subclass: #TextFontReference	instanceVariableNames: 'font'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextFontReference commentStamp: '<historical>' prior: 0!A TextFontReference encodes a font change applicable over a given range of text.  The font reference is absolute:  unlike a TextFontChange, it is independent of the textStyle governing display of this text.!!TextFontReference methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:22'!couldDeriveFromPrettyPrinting	^ false! !!TextFontReference methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the actual font for text display"	scanner setActualFont: font! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 5/10/1999 23:47'!font	^ font! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:47'!forFontInStyle: aTextStyle do: aBlock	aBlock value: font! !!TextFontReference methodsFor: 'as yet unclassified'!toFont: aFont	font _ aFont! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'tk 7/22/2002 18:39'!writeScanOn: strm	strm nextPut: $F.	strm nextPutAll: font familyName; nextPut: $#.	font height printOn: strm.! !!TextFontReference methodsFor: 'comparing' stamp: 'mas 5/7/1999 06:20'!= other 	^ (other class == self class) 		and: [other font == font]! !!TextFontReference methodsFor: 'comparing' stamp: 'ar 9/9/2003 22:03'!hash	"#hash is re-implemented because #= is re-implemented"	^font hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextFontReference class	instanceVariableNames: ''!!TextFontReference class methodsFor: 'as yet unclassified'!toFont: aFont	^ self new toFont: aFont! !TextAttribute subclass: #TextIndent	instanceVariableNames: 'amount'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextIndent commentStamp: '<historical>' prior: 0!create a hanging indent. !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount _ anInteger! !!TextIndent methodsFor: 'printing' stamp: 'ls 6/22/1998 18:03'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' amount: '.	amount printOn: aStream! !!TextIndent methodsFor: 'setting indentation' stamp: 'ls 6/22/1998 18:56'!emphasizeScanner: scanner	scanner indentationLevel: amount! !!TextIndent methodsFor: 'condensing' stamp: 'ls 6/22/1998 19:27'!dominates: anAttribute	^(self class == anAttribute class)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextIndent class	instanceVariableNames: ''!!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:55'!amount: amount	"create a TextIndent which will indent by the given amount.  Currently this is a number of tabs, but may change in the futur"	^super new amount: amount! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text _ 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg _ text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !TextAttribute subclass: #TextKern	instanceVariableNames: 'kern active'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextKern commentStamp: '<historical>' prior: 0!A TextKern encodes a kerning change applicable over a given range of text.  Positive values of kern spread letters out, negative kern will cause them to overlap more.  Note that kerns other than 0 will display somewhat slower, as kerning is not yet supported in the text scanning primitive. !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other kern = kern]! !!TextKern methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:10'!dominatedByCmd0	"Cmd-0 should turn off kerning"	^ true! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:10'!dominates: other	"NOTE: The use of active in this code is specific to its use in the method		Text class addAttribute: att toArray: others"	(active and: [other class == self class and: [other kern + kern = 0]])		ifTrue: [active _ false.  ^ true].  "can only dominate once"	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:50'!emphasizeScanner: scanner	"Augment (or diminish) the kerning offset for text display"	scanner addKern: kern! !!TextKern methodsFor: 'as yet unclassified' stamp: 'ar 9/9/2003 22:03'!hash	"#hash is re-implemented because #= is re-implemented"	^kern hash! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:12'!kern	^ kern! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 09:59'!kern: kernValue	kern _ kernValue.	self reset.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:04'!reset	active _ true! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:11'!set	^ active! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 9/21/1999 15:57'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextKern class	instanceVariableNames: ''!!TextKern class methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:49'!kern: kernValue	^ self new kern: kernValue! !Interval subclass: #TextLineInterval	instanceVariableNames: 'internalSpaces paddingWidth lineHeight baseline'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!TextLineInterval commentStamp: '<historical>' prior: 0!My instances specify the starting and stopping points in a String of a composed line. The step is always 1.!!TextLineInterval methodsFor: 'accessing'!baseline	^ baseline! !!TextLineInterval methodsFor: 'accessing'!internalSpaces	"Answer the number of spaces in the line."	^internalSpaces! !!TextLineInterval methodsFor: 'accessing'!internalSpaces: spacesInteger 	"Set the number of spaces in the line to be spacesInteger."	internalSpaces _ spacesInteger! !!TextLineInterval methodsFor: 'accessing'!lineHeight	^ lineHeight! !!TextLineInterval methodsFor: 'accessing'!paddingWidth	"Answer the amount of space to be added to the font."	^paddingWidth! !!TextLineInterval methodsFor: 'accessing'!paddingWidth: padWidthInteger 	"Set the amount of space to be added to the font to be padWidthInteger."	paddingWidth _ padWidthInteger! !!TextLineInterval methodsFor: 'accessing'!stop: stopInteger 	"Set the stopping point in the string of the line to be stopInteger."	stop _ stopInteger! !!TextLineInterval methodsFor: 'comparing'!= line	self species = line species		ifTrue: [^((start = line first and: [stop = line last])				and: [internalSpaces = line internalSpaces])				and: [paddingWidth = line paddingWidth]]		ifFalse: [^false]! !!TextLineInterval methodsFor: 'scanning'!justifiedPadFor: spaceIndex 	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	spaceIndex <= (paddingWidth \\ internalSpaces)		ifTrue: [^pad + 1]		ifFalse: [^pad]! !!TextLineInterval methodsFor: 'scanning'!justifiedTabDeltaFor: spaceIndex 	"Compute the delta for a tab in a line of justified text, so tab falls 	somewhere plausible when line is justified."	| pad extraPad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	extraPad _ paddingWidth \\ internalSpaces.	spaceIndex <= extraPad		ifTrue: [^spaceIndex * (pad + 1)]		ifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]! !!TextLineInterval methodsFor: 'updating'!slide: delta 	"Change the starting and stopping points of the line by delta."	start _ start + delta.	stop _ stop + delta! !!TextLineInterval methodsFor: 'private'!internalSpaces: spacesInteger paddingWidth: padWidthInteger	internalSpaces _ spacesInteger.	paddingWidth _ padWidthInteger! !!TextLineInterval methodsFor: 'private'!lineHeight: height baseline: ascent	lineHeight _ height.	baseline _ ascent! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextLineInterval class	instanceVariableNames: ''!!TextLineInterval class methodsFor: 'instance creation'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| newSelf |	newSelf _ super from: startInteger to: stopInteger by: 1.	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger! !TextAction subclass: #TextLink	instanceVariableNames: 'classAndMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 5/1/2001 18:17'!actOnClickFor: aMessageSet	"Add to the end of the list.  'aClass selector', 'aClass Comment', 'aClass Definition', 'aClass Hierarchy' are the formats allowed."	aMessageSet addItem: classAndMethod.	^ true! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:49'!analyze: aString	| list |	list _ super analyze: aString.	classAndMethod _ list at: 1.	^ list at: 2! !!TextLink methodsFor: 'as yet unclassified' stamp: 'LC 10/8/2001 10:53'!analyze: aString with: nonMethod	"Initalize this attribute holder with a piece text the user typed into a paragraph.  Returns the text to emphesize (may be different from selection)  Does not return self!!.  nonMethod is what to show when clicked, i.e. the last part of specifier (Comment, Definition, or Hierarchy).  May be of the form:Point<Point>Click Here<Point><Point>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim |	b1 _ aString indexOf: $<.	b2 _ aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		classAndMethod _ self validate: aString, ' ', nonMethod.		^ classAndMethod ifNotNil: [aString]].	"Two parts"	trim _ aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [classAndMethod]]			ifFalse: ["at the front"				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				^ nil]]! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:09'!classAndMethod: aString	classAndMethod _ aString! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ classAndMethod! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 5/7/2001 09:30'!validate: specString	"Can this string be decoded to be Class space Method (or Comment, Definition, Hierarchy)? If so, return it in valid format, else nil" 	| list first mid last |	list _ specString findTokens: ' 	.|'.	last _ list last.	last first isUppercase ifTrue: [		(#('Comment' 'Definition' 'Hierarchy') includes: last) ifFalse: [^ nil].		"Check for 'Rectangle Comment Comment' and remove last one"		(list at: list size - 1) = last ifTrue: [list _ list allButLast]].	list size > 3 ifTrue: [^ nil].	list size < 2 ifTrue: [^ nil].	Symbol hasInterned: list first ifTrue: [:sym | first _ sym].	first ifNil: [^ nil].	Smalltalk at: first ifAbsent: [^ nil].	mid _ list size = 3 		ifTrue: [(list at: 2) = 'class' ifTrue: ['class '] ifFalse: [^ nil]]		ifFalse: [''].	"OK if method name is not interned -- may not be defined yet"	^ first, ' ', mid, last! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:44'!writeScanOn: strm	strm nextPut: $L; nextPutAll: classAndMethod; nextPut: $;! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextLink class	instanceVariableNames: ''!!TextLink class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:53'!scanFrom: strm	"read a link in the funny format used by Text styles on files. LPoint +;LPoint Comment;"	^ self new classAndMethod: (strm upTo: $;)! !TextDoIt subclass: #TextPrintIt	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextPrintIt methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 13:27'!actOnClickFor: anObject in: aParagraph at: clickPoint editor: editor	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	| result range index |	result _ Compiler evaluate: evalString for: anObject logged: false.	result _ ' ', result printString,' '.	"figure out where the attribute ends in aParagraph"	index _ (aParagraph characterBlockAtPoint: clickPoint) stringIndex.	range _ aParagraph text rangeOf: self startingAt: index.	editor selectFrom: range last+1 to: range last.	editor zapSelectionWith: result.	editor selectFrom: range last to: range last + result size.	^ true ! !!TextPrintIt methodsFor: 'as yet unclassified' stamp: 'ar 9/22/2001 16:28'!writeScanOn: strm	strm nextPut: $P; nextPutAll: evalString; nextPutAll: ';;'! !Object subclass: #TextPrinter	instanceVariableNames: 'form para paperSize landscape resolution depth offset columns docTitle noHeader noFooter'	classVariableNames: 'DefaultPaperSize DefaultTextPrinter'	poolDictionaries: ''	category: 'Graphics-Text'!!TextPrinter methodsFor: 'initialize' stamp: 'ar 4/30/98 19:26'!defaultPaperSize	"Return the default paper size (inches) for printing"	^self class defaultPaperSize! !!TextPrinter methodsFor: 'initialize' stamp: 'nk 4/2/2004 11:32'!defaultResolution	"Return the default resolution (DPI) for printing"	^TextStyle pixelsPerInch asPoint! !!TextPrinter methodsFor: 'initialize' stamp: 'ar 4/30/98 19:39'!initialize	self paperSize: self defaultPaperSize.	self resolution: self defaultResolution.	self blackAndWhite.	self landscape: false.	self offsetRect: (1.0@1.0 corner: 1.0@1.0).	self columns: 1.	self noHeader: false.	self noFooter: false.	self documentTitle: 'Squeak Document (from ', Date today printString,')'.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!blackAndWhite	"Set the reproduction quality to black and white"	depth := 1.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:50'!columns	^columns! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:50'!columns: aNumber	columns := aNumber asInteger max: 1.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 20:14'!documentTitle	^docTitle! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 20:14'!documentTitle: aString	docTitle := aString! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!landscape	^landscape! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!landscape: aBoolean	landscape := aBoolean! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:23'!noFooter	^noFooter! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:22'!noFooter: aBoolean	"Turn off footer printing"	noFooter := aBoolean.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:22'!noHeader	^noHeader! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:22'!noHeader: aBoolean	"Turn off header printing"	noHeader := aBoolean.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:27'!offsetRect	^offset! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:27'!offsetRect: aRectangle	"Set the offset rectangle"	offset := aRectangle! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!paperSize	^paperSize! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!paperSize: aPoint	paperSize := aPoint! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:43'!resolution	^resolution! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:43'!resolution: aPoint	resolution := aPoint! !!TextPrinter methodsFor: 'printing' stamp: 'ar 4/30/98 20:41'!flushPage	"The current page has been set up. Send it to the printer."	form primPrintHScale: self resolution x vScale: self resolution y landscape: self landscape.	"Uncomment the following for testing"	"form displayOn: Display. (Delay forSeconds: 5) wait."! !!TextPrinter methodsFor: 'printing' stamp: 'ar 4/30/98 19:19'!printParagraph	| pageNum nextIndex |	para destinationForm: form.	pageNum := 1.	nextIndex := 1.	[form fillColor: Color white.	self printHeader: pageNum.	self printFooter: pageNum.	nextIndex := self formatPage: pageNum startingWith: nextIndex.	self flushPage.	nextIndex isNil] whileFalse:[pageNum := pageNum + 1].! !!TextPrinter methodsFor: 'printing' stamp: 'ar 4/30/98 18:55'!printText: aText	"Print aText"	form isNil ifTrue:[		form := Form extent: self pixelSize depth: depth.	].	para := Paragraph withText: aText asText.	Cursor wait showWhile:[		self printParagraph.	].! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:25'!columnRect: n	"Return a rectangle describing the n-th column"	| area left right |	area := self textArea.	left := area left + ((n-1) * self columnWidth).	left := left + ((n-1) * self columnSkip).	right := left + self columnWidth.	^(self in2pix: left @ area top) corner: 		(self in2pix: right @ area bottom)! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:20'!columnSkip	"Return the separating space between two columns in inches"	^0.2! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:21'!columnWidth	^(self textWidth - ((self columns-1) * self columnSkip)) / self columns! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:29'!formatColumn: columnNum startingWith: anIndex	"Format a new column starting at the given string index. Return the string index indicating the start of the next column or nil if no more columns need printing."	| colRect blk |	colRect := self columnRect: columnNum.	anIndex > 1 ifTrue:[para text: (para text copyFrom: anIndex to: para text size)].	para compositionRectangle: colRect.	para clippingRectangle: colRect.	para composeAll.	para displayOn: form.	para visibleRectangle corner y <= colRect extent y ifTrue:[^nil].	"More columns -- find the character block of the last line and adjust clip rect"	blk := para characterBlockAtPoint: para visibleRectangle bottomLeft.	para clearVisibleRectangle. "Make sure that the background is clean"	para clippingRectangle: (colRect topLeft corner: colRect right@blk top).	para displayOn: form.	^blk stringIndex.! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:29'!formatPage: pageNum startingWith: anIndex	"Format a new page starting at the given string index. Return the string index indicating the start of the next page or nil if no more pages need printing."	| nextIndex |	nextIndex := anIndex.	1 to: self columns do:[:i|		nextIndex := self formatColumn: i startingWith: nextIndex.		nextIndex isNil ifTrue:[^nil].	].	^nextIndex! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:58'!textArea	^(self offsetRect origin + (0.0@self headerHeight)) corner:		(self realPaperSize - self offsetRect corner - (0.0@self footerHeight))! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:23'!textWidth	^self textArea extent x! !!TextPrinter methodsFor: 'header' stamp: 'ar 4/30/98 19:23'!headerHeight	"Return the (additional) height of the header in inches."	self noHeader ifTrue:[^0.0].	^(self pix2in: 0@TextStyle default lineGrid) y * 2! !!TextPrinter methodsFor: 'header' stamp: 'ar 4/30/98 20:11'!headerParagraph	"Return a paragraph for the footer"	| hPara rect |	hPara := Paragraph new.	hPara destinationForm: form.	rect := (self in2pix: self textArea topLeft - (0.0@self headerHeight)) corner: 				(self in2pix: self textArea topRight).	hPara clippingRectangle: rect.	hPara compositionRectangle: rect.	^hPara! !!TextPrinter methodsFor: 'header' stamp: 'ar 4/30/98 19:23'!printHeader: pageNumber	"Print the header for the given page number"	| fPara |	self noHeader ifTrue:[^self].	fPara := self headerParagraph.	fPara centered.	fPara text: self documentTitle asText.	fPara displayOn: form.! !!TextPrinter methodsFor: 'footer' stamp: 'ar 4/30/98 19:23'!footerHeight	"Return the (additional) height of the footer in inches."	self noFooter ifTrue:[^0.0].	^(self pix2in: 0@TextStyle default lineGrid) y * 2! !!TextPrinter methodsFor: 'footer' stamp: 'ar 4/30/98 20:11'!footerParagraph	"Return a paragraph for the footer"	| fPara rect |	fPara := Paragraph new.	fPara destinationForm: form.	rect := (self in2pix: self textArea bottomLeft) corner: 				(self in2pix: self textArea bottomRight + (0.0@self footerHeight)).	fPara clippingRectangle: rect.	fPara compositionRectangle: rect.	^fPara! !!TextPrinter methodsFor: 'footer' stamp: 'ar 4/30/98 19:24'!printFooter: pageNumber	"Print the footer for the given page number"	| fPara |	self noFooter ifTrue:[^self].	fPara := self footerParagraph.	fPara centered.	fPara text: ('Page ', pageNumber printString) asText.	fPara displayOn: form.! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:38'!in2pix: aPoint	"Convert aPoint from inches to actual pixels"	^(aPoint * self resolution) rounded! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:38'!mm2in: aPoint	"Convert aPoint from millimeters to inches"	^aPoint / 25.4! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:39'!pix2in: aPoint	"Convert aPoint from a pixel value to inches"	^aPoint / self resolution! !!TextPrinter methodsFor: 'private' stamp: 'ar 4/30/98 19:40'!pixelSize	"Return the size of the page in pixels"	^self in2pix: (self realPaperSize)! !!TextPrinter methodsFor: 'private' stamp: 'ar 4/30/98 19:39'!realPaperSize	^self landscape		ifTrue:[self paperSize y @ self paperSize x]		ifFalse:[self paperSize]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextPrinter class	instanceVariableNames: ''!!TextPrinter class methodsFor: 'class initialization' stamp: 'ar 4/30/98 18:30'!initialize	"TextPrinter initialize"	self defaultPaperSize: self paperSizeA4.! !!TextPrinter class methodsFor: 'accessing' stamp: 'ar 4/30/98 18:31'!defaultPaperSize	^DefaultPaperSize! !!TextPrinter class methodsFor: 'accessing' stamp: 'ar 4/30/98 18:31'!defaultPaperSize: aPoint	DefaultPaperSize := aPoint! !!TextPrinter class methodsFor: 'accessing' stamp: 'dew 3/7/2000 20:39'!defaultTextPrinter	"This is the global default TextPrinter instance."	DefaultTextPrinter isNil ifTrue: [DefaultTextPrinter _ self new].	^DefaultTextPrinter! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:30'!mm2in: aPoint	"Convert aPoint from millimeters to inches"	^aPoint / 25.4! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSizeA4	^self mm2in: 210@297! !WriteStream subclass: #TextStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!TextStream methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 02:51'!nextPutAll: aCollection 
	"Optimized access to get around Text at:Put: overhead"
	| n |
	n _ aCollection size.
     position + n > writeLimit
       ifTrue:
        [self growTo: position + n + 10].
	collection 
		replaceFrom: position+1
		to: position + n
		with: aCollection
		startingAt: 1.
	position _ position + n! !!TextStream methodsFor: 'as yet unclassified' stamp: 'djp 11/6/1999 20:30'!withAttributes: attributes do: streamBlock 	| pos1 val |	pos1 _ self position.	val _ streamBlock value.	attributes do: [:attribute |		collection			addAttribute: attribute			from: pos1 + 1			to: self position].	^ val! !Object subclass: #TextStyle	instanceVariableNames: 'fontArray fontFamilySize lineGrid baseline alignment firstIndent restIndent rightIndent tabsArray marginTabsArray leading defaultFontIndex'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!TextStyle commentStamp: '<historical>' prior: 0!A TextStyle comprises the formatting information for composing and displaying a unit (usually a paragraph) of text.  Typically one makes a copy of a master TextStyle (such as TextStyle default), and then that copy may get altered in the process of editing.  Bad things can happen if you do not copy first.Each of my instances consists of...	fontArray		An array of StrikeFonts or other fonts	fontFamilySize	unused	lineGrid			An integer; default line spacing for paragraphs	baseline			An integer; default baseline (dist from line top to bottom of an 'a')	alignment		An integer; text alignment, see TextStyle alignment:	firstIndent		An integer; indent of first line in pixels	restIndent		An integer; indent of remaining lines in pixels	rightIndent		An integer; indent of right margin rel to section	tabsArray		An array of integers giving tab offsets in pixels	marginTabsArray	An array of margin tabs	leading			An integer giving default vertical line separationFor a concrete example, look at TextStyle default copy inspect!]style[(367 10 226 20 381 30)f1,f1LStrikeFont Comment;,f1,f1LTextStyle alignment:;,f1,f1dTextStyle default copy inspect;;!!TextStyle methodsFor: 'accessing'!alignment	"Answer the code for the current setting of the alignment."	^alignment! !!TextStyle methodsFor: 'accessing' stamp: 'ar 9/21/2000 15:17'!alignment: anInteger 	"Set the current setting of the alignment to be anInteger:	0=left flush, 1=right flush, 2=centered, 3=justified."	alignment _ anInteger \\ (Justified + 1)! !!TextStyle methodsFor: 'accessing'!baseline	"Answer the distance from the top of the line to the bottom of most of the 	characters (by convention, bottom of the letter 'A')."	^baseline! !!TextStyle methodsFor: 'accessing'!baseline: anInteger 	"Set the distance from the top of the line to the bottom of most of the 	characters."	baseline _ anInteger! !!TextStyle methodsFor: 'accessing'!centered	alignment _ 2! !!TextStyle methodsFor: 'accessing' stamp: 'sw 12/6/1999 12:31'!defaultFont	^ fontArray at: self defaultFontIndex! !!TextStyle methodsFor: 'accessing'!firstIndent	"Answer the horizontal indenting of the first line of a paragraph in the 	style of the receiver."	^firstIndent! !!TextStyle methodsFor: 'accessing'!firstIndent: anInteger 	"Set the horizontal indenting of the first line of a paragraph in the style 	of the receiver to be the argument, anInteger."	firstIndent _ anInteger! !!TextStyle methodsFor: 'accessing'!fontNamed: fontName  "TextStyle default fontNamed: 'TimesRoman10'"	^ fontArray detect: [:x | x name sameAs: fontName]! !!TextStyle methodsFor: 'accessing'!fontNames  "TextStyle default fontNames"	^ fontArray collect: [:x | x name]! !!TextStyle methodsFor: 'accessing' stamp: 'ar 9/21/2000 11:53'!fontNamesWithPointSizes	^ fontArray collect:		[:x | x fontNameWithPointSize]  "TextStyle default fontNamesWithPointSizes"! !!TextStyle methodsFor: 'accessing' stamp: 'nk 6/25/2003 12:54'!isTTCStyle	^ fontArray first isTTCFont.! !!TextStyle methodsFor: 'accessing'!justified	alignment _ 3! !!TextStyle methodsFor: 'accessing'!leading	"Leading (from typographers historical use of extra lead (type metal))	is the extra spacing above and beyond that needed just to accomodate	the various font heights in the set."	^ leading! !!TextStyle methodsFor: 'accessing'!leading: yDelta	leading _ yDelta! !!TextStyle methodsFor: 'accessing'!leftFlush	alignment _ 0! !!TextStyle methodsFor: 'accessing'!lineGrid	"Answer the relative space between lines of a paragraph in the style of 	the receiver."	^lineGrid! !!TextStyle methodsFor: 'accessing'!lineGrid: anInteger 	"Set the relative space between lines of a paragraph in the style of the 	receiver to be the argument, anInteger."	lineGrid _ anInteger! !!TextStyle methodsFor: 'accessing' stamp: 'sma 12/30/1999 13:57'!printOn: aStream	super printOn: aStream.	aStream space; nextPutAll: self defaultFont name! !!TextStyle methodsFor: 'accessing'!restIndent	"Answer the indent for all but the first line of a paragraph in the style 	of the receiver."	^restIndent! !!TextStyle methodsFor: 'accessing'!restIndent: anInteger 	"Set the indent for all but the first line of a paragraph in the style of the 	receiver to be the argument, anInteger."	restIndent _ anInteger! !!TextStyle methodsFor: 'accessing'!rightFlush	alignment _ 1! !!TextStyle methodsFor: 'accessing'!rightIndent	"Answer the right margin indent for the lines of a paragraph in the style 	of the receiver."	^rightIndent! !!TextStyle methodsFor: 'accessing'!rightIndent: anInteger 	"Answer the right margin indent for the lines of a paragraph in the style 	of the receiver to be the argument, anInteger."	rightIndent _ anInteger! !!TextStyle methodsFor: 'tabs and margins'!leftMarginTabAt: marginIndex 	"Set the 'nesting' level of left margin indents of the paragraph in the 	style of the receiver to be the argument, marginIndex."	(marginIndex > 0 and: [marginIndex < marginTabsArray size])		ifTrue: [^(marginTabsArray at: marginIndex) at: 1]		ifFalse: [^0]		"The marginTabsArray is an Array of tuples.  The Array is indexed according 	to the marginIndex, the 'nesting' level of the requestor."! !!TextStyle methodsFor: 'tabs and margins'!nextTabXFrom: anX leftMargin: leftMargin rightMargin: rightMargin 	"Tab stops are distances from the left margin. Set the distance into the 	argument, anX, normalized for the paragraph's left margin."	| normalizedX tabX |	normalizedX _ anX - leftMargin.	1 to: tabsArray size do: 		[:i | (tabX _ tabsArray at: i) > normalizedX 				ifTrue: [^leftMargin + tabX min: rightMargin]].	^rightMargin! !!TextStyle methodsFor: 'tabs and margins'!rightMarginTabAt: marginIndex 	"Set the 'nesting' level of right margin indents of the paragraph in the 	style of the receiver to be marginIndex."	(marginIndex > 0 and: [marginIndex < marginTabsArray size])		ifTrue: [^(marginTabsArray at: marginIndex) at: 2]		ifFalse: [^0]	"The marginTabsArray is an Array of tuples.  The Array is indexed according 	to the marginIndex, the 'nesting' level of the requestor."! !!TextStyle methodsFor: 'tabs and margins'!tabWidth	"Answer the width of a tab."	^DefaultTab! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'sw 12/8/1999 18:02'!consistOnlyOf: aFont	fontArray _ Array with: aFont.	defaultFontIndex _ 1! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'sw 12/6/1999 13:54'!fontIndexOf: aFont	^ fontArray indexOf: aFont ifAbsent: [nil]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:23'!fontIndexOfSize: desiredHeight	"Returns an index in fontArray of the font with height <= desiredHeight"	"Leading is not inluded in the comparison"	| bestMatch bestIndex d |	bestMatch _ 9999.  bestIndex _ 1.	1 to: fontArray size do:		[:i | d _ desiredHeight - (fontArray at: i) height.		d = 0 ifTrue: [^ i].		(d > 0 and: [d < bestMatch]) ifTrue: [bestIndex _ i. bestMatch _ d]].	^ bestIndex! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:33'!fontOfSize: aHeight	"See fontIndexOfSize.	Returns the actual font.  Leading not considered."	^ fontArray at: (self fontIndexOfSize: aHeight)! !!TextStyle methodsFor: 'private'!fontArray	"Only for writing out fonts, etc.  8/16/96 tk"	^ fontArray! !!TextStyle methodsFor: 'private' stamp: 'di 3/20/1999 22:31'!fontAt: index 	"This is private because no object outside TextStyle should depend on the 	representation of the font family in fontArray."	^ fontArray atPin: index! !!TextStyle methodsFor: 'private'!gridForFont: fontIndex withLead: leadInteger 	"Force whole style to suit one of its fonts. Assumes only one font referred	to by runs."	| font |	font _ self fontAt: fontIndex.	self lineGrid: font height + leadInteger.	self baseline: font ascent.	self leading: leadInteger! !!TextStyle methodsFor: 'private' stamp: 'tk 8/20/96'!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (fontArray at: 1) height + leading.	"For whole family"	baseline _ (fontArray at: 1) ascent + leading.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyle methodsFor: 'Disk I/O' stamp: 'di 11/19/1999 20:12'!veryDeepCopyWith: deepCopier	"All inst vars are meant to be shared"	self == #veryDeepCopyWith:.	"to satisfy checkVariables"	^ deepCopier references at: self ifAbsent: [		deepCopier references at: self put: self clone].	"remember"! !!TextStyle methodsFor: 'default font' stamp: 'sw 12/6/1999 12:30'!defaultFontIndex	^ defaultFontIndex ifNil: [defaultFontIndex _ 1]! !!TextStyle methodsFor: 'default font' stamp: 'sw 12/6/1999 13:50'!defaultFontIndex: anIndex	defaultFontIndex _ anIndex! !!TextStyle methodsFor: 'comparing' stamp: 'tk 7/5/2001 22:18'!= other	self species == other species ifFalse: [^ false].	1 to: self class instSize do:		[:i | (self instVarAt: i) == (other instVarAt: i) ifFalse: [^ false]].	^ true! !!TextStyle methodsFor: 'comparing' stamp: 'ar 9/9/2003 22:04'!hash	"#hash is re-implemented because #= is re-implemented"	^fontArray hash! !!TextStyle methodsFor: 'comparing' stamp: 'tk 7/5/2001 22:18'!species	^TextStyle! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextStyle class	instanceVariableNames: ''!!TextStyle class methodsFor: 'TextConstants access' stamp: 'nk 7/3/2003 19:12'!actualTextStyles	| aDict |	"TextStyle actualTextStyles"	"Answer dictionary whose keys are the names of styles in the system and whose values are the actual styles"	aDict _ TextConstants select: [:thang | thang isKindOf: self ].	aDict removeKey: #DefaultTextStyle.	aDict removeKey: #DefaultFixedTextStyle.	^ aDict! !!TextStyle class methodsFor: 'TextConstants access' stamp: 'nk 7/3/2003 19:06'!fontArrayForStyle: aName	"Answer the fonts in the style named aName,	or an empty Array if no such named style."	"TextStyle fontArrayForStyle: #Atlanta"	"TextStyle fontPointSizesFor: 'NewYork'"	^ ((self named: aName) ifNil: [ ^#() ]) fontArray! !!TextStyle class methodsFor: 'TextConstants access' stamp: 'nk 7/3/2003 18:56'!fontPointSizesFor: aName	"Answer the point sizes for all the fonts in the given text style"	"TextStyle fontPointSizesFor: 'Arial'"	"TextStyle fontPointSizesFor: 'NewYork'"	^ (self fontArrayForStyle: aName) collect: [:f | f pointSize]! !!TextStyle class methodsFor: 'TextConstants access' stamp: 'nk 7/3/2003 19:00'!knownTextStyles	"Answer the names of the known text styles, sorted in alphabetical order"	"TextStyle knownTextStyles"	^ (TextConstants select: [:thang | thang isKindOf: TextStyle]) keys asSortedArray! !!TextStyle class methodsFor: 'class initialization' stamp: 'nk 3/25/2004 17:51'!initialize	self initializeStyleDecoder.! !!TextStyle class methodsFor: 'class initialization' stamp: 'nk 3/25/2004 17:53'!initializeStyleDecoder	TextConstants at: #StyleDecoder put: nil.	self styleDecoder.! !!TextStyle class methodsFor: 'class initialization' stamp: 'nk 3/25/2004 17:57'!styleDecoder	TextConstants at: #StyleDecoder ifPresent: [ :dict | dict ifNotNil: [ ^dict ]].	^TextConstants at: #StyleDecoder put: (		Dictionary new at: 'Regular' put: 0;				 at: 'Roman' put: 0;				 at: 'Medium' put: 0;				 at: 'Light' put: 0;				 at: 'Normal' put: 0;				 at: 'Plain' put: 0;				 at: 'Book' put: 0;				 at: 'Demi' put: 0;				 at: 'Demibold' put: 0;				 at: 'Semibold' put: 0;				 at: 'SemiBold' put: 0;				 at: 'ExtraBold' put: 1;				 at: 'SuperBold' put: 1;				 at: 'B' put: 1;				 at: 'I' put: 2;				 at: 'U' put: 4;				 at: 'X' put: 16;				 at: 'N' put: 8;				 at: 'Bold' put: 1;				 at: 'Italic' put: 2;				 at: 'Oblique' put: 2;				 at: 'Narrow' put: 8;				 at: 'Condensed' put: 8;				 at: 'Underlined' put: 4;				 yourself )! !!TextStyle class methodsFor: 'constants'!default	"Answer the system default text style."	^DefaultTextStyle! !!TextStyle class methodsFor: 'constants' stamp: 'sw 12/6/1999 12:32'!defaultFont	"Answer the default system font"	^ DefaultTextStyle defaultFont! !!TextStyle class methodsFor: 'constants' stamp: 'nk 7/3/2003 19:11'!named: familyName	"Answer the TextStyle with the given name, or nil."	"TextStyle named: 'NewYork'"	| textStyle |	textStyle _ TextConstants at: familyName ifAbsent: [ ^nil ].	(textStyle isKindOf: self) ifFalse: [ ^nil ].	^textStyle! !!TextStyle class methodsFor: 'instance creation'!fontArray: anArray 	"Answer an instance of me with fonts those in the argument, anArray."	^self new newFontArray: anArray! !!TextStyle class methodsFor: 'instance creation'!new	^ super new leading: 2! !!TextStyle class methodsFor: 'user interface' stamp: 'dgd 10/8/2003 18:38'!fontSizeSummary	"Open a text window with a simple summary of the available sizes in each of the fonts in the system."	"TextStyle fontSizeSummary"	| aString aList |	aList _ self knownTextStyles.	aString _ String streamContents:		[:aStream |			aList do: [:aStyleName |				aStream nextPutAll:					aStyleName, '  ',					(self fontPointSizesFor: aStyleName) asArray storeString.				aStream cr]].	(StringHolder new contents: aString)		openLabel: 'Font styles and sizes' translated! !!TextStyle class methodsFor: 'user interface' stamp: 'nk 7/3/2003 19:01'!mvcPromptForFont: aPrompt andSendTo: aTarget withSelector: aSelector	"MVC Only!! prompt for a font and if one is provided, send it to aTarget using a message with selector aSelector."	| aMenu aChoice aStyle namesAndSizes aFont |	"TextStyle mvcPromptForFont: 'Choose system font style' andSendTo: TextStyle withSelector: #setSystemFontTo:"	aMenu _ CustomMenu new.	self actualTextStyles keys do:		[:styleName |			aMenu add: styleName action: styleName].	aChoice _ aMenu startUpWithCaption: aPrompt.	aChoice ifNil: [^ self].	aMenu _ CustomMenu new.	aStyle _ self named: aChoice.	(namesAndSizes _ aStyle fontNamesWithPointSizes) do:		[:aString | aMenu add: aString action: aString].	aChoice _ aMenu startUpWithCaption: nil.	aChoice ifNil: [^ self].	aFont _ aStyle fontAt: (namesAndSizes indexOf: aChoice).	aTarget perform: aSelector with: aFont! !!TextStyle class methodsFor: 'utilities' stamp: 'nk 4/2/2004 11:26'!pixelsPerInch	"Answer the nominal resolution of the screen."	^TextConstants at: #pixelsPerInch ifAbsentPut: [ 96.0 ].! !!TextStyle class methodsFor: 'utilities' stamp: 'nk 4/2/2004 11:22'!pointsToPixels: points	^points * self pixelsPerInch / 72.0! !Magnitude subclass: #Time	instanceVariableNames: 'seconds nanos'	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!Time commentStamp: '<historical>' prior: 0!This represents a period of time.!!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 15:54'!< aTime	^ self asDuration < aTime asDuration! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:11'!= aTime	^ [ self ticks = aTime ticks ]		on: MessageNotUnderstood do: [false]! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:32'!duration	^ Duration zero
! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:11'!hash	^ self ticks hash
! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:10'!hour	^ self hour24
! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:17'!hour24
	^ self asDuration hours
! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 22:08'!minute	^ self asDuration minutes! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:19'!second
	^ self asDuration seconds! !!Time methodsFor: 'deprecated' stamp: 'brp 8/23/2003 19:03'!hours: anInteger	self 		deprecated: 'Deprecated';		hours: anInteger minutes: 0 seconds: 0.! !!Time methodsFor: 'deprecated' stamp: 'brp` 8/24/2003 19:27'!hours: hourInteger minutes: minInteger seconds: secInteger	self 		deprecated: 'Deprecated';		setSeconds: (hourInteger * SecondsInHour) + (minInteger * SecondsInMinute) + secInteger.		! !!Time methodsFor: 'deprecated' stamp: 'brp` 8/24/2003 19:28'!setSeconds: secondCount	self 		deprecated: 'Deprecated'.	self ticks: { 0. secondCount. 0 }! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!hhmm24
	"Return a string of the form 1123 (for 11:23 am), 2154 (for 9:54 pm), of exactly 4 digits"

	^(String streamContents: 
		[ :aStream | self print24: true showSeconds: false on: aStream ])
			copyWithout: $:! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!print24
	"Return as 8-digit string 'hh:mm:ss', with leading zeros if needed"

	^String streamContents:
		[ :aStream | self print24: true on: aStream ]

! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!print24: hr24 on: aStream 
	"Format is 'hh:mm:ss' or 'h:mm:ss am' "

	self print24: hr24 showSeconds: true on: aStream 
! !!Time methodsFor: 'printing' stamp: 'brp 2/16/2004 09:10'!print24: hr24 showSeconds: showSeconds on: aStream 
	"Format is 'hh:mm:ss' or 'h:mm:ss am'  or, if showSeconds is false, 'hh:mm' or 'h:mm am'"

	| h m s |
	h _ self hour. m _ self minute. s _ self second.
	hr24	
	ifTrue: 			[ h < 10 ifTrue: [ aStream nextPutAll: '0' ].	
		h printOn: aStream ]	
	ifFalse:			[ h > 12		
		ifTrue: [h - 12 printOn: aStream]		
		ifFalse: 			
		[h < 1		
				ifTrue: [ 12 printOn: aStream ]
						ifFalse: [ h printOn: aStream ]]].

	aStream nextPutAll: (m < 10 ifTrue: [':0'] ifFalse: [':']).
	m printOn: aStream.

	showSeconds ifTrue:	
	[ aStream nextPutAll: (s < 10 ifTrue: [':0'] ifFalse: [':']).
		s asInteger printOn: aStream ].

	hr24 ifFalse:	
	[ aStream nextPutAll: (h < 12 ifTrue: [' am'] ifFalse: [' pm']) ].
! !!Time methodsFor: 'printing' stamp: 'brp 8/23/2003 19:14'!printOn: aStream 
	self print24: false showSeconds: (self seconds ~= 0) on: aStream! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!storeOn: aStream

	aStream print: self printString; nextPutAll: ' asTime'! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:02'!addTime: timeAmount
	"Answer a Time that is timeInterval after the receiver. timeInterval is an 
	instance of Date or Time."

	^ self class seconds: self asSeconds + timeAmount asSeconds! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 15:55'!asSeconds
	"Answer the number of seconds since midnight of the receiver."

	^ seconds! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:29'!hours	^ self hour! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:24'!intervalString	"Treat the time as a difference.  Give it in hours and minutes with two digits of accuracy."	| d |	d _ self asDuration.	^ String streamContents: [ :s |		d hours > 0 ifTrue: [s print: d hours; nextPutAll: ' hours'].		d minutes > 0 ifTrue: [s space; print: d minutes; nextPutAll: ' minutes'].		d seconds > 0 ifTrue: [s space; print: d seconds; nextPutAll: ' seconds'] ].! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 22:07'!minutes	^ self asDuration minutes! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 18:18'!seconds	^ self second! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:03'!subtractTime: timeAmount 	"Answer a Time that is timeInterval before the receiver. timeInterval is  	an instance of Date or Time."	^ self class seconds: self asSeconds - timeAmount asSeconds! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 23:58'!asDate	^ Date today! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:26'!asDateAndTime	^ DateAndTime today + self! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:01'!asDuration
	"Answer the duration since midnight"	^ Duration seconds: seconds nanoSeconds: nanos
! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:29'!asMonth	^ self asDateAndTime asMonth! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:29'!asNanoSeconds	"Answer the number of nanoseconds since midnight"	^ self asDuration asNanoSeconds
! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:08'!asTime	^ self! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:27'!asTimeStamp	^ self asDateAndTime asTimeStamp! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:43'!asYear	^ self asDateAndTime asYear! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:33'!nanoSecond
	^ nanos
! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:35'!to: anEnd	"Answer a Timespan. anEnd must respond to #asDateAndTime"	^ self asDateAndTime to: anEnd! !!Time methodsFor: 'private' stamp: 'brp 8/23/2003 22:38'!ticks	"Answer an Array: { seconds. nanoSeconds }"	^ Array with: 0 with: seconds with: nanos.! !!Time methodsFor: 'private' stamp: 'brp 8/23/2003 20:44'!ticks: anArray	"ticks is an Array: { days. seconds. nanoSeconds }"	seconds _ anArray second.	nanos _ anArray third.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Time class	instanceVariableNames: ''!!Time class methodsFor: 'general inquiries' stamp: 'nk 3/8/2004 12:05'!millisecondClockValue	"Answer the number of milliseconds since the millisecond clock was last reset or rolled over.	Answer 0 if the primitive fails."	<primitive: 135>	^ 0! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 23:59'!dateAndTimeFromSeconds: secondCount

	^ Array
		with: (Date fromSeconds: secondCount)
		with: (Time fromSeconds: secondCount \\ 86400)
! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:50'!dateAndTimeNow
	"Answer a two-element Array of (Date today, Time now)."

	^ self dateAndTimeFromSeconds: self totalSeconds! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:11'!fromSeconds: secondCount 
	"Answer an instance of me that is secondCount number of seconds since midnight."

	^ self seconds: secondCount
! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:11'!millisecondsToRun: timedBlock 
	"Answer the number of milliseconds timedBlock takes to return its value."

	| initialMilliseconds |
	initialMilliseconds _ self millisecondClockValue.
	timedBlock value.
	^ self millisecondClockValue - initialMilliseconds! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 20:01'!new	"Answer a Time representing midnight"	^ self midnight! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 22:01'!primSecondsClock	"Answer the number of seconds since 00:00 on the morning of	 January 1, 1901 (a 32-bit unsigned number).	 Essential. See Object documentation whatIsAPrimitive. "	<primitive: 137>	self primitiveFailed! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 20:07'!readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second ampm |
	hour _ Integer readFrom: aStream.
	minute _ 0.
	second _ 0.
	(aStream peekFor: $:) ifTrue:	
	[ minute _ Integer readFrom: aStream.
		(aStream peekFor: $:) ifTrue: [ second _ Integer readFrom: aStream ]].
	aStream skipSeparators.
	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: 		[ampm _ aStream next asLowercase.	
	(ampm = $p and: [hour < 12]) ifTrue: [hour _ hour + 12].
		(ampm = $a and: [hour = 12]) ifTrue: [hour _ 0].	
	(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self hour: hour minute: minute second: second

	"Time readFrom: (ReadStream on: '2:23:09 pm')"
! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:12'!totalSeconds
	"Answer the total seconds since the Squeck epoch: 1 January 1901."

	^ self primSecondsClock! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:46'!current 	^ self now! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 22:34'!fromString: aString
	^ self readFrom: aString readStream
! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:05'!hour: hour minute: minute second: second	"Answer a Time"

	^ self hour: hour minute: minute second: second nanoSecond: 0! !!Time class methodsFor: 'squeak protocol' stamp: 'brp` 8/24/2003 19:26'!hour: hour minute: minute second: second  nanoSecond: nanoCount	"Answer a Time - only second precision for now"

	^ self 		seconds: (hour * SecondsInHour) + (minute * SecondsInMinute) + second 		nanoSeconds: nanoCount! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:01'!midnight	^ self seconds: 0! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:47'!seconds: seconds
	"Answer a Time from midnight"
	^ self seconds: seconds nanoSeconds: 0! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:46'!seconds: seconds nanoSeconds: nanoCount
	"Answer a Time from midnight"
	^ self basicNew		ticks: (Duration seconds: seconds nanoSeconds: nanoCount) ticks;		yourself
! !!Time class methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 18:56'!now	"Answer a Time representing the time right now - this is a 24 hour clock."	^ self seconds: self totalSeconds \\ 86400.! !MessageSet subclass: #TimeProfileBrowser	instanceVariableNames: 'selectedClass selectedSelector block tally'	classVariableNames: 'TextMenu'	poolDictionaries: ''	category: 'Tools-Debugger'!!TimeProfileBrowser commentStamp: '<historical>' prior: 0!A TimeProfileBrowser is a browser visualizing the runtime profile of an executed Smalltalk block.  It is useful for finding performance bottlenecks in code. When optimizing code it canbe hard to know what methods actually constitute the bulk of the execution time. Is it a fewmethods that take very long time to execute or is it perhaps a single method that gets executed a thousand times?The block is first spied on using a MessageTally instance (which has even more funtionality than used by the TimeProfileBrowser) which samples the block during it's execution and collects the amount of time approximately spent in the methods executed. Then the methods are shown in the browser with their relative execution time in percent.Example:TimeProfileBrowser onBlock: [20 timesRepeat:  [Transcript show: 100 factorial printString]]!!TimeProfileBrowser methodsFor: 'accessing' stamp: 'stp 05/08/1999 11:37'!selectedClass	"Answer the receiver's 'selectedClass'."	^selectedClass! !!TimeProfileBrowser methodsFor: 'accessing' stamp: 'stp 05/08/1999 11:37'!selectedClass: anObject	"Set the receiver's instance variable 'selectedClass' to be anObject."	selectedClass := anObject! !!TimeProfileBrowser methodsFor: 'accessing' stamp: 'stp 05/08/1999 11:37'!selectedSelector	"Answer the receiver's 'selectedSelector'."	^selectedSelector! !!TimeProfileBrowser methodsFor: 'accessing' stamp: 'stp 05/08/1999 11:37'!selectedSelector: anObject	"Set the receiver's instance variable 'selectedSelector' to be anObject."	selectedSelector := anObject! !!TimeProfileBrowser methodsFor: 'accessing' stamp: 'stp 05/08/1999 11:37'!tally	"Answer the receiver's 'tally'."	^tally! !!TimeProfileBrowser methodsFor: 'private' stamp: 'dvf 7/5/2000 18:48'!initializeMessageList: anArray	messageList _ anArray.	messageListIndex _ 0.	contents _ ''! !!TimeProfileBrowser methodsFor: 'private' stamp: 'nk 3/8/2004 13:22'!messageListKey: aChar from: view 	"Respond to a Command key. Cmd-D means re-run block."	aChar == $d ifTrue: [^Cursor execute showWhile: [ block value ]].	^super messageListKey: aChar from: view! !!TimeProfileBrowser methodsFor: 'private' stamp: 'stp 05/08/1999 15:27'!messageListMenu: aMenu shifted: shifted	"Add a menu to the inherited one."	| menu |	menu := super messageListMenu: aMenu shifted: shifted."	menu addItem: (0)."	^menu! !!TimeProfileBrowser methodsFor: 'private' stamp: 'rhi 5/17/2004 10:17'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	| string strm class sel parens |	self flag: #mref.	"fix for faster references to methods"	[string _ self selection asString.	string first == $* ifTrue: [^contents := nil].		"Ignore lines starting with *"	parens := string includes: $(.					"Does it have open-paren?"	strm := ReadStream on: string.	parens		ifTrue: [strm skipTo: $(.		"easy case"			class := strm upTo: $).			strm next: 2.			sel := strm upToEnd]		ifFalse: [strm position: (string findString: ' class>>').			strm position > 0				ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]				ifTrue:					[ | subString |  "find the next to last space character"					subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.					strm position: (subString findLast: [ :ch | ch == $ ])].		"ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])."			class := strm upTo: $>.			strm next.			sel := strm upToEnd].	^ MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock]		on: Error do: [:ex | ^ contents _ nil]! !!TimeProfileBrowser methodsFor: 'message list' stamp: 'nk 2/20/2001 10:38'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent: [^ 'Missing'].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: false].		self selectedClass: class.		self selectedSelector: selector.		^ source asText makeSelectorBoldIn: class].	^''! !DateAndTime subclass: #TimeStamp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!!TimeStamp commentStamp: '<historical>' prior: 0!This represents a duration of 0 length that marks a particular point in time.!!TimeStamp methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:13'!asTimeStamp	"Answer the receiver as an instance of TimeStamp."	^ self! !!TimeStamp methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:14'!date	"Answer the date of the receiver."	^ self asDate! !!TimeStamp methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:17'!printOn: aStream 	"Print receiver's date and time on aStream."	aStream 		nextPutAll: self date printString;		space;		nextPutAll: self time printString.! !!TimeStamp methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:17'!storeOn: aStream 	aStream 		print: self printString;		nextPutAll: ' asTimeStamp'! !!TimeStamp methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:15'!time	"Answer the time of the receiver."	^ self asTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TimeStamp class	instanceVariableNames: ''!!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'cbc 2/4/2004 21:30'!fromString: aString	"Answer a new instance for the value given by aString.	 TimeStamp fromString: '1-10-2000 11:55:00 am'. 	"	^self readFrom: (ReadStream on: aString).! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'cbc 2/4/2004 21:17'!readFrom: stream	| date time |	stream skipSeparators.	date _ Date readFrom: stream.	stream peek = $, ifTrue: [stream next].	stream skipSeparators.	time _ Time readFrom: stream.	^self 		date: date		time: time! !!TimeStamp class methodsFor: 'squeak protocol' stamp: 'brp 3/12/2004 15:49'!current	^ self now		! !!TimeStamp class methodsFor: 'ansi protocol' stamp: 'brp 3/12/2004 15:52'!now	| ts ticks |	ts _ super now.		ticks _ ts ticks.	ticks at: 3 put: 0.	ts ticks: ticks offset: ts offset.		^ ts! !Object subclass: #TimeZone	instanceVariableNames: 'offset abbreviation name'	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!TimeZone commentStamp: 'brp 9/4/2003 06:32' prior: 0!TimeZone is a simple class to colect the information identifying a UTC time zone.

offset			-	Duration	- the time zone's offset from UTC
abbreviation	-	String		- the abbreviated name for the time zone.
name			-	String		- the name of the time zone.

TimeZone class >> #timeZones returns an array of the known time zones
TimeZone class >> #default returns the default time zone (Grenwich Mean Time)!!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!abbreviation

	^ abbreviation
! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!abbreviation: aString

	abbreviation _ aString
! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:29'!name

	^ name
! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!name: aString

	name _ aString
! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!offset

	^ offset! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!offset: aDuration

	offset _ aDuration! !!TimeZone methodsFor: 'private' stamp: 'brp 9/4/2003 06:37'!printOn: aStream

	super printOn: aStream.
	aStream
		nextPut: $(;
		nextPutAll: self abbreviation;
		nextPut: $).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TimeZone class	instanceVariableNames: ''!!TimeZone class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:38'!default
	"Answer the default time zone - GMT"

	^ self timeZones detect: [ :tz | tz offset = Duration zero ]
! !!TimeZone class methodsFor: 'accessing' stamp: 'nk 3/30/2004 10:21'!timeZones	^ {		self offset:  0 hours name: 'Universal Time' abbreviation: 'UTC'.		self offset:  0 hours name: 'Greenwich Mean Time' abbreviation: 'GMT'.		self offset:  0 hours name: 'British Summer Time' abbreviation: 'BST'.		self offset:  2 hours name: 'South African Standard Time' abbreviation: 'SAST'.		self offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST'.		self offset: -7 hours name: 'Pacific Daylight Time' abbreviation: 'PDT'.	}! !!TimeZone class methodsFor: 'instance creation' stamp: 'brp 9/4/2003 06:33'!offset: aDuration name: aName abbreviation: anAbbreviation

	^ self new
		offset: aDuration;
		name: aName;
		abbreviation: anAbbreviation;
		yourself! !Magnitude subclass: #Timespan	instanceVariableNames: 'start duration'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!!Timespan commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a duration starting on a specific DateAndTime.
!!Timespan methodsFor: 'ansi protocol' stamp: 'brp 9/15/2003 14:05'!+ operand	"operand conforms to protocol Duration"
		^ self class starting: (self start + operand) duration: self duration! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 9/15/2003 14:07'!- operand	"operand conforms to protocol DateAndTime or protocol Duration"	^ (operand respondsTo: #asDateAndTime)
	 	ifTrue: [ self start - operand ]	
	ifFalse: [ self + (operand negated) ].
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:43'!< comparand	^ self start < comparand	
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:43'!= comparand	^ (self start = comparand start) and: [self duration = comparand duration]
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 7/27/2003 17:49'!dayOfMonth	"Answer the day of the month represented by the receiver."	^ start dayOfMonth! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 8/6/2003 18:42'!dayOfWeek	"Answer the day of the week represented by the receiver."	^ start dayOfWeek! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 8/6/2003 18:42'!dayOfWeekName	"Answer the day of the week represented by the receiver."	^ start dayOfWeekName! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 8/24/2003 11:50'!dayOfYear	"Answer the day of the year represented by the receiver."	^ start dayOfYear! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!hash	^ start hash + duration hash
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!isLeapYear	^ start isLeapYear
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!month	^ start month
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!monthName
	^ start monthName
! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!year
	^ start year
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:44'!asDate
	^ start asDate
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:44'!asDateAndTime	^ start
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/30/2003 00:10'!asDuration	^ self duration! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:45'!asMonth
	^ start asMonth
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:45'!asTime	^ start asTime! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:25'!asTimeStamp	^ start asTimeStamp! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:45'!asYear
	^ start asYear! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:45'!duration
	"Answer the Duration of this timespan"	^ duration
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:45'!end
	^ self next start - DateAndTime clockPrecision 
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 1/7/2004 16:05'!includes: aDateAndTime
	^ (aDateAndTime isKindOf: Timespan)			ifTrue: [ (self includes: aDateAndTime start)						and: [ self includes: aDateAndTime end ] ]			ifFalse: [ aDateAndTime asDateAndTime between: start and: self end ]! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:54'!includesAllOf: aCollection 	"Answer whether all the elements of aCollection are in the receiver."	aCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].	^ true! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 1/7/2004 15:59'!includesAnyOf: aCollection 	"Answer whether any element of aCollection is included in the receiver"	aCollection do: [ :elem | (self includes: elem) ifTrue: [^ true]].	^false! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:47'!intersection: aTimespan
	 "Return the Timespan both have in common, or nil"	 | aBegin anEnd |
	 aBegin _ self start max: aTimespan start.
	 anEnd _ self end min: aTimespan end.
	 anEnd < aBegin ifTrue: [^nil].
	 ^ self class starting: aBegin ending: anEnd.
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:47'!julianDayNumber
	^ start julianDayNumber
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 09:17'!printOn: aStream
	super printOn: aStream.	aStream 		nextPut: $(;		print: start;		nextPut: $D;		print: duration;		nextPut: $).! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:48'!start
	"Answer the start DateAndTime of this timespan"	^ start
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:48'!start: aDateAndTime	"Store the start DateAndTime of this timespan"	start _ aDateAndTime asDateAndTime
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:49'!to: anEnd	"Answer an Timespan. anEnd must be aDateAndTime or a Timespan"
	^ Timespan starting: (self start) ending: (anEnd asDateAndTime).
! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 1/9/2004 16:46'!union: aTimespan
	 "Return the Timespan spanned by both"	| aBegin anEnd |
	aBegin _ self start min: aTimespan start.	anEnd _ self end max: aTimespan end.	^ Timespan starting: aBegin ending: (anEnd + DateAndTime clockPrecision).
! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:49'!datesDo: aBlock
	self do: aBlock with: start asDate.
! !!Timespan methodsFor: 'private' stamp: 'brp 5/13/2003 08:58'!do: aBlock with: aFirstElement
	self do: aBlock with: aFirstElement when: [ :t | true ].
! !!Timespan methodsFor: 'private' stamp: 'brp 5/13/2003 08:59'!do: aBlock with: aFirstElement when: aConditionBlock	| element end |	element _ aFirstElement.	end _ self end.
	[ element start <= end ] whileTrue:	
	[(aConditionBlock value: element)			ifTrue: [ aBlock value: element ].		element _ element next. ]! !!Timespan methodsFor: 'private' stamp: 'brp 5/13/2003 08:59'!duration: aDuration	"Set the Duration of this timespan"
	duration _ aDuration
! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 14:09'!day	"Answer the day of the year represented by the receiver."	^ self dayOfYear! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:45'!daysInMonth
	^ start daysInMonth
! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:45'!daysInYear
	"Answer the number of days in the month represented by the receiver."	^ start daysInYear
! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 17:50'!daysLeftInYear	^ start daysLeftInYear! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 17:55'!firstDayOfMonth	^ start firstDayOfMonth! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:47'!monthIndex	^ self month
! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:47'!next	^ self class starting: (start + duration) duration: duration
! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Timespan class	instanceVariableNames: ''!!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 5/21/2003 08:35'!current
	^ self starting: DateAndTime now
! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 18:49'!new	"Answer a Timespan starting on the Squeak epoch: 1 January 1901"	^ self starting: DateAndTime new! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:42'!starting: aDateAndTime
	^ self starting: aDateAndTime duration: Duration zero
! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 18:48'!starting: aDateAndTime duration: aDuration	^ self basicNew
 		start: aDateAndTime asDateAndTime;
		duration: aDuration;		yourself.! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:16'!starting: startDateAndTime ending: endDateAndTime	^ self 		starting: startDateAndTime 		duration: (endDateAndTime asDateAndTime - startDateAndTime).
! !WriteStream subclass: #TranscriptStream	instanceVariableNames: ''	classVariableNames: 'AccessSema'	poolDictionaries: ''	category: 'Collections-Streams'!!TranscriptStream commentStamp: '<historical>' prior: 0!This class is a much simpler implementation of Transcript protocol that supports multiple views and very simple conversion to morphic.  Because it inherits from Stream, it is automatically compatible with code that is designe to write to streams.!!TranscriptStream methodsFor: 'initialization' stamp: 'BG 10/29/2003 08:05'!open	| openCount |	openCount _ 0.	self dependents do:		[:d | ((d isKindOf: PluggableTextView) ) ifTrue: [openCount _ openCount + 1]].	openCount = 0		ifTrue: [self openLabel: 'Transcript']		ifFalse: [self openLabel: 'Transcript #' , (openCount+1) printString]! !!TranscriptStream methodsFor: 'initialization' stamp: 'ssa 9/3/2008 11:13'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'access' stamp: 'di 3/16/1999 21:38'!characterLimit	"Tell the views how much to retain on screen"	^ 20000! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'sma 3/15/2000 21:28'!bs	self position > 0 ifTrue: [^ self skip: -1].	self changed: #bs! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'di 5/8/1998 12:35'!clear	"Clear all characters and redisplay the view"	self changed: #clearText.	self reset! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'mir 1/11/2000 11:41'!endEntry	"Display all the characters since the last endEntry, and reset the stream"	self semaphore critical:[		self changed: #appendEntry.		self reset.	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'sma 4/22/2000 16:58'!flush	self endEntry! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'di 5/8/1998 12:35'!pastEndPut: anObject	"If the stream reaches its limit, just output the contents and reset."	self endEntry.	^ self nextPut: anObject! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'sma 2/26/2000 19:31'!show: anObject  "TextCollector compatibility"	self nextPutAll: anObject asString; endEntry! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/29/1998 17:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/3/1999 22:49'!release	self dependents do:		[:view | (view isMorph and: [view isInWorld not])					ifTrue: [self removeDependent: view]]! !!TranscriptStream methodsFor: 'model protocol' stamp: 'sw 3/2/2001 10:18'!step	"Objects that may be models of SystemWindows need to respond to this, albeit vacuously"! !!TranscriptStream methodsFor: 'private' stamp: 'mir 1/11/2000 11:41'!semaphore	^AccessSema ifNil:[AccessSema _ Semaphore forMutualExclusion]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TranscriptStream class	instanceVariableNames: ''!!TranscriptStream class methodsFor: 'as yet unclassified' stamp: 'di 5/8/1998 13:51'!new	^ self on: (String new: 1000)"INSTALLING:TextCollector allInstances do:	[:t | t breakDependents.	t become: TranscriptStream new].TESTING: (Execute this text in a workspace)Do this first...	tt _ TranscriptStream new.	tt openLabel: 'Transcript test 1'.Then this will open a second view -- ooooh...	tt openLabel: 'Transcript test 2'.And finally make them do something...	tt clear.	[Sensor anyButtonPressed] whileFalse:		[1 to: 20 do: [:i | tt print: (2 raisedTo: i-1); cr; endEntry]]."! !!TranscriptStream class methodsFor: 'as yet unclassified' stamp: 'di 5/8/1998 12:44'!newTranscript: aTextCollector 	"Store aTextCollector as the value of the system global Transcript."	Smalltalk at: #Transcript put: aTextCollector! !!TranscriptStream class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:05'!initialize	self registerInFlapsRegistry.	! !!TranscriptStream class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:06'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(TranscriptStream		openMorphicTranscript	'Transcript'			'A Transcript is a window usable for logging and debugging; browse references to #Transcript for examples of how to write to it.')						forFlapNamed: 'Tools']! !!TranscriptStream class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:41'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !ReadWriteStream subclass: #Transcripter	instanceVariableNames: 'frame para'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!Transcripter commentStamp: '<historical>' prior: 0!Transcripter is a dog-simple scrolling stream with display.  It is intended to operate with no support from MVC or color in a minimal, or headless version of Squeak.  No attention has been paid to appearance or performance.!!Transcripter methodsFor: 'initialization' stamp: 'di 8/14/97 12:44'!initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ Paragraph withText: self contents asText				style: TextStyle default				compositionRectangle: ((frame insetBy: 4) withHeight: 9999)				clippingRectangle: frame				foreColor: self black backColor: self white! !!Transcripter methodsFor: 'accessing' stamp: 'di 8/14/97 12:41'!clear	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	self on: (String new: 100); endEntry! !!Transcripter methodsFor: 'accessing' stamp: 'di 8/14/97 12:44'!endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue:		["Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para setWithText: c asText		style: TextStyle default		compositionRectangle: ((frame insetBy: 4) withHeight: 9999)		clippingRectangle: frame		foreColor: self black backColor: self white.	d _ para compositionRectangle bottom - frame bottom.	d > 0 ifTrue:		["Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint: para compositionRectangle topLeft											+ (0@(d+para lineGrid)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	para display! !!Transcripter methodsFor: 'accessing' stamp: 'sma 2/26/2000 19:35'!show: anObject	self nextPutAll: anObject asString; endEntry! !!Transcripter methodsFor: 'command line' stamp: 'di 8/12/97 22:11'!confirm: queryString 	| choice |	[true]		whileTrue: 			[choice _ self request: queryString , 'Please type yes or no followed by return'.			choice first asUppercase = $Y ifTrue: [^ true].			choice first asUppercase = $N ifTrue: [^ false]]! !!Transcripter methodsFor: 'command line' stamp: 'di 11/3/2000 18:52'!readEvalPrint	| line okToRevert |	okToRevert _ true.	[#('quit' 'exit' 'done' ) includes: (line _ self request: '>')]		whileFalse:		[line = 'revert'		ifTrue: [okToRevert			ifTrue: [Utilities revertLastMethodSubmission.					self cr; show: 'reverted: ' , Utilities mostRecentlySubmittedMessage.					okToRevert _ false]			ifFalse: [self cr; show: 'Only one level of revert currently supported']]		ifFalse: [self cr; show: ([Compiler evaluate: line] ifError: [:err :ex | err])]]! !!Transcripter methodsFor: 'command line' stamp: 'sma 2/26/2000 19:39'!request: prompt	| startPos char contents | 	self cr; show: prompt.	startPos _ position.	[[Sensor keyboardPressed] whileFalse.	(char _ Sensor keyboard) = Character cr]		whileFalse:		[char = Character backspace			ifTrue: [readLimit _ position _ (position - 1 max: startPos)]			ifFalse: [self nextPut: char].		self endEntry].	contents _ self contents.	^ contents copyFrom: startPos + 1 to: contents size! !!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12'!black	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].	^ Color black! !!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12'!white	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].	^ Color white! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Transcripter class	instanceVariableNames: ''!!Transcripter class methodsFor: 'instance creation' stamp: 'di 8/14/97 12:09'!newInFrame: frame"(Transcripter newInFrame: (0@0 extent: 100@200))	nextPutAll: 'Hello there'; endEntry;	cr; print: 355.0/113; endEntry;	readEvalPrint."	| transcript |	transcript _ self on: (String new: 100).	transcript initInFrame: frame.	^ transcript clear! !!Transcripter class methodsFor: 'utilities' stamp: 'di 11/3/2000 18:47'!emergencyEvaluator	(Transcripter newInFrame: (0@0 corner: 320@200))		show: 'Type ''revert'' to revert your last method change.Type ''exit'' to exit the emergency evaluator.';		readEvalPrint! !ArrayedCollection variableSubclass: #TranslatedMethod	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TranslatedMethod class	instanceVariableNames: ''!!TranslatedMethod class methodsFor: 'class initialization' stamp: 'ikp 1/10/98 02:34'!initialize	self becomeCompact.	Smalltalk recreateSpecialObjectsArray.	Smalltalk specialObjectsArray size = 41		ifFalse: [self error: 'Please check size of special objects array!!']! !Color subclass: #TranslucentColor	instanceVariableNames: 'alpha'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!TranslucentColor commentStamp: '<historical>' prior: 0!A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the high byte of a 32-bit pixelValue.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!!TranslucentColor methodsFor: 'accessing'!alpha	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."	^ alpha asFloat / 255.0! !!TranslucentColor methodsFor: 'equality'!hash	^ rgb bitXor: alpha! !!TranslucentColor methodsFor: 'printing' stamp: 'mir 7/21/1999 11:43'!storeArrayValuesOn: aStream	self isTransparent ifTrue: [		^ aStream space].	super storeArrayValuesOn: aStream.	aStream space.	(self alpha roundTo: 0.001) storeOn: aStream.! !!TranslucentColor methodsFor: 'printing' stamp: 'di 9/27/2000 13:33'!storeOn: aStream	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		print: (self alpha roundTo: 0.001);		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/15/1999 11:44'!alpha: alphaValue	alphaValue = 1.0 ifTrue:		[^ Color basicNew			setPrivateRed: self privateRed			green: self privateGreen			blue: self privateBlue].	^ super alpha: alphaValue! !!TranslucentColor methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!asNontranslucentColor	^ self alpha: 1.0! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 3/25/2000 17:56'!balancedPatternForDepth: depth	"Return an appropriate bit pattern or stipple.  This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."	alpha = 0 ifTrue: [^ Bitmap with: 0].	^ super balancedPatternForDepth: depth! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/14/1999 20:05'!bitPatternForDepth: depth	"Return an appropriate bit pattern or stipple.  This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."	alpha = 0 ifTrue: [^ Bitmap with: 0].	^ super bitPatternForDepth: depth! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 5/27/2001 16:30'!pixelValueForDepth: d	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	alpha = 0 ifTrue: [^ 0].	basicPixelWord _ super pixelValueForDepth: d.	d < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/6/1999 16:14'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	alpha = 0 ifTrue: [^ 0].	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:30'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	| pv32 a b g r |	pv32 _ super scaledPixelValue32.	a _ (self alpha * 255.0) rounded.	b _ (pv32 bitAnd: 255) * a // 256.	g _ ((pv32 bitShift: -8) bitAnd: 255) * a // 256.	r _ ((pv32 bitShift: -16) bitAnd: 255) * a // 256.	^b + (g bitShift: 8) + (r bitShift: 16) + (a bitShift: 24)! !!TranslucentColor methodsFor: 'private'!privateAlpha	"Return my raw alpha value, an integer in the range 0..255. Used for fast equality testing."	^ alpha! !!TranslucentColor methodsFor: 'private'!setRgb: rgbValue alpha: alphaValue	"Set the state of this translucent color. Alpha is represented internally by an integer in the range 0..255."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgbValue.	alpha _ (255.0 * alphaValue) asInteger min: 255 max: 0.! !!TranslucentColor methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!isOpaque	^alpha = 255! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ alpha < 255! !!TranslucentColor methodsFor: 'queries' stamp: 'di 1/3/1999 12:22'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ alpha > 0! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTransparent	^ alpha = 0! !!TranslucentColor methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:50'!convertToCurrentVersion: varDict refStream: smartRefStrm		"1/13/1999 -- old versions did not have alpha??"	varDict at: 'alpha' ifAbsent: [^ Color transparent].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.	! !Boolean subclass: #True	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!True commentStamp: '<historical>' prior: 0!True defines the behavior of its single instance, true -- logical assertion. Notice how the truth-value checks become direct message sends, without the need for explicit testing.Be aware however that most of these methods are not sent as real messages in normal use. Most are inline coded by the compiler as test and jump bytecodes - avoiding the overhead of the full message sends. So simply redefining these methods here will have no effect.!!True methodsFor: 'logical operations'!& alternativeObject 	"Evaluating conjunction -- answer alternativeObject since receiver is true."	^alternativeObject! !!True methodsFor: 'logical operations'!not	"Negation--answer false since the receiver is true."	^false! !!True methodsFor: 'logical operations'!| aBoolean 	"Evaluating disjunction (OR) -- answer true since the receiver is true."	^self! !!True methodsFor: 'controlling'!and: alternativeBlock 	"Nonevaluating conjunction -- answer the value of alternativeBlock since	the receiver is true."	^alternativeBlock value! !!True methodsFor: 'controlling'!ifFalse: alternativeBlock 	"Since the condition is true, the value is the true alternative, which is nil. 	Execution does not actually reach here because the expression is compiled 	in-line."	^nil! !!True methodsFor: 'controlling'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 	"Answer the value of trueAlternativeBlock. Execution does not 	actually reach here because the expression is compiled in-line."	^trueAlternativeBlock value! !!True methodsFor: 'controlling'!ifTrue: alternativeBlock 	"Answer the value of alternativeBlock. Execution does not actually 	reach here because the expression is compiled in-line."	^alternativeBlock value! !!True methodsFor: 'controlling'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 	"Answer with the value of trueAlternativeBlock. Execution does not 	actually reach here because the expression is compiled in-line."	^trueAlternativeBlock value! !!True methodsFor: 'controlling'!or: alternativeBlock 	"Nonevaluating disjunction -- answer true since the receiver is true."	^self! !!True methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'true'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True class	instanceVariableNames: ''!!True class methodsFor: 'as yet unclassified' stamp: 'sw 5/8/2000 11:09'!initializedInstance	^ true! !Object subclass: #TwoLevelDictionary	instanceVariableNames: 'firstLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!TwoLevelDictionary commentStamp: '<historical>' prior: 0!A simple dictionary for the use of the TextDiffBuilder. Keys are presumed to be Points and a significant speed advantage is gained by using a dictionary of dictionaries. The first is keyed by the x-values and the second by the y-values. Only the minimum necessary protocol is implemented.!!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:42'!at: aPoint	^(firstLevel at: aPoint x ifAbsent: [^nil]) at: aPoint y ifAbsent: [^nil]! !!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:37'!at: aPoint put: anObject	(firstLevel at: aPoint x ifAbsentPut: [Dictionary new]) at: aPoint y put: anObject! !!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:38'!initialize	firstLevel _ Dictionary new.! !!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:40'!keysDo: aBlock	firstLevel keysAndValuesDo: [ :x :v |		v keysDo: [ :y | aBlock value: x@y]	].! !!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:40'!twoLevelKeys	| twoLevelSet |	twoLevelSet _ TwoLevelSet new.	self keysDo: [ :each | twoLevelSet add: each].	^twoLevelSet! !Object subclass: #TwoLevelSet	instanceVariableNames: 'firstLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-File Contents Browser'!!TwoLevelSet commentStamp: '<historical>' prior: 0!A simple set for the use of the TextDiffBuilder. Elements are presumed to be Points and a significant speed advantage is gained by using a dictionary of sets. The first is keyed by the x-values and the second contains the y-values. Only the minimum necessary protocol is implemented.!!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:18'!add: aPoint	(firstLevel at: aPoint x ifAbsentPut: [Set new]) add: aPoint y! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:18'!copy	| answer |	answer _ self class new initialize.	self do: [ :each |		answer add: each	].	^answer! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/3/2001 09:26'!detect: aBlock	firstLevel keysAndValuesDo: [ :x :v |		v do: [ :y | (aBlock value: x@y) ifTrue: [^x@y]]	].	^nil! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:15'!do: aBlock	firstLevel keysAndValuesDo: [ :x :v |		v do: [ :y | aBlock value: x@y]	].! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:19'!includes: aPoint	^(firstLevel at: aPoint x ifAbsent: [^false]) includes: aPoint y! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:11'!initialize	firstLevel _ Dictionary new.! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:13'!isEmpty	^firstLevel isEmpty! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:22'!remove: aPoint	| lev2 |	lev2 _ firstLevel at: aPoint x ifAbsent: [^self].	lev2 remove: aPoint y ifAbsent: [].	lev2 isEmpty ifTrue: [firstLevel removeKey: aPoint x].! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:28'!removeAllXAndY: aPoint	| deletes |	deletes _ OrderedCollection new.	firstLevel removeKey: aPoint x ifAbsent: [].	firstLevel keysAndValuesDo: [ :x :lev2 |		lev2 remove: aPoint y ifAbsent: [].		lev2 isEmpty ifTrue: [deletes add: x].	].	deletes do: [ :each | firstLevel removeKey: each ifAbsent: []].! !Object subclass: #UndefinedObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!UndefinedObject commentStamp: '<historical>' prior: 0!I describe the behavior of my sole instance, nil. nil represents a prior value for variables that have not been initialized, or for results which are meaningless.!!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying'!deepCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying'!shallowCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!UndefinedObject methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:." 	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'testing' stamp: 'sw 1/12/98 18:09'!haltIfNil	self halt! !!UndefinedObject methodsFor: 'testing'!ifNil: aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value! !!UndefinedObject methodsFor: 'testing'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!UndefinedObject methodsFor: 'testing'!ifNotNil: aBlock	"A convenient test, in conjunction with Object ifNotNil:"	^ self! !!UndefinedObject methodsFor: 'testing'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!UndefinedObject methodsFor: 'testing' stamp: 'di 11/8/2000 21:22'!ifNotNilDo: aBlock	"Override to do nothing."	^ self! !!UndefinedObject methodsFor: 'testing' stamp: 'sw 4/7/1999 17:44'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ true! !!UndefinedObject methodsFor: 'testing' stamp: 'sma 6/6/2000 22:53'!isLiteral	^ true! !!UndefinedObject methodsFor: 'testing'!isNil 	"Refer to the comment in Object|isNil."	^true! !!UndefinedObject methodsFor: 'testing'!notNil 	"Refer to the comment in Object|notNil."	^false! !!UndefinedObject methodsFor: 'dependents access'!addDependent: ignored 	"Refer to the comment in Object|dependents."	self error: 'Nil should not have dependents'! !!UndefinedObject methodsFor: 'dependents access'!release	"Nil release is a no-op"! !!UndefinedObject methodsFor: 'dependents access'!suspend	"Kills off processes that didn't terminate properly"	"Display reverse; reverse."  "<-- So we can catch the suspend bug"	Processor terminateActive! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:49'!addSubclass: aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'sd 3/28/2003 15:16'!environment	"Necessary to support disjoint class hierarchies."	^self class environment! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ajh 1/27/2003 17:48'!literalScannedAs: scannedLiteral notifying: requestor 	^ scannedLiteral! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ikp 9/26/97 14:45'!removeSubclass: aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ls 10/9/2001 00:11'!subclass: nameOfClass  	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category	"Calling this method is now considered an accident.  If you really want to create a class with a nil superclass, then create the class and then set the superclass using #superclass:"	Transcript show: ('Attempt to create ', nameOfClass, ' as a subclass of nil.  Possibly a class is being loaded before its superclass.'); cr.	^ProtoObject		subclass: nameOfClass		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictnames		category: category! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 8/29/1999 12:49'!subclassDefinerClass	"For disjunct class hierarchies -- how should subclasses of nil be evaluated"	^Compiler! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:55'!subclasses	"Return all the subclasses of nil"	| classList |	classList _ WriteStream on: Array new.	self subclassesDo:[:class| classList nextPut: class].	^classList contents! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 15:44'!subclassesDo: aBlock	"Evaluate aBlock with all subclasses of nil."	^Class subclassesDo:[:cl| 		cl isMeta ifTrue:[aBlock value: cl soleInstance]].! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'tk 8/18/1999 17:46'!subclassesDoGently: aBlock	"Evaluate aBlock with all subclasses of nil.  Others are not direct subclasses of Class."	^ Class subclassesDoGently: [:cl | 			cl isMeta ifTrue: [aBlock value: cl soleInstance]].! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/13/1999 06:08'!typeOfClass	"Necessary to support disjoint class hierarchies."	^#normal! !!UndefinedObject methodsFor: 'bottom context' stamp: 'ajh 2/1/2003 01:31'!handleSignal: exception	"When no more handler (on:do:) context left in sender chain this gets called.  Return from signal with default action."	^ exception resumeUnchecked: exception defaultAction! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UndefinedObject class	instanceVariableNames: ''!!UndefinedObject class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 09:32'!initializedInstance	^ nil! !!UndefinedObject class methodsFor: 'instance creation'!new	self error: 'You may not create any more undefined objects--use nil'! !Exception subclass: #UnhandledError	instanceVariableNames: 'exception'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 9/5/2002 15:11'!defaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	self isDevelopmentEnvironmentPresent		ifTrue: [self devDefaultAction]		ifFalse: [self runtimeDefaultAction].! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 1/24/2003 19:21'!devDefaultAction	Processor activeProcess		debug: exception signalerContext		title: exception description! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 9/4/2002 19:16'!isDevelopmentEnvironmentPresent	^ Smalltalk includesKey: #Debugger! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 2/1/2003 00:56'!isResumable		^ false! !!UnhandledError methodsFor: 'priv handling' stamp: 'sd 11/16/2003 14:18'!runtimeDefaultAction	"Dump the stack trace to a log file, then exit the program (image)."	| file |	file := FileStream newFileNamed: ('error', Utilities dateTimeSuffix, FileDirectory dot, 'log') asFileName.	Smalltalk timeStamp: file.	(thisContext sender stackOfSize: 20) do: [:ctx | file cr. ctx printOn: file].	file close.	SmalltalkImage current snapshot: false andQuit: true! !!UnhandledError methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:15'!exception	^ exception! !!UnhandledError methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:15'!exception: anError	exception _ anError! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnhandledError class	instanceVariableNames: ''!!UnhandledError class methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:17'!signalForException: anError	^ self new		exception: anError;		signal! !FileDirectory subclass: #UnixFileDirectory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!UnixFileDirectory commentStamp: '<historical>' prior: 0!I represent a Unix FileDirectory.!!UnixFileDirectory methodsFor: 'file names' stamp: 'bf 3/22/2000 18:24'!fullPathFor: path	"Return the fully-qualified path name for the given file."	path isEmpty ifTrue: [^ pathName].	path first = $/ ifTrue: [^ path].	^ pathName = '/'			"Only root dir ends with a slash"		ifTrue: ['/' , path]		ifFalse: [pathName , '/' , path]! !!UnixFileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 23:43'!setPathName: pathString	"Unix path names start with a leading delimiter character."	(pathString isEmpty or: [pathString first ~= self pathNameDelimiter])		ifTrue: [pathName _ self pathNameDelimiter asString, pathString]		ifFalse: [pathName _ pathString].! !!UnixFileDirectory methodsFor: 'testing' stamp: 'sr 5/8/2000 12:58'!directoryExists: filenameOrPath	"Handles the special case of testing for the root dir: there isn't a	possibility to express the root dir as full pathname like '/foo'."	^ filenameOrPath = '/' or: [super directoryExists: filenameOrPath]! !!UnixFileDirectory methodsFor: 'testing' stamp: 'sr 5/8/2000 13:03'!fileOrDirectoryExists: filenameOrPath 	"Handles the special case of testing for the root dir: there isn't a 	possibility to express the root dir as full pathname like '/foo'."	^ filenameOrPath = '/' or: [super fileOrDirectoryExists: filenameOrPath]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnixFileDirectory class	instanceVariableNames: ''!!UnixFileDirectory class methodsFor: 'platform specific' stamp: 'yo 2/4/1999 06:40'!maxFileNameLength	^ 255! !!UnixFileDirectory class methodsFor: 'platform specific' stamp: 'jm 9/17/97 15:48'!pathNameDelimiter	^ $/! !Object subclass: #Utilities	instanceVariableNames: ''	classVariableNames: 'AuthorInitials AuthorName CommonRequestStrings LastStats RecentSubmissions ScrapsBook UpdateDownloader UpdateUrlLists'	poolDictionaries: ''	category: 'System-Support'!!Utilities commentStamp: '<historical>' prior: 0!A repository for general and miscellaneous utilities; much of what is here are in effect global methods that don't naturally attach to anything else.  1/96 sw!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Utilities class	instanceVariableNames: ''!!Utilities class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:11'!initialize	"Initialize the class variables.  5/16/96 sw"	self initializeCommonRequestStrings.	RecentSubmissions _ OrderedCollection new.	self registerInFlapsRegistry.	! !!Utilities class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:12'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(Utilities	recentSubmissionsWindow	'Recent'		'A message browser that tracks the most recently-submitted methods')						forFlapNamed: 'Tools'.]! !!Utilities class methodsFor: 'class initialization' stamp: 'NS 1/26/2004 09:52'!startUp	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #event:.! !!Utilities class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:42'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!Utilities class methodsFor: 'common requests' stamp: 'tk 5/4/1998 17:35'!editCommonRequestStrings	"Let the user edit the common request strings.  2/1/96 sw"	CommonRequestStrings openLabel: 'Common Request Strings'! !!Utilities class methodsFor: 'common requests' stamp: 'sd 1/19/2004 20:58'!evaluate: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"		self deprecated: 'Use Compiler>>evaluate: aString in: aContext to: aReceiver'.	^ Compiler new evaluate: aString in: aContext to: aReceiver! !!Utilities class methodsFor: 'common requests' stamp: 'sw 2/5/2002 13:17'!initializeCommonRequestStrings	"Initialize the common request strings, a directly-editable list of expressions that can be evaluated from the 'do...' menu."	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapse.Utilities closeAllDebuggers.-Sensor keyboard.ParagraphEditor abandonChangeText.Cursor normal show.-CommandHistory resetAllHistory.Project allInstancesDo: [:p | p displayDepth: 16].ScriptingSystem inspectFormDictionary.Form fromUser bitEdit.Display border: (0@0 extent: 640@480) width: 2.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.Transcript clear.Utilities grabScreenAndSaveOnDisk.FrameRateMorph new openInHand.-Utilities reconstructTextWindowsFromFileNamed: ''TW''.Utilities storeTextWindowContentsToFileNamed: ''TW''.ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.-ActiveWorld installVectorVocabulary.ActiveWorld abandonVocabularyPreference.Smalltalk saveAsNewVersion'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'common requests' stamp: 'BG 10/29/2003 08:38'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings _ CommonRequestStrings contents.	normalItemCount _ strings asString lineCount.	aMenu _ PopUpMenu labels: (strings asString, 'edit this menu') lines: (Array with: normalItemCount).	index _ aMenu startUp.	index == 0 ifTrue: [^ self].	reply _ aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result _ self evaluate: reply in: nil to: nil.	(result isKindOf: Number) | (result isKindOf: String)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'debugging' stamp: 'sw 4/29/2001 23:42'!doesNotUnderstand: aMessage	"A temporary expedient for revectoring various messages formerly sent to Utilities that now are instead implemented by Flaps; this is only for the benefit of pre-existing buttons and menu items that were set up to call the old interface"	| aSelector |	aSelector _ aMessage selector.	(#(addLocalFlap explainFlaps addMenuFlap addPaintingFlap addStackToolsFlap addGlobalFlap offerGlobalFlapsMenu toggleWhetherToUseGlobalFlaps ) includes: aSelector)		ifTrue:			[^ self inform: 'Sorry, this is an obsolete menu.  Pleasedismiss it and get a fresh one.  Thank you'].	^ super doesNotUnderstand: aMessage! !!Utilities class methodsFor: 'fetching updates' stamp: 'RAA 12/17/2000 16:19'!zapUpdateDownloader	UpdateDownloader ifNotNil: [UpdateDownloader terminate].	UpdateDownloader _ nil.! !!Utilities class methodsFor: 'deprecated' stamp: 'sd 1/16/2004 21:37'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     self deprecated: 'Use ChangeSorter fileOutChangeSetsNamed: nameList'.	ChangeSorter fileOutChangeSetsNamed: nameList! !!Utilities class methodsFor: 'deprecated' stamp: 'sd 1/16/2004 21:31'!fileOutChanges	"File out the current change set to a file whose name is a function of the current date and time."	self deprecated: 'Use ChangeSet current verboseFileOut'.	ChangeSet current verboseFileOut! !!Utilities class methodsFor: 'deprecated' stamp: 'sd 1/16/2004 21:09'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."		self deprecated: 'Use SystemNavigation default methodHierarchyBrowserForClass: aClass selector: sel'. 	SystemNavigation default methodHierarchyBrowserForClass: aClass selector: sel! !!Utilities class methodsFor: 'deprecated' stamp: 'sd 1/16/2004 21:14'!spawnHierarchyForClass: aClass selector: aSelector	"Utilities spawnHierarchyForClass: SmallInteger selector: #hash"		self deprecated: 'SystemNavigation default spawnHierarchyForClass: aClass selector: aSelector'.	SystemNavigation default spawnHierarchyForClass: aClass selector: aSelector! !!Utilities class methodsFor: 'graphical support' stamp: 'md 12/12/2003 17:03'!grabScreenAndSaveOnDisk  "Utilities grabScreenAndSaveOnDisk"	| form fileName |	self deprecated: 'Use GIFReaderWriter grabScreenAndSaveOnDisk'.	form _ Form fromUser.	form bits size = 0 ifTrue: [^ Beeper beep].	fileName _ FileDirectory default nextNameFor: 'Squeak' extension: 'gif'.	Utilities informUser: 'Writing ' , fileName		during: [GIFReadWriter putForm: form onFileNamed: fileName].! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:48'!authorInitials	"Answer the initials to be used to identify the current code author.  "	[AuthorInitials isEmpty] whileTrue: [self setAuthorInitials].	^ AuthorInitials! !!Utilities class methodsFor: 'identification' stamp: 'sw 7/6/1998 11:49'!authorInitialsPerSe	"Answer the currently-prevailing author initials, such as they, empty or not"	^ AuthorInitials! !!Utilities class methodsFor: 'identification' stamp: 'fc 3/11/2004 12:22'!authorName	AuthorName ifEmpty: [self setAuthorName].	^ AuthorName! !!Utilities class methodsFor: 'identification' stamp: 'tk 4/10/98 06:25'!changeStamp 	"Answer a string to be pasted into source code to mark who changed it and when."	^ self authorInitials , ' ' , Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!Utilities class methodsFor: 'identification' stamp: 'sw 1/29/2001 09:28'!changeStampPerSe	"Answer a string to be pasted into source code to mark who changed it and when."	^ (self authorInitialsPerSe ifNil: ['']) , ' ' , Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 22:45'!dateTimeSuffix	"Answer a string which indicates the date and time, intended for use in building fileout filenames, etc."	"Utilities dateTimeSuffix"	^ Preferences twentyFourHourFileStamps		ifFalse:			[self monthDayTimeStringFrom: Time primSecondsClock]		ifTrue:			[self monthDayTime24StringFrom: Time primSecondsClock]! !!Utilities class methodsFor: 'identification' stamp: 'di 6/13/97 13:52'!fixStamp: changeStamp 	| parts |	parts _ changeStamp findTokens: ' '.	(parts size > 0 and: [parts last first isLetter]) ifTrue:		["Put initials first in all time stamps..."		^ String streamContents:				[:s | s nextPutAll: parts last.				parts allButLast do: [:p | s space; nextPutAll: p]]].	^ changeStamp! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 23:03'!monthDayTime24StringFrom: aSecondCount	| aDate aTime |	"From the date/time represented by aSecondCount, produce a string which indicates the date and time in the compact form             ddMMMhhmm		where dd is a two-digit day-of-month, MMM is the alpha month abbreviation and hhmm is the time on a 24-hr clock.          Utilities monthDayTime24StringFrom: Time primSecondsClock"	aDate _ Date fromSeconds: aSecondCount.	aTime _ Time fromSeconds: aSecondCount \\ 86400.	^ (aDate dayOfMonth asTwoCharacterString), 		(aDate monthName copyFrom: 1 to: 3), 		(aTime hhmm24)! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 23:03'!monthDayTimeStringFrom: aSecondCount	| aDate aTime |	"From the date/time represented by aSecondCount, produce a string which indicates the date and time in the form:		ddMMMhhmmPP	  where:							dd is a two-digit day-of-month,							MMM is the alpha month abbreviation,							hhmm is the time,							PP is either am or pm          Utilities monthDayTimeStringFrom: Time primSecondsClock"	aDate _ Date fromSeconds: aSecondCount.	aTime _ Time fromSeconds: aSecondCount \\ 86400.	^ (aDate dayOfMonth asTwoCharacterString), 		(aDate monthName copyFrom: 1 to: 3), 		((aTime hours \\ 12) asTwoCharacterString), 		(aTime minutes asTwoCharacterString),		(aTime hours > 12 ifTrue: ['pm'] ifFalse: ['am'])! !!Utilities class methodsFor: 'identification' stamp: 'gm 5/15/2004 02:59'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	self setAuthorInitials:		(FillInTheBlank request: 'Please type your initials: '					initialAnswer: AuthorInitials)! !!Utilities class methodsFor: 'identification' stamp: 'fc 3/11/2004 12:13'!setAuthorInitials: aString	AuthorInitials _ aString.	"Case of being reset due to, eg, copy of image."	aString isEmpty ifTrue: [AuthorName _ '']! !!Utilities class methodsFor: 'identification' stamp: 'sma 6/1/2000 12:08'!setAuthorName	AuthorName _ FillInTheBlank 			request: 'Please type your name:'			initialAnswer: 'Your Name'! !!Utilities class methodsFor: 'miscellaneous'!awaitMouseUpIn: box repeating: doBlock ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock. 5/11/96 sw	6/10/96 sw: call new method that adds extra feature"	^ self awaitMouseUpIn: box whileMouseDownDo: doBlock whileMouseDownInsideDo: [] ifSucceed: succBlock! !!Utilities class methodsFor: 'miscellaneous' stamp: 'JMM 3/31/2000 20:41'!awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw3/31/00 JMM added logic to stop multiple redraws"	| p inside lightForm darkForm isLight |	p _ Sensor cursorPoint.	inside _ box insetBy: 1.	isLight _ true.	lightForm _ Form fromDisplay: inside.	darkForm _ lightForm deepCopy reverse.	[Sensor anyButtonPressed] whileTrue:		[doBlock1 value.		(box containsPoint: (p _ Sensor cursorPoint))			ifTrue: [doBlock2 value.					isLight ifTrue: 						[isLight _ false.						darkForm displayAt: inside origin]]			ifFalse: [isLight ifFalse:						[isLight _ true.						lightForm displayAt: inside origin]]].	(box containsPoint: p)		ifTrue: [lightForm displayAt: inside origin.				^ succBlock value]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sma 4/30/2000 10:17'!emergencyCollapse	Smalltalk isMorphic ifTrue: [^ self].	ScheduledControllers screenController emergencyCollapse! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sd 4/17/2003 21:04'!fixUpProblemsWithAllCategory	"Moves all methods that are in formally classified a category named '-- all --' into the default 'as yet unclassified' category"	"Utilities fixUpProblemsWithAllCategory"	| org aCategory methodCount classCount any |	self flag: #ShouldBeMovedInClassOrganization.	methodCount _ 0.	classCount _ 0.	self systemNavigation allBehaviorsDo:		[:aClass | org _ aClass organization.			(org categories includes: #'-- all --') ifTrue:				[any _ false.				aClass selectorsDo:					[:aSelector |						aCategory _ org categoryOfElement: aSelector.						aCategory = #'-- all --' ifTrue:							[org classify: aSelector under: ClassOrganizer default suppressIfDefault: false.							Transcript cr; show: aClass name, ' >> ', aSelector.							methodCount _ methodCount + 1.							any _ true]].			any ifTrue: [classCount _ classCount + 1].			org removeEmptyCategories]].	Transcript cr; show: methodCount printString, ' methods in ', classCount printString, ' classes moved from "-- all --" to "as yet unclassified"'! !!Utilities class methodsFor: 'miscellaneous' stamp: 'nk 2/15/2004 09:36'!garbageCollectAndReport	"Do a garbage collection, and report results to the user."	| cc reportString |	reportString _ String streamContents:		[:aStream | 			aStream nextPutAll: Smalltalk bytesLeftString.			Smalltalk at: #Command ifPresent:				[:cmdClass |				(cc _ cmdClass instanceCount) > 0 ifTrue:					[aStream cr; nextPutAll:		('(note: there are ', cc printString,		                         ' undo record(s) present in yoursystem; purging them may free up more space.)')]]].				self inform: reportString! !!Utilities class methodsFor: 'miscellaneous'!keyLike: aString satisfying: aBlock	"Return a key like aString that satisfies aBlock.  The block should provide a test for acceptability -- typically the test is about whether the key is already in use.  aBlock should return a boolean.  8/11/96 sw"	| stemAndSuffix suffix stem newKey |	(aBlock value: aString) ifTrue: [^ aString].	stemAndSuffix _ aString stemAndNumericSuffix.	suffix _ stemAndSuffix last + 1.	stem _ stemAndSuffix first.	[aBlock value: (newKey _ stem, suffix printString)]		whileFalse:			[suffix _ suffix + 1].	^ newKey! !!Utilities class methodsFor: 'miscellaneous'!keyLike: aString withTrailing: trailerString satisfying: aBlock	"Return a key like (aString, trailerString) that satisfies aBlock.  The block should provide a test for acceptability -- typically the test is about whether the key is already in use.  aBlock should return a boolean.  8/11/96 sw"	| stemAndSuffix suffix stem composite |	composite _ aString, trailerString.	(aBlock value: composite) ifTrue: [^ composite].	stemAndSuffix _ aString stemAndNumericSuffix.	suffix _ stemAndSuffix last + 1.	stem _ stemAndSuffix first.	[aBlock value: (composite _ stem, suffix printString, trailerString)]		whileFalse:			[suffix _ suffix + 1].	^ composite! !!Utilities class methodsFor: 'miscellaneous' stamp: 'BG 10/29/2003 08:13'!lookUpDefinition	| aWord aDefinition |	(aWord _ FillInTheBlank request: 'Enter a word:') isEmpty ifTrue: [^ self]."	(aDefinition _ WordNet definitionsFor: aWord) ifNil: [^ self]. "     aDefinition := ''.	(StringHolder new contents: aDefinition)		openLabel: aWord"Utilities lookUpDefinition"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'md 11/14/2003 18:02'!methodDiffFor: aString class: aClass selector: aSelector prettyDiffs: prettyDiffBoolean	"Return a string comprising a source-code diff between an existing method and the source-code in aString.  DO prettyDiff if prettyDiffBoolean is true."	^ (aClass notNil and: [aClass includesSelector: aSelector])		ifTrue:			[TextDiffBuilder				buildDisplayPatchFrom: (aClass sourceCodeAt: aSelector)				to: aString				inClass: aClass				prettyDiffs: prettyDiffBoolean]		ifFalse:			[aString copy]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 5/3/1998 20:12'!openScratchWorkspaceLabeled: labelString contents: initialContents	"Open a scratch text view with the given label on the given string. A scratch text view won't warn you about unsaved changes when you close it."	"Utilities openScratchWorkspaceLabeled: 'Scratch' contents: 'Hello. world!!'"	| model topView stringView |	model _ StringHolder new contents: initialContents.	topView _ StandardSystemView new.	topView		model: model;		label: labelString;		minimumSize: 180@120.	topView borderWidth: 1.	stringView _ PluggableTextView on: model 		text: #contents		accept: nil		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	stringView		askBeforeDiscardingEdits: false;		window: (0@0 extent: 180@120).	topView addSubView: stringView.	topView controller open.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'RAA 5/28/2001 10:02'!setClassAndSelectorFrom: messageIDString in: csBlock	"Decode strings of the form <className> [class] <selectorName>.   If <className> does not exist as a class, use nil for the class in the block"	| aStream aClass maybeClass sel |	(messageIDString isKindOf: MethodReference) ifTrue: [		^messageIDString setClassAndSelectorIn: csBlock	].	aStream _ ReadStream on: messageIDString.	aClass _ Smalltalk at: (aStream upTo: $ ) asSymbol ifAbsent: [nil].	maybeClass _ aStream upTo: $ .	sel _ aStream upTo: $ .	((maybeClass = 'class') & (sel size ~= 0))		ifTrue:			[aClass				ifNil:					[csBlock value: nil value: sel asSymbol]				ifNotNil:					[csBlock value: aClass class value: sel asSymbol]]		ifFalse:			[csBlock value: aClass value: maybeClass asSymbol]"Utilities setClassAndSelectorFrom: 'Utilities class oppositeModeTo:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString].Utilities setClassAndSelectorFrom: 'MessageSet setClassAndSelectorIn:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString]."! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 7/29/2002 02:23'!timeStampForMethod: method	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"Utilities timeStampForMethod: (Utilities class compiledMethodAt: #timeStampForMethod:)"	^ method timeStamp! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 7/29/2002 02:18'!assureMostRecentSubmissionExists	"Make certain that the most recent submission exists"	[RecentSubmissions size > 0 and:		[RecentSubmissions last isValid not]] whileTrue:			[RecentSubmissions removeLast].! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 11/5/2001 01:16'!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw."	"Utilities browseRecentSubmissions"	| recentMessages |	self recentMethodSubmissions size == 0 ifTrue:		[^ self inform: 'There are no recent submissions'].		recentMessages _ RecentSubmissions copy reversed.	RecentMessageSet 		openMessageList: recentMessages 		name: 'Recent submissions -- youngest first ' 		autoSelect: nil! !!Utilities class methodsFor: 'recent method submissions' stamp: 'NS 4/12/2004 22:47'!event: anEvent	"Hook for SystemChangeNotifier"	(anEvent isCommented and: [anEvent itemKind = SystemChangeNotifier classKind])		ifTrue: [self noteMethodSubmission: #Comment forClass: anEvent item].	((anEvent isAdded or: [anEvent isModified]) and: [anEvent itemKind = SystemChangeNotifier methodKind])		ifTrue: [anEvent itemRequestor ifNotNil: [self noteMethodSubmission: anEvent itemSelector forClass: anEvent itemClass]].	((anEvent isAdded or: [anEvent isModified]) and: [anEvent itemKind = SystemChangeNotifier methodKind]) ifTrue:[		InMidstOfFileinNotification signal			ifFalse: [Utilities changed: #recentMethodSubmissions].	].! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 7/29/2002 02:12'!mostRecentlySubmittedMessage	"Answer a string indicating the most recently submitted method that is still extant"	self flag: #mref.	"fix for faster references to methods"	self assureMostRecentSubmissionExists.	^ RecentSubmissions last asStringOrText asString! !!Utilities class methodsFor: 'recent method submissions' stamp: 'RAA 5/28/2001 10:53'!noteMethodSubmission: selectorName forClass: class	| submission |	self flag: #mref.	"fix for faster references to methods"	self recentMethodSubmissions.	"ensure it is valid"	class wantsChangeSetLogging ifFalse: [^ self].	self purgeRecentSubmissionsOfMissingMethods.	submission _ class name asString, ' ', selectorName.	RecentSubmissions removeAllSuchThat: [ :each |		each asStringOrText = submission	].	RecentSubmissions size >= self numberOfRecentSubmissionsToStore ifTrue: [		RecentSubmissions removeFirst	].	RecentSubmissions addLast: (		MethodReference new			setClass: class 			methodSymbol: selectorName 			stringVersion: submission	) ! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 7/28/2002 23:20'!numberOfRecentSubmissionsToStore	"Answer how many methods back the 'recent method submissions' history should store"	^ Preferences parameterAt: #numberOfRecentSubmissionsToStore ifAbsentPut: [30]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 7/28/2002 23:52'!numberOfRecentSubmissionsToStore: aNumber	"Set the number of Recent Submissions to store"	Preferences setParameter: #numberOfRecentSubmissionsToStore to: aNumber! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 9/26/2002 19:16'!purgeFromRecentSubmissions: aMethodReference	"Purge any reference found in RecentSubmissions to the method supplied"	RecentSubmissions _ RecentSubmissions select:		[:aSubmission |			Utilities setClassAndSelectorFrom: aSubmission in:				[:aClass :aSelector | (aClass ~~ aMethodReference actualClass) or: [aSelector ~~ aMethodReference methodSymbol]]]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 11/5/2001 12:04'!purgeRecentSubmissionsOfMissingMethods	"Utilities purgeRecentSubmissionsOfMissingMethods"	| keep |	self flag: #mref.	"fix for faster references to methods"	RecentSubmissions _ RecentSubmissions select:		[:aSubmission | 			Utilities setClassAndSelectorFrom: aSubmission in:				[:aClass :aSelector |					keep _ (aClass == nil) not						and: [aClass isInMemory						and: [aSelector == #Comment or: [(aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil]]]].			keep]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'RAA 5/28/2001 07:39'!recentMethodSubmissions	"Answer the list of recent method submissions, in order.  5/16/96 sw"	self flag: #mref.	"fix for faster references to methods"	RecentSubmissions == nil ifTrue: [RecentSubmissions _ OrderedCollection new].	^ RecentSubmissions! !!Utilities class methodsFor: 'recent method submissions' stamp: 'BG 11/1/2003 18:33'!recentSubmissionsWindow	"Answer a SystemWindow holding recent submissions"	| recentMessages messageSet |	recentMessages _ RecentSubmissions copy reversed.	messageSet _ RecentMessageSet messageList: recentMessages.	messageSet autoSelectString: nil."	^ (messageSet inMorphicWindowLabeled: 'Recent submissions -- youngest first') applyModelExtent "	"Utilities recentSubmissionsWindow openInHand"! !!Utilities class methodsFor: 'recent method submissions' stamp: 'nb 6/17/2003 12:25'!revertLastMethodSubmission	| changeRecords lastSubmission theClass theSelector |	"If the most recent method submission was a method change, revert	that change, and if it was a submission of a brand-new method, 	remove that method."	RecentSubmissions isEmptyOrNil ifTrue: [^ Beeper beep].	lastSubmission _ RecentSubmissions last.	theClass _ lastSubmission actualClass ifNil: [^ Beeper beep].	theSelector _ lastSubmission methodSymbol.	changeRecords _ theClass changeRecordsAt: theSelector.	changeRecords isEmptyOrNil ifTrue: [^ Beeper beep].	changeRecords size == 1		ifTrue:			["method has no prior version, so reverting in this case means removing"			theClass removeSelector: theSelector]		ifFalse:			[changeRecords second fileIn]."Utilities revertLastMethodSubmission"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 1/9/2001 05:34'!classFromPattern: pattern withCaption: aCaption	"If there is a class whose name exactly given by pattern, return it.	If there is only one class in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores tab, space, & cr characters in the pattern"	| toMatch potentialClassNames classNames exactMatch index |	(toMatch _  pattern copyWithoutAll:			{Character space.  Character cr.  Character tab})		isEmpty ifTrue: [^ nil].	Symbol hasInterned: toMatch ifTrue:		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:			[:maybeClass | (maybeClass isKindOf: Class) ifTrue: [^ maybeClass]]].	toMatch _ (toMatch copyWithout: $.) asLowercase.	potentialClassNames _ Smalltalk classNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ nil].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUpWithCaption: aCaption]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUpWithCaption: aCaption]].	index = 0 ifTrue: [^ nil].	^ Smalltalk at: (classNames at: index) asSymbol"	Utilities classFromPattern: 'CharRecog'	Utilities classFromPattern: 'rRecog'	Utilities classFromPattern: 'znak'	Utilities classFromPattern: 'orph'"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 4/30/1998 12:20'!inviolateInstanceVariableNames	"Answer a list of instance variable names not to be used.  (Place holder for real list)"	^ #('thisContext' 'self')! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 4/30/1998 12:20'!isLegalInstVarName: aString	"Answer whether aString is a legal instance variable name."	^ ((Scanner isLiteralSymbol: aString) and: [(aString includes: $:) not]) and:		[(self inviolateInstanceVariableNames includes:  aString) not]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/6/2000 22:47'!wellFormedInstanceVariableNameFrom: aString	"Answer a legal instance variable name, derived from aString"	| cleansedString |	cleansedString _ aString select: [:ch | ch isDigit or: [ch isLetter]].	(cleansedString size == 0 or: [cleansedString first isDigit])		ifTrue: [cleansedString _ 'a', cleansedString]		ifFalse:	[cleansedString _ cleansedString withFirstCharacterDownshifted].	[self isLegalInstVarName: cleansedString] whileFalse:		[cleansedString _ cleansedString, 'x'].	^ cleansedString"Utilities wellFormedInstanceVariableNameFrom:  '234 xx\ Uml /ler42342380-4'"! !!Utilities class methodsFor: 'support windows' stamp: 'dgd 9/21/2003 15:12'!commandKeyMappings	^ (self class firstCommentAt: #commandKeyMappings) translated"Lower-case command keys(use with Cmd key on Mac and Alt key on other platforms)a	Select allb	Browse it (selection is a class name or cursor is over a class-list or message-list)c	Copy selectiond	Do it (selection is a valid expression)e	Exchange selection with prior selectionf	Findg	Find againh	Set selection as search string for find againi	Inspect it (selection is a valid expression, or selection is over an inspect-ilst)j	Again once (do the last text-related operation again)k	Set fontl	Cancelm	Implementors of it (selection is a message selector or cursor is over a class-list or message-list)n	Senders of it (selection is a message selector or cursor is over a class-list or message-list)o	Spawn current methodp	Print it (selection is a valid expression)q	Query symbol (toggle all possible completion for a given prefix)r	Recognizers	Save (i.e. accept)t	Finds a Transcript (when cursor is over the desktop)u	Toggle alignmentv	Pastew	Delete preceding word (over text);  Close-window (over morphic desktop)x	Cut selectiony	Swap charactersz	UndoNote: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.Upper-case command keys	(use with Shift-Cmd, or Ctrl on Mac	or Shift-Alt on other platforms; sometimes Ctrl works too)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'G	fileIn from it (a file name)H	cursor TopHome:I	Inspect via Object ExplorerJ	Again many (apply the previous text command repeatedly until the end of the text)K	Set styleL	Outdent (move selection one tab-stop left)M	Select current type-inN	References to it (selection is a class name, or cursor is over a class-list or message-list)O	Open single-message browser (in message lists)P	Make project linkR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing it (in text); show-world-menu (when issued with cursor over desktop)X	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selectionOther special keysBackspace	Backward delete characterDel			Forward delete characterShift-Bksp	Backward delete wordShift-Del	Forward delete wordEsc			Pop up the Desktop Menu\			Send top window to backCursor keysleft, right,up, down	Move cursor left, right, up or downCtrl-left		Move cursor left one wordCtrl-right	Move cursor right one wordHome		Move cursor to begin of line or begin of textEnd			Move cursor to end of line or end of textPgUp, Ctrl-up	Move cursor up one pagePgDown, Ctrl-Dn	Move cursor down one pageNote all these keys can be used together with Shift to define or enlarge the selection. You cannot however shrink that selection again, as in some other systems.Other Cmd-key combinations (not available on all platforms)Return		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)Space		Select the current word as with double clickingEnclose the selection in a kind of bracket.  Each is a toggle.	(not available on all platforms)Ctrl-(	Enclose within ( and ), or remove enclosing ( and )Ctrl-[	Enclose within [ and ], or remove enclosing [ and ]Crtl-{	Enclose within { and }, or remove enclosing { and }Ctrl-<	Enclose within < and >, or remove enclosing < and >Ctrl-'	Enclose within ' and ', or remove enclosing ' and 'Ctrl-""	Enclose within "" and "", or remove enclosing "" and ""Note also that you can double-click just inside any of the above delimiters,or at the beginning or end of a line, to select the text enclosed.Text Emphasis	(not available on all platforms)Cmd-1	10 point fontCmd-2	12 point fontCmd-3	18 point fontCmd-4	24 point fontCmd-5	36 point fontCmd-6	color, action-on-click, link to class comment, link to method, url		Brings up a menu.  To remove these properties, select		more than the active part and then use command-0.Cmd-7	boldCmd-8	italicCmd-9	narrow (same as negative kern)Cmd-0	plain text (resets all emphasis)Cmd--	underlined (toggles it)Cmd-=	struck out (toggles it)Shift-Cmd--	(aka _) negative kern (letters 1 pixel closer)Shift-Cmd-+	positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'support windows' stamp: 'dgd 9/21/2003 15:12'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(StringHolder new contents: self commandKeyMappings)		openLabel: 'Command Key Actions' translated! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 02:02'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	(StringHolder new contents: self standardWorkspaceContents)		openLabel: 'Useful Expressions ', Date today printString! !!Utilities class methodsFor: 'support windows' stamp: 'sw 1/19/2000 13:59'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Utilities reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop]MessageTally spyOn: [Smalltalk allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'user interface' stamp: 'BG 11/11/2003 10:12'!informUser: aString during: aBlock	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait]"	(SelectionMenu labels: '')		displayAt: Sensor cursorPoint		withCaption: aString		during: [aBlock value]! !!Utilities class methodsFor: 'user interface' stamp: 'ssa 9/3/2008 11:13'!informUserDuring: aBlock	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUserDuring:[:bar|		#(one two three) do:[:info|			bar value: info.			(Delay forSeconds: 1) wait]]"	aBlock value:[:string| Transcript cr; show: string]! !!Utilities class methodsFor: 'vm statistics' stamp: 'nk 2/15/2004 09:35'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		Utilities vmStatisticsReportString) label: 'VM Statistics'"	self deprecated: 'Use SmalltalkImage current  vmStatisticsReportString'.	^SmalltalkImage current vmStatisticsReportString! !Model subclass: #ValueHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents	^contents! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'sw 1/28/1999 12:35'!contents: newContents	contents _ newContents.	self contentsChanged! !ObjectWithDocumentation subclass: #Variable	instanceVariableNames: 'defaultValue floatPrecision variableName variableType'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Kernel'!!Variable methodsFor: 'name' stamp: 'sw 5/3/2001 00:04'!printOn: aStream	"Print the receiver on the stream"	super printOn: aStream.	aStream nextPutAll: ' named ', (self variableName ifNil: ['<unnamed>']), ' type = ', variableType printString! !!Variable methodsFor: 'name' stamp: 'sw 12/11/2000 14:07'!variableName	"Answer the variable name of the receiver"	^ variableName! !!Variable methodsFor: 'type' stamp: 'sw 12/11/2000 14:06'!variableType	"Anser the variable type of the receiver"	^ variableType! !!Variable methodsFor: 'value' stamp: 'sw 12/11/2000 14:06'!defaultValue	"Answer the default value to be supplied to the receiver"	^ defaultValue! !LeafNode subclass: #VariableNode	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!VariableNode commentStamp: '<historical>' prior: 0!I am a parse tree leaf representing a variable. Note that my name and key are different for pool variables: the key is the Object Reference.!!VariableNode methodsFor: 'initialize-release'!asStorableNode: encoder	^ self! !!VariableNode methodsFor: 'initialize-release' stamp: 'tk 9/28/2001 11:33'!name: string	"Change name"	name _ string.! !!VariableNode methodsFor: 'initialize-release'!name: varName index: i type: type	"Only used for initting instVar refs"	name _ varName.	self key: varName		index: i		type: type! !!VariableNode methodsFor: 'initialize-release'!name: string key: object code: byte	"Only used for initting std variables, nil, true, false, self, etc."	name _ string.	key _ object.	code _ byte! !!VariableNode methodsFor: 'initialize-release'!name: varName key: objRef index: i type: type	"Only used for initting global (litInd) variables"	name _ varName.	self key: objRef		index: i		type: type! !!VariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name)		ifTrue: [^ location]		ifFalse: [^ -1]! !!VariableNode methodsFor: 'testing'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^code < LdNil! !!VariableNode methodsFor: 'testing' stamp: 'ar 8/14/2001 23:00'!index	"This code attempts to reconstruct the index from its encoding in code."	code < 0 ifTrue:[^nil].	code > 256 ifTrue:[^code \\ 256].	^code - self type! !!VariableNode methodsFor: 'testing' stamp: 'tk 1/30/2001 14:04'!isSelfPseudoVariable	"Answer if this ParseNode represents the 'self' pseudo-variable."	^ (key = 'self') | (name = '{{self}}')! !!VariableNode methodsFor: 'testing'!isVariableReference	^true! !!VariableNode methodsFor: 'testing' stamp: 'di 2/3/1999 09:41'!type	"This code attempts to reconstruct the type from its encoding in code.		This allows one to test, for instance, (aNode type = LdInstType)."	| type |	code < 0 ifTrue: [^ code negated].	code < 256 ifFalse: [^ code // 256].	type _ CodeBases findFirst: [:one | code < one].	type = 0		ifTrue: [^ 5]		ifFalse: [^ type - 1]! !!VariableNode methodsFor: 'code generation'!emitForReturn: stack on: strm	(code >= LdSelf and: [code <= LdNil])		ifTrue: 			["short returns"			strm nextPut: EndMethod - 4 + (code - LdSelf).			stack push: 1 "doesnt seem right"]		ifFalse: 			[super emitForReturn: stack on: strm]! !!VariableNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: 			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).			stack push: 1]		ifFalse: 			[self emitLong: LoadLong on: strm.			stack push: 1]! !!VariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2001 23:14'!emitLoad: stack on: strm	"Do nothing"! !!VariableNode methodsFor: 'code generation'!emitStore: stack on: strm	self emitLong: Store on: strm! !!VariableNode methodsFor: 'code generation'!emitStorePop: stack on: strm	(code between: 0 and: 7)		ifTrue: 			[strm nextPut: ShortStoP + code "short stopop inst"]		ifFalse:			[(code between: 16 and: 23)				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]						ifFalse: [self emitLong: StorePop on: strm]]].	stack pop: 1! !!VariableNode methodsFor: 'code generation' stamp: 'di 2/6/2000 10:52'!fieldOffset  "Return temp or instVar offset for this variable"	code < 256		ifTrue: 			[^ code \\ 16]		ifFalse: 			[^ code \\ 256]! !!VariableNode methodsFor: 'code generation'!sizeForReturn: encoder	(code >= LdSelf and: [code <= LdNil])		ifTrue: ["short returns" ^1].	^super sizeForReturn: encoder! !!VariableNode methodsFor: 'code generation'!sizeForStore: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 2].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!VariableNode methodsFor: 'code generation'!sizeForStorePop: encoder	self reserve: encoder.	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].	code < 256 ifTrue: [^ 2].	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"	self halt.  "Shouldn't get here"! !!VariableNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printOn: aStream indent: level 	aStream withStyleFor: #variable		do: [aStream nextPutAll: name].! !!VariableNode methodsFor: 'accessing' stamp: 'tk 1/30/2001 13:45'!name	^ name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!VariableNode class	instanceVariableNames: ''!!VariableNode class methodsFor: 'class initialization'!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder _ Encoder new.	StdVariables _ Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors _ Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals _ LiteralDictionary new: 16.	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil _ encoder encodeVariable: 'nil'.	NodeTrue _ encoder encodeVariable: 'true'.	NodeFalse _ encoder encodeVariable: 'false'.	NodeSelf _ encoder encodeVariable: 'self'.	NodeThisContext _ encoder encodeVariable: 'thisContext'.	NodeSuper _ encoder encodeVariable: 'super'! !Magnitude subclass: #VersionNumber	instanceVariableNames: 'numbers'	classVariableNames: ''	poolDictionaries: ''	category: 'VersionNumber'!!VersionNumber commentStamp: '<historical>' prior: 0!I am a version number.  My representation allows me to handle an entire tree of versions.  Once created, an instance should not change (note: VersionNumbers could be canonicalized like Symbols, but are not currently).  

I am a magnitude so that you can see if one version preceeds another (only if the two versions are in the same branch).  

	'2.1' asVersion < '2.2.1' asVersion	"true"
	'2.3' asVersion < '2.2.1' asVersion	"error different branches"
	'2.3' asVersion inSameBranchAs: '2.2.1' asVersion	"false, why the previous one failed."	
	'2.1' asVersion = '2.1' asVersion		"true, obviously"

To get the next version number in the same branch:

	'2.3.4' asVersion next	"2.3.5"

To get the next version number, starting a new branch:

	'2.3.4' asVersion branchNext		"2.3.4.1"

To get the common base version of any two version numbers (useful for merging):

	'2.3.8' asVersion commonBase: '2.3.4.1' asVersion		"2.3.4"!!VersionNumber methodsFor: 'comparing' stamp: 'svp 6/18/2002 15:05'!< another 
	"Answer whether the receiver is less than the argument."

	| tmp |
	(self inSameBranchAs: another) ifFalse: 
		[^self error: 'Receiver and argument in different branches'].

	tmp := another numbers.
	(tmp size = numbers size) ifTrue:
		[1 to: numbers size do: 
			[ :in | (numbers at: in) < (tmp at: in) ifTrue: [^true]].
		^false].

	^numbers size < tmp size
! !!VersionNumber methodsFor: 'comparing' stamp: 'svp 6/18/2002 15:10'!= aVersion

	^numbers = aVersion numbers! !!VersionNumber methodsFor: 'comparing' stamp: 'svp 6/18/2002 12:23'!hash

	^numbers hash! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 12:14'!next

	| tmp |
	tmp := numbers copy.
	tmp at: numbers size put: (numbers last + 1).
	^self class fromCollection: tmp! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 14:51'!numbers
	"Answer a copy (to discourage people from directly changing a version number).
	VersionNumbers should never change, instead, instantiate a new instance."

	^numbers copy! !!VersionNumber methodsFor: 'testing' stamp: 'svp 6/18/2002 14:57'!inSameBranchAs: aVersion

	| less more |
	(aVersion numbers size <= numbers size) 
		ifTrue: [less := aVersion numbers. more := numbers] 
		ifFalse: [less := numbers. more := aVersion numbers].

	1 to: (less size - 1) do: [ :in | ((less at: in) = (more at: in)) ifFalse: [^false]].
	^less size = more size or:
		[(less at: less size) <= (more at: less size)]
! !!VersionNumber methodsFor: 'initialization' stamp: 'svp 6/18/2002 15:08'!initializeNumbers: aCollection

	aCollection do: [ :ea | 
		ea <= 0 ifTrue: 
			[^self error: 'VersionNumbers cannot contain zero or negative numbers']].

	numbers := aCollection asArray! !!VersionNumber methodsFor: 'printing' stamp: 'svp 6/18/2002 12:27'!printOn: strm

	self storeOn: strm! !!VersionNumber methodsFor: 'printing' stamp: 'svp 6/18/2002 17:24'!storeOn: strm

	strm nextPut: $'.
	self versionStringOn: strm.
	strm nextPutAll: ''' asVersion'.! !!VersionNumber methodsFor: '*smbase-override' stamp: 'svp 6/18/2002 17:23'!versionStringOn: strm	| first |	first := true.	numbers do: [ :ea |		first ifFalse: [strm nextPut: $.].		first := false.		ea printOn: strm]	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!VersionNumber class	instanceVariableNames: ''!!VersionNumber class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 16:34'!first

	^self fromCollection: #(1)! !!VersionNumber class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 12:21'!fromCollection: aCollection

	^self new
		initializeNumbers: aCollection;
		yourself! !!VersionNumber class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 12:20'!fromString: aString

	^self fromCollection: 
		((aString findTokens: '.') collect: [:ea | ea asNumber ])
	! !ChangeList subclass: #VersionsBrowser	instanceVariableNames: 'classOfMethod selectorOfMethod addedChangeRecord'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!VersionsBrowser commentStamp: 'nk 11/25/2003 10:04' prior: 0!VersionsBrowser shows all the versions of a particular method, and lets you compare them, revert to selected versions, and so on.!!VersionsBrowser methodsFor: 'init & update' stamp: 'nk 1/7/2004 10:10'!addedChangeRecord	^addedChangeRecord! !!VersionsBrowser methodsFor: 'init & update' stamp: 'nk 1/7/2004 10:23'!addedChangeRecord: aChangeRecord	addedChangeRecord _ aChangeRecord.	self reformulateList.! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sw 5/6/2000 01:16'!changeListButtonSpecs	^#(		('compare to current'		compareToCurrentVersion		'opens a separate window which shows the text differences between the selected version and the current version')		('revert'		fileInSelections		'reverts the method to the version selected')		('remove from changes'		removeMethodFromChanges		'remove this method from the current change set')		('help'		offerVersionsHelp		'further explanation about use of Versions browsers')		)! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sw 11/28/1999 22:50'!reformulateList	| aMethod |	"Some uncertainty about how to deal with lost methods here"	aMethod _ classOfMethod compiledMethodAt: selectorOfMethod ifAbsent: [^ self].		self scanVersionsOf: aMethod class: classOfMethod theNonMetaClass meta: classOfMethod isMeta category: (classOfMethod whichCategoryIncludesSelector: selectorOfMethod) selector: selectorOfMethod.	self changed: #list. "for benefit of mvc"	listIndex _ 1.	self changed: #listIndex.	self contentsChanged! !!VersionsBrowser methodsFor: 'init & update' stamp: 'nk 1/7/2004 10:29'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	selectorOfMethod _ selector.	currentCompiledMethod _ method.	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].	changeList _ OrderedCollection new.	list _ OrderedCollection new.	self addedChangeRecord ifNotNilDo: [ :change |		self addItem: change text: ('{1} (in {2})' translated format: { change stamp. change fileName }) ].	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!VersionsBrowser methodsFor: 'init & update' stamp: 'di 11/28/2000 01:25'!updateListsAndCodeIn: aWindow	| aMethod |	aMethod _ classOfMethod compiledMethodAt: selectorOfMethod ifAbsent: [^ false].	aMethod == currentCompiledMethod		ifFalse:			["Do not attempt to formulate if there is no source pointer.			It probably means it has been recompiled, but the source hasn't been written			(as during a display of the 'save text simply?' confirmation)."			aMethod last ~= 0 ifTrue: [self reformulateList]].	^ true! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 2/27/2001 08:46'!changeListKey: aChar from: view	"Respond to a Command key in the list pane. of the versions browser"	^ self messageListKey: aChar from: view! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 10/12/1999 17:51'!fileInSelections 	super fileInSelections.	self reformulateList! !!VersionsBrowser methodsFor: 'menu' stamp: 'BG 10/28/2003 20:49'!versionsMenu: aMenu	"Fill aMenu with menu items appropriate to the receiver"	^ aMenu addList: #(		('compare to current'		compareToCurrentVersion		'compare selected version to the current version')		('revert to selected version'	fileInSelections					'resubmit the selected version, so that it becomes the current version')		('remove from changes'		removeMethodFromChanges		'remove this method from the current change set, if present')		('edit current method (O)'	openSingleMessageBrowser		'open a single-message browser on the current version of this method')				('find original change set'		findOriginalChangeSet		'locate the changeset which originally contained this version')		-		('toggle diffing (D)'			toggleDiffing					'toggle whether or not diffs should be shown here')		('update list'				reformulateList					'reformulate the list of versions, in case it somehow got out of synch with reality')		-		('senders (n)'				browseSenders					'browse all senders of this selector')		('implementors (m)'			browseImplementors				'browse all implementors of this selector')		-		('help...'					offerVersionsHelp				'provide an explanation of the use of this tool'))! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 2/27/2001 08:17'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior versions are seen in a versions browser -- in this case, the inherited version of this method will not work."	(aClass includesSelector: aSelector) ifTrue:		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].	aStream nextPutAll: 		((changeList size > 0			ifTrue:				[changeList size == 1					ifTrue:						['Deleted - one prior version']					ifFalse:						['Deleted - ', changeList size printString, ' prior versions']]			ifFalse:				['surprisingly, no prior versions']), self annotationSeparator)! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 8/17/2002 21:57'!classCommentIndicated	"Answer whether the receiver is pointed at a class comment"	^ false! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 1/25/2001 07:03'!selectedClass	"Answer the class currently selected in the browser.  In the case of a VersionsBrowser, the class and selector are always the same, regardless of which version is selected and indeed whether or not any entry is selected in the list pane"	^ classOfMethod theNonMetaClass! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 1/25/2001 06:26'!selectedClassOrMetaClass	"Answer the class or metaclass currently selected in the browser.  In the case of a VersionsBrowser, the class and selector are always the same, regardless of which version is selected and indeed whether or not any entry is selected in the list pane"	^ classOfMethod! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 1/25/2001 06:10'!selectedMessageName	"Answer the message name currently selected in the browser.  In the case of a VersionsBrowser, the class and selector are always the same, regardless of which version is selected and indeed whether or not any entry is selected in the list pane"	^ selectorOfMethod! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 10/19/1999 15:04'!showsVersions	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!VersionsBrowser class	instanceVariableNames: ''!!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'di 1/11/2000 12:45'!browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector 	^ self browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector lostMethodPointer: nil! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 1/7/2004 10:19'!browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector lostMethodPointer: sourcePointer 	| changeList browser |	Cursor read showWhile:		[changeList _ (browser _ self new)			scanVersionsOf: method class: class meta: meta			category: msgCategory selector: selector].	changeList ifNil: [ self inform: 'No versions available'. ^nil ].	sourcePointer ifNotNil:		[changeList setLostMethodPointer: sourcePointer].	self open: changeList name: 'Recent versions of ' ,selector multiSelect: false.	^browser! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/21/1999 17:21'!timeStampFor: aSelector class: aClass reverseOrdinal: anInteger	"Answer the time stamp corresponding to some version of the given method, nil if none.  The reverseOrdinal parameter is interpreted as:  1 = current version; 2 = last-but-one version, etc."		| method aChangeList |	method _ aClass compiledMethodAt: aSelector ifAbsent: [^ nil].	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [nil] ifNotNil:		[aChangeList list size >= anInteger			ifTrue:				[(aChangeList changeList at: anInteger) stamp]			ifFalse:				[nil]]! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 15:01'!versionCountForSelector: aSelector class: aClass	"Answer the number of versions known to the system for the given class and method, including the current version.  A result of greater than one means that there is at least one superseded version.  Answer zero if no logged version can be obtained."		| method aChangeList |	method _ aClass compiledMethodAt: aSelector ifAbsent: [^ 0].	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [0] ifNotNil: [aChangeList list size]! !Object subclass: #View	instanceVariableNames: 'model controller superView subViews transformation viewport window displayTransformation insetDisplayBox borderWidth borderColor insideColor boundingBox'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Framework'!!View commentStamp: '<historical>' prior: 0!My instances are intended to be components in a structured picture. Each View in the structured picture can contain other Views as sub-components. These sub-components are called subViews. A View can be a subView of only one View. This View is called its superView. The set of Views in a structured picture forms a hierarchy. The one View in the hierarchy that has no superView is called the topView of the structured picture. A View in a structured picture with no subViews is called a bottom View. A View and all of its subViews, and all of their subViews and so on, are treated as a unit in many operations on the View. For example, if a View is displayed, all of its subViews are displayed as well. There are several categories of operations that can be performed on a View. Among these are the following:		1.	Adding subViews to a View.	2.	Positioning subViews within a View.	3.	Deleting subViews from a View.	4.	Transforming a View.	5.	Displaying a View.	Each View has its own coordinate system. In order to change from one coordinate system to another, each View has two transformations associated with it. The local transformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the coordinate system of the superView of the View. The displayTransformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the display screen coordinate system.	The part of the space that is to be made visible is represented by the window of the View. The window of a View is a Rectangle expressed in the coordinate system of the View. The area occupied by a View in the coordinate system of its superView is called its viewport. The viewport of a View is its window transformed by its local transformation. The region of the display screen occupied by a View is called its displayBox. The display box of a View can include a border. The width of the border expressed in display screen coordinates is called the border width of the View. The color of the border is called the border color. The region of the display box of a View excluding the border is called the inset display box. The color of the inset display box is called the inside color of the View.!!View methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	self resetSubViews.	transformation _ WindowingTransformation identity.	self borderWidth: 0! !!View methodsFor: 'initialize-release'!release	"Remove the receiver from its model's list of dependents (if the model	exists), and release all of its subViews. It is used to break possible cycles	in the receiver and should be sent when the receiver is no longer needed.	Subclasses should include 'super release.' when redefining release."	model removeDependent: self.	model _ nil.	controller release.	controller _ nil.	subViews ~~ nil ifTrue: [subViews do: [:aView | aView release]].	subViews _ nil.	superView _ nil! !!View methodsFor: 'initialize-release'!setDefaultBackgroundColor	"Obtain the background color from the receiver's model, unless the #uniformWindowColors preference is set to true, in which case obtain it from generic Object; and install it as the receiver's background color.  5/1/96 sw"	| colorToUse |	colorToUse _ Preferences uniformWindowColors		ifTrue:			[Object new defaultBackgroundColor]		ifFalse:			[model defaultBackgroundColor].	self backgroundColor: colorToUse! !!View methodsFor: 'testing' stamp: 'tk 4/13/1998 22:58'!canDiscardEdits	"Return true if this pane is not dirty."	^ true! !!View methodsFor: 'testing'!containsPoint: aPoint	"Answer whether aPoint is within the receiver's display box. It is sent to 	a View's subViews by View|subViewAt: in order to determine which 	subView contains the cursor point (so that, for example, control can be 	pass down to that subView's controller)."	^ self insetDisplayBox containsPoint: aPoint! !!View methodsFor: 'testing' stamp: 'jm 3/17/98 13:35'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ false! !!View methodsFor: 'testing'!isObscured	| topController displayRect |	(topController _ self topView controller)		== ScheduledControllers activeController			ifTrue: [^false].	displayRect _ self insetDisplayBox.	ScheduledControllers scheduledControllers do: [:ctrlr |		ctrlr == topController ifTrue: [^false].		(displayRect intersects: ctrlr view insetDisplayBox)			ifTrue: [^true]].	self error: 'not in ScheduledControllers'.	^false! !!View methodsFor: 'model access'!model	"Answer the receiver's model."	^model! !!View methodsFor: 'model access'!model: aModel 	"Set the receiver's model to aModel. The model of the receiver's controller 	is also set to aModel."	self model: aModel controller: controller! !!View methodsFor: 'superView access'!isTopView	"Answer whether the receiver is a top view, that is, if it has no 	superView."	^superView == nil! !!View methodsFor: 'superView access'!superView	"Answer the superView of the receiver."	^superView! !!View methodsFor: 'superView access'!topView	"Answer the root of the tree of Views in which the receiver is a node. 	The root of the tree is found by going up the superView path until 	reaching a View whose superView is nil."	superView == nil		ifTrue: [^self]		ifFalse: [^superView topView]! !!View methodsFor: 'subView access'!firstSubView	"Answer the first subView in the receiver's list of subViews if it is not 	empty, else nil."	subViews isEmpty		ifTrue: [^nil]		ifFalse: [^subViews first]! !!View methodsFor: 'subView access'!lastSubView	"Answer the last subView in the receiver's list of subViews if it is not 	empty, else nil."	subViews isEmpty		ifTrue: [^nil]		ifFalse: [^subViews last]! !!View methodsFor: 'subView access'!resetSubViews	"Set the list of subviews to an empty collection."		subViews _ OrderedCollection new! !!View methodsFor: 'subView access'!subViewContaining: aPoint 	"Answer the first subView that contains aPoint within its window and 	answer nil, otherwise. It is typically sent from a Controller in order to 	determine where to pass control (usually to the Controller of the View 	returned by View|subViewContaining:)."	subViews reverseDo: 		[:aSubView | 		(aSubView displayBox containsPoint: aPoint) ifTrue: [^aSubView]].	^nil! !!View methodsFor: 'subView access'!subViewSatisfying: aBlock	"Return the first subview that satisfies aBlock, or nil if none does.  1/31/96 sw"	^ subViews detect: [:aView | aBlock value: aView] ifNone: [nil]! !!View methodsFor: 'subView access'!subViews	"Answer the receiver's collection of subViews."	^subViews! !!View methodsFor: 'subView access'!textEditorView	"Return the first view in the receiver whose controller is a ParagraphEdior, or nil if none.  1/31/96 sw"	(controller isKindOf: ParagraphEditor) ifTrue: [^ self].	^ self subViewSatisfying:		[:v | v textEditorView ~~ nil]! !!View methodsFor: 'controller access'!controller	"If the receiver's controller is nil (the default case), answer an initialized 	instance of the receiver's default controller. If the receiver does not 	allow a controller, answer the symbol #NoControllerAllowed."	controller == nil ifTrue: [self controller: self defaultController].	^controller! !!View methodsFor: 'controller access'!controller: aController 	"Set the receiver's controller to aController. #NoControllerAllowed can be 	specified to indicate that the receiver will not have a controller. The 	model of aController is set to the receiver's model."	self model: model controller: aController! !!View methodsFor: 'controller access'!defaultController	"Answer an initialized instance of the receiver's default controller. 	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new! !!View methodsFor: 'controller access'!defaultControllerClass	"Answer the class of the default controller for the receiver. Subclasses 	should redefine View|defaultControllerClass if the class of the default 	controller is not Controller."	^Controller! !!View methodsFor: 'controller access'!model: aModel controller: aController 	"Set the receiver's model to aModel, add the receiver to aModel's list of 	dependents, and set the receiver's controller to aController. Subsequent 	changes to aModel (see Model|change) will result in View|update: 	messages being sent to the receiver. #NoControllerAllowed for the value 	of aController indicates that no default controller is available; nil for the 	value of aController indicates that the default controller is to be used 	when needed. If aController is neither #NoControllerAllowed nor nil, its 	view is set to the receiver and its model is set to aModel."	model ~~ nil & (model ~~ aModel)		ifTrue: [model removeDependent: self].	aModel ~~ nil & (aModel ~~ model)		ifTrue: [aModel addDependent: self].	model _ aModel.	aController ~~ nil		ifTrue: 			[aController view: self.			aController model: aModel].	controller _ aController! !!View methodsFor: 'basic control sequence'!subViewWantingControl	"Answer the first subView that has a controller that now wants control."	subViews reverseDo: 		[:aSubView | aSubView controller isControlWanted ifTrue: [^aSubView]].	^nil! !!View methodsFor: 'window access'!defaultWindow	"Build the minimum Rectangle that encloses all the windows of the 	receiver's subViews. The answer is a Rectangle obtained by expanding 	this minimal Rectangle by the borderWidth of the receiver. If the 	receiver has no subViews, then a Rectangle enclosing the entire display 	screen is answered. It is used internally by View methods if no window 	has been specified for the View. Specialized subclasses of View should 	redefine View|defaultWindow to handle the default case for instances 	that have no subViews."	| aRectangle |	subViews isEmpty ifTrue: [^DisplayScreen boundingBox].	aRectangle _ self firstSubView viewport.	subViews do: [:aView | aRectangle _ aRectangle merge: aView viewport].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'window access'!insetWindow	"Answer a Rectangle that is obtained by insetting the receiver's window 	rectangle by the border width."	^self getWindow insetBy: borderWidth! !!View methodsFor: 'window access'!window	"Answer a copy of the receiver's window."	^self getWindow copy! !!View methodsFor: 'window access'!window: aWindow 	"Set the receiver's window to a copy of aWindow."	self setWindow: aWindow copy! !!View methodsFor: 'viewport access'!viewport	"Answer a copy of the receiver's viewport."	^self getViewport copy! !!View methodsFor: 'display box access'!apparentDisplayBox	^self insetDisplayBox expandBy: 2 @ 2! !!View methodsFor: 'display box access'!boundingBox	"Answer the bounding box which for the default case is the rectangular 	area surrounding the bounding boxes of all the subViews."	boundingBox ~~ nil		ifTrue: [^boundingBox]		ifFalse: [^self computeBoundingBox]! !!View methodsFor: 'display box access'!computeBoundingBox	"Answer the minimum Rectangle that encloses the bounding boxes of the 	receiver's subViews. If the receiver has no subViews, then the bounding 	box is the receiver's window. Subclasses should redefine 	View|boundingBox if a more suitable default for the case of no subViews 	is available."	| aRectangle |	subViews isEmpty ifTrue: [^self getWindow].	aRectangle _ self firstSubView transform: self firstSubView boundingBox.	subViews do: 		[:aView | 		aRectangle _ aRectangle merge: (aView transform: aView boundingBox).].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'display box access'!displayBox	"Answer the receiver's inset display box (see View|insetDisplayBox) 	expanded by the borderWidth. The display box represents the region of 	the display screen in which the receiver (including the border) is 	displayed. If the receiver is totally clipped by the display screen and its 	superView, the resulting Rectangle will be invalid."	^self insetDisplayBox expandBy: borderWidth! !!View methodsFor: 'display box access' stamp: 'acg 2/23/2000 00:08'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: [insetDisplayBox _ self computeInsetDisplayBox].	^insetDisplayBox! !!View methodsFor: 'lock access'!isLocked	"Answer whether the receiver is locked. A View is 'locked' if its display 	transformation and inset display box are defined. If these are undefined, 	the View is 'unlocked'. The display transformation and inset display box 	become undefined when the transformation of the View (or the 	transformation of a View in its superView chain) is changed, or when 	the superView of the View is changed, or any other change to the View 	that affects the display screen coordinates of the View. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired (see View|lock, and 	View|unlock)."	displayTransformation == nil | (insetDisplayBox == nil)		ifTrue: [^false]		ifFalse: [^true]! !!View methodsFor: 'lock access'!isUnlocked	"Answer whether the receiver is unlocked. See comment in 	View|isLocked."	^displayTransformation == nil & (insetDisplayBox == nil)! !!View methodsFor: 'lock access'!lock	"'Lock' the receiver and all of its subViews (see View|isLocked). This has 	the effect of computing and storing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews. The locking 	and unlocking of a View is handled automatically by the internal 	methods of the View, but can also be done explicitly if desired."	self isLocked ifTrue: [^self].	displayTransformation _ self computeDisplayTransformation.	insetDisplayBox _ self computeInsetDisplayBox.	subViews do: [:aSubView | aSubView lock]! !!View methodsFor: 'lock access'!unlock	"Unlock the receiver and all of its subViews (see View|isUnlocked). This 	has the effect of forcing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews to be 	recomputed the next time they are referenced. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired."	self isUnlocked ifTrue: [^self].	displayTransformation _ nil.	insetDisplayBox _ nil.	subViews do: [:aSubView | aSubView unlock]! !!View methodsFor: 'subView inserting'!addSubView: aView 	"Remove aView from the tree of Views it is in (if any) and adds it to the 	rear of the list of subViews of the receiver. Set the superView of aView 	to be the receiver. It is typically used to build up a hierarchy of Views 	(a structured picture). An error notification is generated if aView is the 	same as the receiver or its superView, and so on."	self addSubView: aView ifCyclic: [self error: 'cycle in subView structure.']! !!View methodsFor: 'subView inserting'!addSubView: aSubView above: lowerView	"Adds aView (see View|addSubView:) so that it lies above topView."	self addSubView: aSubView		align: aSubView viewport bottomLeft		with: lowerView viewport topLeft! !!View methodsFor: 'subView inserting'!addSubView: aSubView align: aPoint1 with: aPoint2 	"Add aView to the receiver's list of subViews (see View|addSubView:) 	and translate aView so that aPoint1 coincides with aPoint2. It is typically 	used to build up a hierarchy of Views (a structured picture). Normally, 	aPoint1 is a point on aView's viewport (e.g. aView viewport topLeft), 	and aPoint2 is either an arbitrary point in the receiver's coordinate 	system or a point on the receiver's window (e.g., self window topRight)."	self addSubView: aSubView.	aSubView align: aPoint1 with: aPoint2! !!View methodsFor: 'subView inserting'!addSubView: aSubView below: lowerView	"Add the argument, aSubView, (see View|addSubView:) so that it lies 	below the view, topView."	self addSubView: aSubView		align: aSubView viewport topLeft		with: lowerView viewport bottomLeft! !!View methodsFor: 'subView inserting'!addSubView: aView ifCyclic: exceptionBlock 	"Remove aView from the tree of Views it is in (if any) and add it to the 	rear of the list of subViews of the receiver. Set the superView of aView 	to be the receiver. It is typically used to build up a hierarchy of Views 	(a structured picture). An error notification is generated if aView is the 	same as the receiver or its superView, and so on."	(self isCyclic: aView)		ifTrue: [exceptionBlock value]		ifFalse: 			[aView removeFromSuperView.			subViews addLast: aView.			aView superView: self]! !!View methodsFor: 'subView inserting' stamp: 'ssa 8/15/2008 17:31'!addSubView: aView in: aRelativeRectangle borderWidth: width	"ssa - added for compatibility." 	"Make 'aView' into a subview. Use 'aRelativeRectangle' and the 	super view's window to compute (1) a viewport within the 	superview for 'aView' and (2) the window extent for 'aView'. Note: 	defining the windowing transformation and deriving the viewport is 	logically equivalent but does not seem to be easily done"	| subViewPort myWindow myExtent myOrigin |	self addSubView: aView ifCyclic: [self error: 'cycle in subView structure.'].	aView borderWidth: width.	myWindow _ self window.	myExtent _ myWindow extent.	myOrigin _ myWindow origin.	subViewPort _ myExtent * aRelativeRectangle origin + myOrigin 						corner: myExtent * aRelativeRectangle corner + myOrigin.	aView window: aView window viewport: subViewPort! !!View methodsFor: 'subView inserting'!addSubView: aSubView toLeftOf: rightView	"Adds aView (see addSubView:) so that it lies to the right of rightView."	self addSubView: aSubView		align: aSubView viewport topRight		with:  rightView viewport topLeft! !!View methodsFor: 'subView inserting'!addSubView: aSubView toRightOf: leftView	"Add the argument, aSubView, (see View|addSubView:) so that it lies to 	the right of the view, leftView."	self addSubView: aSubView		align: aSubView viewport topLeft		with: leftView viewport topRight! !!View methodsFor: 'subView inserting'!addSubView: aView viewport: aViewport 	"Add aView to the receiver's list of subViews (see View|addSubView:) and 	applies to aView a scale and translation computed from its window and 	aViewport (such that its window fills aViewport)."	self addSubView: aView.	aView window: aView window viewport: aViewport! !!View methodsFor: 'subView inserting'!addSubView: aView window: aWindow viewport: aViewport 	"Add aView to the receiver's list of subViews (see View|addSubView:) 	and applies to aView a scale and translation computed from aWindow 	and aViewport (such that aWindow fills aViewport)."	self addSubView: aView.	aView window: aWindow viewport: aViewport! !!View methodsFor: 'subView removing'!releaseSubView: aView 	"Delete aView from the receiver's list of subViews and send it the 	message 'release' (so that it can break up cycles with subViews, etc.)."	self removeSubView: aView.	aView release! !!View methodsFor: 'subView removing'!releaseSubViews	"Release (see View|releaseSubView:) all subViews in the receiver's list of 	subViews."	subViews do: [:aView | aView release].	self resetSubViews! !!View methodsFor: 'subView removing'!removeFromSuperView	"Delete the receiver from its superView's collection of subViews."	superView ~= nil ifTrue: [superView removeSubView: self]! !!View methodsFor: 'subView removing'!removeSubView: aView 	"Delete aView from the receiver's list of subViews. If the list of subViews 	does not contain aView, create an error notification."	subViews remove: aView.	aView superView: nil.	aView unlock! !!View methodsFor: 'subView removing'!removeSubViews	"Delete all the receiver's subViews."	subViews do: 		[:aView | 		aView superView: nil.		aView unlock].	self resetSubViews! !!View methodsFor: 'displaying'!clippingTo: rect do: aBlock	superView clippingTo: rect do: aBlock! !!View methodsFor: 'displaying' stamp: 'hmm 6/27/2000 07:07'!display	"Display the receiver's border, display the receiver, then display the 	subViews of the receiver. Can be sent to the top View of a structured 	picture in order to display the entire structure, or to any particular View 	in the structure in order to display that View and its subViews. It is 	typically sent in response to an update request to a View."	Display deferUpdatesIn: self displayBox while: [		self displayBorder.		self displayView.		self displaySubViews]! !!View methodsFor: 'displaying'!displayBorder	"Display the receiver's border (using the receiver's borderColor)."	borderWidth = 0		ifTrue:			[insideColor == nil				ifFalse: 					[Display fill: self displayBox fillColor: self backgroundColor]]		ifFalse:			[Display				border: self displayBox				widthRectangle: borderWidth				rule: Form over				fillColor: self foregroundColor.			insideColor == nil ifFalse:				[Display fill: self insetDisplayBox fillColor: self backgroundColor]]! !!View methodsFor: 'displaying'!displayClippingTo: rect	| bigRect |	bigRect _ rect insetBy: -1.	self clippingTo: bigRect do: [Display clippingTo: bigRect do: [self display]]! !!View methodsFor: 'displaying'!displayDeEmphasized	self display; deEmphasize! !!View methodsFor: 'displaying'!displaySubViews	"Display all the subViews of the receiver."	subViews do: [:aSubView | aSubView display]! !!View methodsFor: 'displaying'!displayView	"Subclasses should redefine View|displayView in order to display 	particular objects associated with the View such as labels, lines, and 	boxes."	^self! !!View methodsFor: 'displaying'!displayViewDeEmphasized	self displayView; deEmphasizeView! !!View methodsFor: 'displaying'!inspectFirstSubView	subViews notNil ifTrue:		[subViews size > 0 ifTrue:			[(subViews at: 1) inspect]]! !!View methodsFor: 'displaying'!inspectModel	model notNil		ifTrue: [^ model inspect]		ifFalse: [self flash]! !!View methodsFor: 'displaying'!inspectView	^self inspect! !!View methodsFor: 'displaying'!maximumSize	"Answer the maximum size of the receiver."	^ 10000 @ 10000	! !!View methodsFor: 'displaying'!minimumSize	"Answer the minimum size of the receiver."	^ 10 @ 10	! !!View methodsFor: 'deEmphasizing'!deEmphasize	"Modify the emphasis (highlighting, special tabs) of the receiver. This 	includes objects such as labels, lines, and boxes. Typically used so that 	the receiver is not presented as active. Do this for the receiver and then 	for each of the receiver's subViews."	self deEmphasizeView.	self deEmphasizeSubViews! !!View methodsFor: 'deEmphasizing'!deEmphasizeForDebugger	"Overridden by StandardSystemView. This default behavior does nothing."! !!View methodsFor: 'deEmphasizing'!deEmphasizeSubViews	"Send the deEmphasize message to each of the receiver's subviews."	subViews do: [:aSubView | aSubView deEmphasize]! !!View methodsFor: 'deEmphasizing'!deEmphasizeView	"Subclasses should redefine View|deEmphasizeView in order to modify 	the emphasis (highlighting, special tabs) of particular objects associated 	with the View such as labels, lines, and boxes."	^self! !!View methodsFor: 'deEmphasizing'!emphasize	"Modify the emphasis (highlighting, special tabs) of the receiver. This 	includes objects such as labels, lines, and boxes. Typically used so that 	the receiver is presented as active. Do this for the receiver and then 	for each of the receiver's subViews."	self emphasizeView.	self emphasizeSubViews! !!View methodsFor: 'deEmphasizing'!emphasizeSubViews	"Send the emphasize message to each of the receiver's subviews."	subViews do: [:aSubView | aSubView emphasize]! !!View methodsFor: 'deEmphasizing'!emphasizeView	"Subclasses should redefine View|emphasizeView in order to modify 	the emphasis (highlighting, special tabs) of particular objects associated 	with the View such as labels, lines, and boxes."	^self! !!View methodsFor: 'display transformation'!displayTransform: anObject 	"Apply the display transformation of the receiver to anObject (see 	View|displayTransformation) and answer the resulting scaled, translated 	object. It is normally applied to Rectangles, Points, and other objects with 	coordinates defined in the View's local coordinate system in order to get 	a corresponding object in display coordinates."	^(self displayTransformation applyTo: anObject) rounded! !!View methodsFor: 'display transformation'!displayTransformation	"Answer a WindowingTransformation that is the result of composing all 	local transformations in the receiver's superView chain with the 	receiver's own local transformation. The resulting transformation 	transforms objects in the receiver's coordinate system into objects in the 	display screen coordinate system."	displayTransformation == nil		ifTrue: [displayTransformation _ self computeDisplayTransformation].	^displayTransformation! !!View methodsFor: 'display transformation'!inverseDisplayTransform: aPoint 	"Answer a Point that is obtained from the argument, aPoint, by applying 	to it the inverse of the receiver's display transformation. It is typically 	used by the Controller of the receiver in order to convert a point in 	display coordinates, such as the cursor point, to the local coordinate 	system of the receiver."	^self displayTransformation applyInverseTo: aPoint! !!View methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Add a translation of (aPoint2 - aPoint1) to the receiver's local 	transformation. The point in the receiver's coordinate system that 	previously was transformed to aPoint1 in the superView's coordinate 	system will now be transformed to aPoint2 in the superView's coordinate 	system. Other points will be translated by the same amount. It is 	normally used when adding subViews to their superView in order to 	line up the Viewport of one subView with that of another subView (see 	View|addSubView:align:with:). aPoint1 and aPoint2 are usually points on 	the viewports that are to be aligned. For example, 'subView2 align: 	subView2 viewport topLeft with: subView1 viewport topRight' would be 	used to place the viewport of subView2 next to the viewport of 	subView1 with the topLeft and topRight corners, respectively, 	coinciding. It is also possible to align the viewport of a subView with 	the window of the superView, e.g., 'subView align: subView viewport 	center with: superView window center'. View|align:with: assumes that 	the view has been properly scaled, if necessary, to match its superView 	(see View|scaleBy:). Typically, the coordinate systems of the receiver 	and its superView will differ only by a translation offset so that no 	scaling is necessary."	self setTransformation: (transformation align: aPoint1 with: aPoint2)! !!View methodsFor: 'transforming'!scale: aScale translation: aTranslation 	"The x component of aScale (a Point) specifies the scale (translation) in 	the x direction; the y component specifies the scale (translation) in the y 	direction. aScale can optionally be an instance of Integer or Float in 	order to specify uniform scaling in both directions. Create a new local 	transformation for the receiver with a scale factor of aScale and a 	translation offset of aTranslation. When the transformation is applied (see 	View|transform:), the scale is applied first, followed by the translation. It 	is typically used when building a superView from its subViews in order 	to line up the viewports of the subViews in the desired way. If no 	scaling is required between subView and superView, then 	View|align:with: is often more convenient to use."	self setTransformation:		(WindowingTransformation scale: aScale translation: aTranslation)! !!View methodsFor: 'transforming'!scaleBy: aScale 	"The x component of aScale (a Point) specifies the scale in the x 	direction; the y component specifies the scale in the y direction. aScale 	can, optionally, be an instance of Integer or Float in order to specify 	uniform scaling in both directions. Scales the View by aScale. The scale 	is concatenated with the current transformation of the receiver and is 	applied when View|transform is sent. This happens automatically in the 	process of displaying the receiver, for example."	self setTransformation: (transformation scaleBy: aScale)! !!View methodsFor: 'transforming'!transform: anObject 	"Apply the local transformation of the receiver to anObject and answer 	the resulting transformation. It is used to get the superView coordinates 	of an object. For example, the viewport is equal to the window 	transformed."	^transformation applyTo: anObject! !!View methodsFor: 'transforming'!transformation	"Answer a copy of the receiver's local transformation."	^transformation copy! !!View methodsFor: 'transforming'!transformation: aTransformation 	"Set the receiver's local transformation to a copy of aTransformation, 	unlock the receiver (see View|unlock) and set the viewport to undefined 	(this forces it to be recomputed when needed)."	self setTransformation: aTransformation copy! !!View methodsFor: 'transforming'!translateBy: aPoint 	"Translate the receiver by aPoint. The translation is concatenated with 	the current transformation of the receiver and is applied when 	View|transform is sent. This happens automatically in the process of 	displaying the receiver."	self setTransformation: (transformation translateBy: aPoint)! !!View methodsFor: 'transforming'!window: aWindow viewport: aViewport 	"Set the receiver's window to aWindow, set its viewport to aViewport, and 	create a new local transformation for the receiver based on aWindow and 	aViewport. The receiver is scaled and translated so that aWindow, when 	transformed, coincides with aViewport. It is used to position a subView's 	window within some specific region of its superView's area. For example, 	'subView window: aRectangle1 viewport: aRectangle2' sets subView's 	window to aRectangle1, its viewport to aRectangle2, and its local 	transformation to one that transforms aRectangle1 to aRectange2."	self window: aWindow.	self setTransformation:		(WindowingTransformation window: aWindow viewport: aViewport).	self getViewport! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:34'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor ifNotNil: [^ Color colorFrom: insideColor].	^ superView == nil		ifFalse: [superView backgroundColor]		ifTrue:	[Color white]! !!View methodsFor: 'bordering' stamp: 'tk 10/21/97 12:31'!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor isTransparent not]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor _ Color white]].	insideColor _ aColor! !!View methodsFor: 'bordering'!borderWidth	"Answer either 0, indicating no border, or a Rectangle whose left value is 	the width in display coordinates of the receiver's left border. Right, top, 	and bottom widths are analogous. The border width is initially 0. A 	View with a border width of 0 will not have any border displayed."	^borderWidth! !!View methodsFor: 'bordering'!borderWidth: anInteger	"Set the four border widths of the receiver to anInteger."	self		borderWidthLeft: anInteger		right: anInteger		top: anInteger		bottom: anInteger! !!View methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border widths of the receiver. These arguments represent the left, 	right, top, and bottom border widths."	borderWidth _			Rectangle				left: anInteger1				right: anInteger2				top: anInteger3				bottom: anInteger4.	self unlock! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:35'!foregroundColor	borderColor ifNotNil: [^ Color colorFrom: borderColor].	^ superView == nil		ifFalse: [superView foregroundColor]		ifTrue:	[Color black]! !!View methodsFor: 'bordering'!foregroundColor: aColor	borderColor _ aColor! !!View methodsFor: 'bordering'!insideColor: aColor 	^ self backgroundColor: aColor! !!View methodsFor: 'scrolling'!scrollBy: aPoint 	"The x component of aPoint specifies the amount of scrolling in the x 	direction; the y component specifies the amount of scrolling in the y 	direction. The amounts are specified in the receiver's local coordinate 	system. Scroll the receiver up or down, left or right. The window of the 	receiver is kept stationary and the subViews and other objects in the 	receiver are translated relative to it. Scrolling doesn't change the 	insetDisplayBox or the viewport since the change in the transformation 	is canceled by the change in the window. In other words, all display 	objects in the view, except the window, are translated by the scrolling 	operation.	Note: subclasses may override to return false if no scrolling takes place."	| aRectangle |	aRectangle _ insetDisplayBox.	transformation _ transformation scrollBy: aPoint.	window _ self getWindow translateBy: aPoint x negated @ aPoint y negated.	self unlock.	insetDisplayBox _ aRectangle.	^ true! !!View methodsFor: 'clearing'!clear	"Use the border color to paint the display box (including the border, see 	View|displayBox) of the receiver."	borderColor ~= nil ifTrue: [self clear: Color black]! !!View methodsFor: 'clearing'!clear: aColor 	"Use aColor to paint the display box (including the border, see 	View|displayBox) of the receiver."	aColor ~= nil ifTrue: [Display fill: self displayBox fillColor: aColor]! !!View methodsFor: 'clearing'!clearInside	"Use the inside color to paint the inset display box (excluding the border, 	see View|insetDisplayBox) of the receiver."	self clearInside: self backgroundColor! !!View methodsFor: 'clearing'!clearInside: aColor 	"Use aColor to paint the inset display box (excluding the border, see 	View|insetDisplayBox) of the receiver."	aColor ~~ nil ifTrue: [Display fill: self insetDisplayBox fillColor: aColor]! !!View methodsFor: 'indicating'!flash	"Cause the inset display box (the display box excluding the border, see 	View|insetDisplayBox) of the receiver to complement twice in succession."	Display flash: self insetDisplayBox! !!View methodsFor: 'indicating'!highlight	"Cause the inset display box (the display box excluding the border, see 	View|insetDisplayBox) of the receiver to complement."	Display reverse: self insetDisplayBox! !!View methodsFor: 'updating'!update	"Normally sent by the receiver's model in order to notify the receiver of 	a change in the model's state. Subclasses implement this message to do 	particular update actions. A typical action that might be required is to 	redisplay the receiver."	self update: self! !!View methodsFor: 'updating'!update: aParameter 	"Normally sent by the receiver's model in order to notify the receiver of 	a change in the model's state. Subclasses implement this message to do 	particular update actions. A typical action that might be required is to 	redisplay the receiver."	^self! !!View methodsFor: 'private'!computeDisplayTransformation	"Answer a WindowingTransformation that transforms the coordinate 	system of the View into that of the display screen. The transformation is 	computed by composing the View's transformation with all transformations 	along its superView chain. It is sent by View|displayTransformation when	the View is unlocked (see View|unlock)."	self isTopView		ifTrue: [^transformation]		ifFalse: [^superView displayTransformation compose: transformation]! !!View methodsFor: 'private'!computeInsetDisplayBox	"Compute the View's inset display box by intersecting the superView's	inset display box with the View's window transformed to display	coordinates and then inseting the result by the border width. It is sent by 	View|insetDisplayBox if the inset display box is nil.	The insetDisplayBox points are truncated to prevent sending floating point numbers to QuickDraw which will die."	self isTopView		ifTrue:			[^((self displayTransform: self getWindow) insetBy: borderWidth) truncated]		ifFalse:			[^(superView insetDisplayBox				intersect: (self displayTransform: self getWindow)) truncated						insetBy: borderWidth]! !!View methodsFor: 'private'!getController	"Answer the View's controller if one exists. nil indicates that the default	controller is to be used."	^controller! !!View methodsFor: 'private'!getViewport	"Answer the Rectangle representing the View's viewport (in the	coordinate system of the superclass). If no viewport has been specified,	the View's window transformed into the superView's coordinate system is	saved and returned. It should be used by methods of View and subclasses	(instead of directly referring to the viewport) unless it is known that a	viewport actually exists. It should not be used outside of View or	subclasses because the viewport is not sharable."	viewport == nil ifTrue: [viewport _ (self transform: self getWindow) truncated].	^viewport! !!View methodsFor: 'private'!getWindow	"Answer the Rectangle that represents the window of this View. If no	window has been specified, a default window (see View|defaultWindow)	is created, saved, and returned. Should be used by methods of View and	subclasses to access the View window instead of directly accessing the	field unless it is known that a window actually exists. It is not to be used	outside of View (or subclasses) because the window is not sharable.	View|window should be used for outside access to the window."	window == nil ifTrue: [self setWindow: self defaultWindow].	^window! !!View methodsFor: 'private'!isCyclic: aView 	"Answer true if aView is the same as this View or its superView, false 	otherwise."	self == aView ifTrue: [^true].	self isTopView ifTrue: [^false].	^superView isCyclic: aView! !!View methodsFor: 'private'!setTransformation: aTransformation 	"Set the View's local transformation to aTransformation, unlock the View 	(see View|unlock), and set the viewport to undefined (this forces it to be 	recomputed when needed). Should be used instead of setting the 	transformation directly."	transformation _ aTransformation.	self unlock.	viewport _ nil! !!View methodsFor: 'private'!setWindow: aWindow 	"Set the View's window to aWindow and unlock the View (see	View|unlock). View|setWindow should be used by methods of View and	subclasses to set the View window (rather than directly setting the	instance variable) to insure that the View is unlocked."	window _ aWindow.	viewport _ nil.	self unlock! !!View methodsFor: 'private'!superView: aView 	"Set the View's superView to aView and unlock the View (see	View|unlock). It is sent by View|addSubView: in order to properly set all	the links."	superView _ aView.	self unlock! !!View methodsFor: 'miscellaneous'!clipRect	^ superView clipRect! !!View methodsFor: 'miscellaneous'!clipRect: r	superView clipRect: r! !!View methodsFor: 'miscellaneous'!gridSpacing	^ superView gridSpacing! !!View methodsFor: 'miscellaneous'!nestedViewport	"The viewport size used to control scaling of nested user views."	^ (0@0 extent: self viewport extent)			insetBy: 16 @ 16! !!View methodsFor: 'miscellaneous'!printViewSpecOn: strm nested: level	"Print window and viewport specs	of this and all nested views."	strm crtab: level; nextPutAll: self class name.	strm crtab: level; nextPutAll: 'window: '; print: self window.	strm crtab: level; nextPutAll: 'viewport: '; print: self viewport.	strm crtab: level; nextPutAll: 'displayBox: '; print: self displayBox.	strm crtab: level; nextPutAll: 'border: '; print: self borderWidth.	subViews do: [:v | v printViewSpecOn: strm nested: level+1]! !!View methodsFor: 'miscellaneous' stamp: 'JMM 10/21/2003 18:12'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click delay |	delay _ Delay forMilliseconds: 10.	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click _ false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[delay wait.		click _ click | Sensor anyButtonPressed.		newFrame _ newFrameBlock value: frame.		newFrame _ newFrame topLeft extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame _ newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!View methodsFor: 'morphic compatibility' stamp: 'mdr 1/24/2000 17:27'!setBalloonText: aString	"Unfortunately we just ignore this help text because we are not morphic"! !Notification subclass: #Warning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!Warning commentStamp: '<historical>' prior: 0!A Warning is a Notification which by default should be brought to the attention of the user.!!Warning methodsFor: 'exceptionDescription' stamp: 'brp 5/9/2003 12:54'!defaultAction	"The user should be notified of the occurrence of an exceptional occurrence and given an option of continuing or aborting the computation. The description of the occurrence should include any text specified as the argument of the #signal: message."	Debugger		openContext: thisContext		label: 'Warning'		contents: self messageText, '\\Select Proceed to continue, or close this window to cancel the operation.' withCRs.	self resume! !BitBlt subclass: #WarpBlt	instanceVariableNames: 'p1x p1y p1z p2x p2y p2z p3x p3y p3z p4x p4y p4z cellSize sourceRGBmap'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!WarpBlt commentStamp: '<historical>' prior: 0!WarpBlt is a little warp-drive added on to BitBlt.  It takes a quadrilateral as its source specification, while its destination is traversed and combined just like any other call to copyBits.The source quadrilateral is specified as an array of points starting with the corner that wants to end up in the topLeft, and proceding to the successive points that want to follow CCW around the destination rectangle.  Note that in specifying a plain old rectangle source, its non topLeft points must be actual pixels, not outside by 1, as with rectangle bottmRight, eg.  See the method Rectangle asQuad.WarpBlt does a fast job of rotation, reflection and scaling, and it can even produce a semblance of perspective.  Depth parameters are included for future improvements in this direction. but the primitve does not support this yet.!!WarpBlt methodsFor: 'setup' stamp: 'jm 4/11/1999 12:00'!cellSize: s	cellSize _ s.	cellSize = 1 ifTrue: [^ self].	colorMap _ Color colorMapIfNeededFrom: 32 to: destForm depth.! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:09'!mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix _ pix size.	r _ 0. g _ 0. b _ 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb _ sourceForm depth <= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [sourceForm depth = 32						ifTrue: [pix at: i]						ifFalse: [self rgbMap: (pix at: i) from: 5 to: 8]].		r _ r + ((rgb bitShift: -16) bitAnd: 16rFF).		g _ g + ((rgb bitShift: -8) bitAnd: 16rFF).		b _ b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor _ 3.  "just in case eg depth <= 8 and no map"				destForm depth = 16 ifTrue: [bitsPerColor _ 5].				destForm depth = 32 ifTrue: [bitsPerColor _ 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor _ 3].				destMap size = 4096 ifTrue: [bitsPerColor _ 4].				destMap size = 32768 ifTrue: [bitsPerColor _ 5]].	d _ bitsPerColor - 8.	rgb _ ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	destMap == nil		ifTrue: [^ rgb]		ifFalse: [^ destMap at: rgb+1]! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:08'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			destPix _ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!WarpBlt methodsFor: 'primitives'!copyQuad: pts toRect: destRect	self sourceQuad: pts destRect: destRect.	self warpBits! !!WarpBlt methodsFor: 'primitives'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	x1 is starting pixel, x2 is ending pixel;  assumes n >= 1"	| fixedPtOne |	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	x2 > x1		ifTrue: [^ x2 - x1 + fixedPtOne // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + fixedPtOne // (n+1) + 1)]! !!WarpBlt methodsFor: 'primitives' stamp: 'jm 5/2/1999 07:09'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	sourceForm _ srcForm.	sourceX _ sourceY _ 0.	destX _ dstRectangle left.	destY _ dstRectangle top.	width _ dstRectangle width.	height _ dstRectangle height.	w _ 16384 * (srcForm width - 1).	h _ 16384 * (srcForm height - 1).	p1x _ 0.	p2x _ 0.	p3x _ w.	p4x _ w.	p1y _ 0.	p2y _ h.	p3y _ h.	p4y _ 0.	p1z _ p2z _ p3z _ p4z _ 16384.  "z-warp ignored for now"! !!WarpBlt methodsFor: 'primitives'!sourceQuad: pts destRect: aRectangle	| fixedPt1 |	sourceX _ sourceY _ 0.	self destRect: aRectangle.	fixedPt1 _ (pts at: 1) x isInteger ifTrue: [16384] ifFalse: [16384.0].	p1x _ (pts at: 1) x * fixedPt1.	p2x _ (pts at: 2) x * fixedPt1.	p3x _ (pts at: 3) x * fixedPt1.	p4x _ (pts at: 4) x * fixedPt1.	p1y _ (pts at: 1) y * fixedPt1.	p2y _ (pts at: 2) y * fixedPt1.	p3y _ (pts at: 3) y * fixedPt1.	p4y _ (pts at: 4) y * fixedPt1.	p1z _ p2z _ p3z _ p4z _ 16384.  "z-warp ignored for now"! !!WarpBlt methodsFor: 'primitives'!startFrom: x1 to: x2 offset: sumOfDeltas	"Utility routine for computing Warp increments."	x2 >= x1		ifTrue: [^ x1]		ifFalse: [^ x2 - sumOfDeltas]! !!WarpBlt methodsFor: 'primitives' stamp: 'jm 4/11/1999 13:45'!warpBits	"Move those pixels!!"	self warpBitsSmoothing: cellSize		sourceMap: (sourceForm colormapIfNeededForDepth: 32).! !!WarpBlt methodsFor: 'primitives' stamp: 'nk 4/17/2004 19:50'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 'primitiveWarpBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt current bitPeekerFromForm: sourceForm.	poker _ BitBlt current bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WarpBlt class	instanceVariableNames: ''!!WarpBlt class methodsFor: 'initialization'!toForm: destinationForm	"Default cell size is 1 (no pixel smoothing)"	^ (super toForm: destinationForm) cellSize: 1! !!WarpBlt class methodsFor: 'examples'!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:00'!current	"Return the class currently to be used for WarpBlt"	^Display defaultWarpBltClass! !Array variableSubclass: #WeakActionSequence	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!WeakActionSequence methodsFor: 'converting' stamp: 'rw 4/27/2002 07:44'!asActionSequence	^self! !!WeakActionSequence methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors withAll: self! !!WeakActionSequence methodsFor: 'converting' stamp: 'nk 7/21/2003 15:16'!asMinimalRepresentation	| valid |	valid := self select: [:e | e isValid ].	valid size = 0		ifTrue: [^nil].	valid size = 1		ifTrue: [^valid first].	^valid! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'nk 7/21/2003 15:17'!value    "Answer the result of evaluating the elements of the receiver.	Actually, return just the last result."    | answer |    self do:        [:each | each isValid ifTrue: [answer := each value]].    ^answer! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'nk 7/21/2003 15:17'!valueWithArguments: anArray	"Return the last result"    | answer |    self do:        [:each |        	each isValid ifTrue: [answer := each valueWithArguments: anArray]].    ^answer! !!WeakActionSequence methodsFor: 'printing' stamp: 'rw 4/27/2002 07:46'!printOn: aStream	self size < 2 ifTrue: [^super printOn: aStream].	aStream nextPutAll: '#('.	self		do: [:each | each printOn: aStream]		separatedBy: [aStream cr].	aStream nextPut: $)! !WeakActionSequence variableSubclass: #WeakActionSequenceTrappingErrors	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:09'!value	"Do the same as my parent, but make sure that all actions that do not  	give errors are evaluated before resignaling the ones that gave errors  	(giving the chance to clients to handle them)."	^self valueStartingFrom: 1! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:12'!valueStartingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Exception so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Exception."	| each answer |	startIndex to: self size do: [:index |		each := self at: index.		each isReceiverOrAnyArgumentGarbage ifFalse: [			[answer _ each value]				on: Halt, Exception				do: [:exc | 						self valueStartingFrom: index + 1.						exc pass]]].	^ answer! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:07'!valueWithArguments: anArray 	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	^self valueWithArguments: anArray startingFrom: 1! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:11'!valueWithArguments: anArray startingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Exception so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Exception."	| each answer |	startIndex to: self size do: [:index |		each := self at: index.		each isReceiverOrAnyArgumentGarbage ifFalse: [			[answer _ each valueWithArguments: anArray]				on: Halt, Exception				do: [:exc | 						self valueWithArguments: anArray startingFrom: index + 1.						exc pass]]].	^ answer! !!WeakActionSequenceTrappingErrors methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^self! !Array weakSubclass: #WeakArray	instanceVariableNames: ''	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore IsFinalizationSupported'	poolDictionaries: ''	category: 'Collections-Weak'!!WeakArray commentStamp: '<historical>' prior: 0!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WeakArray class	instanceVariableNames: ''!!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!addWeakDependent: anObject	| finished index weakDependent |	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).			FinalizationDependents at: index put: anObject.		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject _ WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported _false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported _ (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'accessing' stamp: 'nk 10/28/2000 20:26'!runningFinalizationProcess	"Answer the FinalizationProcess I am running, if any"	^FinalizationProcess! !!WeakArray class methodsFor: 'class initialization' stamp: 'nk 6/21/2004 10:22'!initialize	"WeakArray initialize"	"Do we need to initialize specialObjectsArray?"	Smalltalk specialObjectsArray size < 42 		ifTrue:[Smalltalk recreateSpecialObjectsArray].	Smalltalk addToStartUpList: self.	self restartFinalizationProcess.! !!WeakArray class methodsFor: 'system startup' stamp: 'nk 6/21/2004 09:22'!startUp: resuming	resuming ifFalse: [ ^self ].	self restartFinalizationProcess.! !!WeakArray class methodsFor: 'private' stamp: 'di 5/21/2001 21:49'!finalizationProcess	[true] whileTrue:		[FinalizationSemaphore wait.		FinalizationLock critical:			[FinalizationDependents do:				[:weakDependent |				weakDependent ifNotNil:					[weakDependent finalizeValues.					"***Following statement is required to keep weakDependent					from holding onto its value as garbage.***"					weakDependent _ nil]]]			ifError:			[:msg :rcvr | rcvr error: msg].		].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/7/1998 15:24'!pvtCreateTemporaryObjectIn: tempObject	"We have to create the temporary object in a separate stack frame"	tempObject at: 1 put: Object new! !!WeakArray class methodsFor: 'private' stamp: 'nk 6/21/2004 10:22'!restartFinalizationProcess	"kill any old process, just in case"	FinalizationProcess		ifNotNil: [FinalizationProcess terminate.			FinalizationProcess := nil].	"Check if Finalization is supported by this VM"	IsFinalizationSupported := nil.	self isFinalizationSupported		ifFalse: [^ self].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess]		forkAt: Processor userInterruptPriority! !WeakKeyDictionary subclass: #WeakIdentityKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!WeakIdentityKeyDictionary commentStamp: '<historical>' prior: 0!This class represents an identity dictionary with weak keys.!!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ar 7/1/2003 15:15'!scanFor: anObject	"ar 10/21/2000: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForNil: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish hash |	finish _ array size.	finish > 4096		ifTrue: [hash _ anObject identityHash * (finish // 4096)]		ifFalse: [hash _ anObject identityHash].	start _ (hash \\ array size) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ar 7/1/2003 15:15'!scanForNil: anObject	"Private. Scan the key array for the first slot containing nil (indicating an empty slot). Answer the index of that slot."	| start finish hash |	finish _ array size.	finish > 4096		ifTrue: [hash _ anObject identityHash * (finish // 4096)]		ifFalse: [hash _ anObject identityHash].	start _ (hash \\ array size) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !Association subclass: #WeakKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!WeakKeyAssociation commentStamp: '<historical>' prior: 0!I am an association holding only weakly on my key.!!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:45'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^self key hashMappedBy: map! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:47'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ self key identityHashMappedBy: map! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!key	^key isNil		ifTrue:[nil]		ifFalse:[key at: 1]! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:45'!key: aKey	key := WeakArray with: aKey! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'raok 11/29/2002 14:49'!key: aKey value: anObject	key := WeakArray with: aKey.	value := anObject.! !Dictionary subclass: #WeakKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!WeakKeyDictionary commentStamp: '<historical>' prior: 0!I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.See WeakRegistry for an example of use.!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 10/21/2000 20:00'!finalizeValues	"remove all nil keys and rehash the receiver afterwards"	| assoc |	1 to: array size do:[:i|		assoc _ array at: i.		(assoc notNil and:[assoc key == nil]) ifTrue:[array at: i put: nil].	].	self rehash.! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 10/21/2000 20:01'!finalizeValues: finiObjects	"Remove all associations with key == nil and value is in finiObjects.	This method is folded with #rehash for efficiency."	| oldArray assoc newIndex |	oldArray _ array.	array _ Array new: oldArray size.	tally _ 0.	1 to: array size do:[:i|		assoc _ oldArray at: i.		assoc ifNotNil:[			(assoc key == nil and:[finiObjects includes: assoc value]) ifFalse:[				newIndex _ self scanForNil: assoc key.				self atNewIndex: newIndex put: assoc].		].	].! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 2/11/2001 02:21'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | 		association key ifNotNil:[aBlock value: association key]].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:58'!fixCollisionsFrom: oldIndex	"The element at index has been removed and replaced by nil."	self rehash. "Do it the hard way - we may have any number of nil keys and #rehash deals with them"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:56'!rehash	"Rehash the receiver. Reimplemented to allow for multiple nil keys"	| oldArray assoc newIndex |	oldArray _ array.	array _ Array new: oldArray size.	tally _ 0.	1 to: array size do:[:i|		assoc _ oldArray at: i.		assoc ifNotNil:[			newIndex _ self scanForNil: assoc key.			self atNewIndex: newIndex put: assoc.		].	].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:46'!scanFor: anObject	"ar 10/21/2000: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForNil: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:46'!scanForNil: anObject	"Private. Scan the key array for the first slot containing nil (indicating an empty slot). Answer the index of that slot."	| start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:00'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !Object weakSubclass: #WeakMessageSend	instanceVariableNames: 'selector shouldBeNil arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 09:54'!arguments	^arguments ifNil: [ Array new ]! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 09:38'!arguments: anArray	arguments _ WeakArray withAll: anArray.	"no reason this should be a WeakArray"	shouldBeNil _ Array withAll: (anArray collect: [ :ea | ea isNil ]).! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:54'!receiver	^self at: 1! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:54'!receiver: anObject	self at: 1 put: anObject! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:54'!selector	^selector! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:55'!selector: aSymbol	selector _ aSymbol! !!WeakMessageSend methodsFor: 'comparing' stamp: 'nk 4/25/2002 08:05'!= anObject	"Compare equal to equivalent MessageSend"	^ anObject isMessageSend		and: [self receiver == anObject receiver		and: [selector == anObject selector		and: [(Array withAll: arguments) = (Array withAll: anObject arguments)]]]! !!WeakMessageSend methodsFor: 'comparing' stamp: 'nk 4/25/2002 09:31'!hash	"work like MessageSend>>hash"	^self receiver hash bitXor: selector hash! !!WeakMessageSend methodsFor: 'converting' stamp: 'rww 10/20/2002 19:56'!asMinimalRepresentation	self isReceiverOrAnyArgumentGarbage		ifTrue: [^nil]		ifFalse:[^self].! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nk 12/8/2002 12:15'!value	^ arguments isNil		ifTrue: [self ensureReceiver				ifTrue: [self receiver perform: selector] ifFalse: []]		ifFalse: [self ensureReceiverAndArguments				ifTrue: [self receiver						perform: selector						withArguments: (Array withAll: arguments)] ifFalse: []]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nk 12/8/2002 12:15'!valueWithArguments: anArray	self ensureReceiverAndArguments ifFalse: [ ^nil ].	^ self receiver 		perform: selector 		withArguments: (self collectArguments: anArray)! !!WeakMessageSend methodsFor: 'printing' stamp: 'nk 4/25/2002 09:36'!printOn: aStream        aStream                nextPutAll: self class name;                nextPut: $(.        selector printOn: aStream.        aStream nextPutAll: ' -> '.        self receiver printOn: aStream.        aStream nextPut: $)! !!WeakMessageSend methodsFor: 'testing' stamp: 'nk 4/25/2002 08:04'!isMessageSend	^true! !!WeakMessageSend methodsFor: 'testing' stamp: 'nk 8/24/2003 01:12'!isValid	^self isReceiverOrAnyArgumentGarbage not! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 4/25/2002 09:49'!collectArguments: anArgArray	"Private"    | staticArgs |    staticArgs := self arguments.    ^(anArgArray size = staticArgs size)        ifTrue: [anArgArray]        ifFalse:            [(staticArgs isEmpty                ifTrue: [ staticArgs := Array new: selector numArgs]                ifFalse: [staticArgs copy] )                    replaceFrom: 1                    to: (anArgArray size min: staticArgs size)                    with: anArgArray                    startingAt: 1]! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 12/8/2002 12:13'!ensureReceiver	"Return true if my receiver hasn't gone away"	^self receiver notNil! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 12/8/2002 12:13'!ensureReceiverAndArguments	"Return true if my receiver hasn't gone away"	self receiver ifNil: [ ^false ].	"Make sure that my arguments haven't gone away"	arguments ifNotNil: [		arguments with: shouldBeNil do: [ :arg :flag |			arg ifNil: [ flag ifFalse: [ ^false ]]		]	].	^true! !!WeakMessageSend methodsFor: 'private' stamp: 'rw 4/27/2002 07:33'!isAnyArgumentGarbage	"Make sure that my arguments haven't gone away"	arguments ifNotNil: [		arguments with: shouldBeNil do: [ :arg :flag |			(flag not and: [arg isNil])				ifTrue: [^true]		]	].	^false! !!WeakMessageSend methodsFor: 'private' stamp: 'rw 4/27/2002 07:31'!isReceiverGarbage	"Make sure that my receiver hasn't gone away"	^self receiver isNil! !!WeakMessageSend methodsFor: 'private' stamp: 'rw 4/27/2002 07:34'!isReceiverOrAnyArgumentGarbage	"Make sure that my receiver hasn't gone away"	^self isReceiverGarbage 		or: [self isAnyArgumentGarbage]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WeakMessageSend class	instanceVariableNames: ''!!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 10:00'!new	^self new: 1! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 09:37'!receiver: anObject selector: aSymbol	^ self receiver: anObject selector: aSymbol arguments: #()! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 09:37'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 09:37'!receiver: anObject selector: aSymbol arguments: anArray	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray! !Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Collections-Weak'!!WeakRegistry commentStamp: '<historical>' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry methodsFor: 'finalization' stamp: 'ar 10/22/2000 20:24'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."	| finiObjects |	finiObjects := nil.	"First collect the objects."	self protected:[		valueDictionary associationsDo:[:assoc|			assoc key isNil ifTrue:[				finiObjects isNil 					ifTrue:[finiObjects := OrderedCollection with: assoc value]					ifFalse:[finiObjects add: assoc value]]		].		finiObjects isNil ifFalse:[valueDictionary finalizeValues: finiObjects asArray].	].	"Then do the finalization"	finiObjects isNil ifTrue:[^self].	finiObjects do:[:each| each finalize].! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 3/21/98 16:33'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."	| executor |	executor := anObject executor.	self protected:[		valueDictionary at: anObject put: executor.	].	^anObject! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 5/19/2003 20:08'!add: anObject executor: anExecutor	"Add anObject to the receiver. Store the object as well as the associated executor."	self protected:[		valueDictionary at: anObject put: anExecutor.	].	^anObject! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 12/12/2001 16:00'!keys	^self protected:[		Array streamContents:[:s| valueDictionary keysDo:[:key| s nextPut: key]]].! !!WeakRegistry methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:40'!size	^ self protected: [valueDictionary size]! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/20/98 19:31'!species	^Set! !!WeakRegistry methodsFor: 'initialize' stamp: 'ar 3/21/98 16:08'!initialize: n	valueDictionary := WeakKeyDictionary new: n.	accessLock := Semaphore forMutualExclusion.! !!WeakRegistry methodsFor: 'private' stamp: 'ar 10/8/1998 11:18'!protected: aBlock	"Execute aBlock protected by the accessLock"	^accessLock isNil		ifTrue:[aBlock value]		ifFalse:[accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !!WeakRegistry methodsFor: 'enumerating' stamp: 'ar 3/21/98 18:36'!do: aBlock	^self protected:[		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'removing' stamp: 'ar 3/21/98 21:12'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."	| removedObject |	oldObject isNil ifTrue:[^oldObject].	self protected:[		removedObject := valueDictionary removeKey: oldObject ifAbsent:[nil].	].	^removedObject isNil		ifTrue:[exceptionBlock value]		ifFalse:[removedObject].! !!WeakRegistry methodsFor: 'printing' stamp: 'tk 12/5/2001 09:42'!printElementsOn: aStream	aStream nextPut: $(.	accessLock 		ifNil: [self do: [:element | aStream print: element; space]]		ifNotNil: [aStream nextPutAll: '<this WeakRegistry is locked>; space'].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WeakRegistry class	instanceVariableNames: ''!!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:32'!new	^self new: 5! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:33'!new: n	| registry |	registry := super new initialize: n.	WeakArray addWeakDependent: registry.	^registry! !!WeakRegistry class methodsFor: 'accessing' stamp: 'ar 5/19/2003 20:10'!default	^Default ifNil:[Default := self new]! !Set subclass: #WeakSet	instanceVariableNames: 'flag'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:15'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	((array at: index) == flag or: [(array at: index) isNil])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!WeakSet methodsFor: 'public' stamp: 'nk 3/11/2002 20:35'!collect: aBlock	| each newSet |	newSet _ self species new: self size.	tally = 0 ifTrue: [^newSet ].	1 to: array size do:		[:index |			((each _ array at: index) == nil or: [each == flag])				ifFalse: [newSet add: (aBlock value: each)]		].	^newSet! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:46'!do: aBlock	| each |	tally = 0 ifTrue: [^self].	1 to: array size do:		[:index |			((each _ array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:13'!do: aBlock after: anElement	| each startIndex |	tally = 0 ifTrue: [^self].	startIndex _ anElement ifNil: [1] ifNotNil:		[self findElementOrNil: anElement].	startIndex + 1 to: array size do:		[:index |			((each _ array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:15'!includes: anObject 	^(array at: (self findElementOrNil: anObject)) ~~ flag! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 16:02'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index element |	^(index _ self scanFor: anObject) = 0		ifFalse: [(element _ array at: index) == flag ifFalse: [element]]! !!WeakSet methodsFor: 'public' stamp: 'di 2/3/2001 16:46'!printElementsOn: aStream	| oldPos |	aStream nextPut: $(.	oldPos _ aStream position.	self do: [:element | aStream print: element; space].	aStream position > oldPos ifTrue: [aStream skip: -1 "remove the extra space"].	aStream nextPut: $)! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:08'!remove: oldObject ifAbsent: aBlock	| index |	index _ self findElementOrNil: oldObject.	(array at: index) == flag ifTrue: [ ^ aBlock value ].	array at: index put: flag.	tally _ tally - 1.	self fixCollisionsFrom: index.	^oldObject! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:12'!size	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	^tally! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:30'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex _ index.	length _ array size.	[oldIndex = length			ifTrue: [oldIndex _ 1]			ifFalse: [oldIndex _ oldIndex + 1].	(element _ self keyAt: oldIndex) == flag]		whileFalse: 			[newIndex _ self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!grow	"Grow the elements array and reinsert the old elements"	self growTo: array size + self growSize! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!growTo: anInteger	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements _ array.	array _ WeakArray new: anInteger.	array atAllPut: flag.	tally _ 0.	oldElements do:		[:each | (each == flag or: [each == nil]) ifFalse: [self noCheckAdd: each]]! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:38'!init: n	"Initialize array to an array size of n"	flag _ Object new.	array _ WeakArray new: n.	array atAllPut: flag.	tally _ 0! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!rehash	self growTo: array size! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:35'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !Timespan subclass: #Week	instanceVariableNames: ''	classVariableNames: 'StartDay'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!Week commentStamp: 'brp 5/13/2003 09:48' prior: 0!I represent a week.!!Week methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:37'!printOn: aStream	aStream nextPutAll: 'a Week starting: '.	self start printOn: aStream.
! !!Week methodsFor: 'deprecated' stamp: 'brp 8/5/2003 22:17'!do: aBlock	self deprecated: 'Use #datesDo:'.	self datesDo: aBlock! !!Week methodsFor: 'deprecated' stamp: 'brp 8/6/2003 18:39'!index	self deprecated: 'obsolete'.	^ self indexInMonth: self asMonth ! !!Week methodsFor: 'deprecated' stamp: 'brp 8/6/2003 18:42'!indexInMonth: aMonth	"1=first week, 2=second week, etc."	self deprecated: 'obsolete'.	^ (Date dayOfWeek: aMonth dayOfWeekName) + self dayOfMonth - 2  // 7 + 1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Week class	instanceVariableNames: ''!!Week class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:34'!indexOfDay: aSymbol	^ DayNames indexOf: aSymbol
! !!Week class methodsFor: 'squeak protocol' stamp: 'brp` 8/24/2003 19:38'!startDay	^ StartDay
ifNil: [ StartDay
 _ DayNames first ]! !!Week class methodsFor: 'squeak protocol' stamp: 'jf 4/23/2004 14:51'!starting: aDateAndTime duration: aDuration	"Override - the duration is always one week.	 Week will start from the Week class>>startDay"	| midnight delta adjusted |	midnight _ aDateAndTime asDateAndTime midnight.	delta _ ((midnight dayOfWeek + 7 - (DayNames indexOf: self startDay)) rem: 7) abs.	adjusted _ midnight - (Duration days: delta hours: 0 minutes: 0 seconds: 0).	^ super starting: adjusted duration: (Duration weeks: 1).! !!Week class methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 09:34'!nameOfDay: anIndex	^ DayNames at: anIndex
! !Object subclass: #WindowingTransformation	instanceVariableNames: 'scale translation'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Framework'!!WindowingTransformation commentStamp: '<historical>' prior: 0!My instances are used to transform objects from a source coordinate system to a destination coordinate system. Each instance contains a scale and a translation which can be applied to objects that respond to scaleBy: and translateBy:. It can be created with a default identity scale and translation, or with a specified scale and translation, or with a scale and translation computed from a window (a Rectangle in the source coordinate system) and a viewport (a Rectangle in the destination coordinate system). In applying a WindowingTransformation to an object, the object is first scaled (around the origin of the source coordinate system) and then translated. WindowingTransformations can be composed to form a single compound transformation.!!WindowingTransformation methodsFor: 'scrolling'!scrollBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint scaled by 	the current scale. It is used when the translation is known in source 	coordinates, rather than scaled source coordinates (see 	WindowingTransformation|translateBy:). An example is that of scrolling 	objects with respect to a stationary window in the source coordinate 	system. If no scaling is in effect (scale = nil), then 	WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	| newTranslation |	scale == nil		ifTrue: [newTranslation _ aPoint]		ifFalse: [newTranslation _ scale * aPoint].	^self translateBy: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!align: point1 with: point2 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of (aPoint2 - aPoint1). It is normally used when 	the source and destination coordinate systems are scaled the same (that 	is, there is no scaling between them), and is then a convenient way of 	specifying a translation, given two points that are intended to coincide."	^self translateBy: point2 - point1! !!WindowingTransformation methodsFor: 'transforming'!noScale	"Answer true if the identity scale is in effect; answer false, otherwise."	^scale == nil! !!WindowingTransformation methodsFor: 'transforming'!scale	"Answer a copy of the point that represents the current scale of the 	receiver."	scale == nil		ifTrue: [^1.0 @ 1.0]		ifFalse: [^scale copy]! !!WindowingTransformation methodsFor: 'transforming'!scaleBy: aScale 	"Answer a WindowingTransformation with the scale and translation of 	the receiver both scaled by aScale."	| checkedScale newScale newTranslation |	aScale == nil		ifTrue: 			[newScale _ scale.			newTranslation _ translation]		ifFalse: 			[checkedScale _ self checkScale: aScale.			scale == nil				ifTrue: [newScale _ checkedScale]				ifFalse: [newScale _ scale * checkedScale].			newTranslation _ checkedScale * translation].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!translateBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint. It is used 	when the translation is known in scaled source coordinates, rather than 	source coordinates (see WindowingTransformation|scrollBy:). If no scaling 	is in effect (scale = nil), then WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	^WindowingTransformation scale: scale translation: translation + aPoint! !!WindowingTransformation methodsFor: 'transforming'!translation	"Answer a copy of the receiver's translation."	^translation copy! !!WindowingTransformation methodsFor: 'applying transform'!applyInverseTo: anObject 	"Apply the inverse of the receiver to anObject and answer the result. 	Used to map some object in destination coordinates to one in source 	coordinates."	| transformedObject |	transformedObject _ anObject translateBy: translation x negated @ translation y negated.	scale == nil		ifFalse: [transformedObject _ transformedObject scaleBy: 1.0 / scale x @ (1.0 / scale y)].	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!applyTo: anObject 	"Apply the receiver to anObject and answer the result. Used to map some 	object in source coordinates to one in destination coordinates."	| transformedObject |	scale == nil		ifTrue: [transformedObject _ anObject]		ifFalse: [transformedObject _ anObject scaleBy: scale].	transformedObject _ transformedObject translateBy: translation.	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!compose: aTransformation 	"Answer a WindowingTransformation that is the composition of the 	receiver and aTransformation. The effect of applying the resulting 	WindowingTransformation to an object is the same as that of first 	applying aTransformation to the object and then applying the receiver to 	its result."	| aTransformationScale newScale newTranslation |	aTransformationScale _ aTransformation scale.	scale == nil		ifTrue: 			[aTransformation noScale				ifTrue: [newScale _ nil]				ifFalse: [newScale _ aTransformationScale].			newTranslation _ translation + aTransformation translation]		ifFalse: 			[aTransformation noScale				ifTrue: [newScale _ scale]				ifFalse: [newScale _ scale * aTransformationScale].			newTranslation _ translation + (scale * aTransformation translation)].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: self class name, ' scale: ';		print: scale; nextPutAll: ' translation: ';		print: translation! !!WindowingTransformation methodsFor: 'private'!checkScale: aScale	"Convert aScale to the internal format of a floating-point Point." 	| checkedScale |	checkedScale _ aScale asPoint.	^checkedScale x asFloat @ checkedScale y asFloat! !!WindowingTransformation methodsFor: 'private'!setScale: aScale translation: aTranslation 	"Sets the scale to aScale and the translation to aTranslation."	scale _ aScale.	translation _ aTranslation! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WindowingTransformation class	instanceVariableNames: ''!!WindowingTransformation class methodsFor: 'instance creation'!identity	"Answer an instance of me with no scaling (nil) and no translation 	(0@0)."	^self new setScale: nil translation: 0 @ 0! !!WindowingTransformation class methodsFor: 'instance creation'!scale: aScale translation: aTranslation 	"Answer an instance of me with a scale factor of aScale and a translation 	offset of aTranslation. When the transformation is applied (see 	WindowingTransformation|apply:), the scale is applied first, followed by 	the translation."	^self new setScale: aScale translation: aTranslation! !!WindowingTransformation class methodsFor: 'instance creation'!window: aWindow viewport: aViewport 	"Answer an instance of me with a scale and translation based on 	aWindow and aViewport. The scale and translation are computed such 	that aWindow, when transformed, coincides with aViewport."	| scale translation |	aViewport width = aWindow width & (aViewport height = aWindow height)		ifTrue:			[scale _ nil]		ifFalse:			[scale _ aViewport width asFloat / aWindow width asFloat						@ (aViewport height asFloat / aWindow height asFloat)].	scale == nil		ifTrue: [translation _ aViewport left - aWindow left								@ (aViewport top - aWindow top)]		ifFalse: [translation _ aViewport left - (scale x * aWindow left)								@ (aViewport top - (scale y * aWindow top))].	^self new setScale: scale translation: translation! !ArrayedCollection variableWordSubclass: #WordArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!WordArray commentStamp: '<historical>' prior: 0!WordArrays store 32-bit unsigned Integer values.!!WordArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asWordArray	^self! !!WordArray methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:47'!atAllPut: value	"Fill the receiver with the given value"	<primitive: 145>	super atAllPut: value! !!WordArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 16:18'!byteSize	^self size * 4! !!WordArray methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 4! !!WordArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!WordArray methodsFor: 'private' stamp: 'ar 2/15/1999 00:51'!replaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	^super replaceFrom: start to: stop with: replacement startingAt: repStart ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WordArray class	instanceVariableNames: ''!!WordArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:19'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asIntPtrFrom: anInteger on: aStream! !!WordArray class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 13:16'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asUnsignedPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isWords')! !!WordArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:19'!ccgDeclareCForVar: aSymbolOrString	^'unsigned *', aSymbolOrString! !StringHolder subclass: #Workspace	instanceVariableNames: 'bindings acceptDroppedMorphs'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 0!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!]style[(286 14 722)f1,f1dWorkspace open;;,f1!!Workspace methodsFor: 'binding'!bindingOf: aString	bindings isNil		ifTrue: [bindings _ Dictionary new].	(bindings includesKey: aString)		ifFalse: [bindings at: aString put: nil].	^bindings associationAt: aString! !!Workspace methodsFor: 'accessing' stamp: 'jsp 3/23/1999 12:19'!setBindings: aDictionary	"Sets the Workspace to use the specified dictionary as its namespace"	bindings _ aDictionary.! !!Workspace methodsFor: 'as yet unclassified' stamp: 'BG 11/1/2003 22:13'!saveContentsInFile	"A bit of a hack to pass along this message to the controller or morph.  (Possibly this Workspace menu item could be deleted, since it's now in the text menu.)"	| textView |	textView _ self dependents detect: [:dep | dep isKindOf: PluggableTextView] ifNone: [nil].	textView notNil ifTrue: [^ textView controller saveContentsInFile].! !!Workspace methodsFor: 'initialize-release' stamp: 'sma 11/11/2000 16:33'!initialize	super initialize.	acceptDroppedMorphs _ false! !!Workspace methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:50'!convertToCurrentVersion: varDict refStream: smartRefStrm		acceptDroppedMorphs ifNil: [acceptDroppedMorphs _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!Workspace methodsFor: 'menu commands' stamp: 'ssa 9/3/2008 10:48'!addModelItemsToWindowMenu: aMenu	"Add model-related items to the supplied window menu"	aMenu addLine.	aMenu add: 'save contents to file...' target: self action: #saveContentsInFile.	aMenu addLine.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Workspace class	instanceVariableNames: ''!!Workspace class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:13'!initialize	self registerInFlapsRegistry.	! !!Workspace class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:14'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(Workspace	prototypicalToolWindow	'Workspace'		'A Workspace is a simple window for editing text.  You can later save the contents to a file if you desire.')						forFlapNamed: 'Tools'.]! !!Workspace class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:42'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !PositionableStream subclass: #WriteStream	instanceVariableNames: 'writeLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!WriteStream commentStamp: '<historical>' prior: 0!I represent an accessor for a sequence of objects that can only store objects in the sequence.!!WriteStream methodsFor: 'accessing'!contents	readLimit _ readLimit max: position.	^collection copyFrom: 1 to: position! !!WriteStream methodsFor: 'accessing'!next	self shouldNotImplement! !!WriteStream methodsFor: 'accessing' stamp: 'di 3/8/1999 09:02'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection at: position put: anObject]! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/24/2003 20:41'!nextPutAll: aCollection

	| newEnd |
	collection class == aCollection class ifFalse:
		[^ super nextPutAll: aCollection ].

	newEnd _ position + aCollection size.
	newEnd > writeLimit ifTrue:
		[self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position _ newEnd.! !!WriteStream methodsFor: 'accessing'!size	^readLimit _ readLimit max: position! !!WriteStream methodsFor: 'positioning'!position: anInteger 	"Refer to the comment in PositionableStream|position:."	readLimit _ readLimit max: position.	super position: anInteger! !!WriteStream methodsFor: 'positioning'!reset 	"Refer to the comment in PositionableStream|reset."	readLimit _ readLimit max: position.	position _ 0! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit _ position _ 0.! !!WriteStream methodsFor: 'positioning' stamp: 'ajh 5/25/2001 20:19'!setToEnd 	"Refer to the comment in PositionableStream|setToEnd."	readLimit _ readLimit max: position.	super setToEnd.! !!WriteStream methodsFor: 'character writing'!cr	"Append a return character to the receiver."	self nextPut: Character cr! !!WriteStream methodsFor: 'character writing'!crtab	"Append a return character, followed by a single tab character, to the 	receiver."	self nextPut: Character cr.	self nextPut: Character tab! !!WriteStream methodsFor: 'character writing'!crtab: anInteger 	"Append a return character, followed by anInteger tab characters, to the 	receiver."	self nextPut: Character cr.	anInteger timesRepeat: [self nextPut: Character tab]! !!WriteStream methodsFor: 'character writing' stamp: 'di 6/7/2000 22:43'!nextPutKeyword: keyword withArg: argValue	"Emit a keyword/value pair in the alternate syntax"	self nextPutAll: (keyword copyWithout: $:);		nextPut: $(;		store: argValue;		nextPut: $)! !!WriteStream methodsFor: 'character writing'!space	"Append a space character to the receiver."	self nextPut: Character space! !!WriteStream methodsFor: 'character writing'!tab	"Append a tab character to the receiver."	self nextPut: Character tab! !!WriteStream methodsFor: 'character writing' stamp: 'JF 7/31/2003 13:00'!tab: anInteger 	"Append anInteger tab characters to the receiver."	anInteger timesRepeat: [self tab]! !!WriteStream methodsFor: 'fileIn/Out'!nextChunkPut: aString	"Append the argument, aString, to the receiver, doubling embedded terminators."	| i remainder terminator |	terminator _ $!!.	remainder _ aString.	[(i _ remainder indexOf: terminator) = 0] whileFalse:		[self nextPutAll: (remainder copyFrom: 1 to: i).		self nextPut: terminator.  "double imbedded terminators"		remainder _ remainder copyFrom: i+1 to: remainder size].	self nextPutAll: remainder; nextPut: terminator! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'di 2/2/98 13:03'!nextChunkPutWithStyle: aStringOrText	"Append the argument, aText, to the receiver, doubling embedded terminators.  Put out one chunk for the string and one for the style runs.  Mark the style with ]style[."	aStringOrText class == String ifTrue: [^ self nextChunkPut: aStringOrText].	aStringOrText runs coalesce.	aStringOrText unembellished ifTrue: [^ self nextChunkPut: aStringOrText asString].	self nextChunkPut: aStringOrText asString.	self cr; nextPutAll: ']style['.	self nextChunkPut: 		(String streamContents: [:strm | 			aStringOrText runs writeScanOn: strm]).! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'dew 9/24/2001 23:45'!timeStamp	"Append the current time to the receiver as a String."	self nextChunkPut:	"double string quotes and !!s"		(String streamContents: [:s | Smalltalk timeStamp: s]) printString.	self cr! !!WriteStream methodsFor: 'printing'!store: anObject 	"Have anObject print on the receiver for purposes of rereading."	anObject storeOn: self! !!WriteStream methodsFor: 'private' stamp: 'di 11/18/1999 22:55'!braceArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ collection! !!WriteStream methodsFor: 'private' stamp: 'di 11/18/1999 22:50'!braceArray: anArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	collection _ anArray.	position _ 0.	readLimit _ 0.	writeLimit _ anArray size.! !!WriteStream methodsFor: 'private' stamp: 'BG 5/24/2003 22:49'!growTo: anInteger

   " anInteger is the required minimal new size of the collection "
	| oldSize grownCollection newSize |
	oldSize _ collection size.
     newSize := anInteger + (oldSize // 4 max: 20).
	grownCollection _ collection class new: newSize.
	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit _ collection size.
! !!WriteStream methodsFor: 'private'!on: aCollection	super on: aCollection.	readLimit _ 0.	writeLimit _ aCollection size! !!WriteStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection _ aCollection.	readLimit _ 		writeLimit _ lastIndex > (len _ collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position _ firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!WriteStream methodsFor: 'private' stamp: 'gh 5/15/2002 09:55'!pastEndPut: anObject	"Grow the collection by creating a new bigger collection and then	copy over the contents from the old one. We grow by doubling the size	but the growth is kept between 20 and 1000000.	Finally we put <anObject> at the current write position."	| oldSize grownCollection |	oldSize _ collection size.	grownCollection _ collection class new: oldSize + ((oldSize max: 20) min: 1000000).	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit _ collection size.	collection at: (position _ position + 1) put: anObject! !!WriteStream methodsFor: 'private'!with: aCollection	super on: aCollection.	position _ readLimit _ writeLimit _ aCollection size! !!WriteStream methodsFor: 'private' stamp: 'djp 11/6/1999 23:15'!withAttributes: attributes do: strmBlock 	"No-op here is overriden in TextStream for font emphasis"	^ strmBlock value! !!WriteStream methodsFor: 'file open/close' stamp: 'mir 8/10/1999 11:56'!flush! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WriteStream class	instanceVariableNames: ''!!WriteStream class methodsFor: 'instance creation'!on: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me on a copy of the argument, aCollection, 	determined by the indices firstIndex and lastIndex. Position the instance 	at the beginning of the collection."	^self basicNew		on: aCollection		from: firstIndex		to: lastIndex! !!WriteStream class methodsFor: 'instance creation'!with: aCollection 	"Answer an instance of me on the argument, aCollection, positioned to 	store objects at the end of aCollection."	^self basicNew with: aCollection! !!WriteStream class methodsFor: 'instance creation'!with: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me on the subcollection of the argument, 	aCollection, determined by the indices firstIndex and lastIndex. Position 	the instance to store at the end of the subcollection."	^self basicNew with: (aCollection copyFrom: firstIndex to: lastIndex)! !Timespan subclass: #Year	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!!Year commentStamp: '<historical>' prior: 0!I represent a year.
!!Year methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:01'!asYear
	^ self
! !!Year methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:01'!daysInMonth
	self shouldNotImplement 
! !!Year methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:01'!daysInYear	^ self duration days.! !!Year methodsFor: 'squeak protocol' stamp: 'brp 5/21/2003 08:38'!printOn: aStream	aStream nextPutAll: 'a Year ('.
	self start year printOn: aStream.
	aStream nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Year class	instanceVariableNames: ''!!Year class methodsFor: 'squeak protocol' stamp: 'brp 9/11/2003 14:05'!current 	^ self year: (DateAndTime now year)! !!Year class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:00'!isLeapYear: aYearInteger
	| adjustedYear |
	adjustedYear _ aYearInteger > 0		ifTrue: [aYearInteger]		ifFalse: [(aYearInteger + 1) negated].
	"There was no year 0"
	^ ((adjustedYear \\ 4 ~= 0) or: [(adjustedYear \\ 100 = 0) and: [adjustedYear \\ 400 ~= 0]]) not.! !!Year class methodsFor: 'squeak protocol' stamp: 'brp 7/1/2003 13:53'!starting: aDateAndTime duration: aDuration 	"Override - start from midnight"	| midnight |	midnight _ aDateAndTime asDateAndTime midnight.	^ super		starting: midnight		duration: (Duration days: (self daysInYear: midnight year)).! !!Year class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:00'!year: aYear	^ self starting: (DateAndTime year: aYear month: 1 day: 1).! !!Year class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:52'!daysInYear: yearInteger	^ 365 + ((self isLeapYear: yearInteger) ifTrue: [1] ifFalse: [0]).! !!Year class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:55'!leapYear: yearInteger 	^ (self isLeapYear: yearInteger)		ifTrue: [1]		ifFalse: [0]! !ArithmeticError subclass: #ZeroDivide	instanceVariableNames: 'dividend'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ZeroDivide commentStamp: '<historical>' prior: 0!ZeroDivide may be signaled when a mathematical division by 0 is attempted.!!ZeroDivide methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 15:05'!isResumable	"Determine whether an exception is resumable."	^true! !!ZeroDivide methodsFor: 'exceptionBuilder' stamp: 'pnm 8/16/2000 15:05'!dividend: argument	"Specify the number that was being divided by zero."	dividend := argument! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ZeroDivide class	instanceVariableNames: ''!!ZeroDivide class methodsFor: 'exceptionInstantiator' stamp: 'bf 9/27/1999 17:26'!dividend: argument	^self new dividend: argument; yourself! !